{
    "vast-vision-nocode-tool-analysis": {},
    "vast-vision-nocode-tool-analysis\\nodes_common": {
        "create_dummy.py": "import tempfile\nimport os\n\ndef create_dummy(controller):\n    nodenames = controller.get_table_names()\n    inputs_list = [item for item in nodenames if \"inputs\" in item.lower()]\n\n    with tempfile.NamedTemporaryFile(dir=os.path.dirname(__file__), suffix=\".py\", delete=False) as temp_file:\n        temp_file_path = temp_file.name\n    # tempファイルに記述\n        for i_name in inputs_list:\n            source_code = f\"\"\"\nclass {i_name}(NodeBase):\n    pass\n                \"\"\"\n            with open(temp_file_path, 'a+') as f:\n                f.write(source_code)\n                f.seek(0)\n\n    return temp_file_path",
        "gui.py": "import re\nfrom ryven.gui_env import *\n#from special_nodes import *\n\nfrom qtpy.QtGui import QFont\nfrom qtpy.QtCore import Qt, Signal, QEvent\nfrom qtpy.QtWidgets import QPushButton, QComboBox, QSlider, QTextEdit, QPlainTextEdit, QWidget, QVBoxLayout, QLineEdit, \\\n    QDialog, QMessageBox\n\n# QLineEditのシンプルな入力GUI\nclass BasicInputWidget(NodeInputWidget, QLineEdit):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QLineEdit.__init__(self)\n\n        self.setMinimumWidth(60)\n        self.setMaximumWidth(100)\n        self.setStyleSheet(\"background-color:black;\")\n\n        ## loadしたとき毎回発火してしまう->silent=Trueで解決\n        self.textChanged.connect(lambda: self.text_changed())\n        self.init_value()\n\n    def text_changed(self):\n        self.update_node_input(Data(self.text()), silent=True)\n\n    def get_state(self) -> dict:\n        return {'value': self.text()}\n\n    def set_state(self, data: dict):\n        try:\n            self.setText(data['value'])\n        except:\n            pass\n\n    def val_update_event(self, val: Data):\n        try:\n            super().val_update_event(val)\n            # 値を取得（画像のパス）\n            data = val.payload\n            self.setText(str(data))\n        except:\n            pass\n\n    def init_value(self):\n        # input the default value\n        self.set_state({\"value\": self.input.default})\n\"\"\"\n    generic base classes\n\"\"\"\n\n# 入力部にQLineEditが付いたGUI\nclass BasicNodeGui(NodeGUI):\n    input_widget_classes = {'input': BasicInputWidget}\n\n    def add_input(self, name):\n        self.init_input_widgets[len(self.init_input_widgets)] = {'name':'input', 'pos':'below'}\n\n    def __init__(self, params):\n        super().__init__(params)\n\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'input', 'pos': 'besides'}\n\n\n\"\"\"\n    operator nodes\n\"\"\"\n## 以下はryvenにもともと載っていたサンプルコード（参考）\nclass GuiBase(NodeGUI):\n    pass\n\nclass OperatorNodeBaseGui(GuiBase):\n    input_widget_classes = {\n        'in': inp_widgets.Builder.evaled_line_edit(size='s', resizing=True),\n    }\n    # init_input_widgets = {\n    #     0: {'name': 'in', 'pos': 'besides'},\n    #     1: {'name': 'in', 'pos': 'besides'},\n    # }\n    style = 'small'\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.actions['add input'] = {'method': self.add_operand_input}\n        self.actions['remove input'] = {}\n\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'in', 'pos': 'besides'}\n\n    def initialized(self):\n        super().initialized()\n        self.rebuild_remove_actions()\n\n    def add_operand_input(self):\n        self.register_new_operand_input(self.node.num_inputs + 1)\n        self.node.add_op_input()\n\n    def register_new_operand_input(self, index):\n        self.actions[f'remove input'][f'{index}'] = {\n            'method': self.remove_operand_input,\n            'data': index\n        }\n\n    def remove_operand_input(self, index):\n        self.node.remove_op_input(index)\n        self.rebuild_remove_actions()\n\n    def rebuild_remove_actions(self):\n        try:\n            self.actions['remove input'] = {}\n            for i in range(self.node.num_inputs):\n                self.actions[f'remove input'][f'{i}'] = \\\n                    {'method': self.remove_operand_input, 'data': i}\n        except Exception as e:\n            print(e)\n\n\n\nexport_guis([\n    # DualNodeBaseGui,\n    #\n    # CheckpointNodeGui,\n    # OperatorNodeBaseGui,\n    BasicNodeGui\n    # LogicNodeBaseGui,\n    # ArithNodeBaseGui,\n    # CompNodeBaseGui,\n    #\n    # CSNodeBaseGui,\n    # ForLoopGui,\n    # ForEachLoopGui,\n    #\n    # SpecialNodeGuiBase,\n    # ButtonNodeGui,\n    # ClockNodeGui,\n    # LogNodeGui,\n    # SliderNodeGui,\n    # DynamicPortsGui,\n    # ExecNodeGui,\n    # EvalNodeGui,\n    # InterpreterConsoleGui,\n    # StorageNodeGui,\n    # LinkIN_NodeGui,\n    # LinkOUT_NodeGui,\n])\n\n",
        "nodes.py": "from ryven.node_env import *\nimport sys\nimport os\nsys.path.append(os.path.dirname(__file__))\nimport node_from_db\nimport create_dummy\nimport tempfile\nimport atexit\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\nfrom database_lib import redis_lib_client\nfrom vastlib.utils import read_json\n\ndef remove_temp(path):\n    if os.path.exists(path):  # if file is existing then delete it\n        os.remove(path)\n\n# TODO: db configuration is read by config file (not hard cording)\n# config = read_json(\"config/config.json\")\n# DATABASE_URL = config[\"db_url\"]\n# controller = db_lib.db_controller(DATABASE_URL)\ncontroller = redis_lib_client.db_controller()\n\ndummy_path = create_dummy.create_dummy(controller)\n# delete dummy file when program ends\natexit.register(remove_temp, path=dummy_path)\n\n# source code for dynamic class from metadata\nwith open(node_from_db.__file__, 'r') as f:\n    node_from_db_code = f.read()\n\n# dummy code for dynamic class\nwith open(dummy_path, 'r') as f:\n    dummy_code = f.read()\n\n# dummy file path (debug)\n#path = os.path.dirname(os.path.abspath(__file__)) + \"\\\\temp.py\"\n\n# merge dynamic class file and dummy class file\n#with open(path, 'w+') as fw:\nwith tempfile.NamedTemporaryFile(dir=os.path.dirname(__file__), suffix=\".py\", delete=False) as temp_file:\n    temp_file_path = temp_file.name\n    with open(temp_file_path, 'a+') as fw:\n        fw.write(node_from_db_code)\n        fw.write(dummy_code)\n        fw.seek(0)\n\natexit.register(remove_temp, path=temp_file_path)\n\nfile_path = os.path.dirname(temp_file_path)\nsys.path.append(file_path)\n\n# import merged file\nmdl = __import__(os.path.basename(temp_file_path[:-3]), fromlist=['*'])\n\n# export custom nodes\nexport_nodes([\n    *mdl.get_nodes()\n])\n\n",
        "node_from_db.py": "from ryven.node_env import *\nimport sys\nimport os\nimport time\nfrom time import sleep\nfrom copy import copy, deepcopy\nfrom PySide2.QtCore import Signal, QObject, QThread\nfrom database_lib import redis_lib_client\nfrom functools import partial\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\n\nguis = import_guis(__file__)\nglobalcount = 0\nclass NodeBase(Node):\n    color = '#00a6ff'\n\nclass BasicNode(NodeBase):\n    version = 'v0.1'\n    title = 'base'\n    name = 'base'\n    counter = 0\n    message = {}\n    _FUNC = None\n\n    INSTANCES = []\n    controller = None\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.activate = True\n        global comm\n        self.comm = comm\n        self.message_recv_slot = partial(self.get_message, self)\n        self.connect = False\n\n    def __start(self):\n        if not self.connect:\n            self.comm.recv_signal.connect(self.message_recv_slot)\n            self.connect = True\n\n    def __stop(self):\n        if self.connect:\n            self.comm.recv_signal.disconnect(self.message_recv_slot)\n            self.connect = False\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\n    def get_message(self, _self, _recv_message):\n        recv_message = _recv_message\n\n        try:\n            obj_name, id_num = recv_message.split(\":\")\n        except Exception as e:\n            # if message format is not correct, continue recv\n            return\n\n        if \"Errors\" in obj_name:\n            # check error message\n            ret = self.check_err(obj_name, id_num, self.message)\n            # if \"module\" and \"id\" in error message are matched, stop recv\n            try:\n                if ret:\n                    self.gui.set_display_title(self.title + \"(err)\")\n                    self.__stop()\n                    # display log on headless gui\n                    if self._FUNC is not None:\n                        self._FUNC(self.name[:-6], \"Error\")\n                    return\n                else:\n                    return\n            except:\n                pass\n\n\n        # check name and id\n        if (obj_name[:-7] == self.name[:-6] and int(id_num) == int(self.message[\"id\"])):\n            # if name and id is correct, stop recv\n            self.__stop()\n            pass\n        else:\n            return\n\n        # get result record\n        record_dict = self.controller.get_record_client(obj_name, id_num)\n        # write recode to output ports\n        for i, outp in enumerate(self.outputs):\n            if outp.type_ == \"exec\":\n                continue\n            self.set_output_val(i, Data(record_dict[outp.label_str]))\n\n        # exec flow\n        try:\n            self.gui.set_display_title(self.title)\n        except:\n            pass\n        # display log on headless gui\n        if self._FUNC is not None:\n            self._FUNC(self.name[:-6], \"Done\")\n        self.exec_output(0)\n\n\n\n    # main function of nodes\n    def update_event(self, inp_num=-1):\n        # update only for exec flow\n        if inp_num == 0:\n            # reset input port color\n            self.reset_color()\n            # check id\n            self.counter = self.controller.check_key(self.title + \"Inputs\", self.counter)\n            # create message\n            message = {\"id\": copy(self.counter)}\n            self.counter += 1\n            for i, inp in enumerate(self.inputs):\n                if inp.type_ == \"exec\":\n                    continue\n                try:\n                    if self.input(i).payload != \"None\":\n                        message[inp.label_str] = self.input(i).payload\n                except:\n                    pass\n\n            self.message = deepcopy(message)\n\n            self.__stop()\n            self.__start()\n\n            res = self.controller.set_record_and_notify_client(self.title + \"Inputs\",\n                                                               message,\n                                                               \"input\",\n                                                               message[\"id\"]\n            )\n            try:\n                self.gui.set_display_title(self.title + \"<<<\")\n            except:\n                pass\n\n            if self._FUNC is not None:\n                self._FUNC(self.name[:-6], \"start\")\n\n    def check_err(self, obj_name, id_num, send_message):\n        # get result record\n        try:\n            record_dict = self.controller.get_record_client(obj_name, id_num)\n            if record_dict[\"input_id\"] == send_message[\"id\"] and self.title in record_dict[\"module\"]:\n                if obj_name == \"FlowErrors\":\n                    for name in record_dict[\"message\"]:\n                        for num, input in enumerate(self.inputs):\n                            if num == 0:\n                                continue\n                            if name == input.label_str:\n                                self.gui.input_widget(num).setStyleSheet(\"background-color:red;\")\n                return True\n            else:\n                return False\n        except:\n            return False\n\n    def reset_color(self):\n        try:\n            for i in range(len(self.gui.input_widgets)):\n                if i == 0:\n                    continue\n                self.gui.input_widget(i).setStyleSheet(\"background-color:black;\")\n        except:\n            pass\n\n\n# matching xxinputs and xxoutputs\ndef extract_nodenames(names):\n    inputs_list = [item for item in names if \"inputs\" in item.lower()]\n    results_list = [item for item in names if \"outputs\" in item.lower()]\n\n    mapping = {}\n    for item in inputs_list:\n        prefix = item[:-6]\n        matching_result = [result for result in results_list if result.startswith(prefix)]\n        if matching_result:\n            mapping[item] = matching_result[0]\n\n    return mapping\n\ndef get_nodes():\n    controller = redis_lib_client.db_controller()\n    nodenames = controller.get_table_names()\n    io_pairs = extract_nodenames(nodenames)\n    _nodes = []\n\n    # create node class\n    for i, (i_name, r_name) in enumerate(io_pairs.items()):\n        i_columns = controller.get_columns(i_name)\n        r_columns = controller.get_columns(r_name)\n\n        cls = type(i_name, (BasicNode,), {})\n\n        init_record = controller.get_record_client(table_name=i_name, record_id=0)\n\n        cls.name = i_name\n        cls.title = i_name[:-6]\n\n        node_inputs = [NodeInputType(type_='exec')]\n        node_outputs = [NodeOutputType(type_='exec')]\n\n        for i, i_column in enumerate(i_columns):\n            if i_column[\"name\"] != \"id\" and i_column[\"name\"] != \"date\":\n                if type(init_record) == dict:\n                        try:\n                            node_inputs.append(NodeInputType(i_column[\"name\"], default=str(init_record[i_column[\"name\"]])))\n                        except:\n                            node_inputs.append(NodeInputType(i_column[\"name\"]))\n                else:\n                    node_inputs.append(NodeInputType(i_column[\"name\"]))\n        for i, r_column in enumerate(r_columns):\n            if r_column[\"name\"] != \"id\" and r_column[\"name\"] != \"date\":\n                node_outputs.append(NodeOutputType(r_column[\"name\"]))\n        cls.init_inputs = node_inputs\n        cls.init_outputs = node_outputs\n\n        cls.num_inputs = len(i_columns)\n        # cls.GUI = guis.OperatorNodeBaseGui\n        cls.GUI = guis.BasicNodeGui\n\n        # TODO:this inplementation may be bad.\n        cls.controller = controller\n\n        _nodes.append(cls)\n\n    return _nodes\n\nclass Communicate(QObject):\n    # カスタムシグナルの定義\n    recv_signal = Signal(str)\n    def __init__(self, controller):\n        super().__init__()\n        self.thread = listen_thread(controller)\n        self.thread.message_signal.connect(lambda v: self._notification(v))\n\n    def _start(self):\n        self.thread.running = True\n        self.thread.start()\n        while not self.thread.isRunning():\n            time.sleep(0.001)\n\n    def _stop(self):\n        self.thread.stop()\n        self.thread.wait()\n\n    def _notification(self, message):\n        self.recv_signal.emit(message)\n\n    def __del__(self):\n        self._stop()\n\nclass listen_thread(QThread):\n    message_signal = Signal(str)\n    def __init__(self, controller):\n        super().__init__()\n        self.running = True\n        self.controller = controller\n\n    def run(self):\n        while self.running:\n            try:\n                sleep(0.001)\n                recv_message = self.controller._listen_message(channels=[\"output\", \"error\"],\n                                                              timeout=0\n                                                              )\n                if recv_message is not None:\n                    self.message_signal.emit(recv_message)\n                    continue\n                else:\n                    continue\n            except:\n                continue\n\n        return\n\n    def set_controller(self, controller):\n        self.controller = controller\n\n    def stop(self):\n        self.running = False\n\ncontroller = redis_lib_client.db_controller()\ncomm = Communicate(controller)\ncomm._start()"
    },
    "vast-vision-nocode-tool-analysis\\nodes_common\\calculation_nodes": {},
    "vast-vision-nocode-tool-analysis\\nodes_uncommon": {},
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\display_image": {
        "gui.py": "from ryven.gui_env import *\n\nfrom qtpy.QtWidgets import QLineEdit, QFrame, QVBoxLayout\nimport cv2\nimport pyqtgraph as pg\n\nimport os\nimport sys\nsys.path.append(os.path.dirname(__file__))\nimport numpy as np\nfrom vastlib.utils import get_img_from_fs\nfrom media_plugins.media_controller import media_controller\n\n# class BasicViewWidget(NodeInputWidget, QGraphicsView):\n#     def __init__(self, params):\n#         NodeInputWidget.__init__(self, params)\n#         QGraphicsView.__init__(self)\n#         # シーンの定義\n#         self.graphics_scene = QGraphicsScene()\n#         self.setScene(self.graphics_scene)\n#\n#         self.img = np.zeros((640, 480, 3), dtype=np.uint8)\n#         self.image_item = pg.ImageItem(image=self.img)\n#         self.graphics_scene.addItem(self.image_item)\n#         #self.image_item = None\n#\n#     def val_update_event(self, val: Data):\n#         super().val_update_event(val)\n#         path = val.payload\n#         file_name = os.path.basename(path)\n#         res = samba_lib.get_image(\n#             \"vast\",\n#             \"vast\",\n#             \"pysmb\",\n#             \"vast\",\n#             \"\",\n#             \"192.168.0.100\",\n#             file_name\n#         )\n#         self.set_image(res)\n#\n#\n#     def set_image(self, img):\n#         img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n#         self.image_item.setImage(image=img, autoLevels=False)\n#         #self.graphics_scene.clear()\n\n# 画像を表示するウィジェット\nclass BasicViewWidget(NodeInputWidget, QFrame):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QFrame.__init__(self)\n\n        self.media_controller = media_controller()\n\n        # QFrameを継承し、レイアウトとQGraphicsLayoutViewを載せる\n        layout = QVBoxLayout(self)\n        self.gl = pg.GraphicsLayoutWidget()\n        self.box_layout = self.gl.addLayout(row=0, col=0)\n        self.box_layout.setBorder((255, 255, 255, 255), width=0.8)\n\n        # QGraphicsLayoutViewにViewBoxを追加する\n        self.vb = pg.ViewBox()\n        self.vb.setAspectLocked()\n        self.box_layout.addItem(self.vb, row=0, col=0, rowspan=1, colspan=1)\n\n        # 画像を貼り付けておく\n        img = np.zeros((640, 480, 3), dtype=np.uint8)\n        self.img_item = pg.ImageItem(image=img)\n        self.vb.addItem(self.img_item)\n\n        # サイズ指定\n        # TODO:画像に合わせて変わるもしくは指定できるようにする\n        self.setMinimumWidth(640)\n        self.setMinimumHeight(480)\n\n        layout.addWidget(self.gl)\n\n\n    # ポートの値が更新された際に発火するイベント\n    def val_update_event(self, val: Data):\n        super().val_update_event(val)\n        try:\n            # 値を取得（画像のパス）\n            path = val.payload\n\n            if os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n                # ファイル名でsambaサーバを検索\n                res = get_img_from_fs(path=path, ip_address=os.environ[\"VAST_SERVER\"])\n            else:\n                res = self.media_controller.read(path, np.ndarray)\n\n            # ViewBoxに画像をセット\n            self.set_image(res)\n        except:\n            pass\n\n    def set_image(self, img):\n        try:\n            # self.vb.clear()\n            img = np.rot90(img, 2)\n            img = cv2.flip(img, 1)\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n            self.img_item.setImage(image=img, autoLevels=False)\n            # self.graphics_scene.clear()\n        except:\n            pass\n\nclass BasicInputWidget(NodeInputWidget, QLineEdit):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QLineEdit.__init__(self)\n\n        self.setMinimumWidth(60)\n        self.setMaximumWidth(100)\n        self.setStyleSheet(\"background-color:black;\")\n\n        ## loadしたとき毎回発火してしまう->silent=Trueで解決\n        self.textChanged.connect(lambda: self.text_changed())\n        self.init_value()\n\n    def text_changed(self):\n        self.update_node_input(Data(self.text()), silent=True)\n\n    def get_state(self) -> dict:\n        return {'value': self.text()}\n\n    def set_state(self, data: dict):\n        try:\n            self.setText(data['value'])\n        except:\n            pass\n\n    def init_value(self):\n        # input the default value\n        self.set_state({\"value\": self.input.default})\n\n    def val_update_event(self, val: Data):\n        try:\n            super().val_update_event(val)\n            # 値を取得（画像のパス）\n            data = val.payload\n            self.setText(str(data))\n        except:\n            pass\n\n# 画像確認用のGUI\nclass BasicViewNodeGui(NodeGUI):\n    # inputのポートの横に、BasicViewWidgetが付く\n    input_widget_classes = {'input': BasicViewWidget,\n                            'display_name': BasicInputWidget}\n    def __init__(self, params):\n        super().__init__(params)\n        for i, inp in enumerate(self.node.inputs):\n            if i == 0:\n                self.input_widgets[inp] = {'name': 'input', 'pos': 'besides'}\n            else:\n                self.input_widgets[inp] = {'name': 'display_name', 'pos': 'besides'}\n\n\nexport_guis([\n    BasicViewNodeGui,\n])",
        "nodes.py": "from ryven.node_env import *\nimport sys\nimport os\n\nsys.path.append(os.path.dirname(__file__))\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\n\nguis = import_guis(__file__)\n\nclass NodeBase(Node):\n    version = \"v0.1\"\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\n\n# QGraphicsLayoutView(pyqtgraph)で画像を確認するノード\nclass BasicViewNode(NodeBase):\n    title = 'Disp_DisplayImage'\n\n    init_inputs = [\n        NodeInputType(type_='data'),\n        NodeInputType(\"name\", type_='data')\n    ]\n    init_outputs = []\n\n    GUI = guis.BasicViewNodeGui\n    _FUNC = None # 外部ファンクションの受け皿\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.active = True\n\n    def update_event(self, inp_num=-1):\n        # gui.pyで更新処理が行われる\n        if self._FUNC is not None:\n            self._FUNC(self)\n\n\nexport_nodes([\n    BasicViewNode,\n])\n"
    },
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\logical_nodes": {
        "gui.py": "from ryven.gui_env import *\n\nfrom qtpy.QtWidgets import QPushButton, QWidget, QFrame, QVBoxLayout, QFileDialog, QLabel\nimport pyqtgraph as pg\nfrom PySide2 import QtCore\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nimport numpy as np\n\n\nclass PrgAndWidget(NodeMainWidget, QLabel):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QLabel.__init__(self)\n\n        # Create a QLabel to display some text\n        self.label1 = QLabel(' default')\n        self.label2 = QLabel(' status')\n        self.label1.setAlignment(QtCore.Qt.AlignCenter)\n        self.label2.setAlignment(QtCore.Qt.AlignCenter)\n\n        # Set the widget's layout\n        self.layout = QVBoxLayout(self)\n        self.layout.addWidget(self.label1)\n        self.layout.addWidget(self.label2)\n\n    def update_label1(self):\n        self.label1.setText('input1=1')\n        self.label2.setText('input2=0')\n        # print('input1=1')\n\n    def update_label2(self):\n        self.label1.setText('input1=0')\n        self.label2.setText('input2=1')\n        # print('input2=1')\n\n    def update_label_reset(self):\n        self.label1.setText('input 1+2')\n        self.label2.setText('activated')\n        # print('reset')\n\n\nclass PrgOrWidget(NodeMainWidget, QLabel):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QLabel.__init__(self)\n\n        # Create a QLabel to display some text\n        self.label1 = QLabel(' default')\n        self.label2 = QLabel(' status')\n        self.label1.setAlignment(QtCore.Qt.AlignCenter)\n        self.label2.setAlignment(QtCore.Qt.AlignCenter)\n\n        # Set the widget's layout\n        self.layout = QVBoxLayout(self)\n        self.layout.addWidget(self.label1)\n        self.layout.addWidget(self.label2)\n\n    def update_label1(self):\n        self.label1.setText('input1')\n        self.label2.setText('activated')\n        # print('input1=1')\n\n    def update_label2(self):\n        self.label1.setText('input2')\n        self.label2.setText('activated')\n        # print('input2=1')\n\n\nclass PrgSwitchWidget(NodeMainWidget, QLabel):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QLabel.__init__(self)\n\n        # Create a QLabel to display some text\n        self.label1 = QLabel('switch button')\n        self.label2 = QLabel('loop entrance')\n        self.label1.setAlignment(QtCore.Qt.AlignCenter)\n        self.label2.setAlignment(QtCore.Qt.AlignCenter)\n\n        # Set the widget's layout\n        self.layout = QVBoxLayout(self)\n        self.layout.addWidget(self.label1)\n        self.layout.addWidget(self.label2)\n\n    def update_label1(self):\n        if self.label1.text() == 'button negative' or self.label1.text() == 'switch button':\n            self.label1.setText('button active')\n        elif self.label1.text() == 'button active':\n            self.label1.setText('button negative')\n        # print('input1=1')\n\n    def update_label2(self):\n        if self.label1.text() == 'button negative' or self.label1.text() == 'switch button':\n            self.label2.setText('loop negative')\n        elif self.label1.text() == 'button active':\n            self.label2.setText('looping')\n        # print('input2=1')\n\n    def update_label_reset(self):\n        self.label1.setText('input1=1')\n        self.label2.setText('input2=1')\n        # print('reset')\n\n\nclass PrgAndGui(NodeGUI):\n    main_widget_class = PrgAndWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        pass\n\n    # def update_label(self, text):\n    #     print('gui',text)\n    #     if self.main_widget_class:\n    #         self.main_widget_class.update_label(self,text)\n\n\nclass PrgOrGui(NodeGUI):\n    main_widget_class = PrgOrWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        pass\n\n\nclass PrgSwitchGui(NodeGUI):\n    main_widget_class = PrgSwitchWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        pass\n\n\nexport_guis([\n    PrgAndGui,\n    PrgOrGui,\n    PrgSwitchGui\n])\n\nif __name__ == \"__main__\":\n    test = PrgSwitchWidget\n    print(test)\n",
        "nodes.py": "from ryven.node_env import *\nimport sys\nimport os\nimport json\nimport threading\nimport time\nfrom queue import Queue\nfrom PySide2.QtWidgets import QWidget, QLabel, QVBoxLayout\n\nsys.path.append(os.path.dirname(__file__))\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\n\nguis = import_guis(__file__)\n\n\nclass NodeBase(Node):\n    version = \"v0.1\"\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\n\nclass PrgAndNode(NodeBase):\n    title = 'Prg_And'\n    name = 'Prg_And'\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(type_=\"exec\"),\n    ]\n    init_outputs = [\n        NodeInputType(type_=\"exec\")\n    ]\n    GUI = guis.PrgAndGui\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.input_1_triggered = False\n        self.input_2_triggered = False\n        self.active = True\n\n    def update_event(self, input_called=-1):\n        try:\n            if input_called == 0:  # exec input 1 called\n                self.input_1_triggered = True\n                try:\n                    self.gui.main_widget().update_label1()\n                except:\n                    pass\n            elif input_called == 1:  # exec input 2 called\n                self.input_2_triggered = True\n                try:\n                    self.gui.main_widget().update_label2()\n                except:\n                    pass\n            if self.input_1_triggered and self.input_2_triggered:\n                self.exec_output(0)  # trigger exec output\n                self.input_1_triggered = False\n                self.input_2_triggered = False\n                try:\n                    self.gui.main_widget().update_label_reset()\n                except:\n                    pass\n            # self.input_label.setText(self.input_1_triggered)\n        except Exception as e:\n            print(f\"Error sending message: {e}\")\n\n\nclass PrgOrNode(NodeBase):\n    title = 'Prg_Or'\n    name = 'Prg_Or'\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(type_=\"exec\"),\n\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n    ]\n    GUI = guis.PrgOrGui\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.input_2_triggered = False\n        self.input_1_triggered = False\n\n    def update_event(self, input_called=-1):\n        print(\"EXEC!!\")\n        try:\n            if input_called == 0:  # exec input 1 called\n                self.exec_output(0)  # trigger exec output\n                try:\n                    self.gui.main_widget().update_label1()\n                except:\n                    pass\n            elif input_called == 1:  # exec input 2 called\n                self.exec_output(0)  # trigger exec output\n                try:\n                    self.gui.main_widget().update_label2()\n                except:\n                    pass\n        except Exception as e:\n            print(f\"Error receiving message: {e}\")\n\n\nclass PrgSwitchNode(NodeBase):\n    title = 'Prg_Switch'\n    name = 'Prg_Switch'\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(type_=\"exec\"),\n    ]\n    init_outputs = [\n        NodeInputType(type_=\"exec\")\n    ]\n    GUI = guis.PrgSwitchGui\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.input_1_triggered = False\n        # self.input_2_triggered = False\n        self.active = False\n\n    def update_event(self, input_called=-1):\n        try:\n            if input_called == 0:  # exec input 1 called\n                if self.input_1_triggered:\n                    self.input_1_triggered = False\n                    try:\n                        self.gui.main_widget().update_label1()\n                    except:\n                        pass\n                else:\n                    self.input_1_triggered = True\n                    try:\n                        self.gui.main_widget().update_label1()\n                    except:\n                        pass\n                    self.exec_output(0)\n            elif input_called == 1:  # exec input 2 called\n                # self.input_2_triggered = True\n                try:\n                    self.gui.main_widget().update_label2()\n                except:\n                    pass\n            if self.input_1_triggered:\n                self.exec_output(0)  # trigger exec output\n                # self.gui.main_widget().update_label_reset()\n            # self.input_label.setText(self.input_1_triggered)\n        except Exception as e:\n            print(f\"Error sending message: {e}\")\n\nclass PrgBranchNode(NodeBase):\n    title = 'Prg_Branch'\n    name = 'Prg_Branch'\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"bool\", type_=\"data\"),\n    ]\n    init_outputs = [\n        NodeInputType(\"True\", type_=\"exec\"),\n        NodeInputType(\"False\", type_=\"exec\")\n    ]\n\n    def __init__(self, params):\n        super().__init__(params)\n\n    def update_event(self, inp=-1):\n        if inp == 0:\n            try:\n                if self.input(1) is None:\n                    # False\n                    self.exec_output(1)\n                else:\n                    val = self.input(1).payload\n                    if val == \"True\":\n                        # True\n                        self.exec_output(0)\n                    elif val == \"False\":\n                        # False\n                        self.exec_output(1)\n                    else:\n                        if val:\n                            # True\n                            self.exec_output(0)\n                        else:\n                            # False\n                            self.exec_output(1)\n            except Exception as e:\n                print(e)\n                self.exec_output(1)\n\n\nexport_nodes([\n    PrgAndNode,\n    PrgOrNode,\n    PrgSwitchNode,\n    PrgBranchNode\n])\n\nif __name__ == \"__main__\":\n    test = PrgSwitchNode\n"
    },
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\mask_nodes": {},
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\mask_nodes(delete)": {
        "gui.py": "from ryven.gui_env import *\n\nfrom qtpy.QtWidgets import QPushButton, QFrame, QVBoxLayout, QFileDialog, QLabel\nimport pyqtgraph as pg\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nimport numpy as np\n\n\nclass CreateMaskWidget(NodeMainWidget, QLabel):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QLabel.__init__(self)\n\n\nclass CreateMaskGui(NodeGUI):\n    main_widget_class = CreateMaskWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n\nexport_guis([\n    CreateMaskGui,\n])\n",
        "mask_function.py": "# -*- coding : UTF-8 -*-\n# ===============================================================================\n# Name      : mask_function.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp:2024-08-23 13:46\n# Copyirght 2024 Tatsuya Sugino\n# ===============================================================================\nimport cv2\nimport numpy as np\nfrom typing import List, Optional, Tuple, Union\n\nfrom cv_shapes_lib import CvShape, Rectangle, Circle, Ellipse, Polygon\n\n\ndef make_mask_img(img: np.ndarray,\n                  canvas: Union[np.ndarray, None],\n                  inverse: Union[bool, None],\n                  shape: CvShape):\n    # イメージが入力されていない場合キャンバスをコピー\n    if img is None:\n        # イメージ・キャンバスの両方が無い場合エラー\n        if canvas is None:\n            raise SystemError(\"Please input img or canvas.\")\n        else:\n            img = canvas.copy()\n\n    # 画像の大きさを取得\n    height, width = img.shape[:2]\n\n    # キャンバスが指定されていない場合、imgからキャンバスを作成\n    if canvas is None:\n        if inverse:\n            canvas = np.full((height, width), 255, dtype=np.uint8)\n        else:\n            canvas = np.zeros((height, width), dtype=np.uint8)\n\n    # 描画する色を設定\n    # color = (255, 255, 255) if inverse else (0, 0, 0)\n    # color = (0, 0, 0) if inverse else (255, 255, 255)\n    if inverse:\n        color = (0, 0, 0)\n    else:\n        color = (255, 255, 255)\n\n\n    if not isinstance(shape, CvShape):\n        raise TypeError(f\"Shape data must be an instance of CvShape, got {type(shape_data)}\")\n\n    # draw_shapeメソッドを呼び出して形状を描画\n    shape.draw_shape(canvas, color)\n\n    return canvas\n\n\nif __name__ == \"__main__\":\n    # テスト用の画像とキャンバスを作成\n    img = np.ones((300, 300, 3), dtype=np.uint8)\n    img = img * 255\n    canvas = None\n\n    # 形状を定義\n    rect = [Rectangle(x1=50, y1=50, x2=150, y2=150)]\n\n    # マスク画像を作成\n    mask = make_mask_img(img, canvas, inverse=False, shape=rect)\n\n    # 結果を表示\n    cv2.imshow(\"Mask\", mask)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n",
        "nodes.py": "from ryven.node_env import *\nimport sys\nimport os\nimport numpy as np\nfrom datetime import datetime\nfrom cv_shapes_lib import CvShape\nimport re\n\nsys.path.append(os.path.dirname(__file__))\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\n\nfrom media_plugins.media_controller import media_controller\n\nfrom nodes_uncommon.mask_nodes.mask_function import make_mask_img\n\n\nimport platform\nif platform.system() != \"Windows\":\n    server_path = \"/opt/.VAST/file_server/\"\nelse:\n    server_path = \"C:/file_server/\"\n\nguis = import_guis(__file__)\n\n\nclass NodeBase(Node):\n    version = \"v0.1\"\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\n\nclass Pre_Create_Mask_Node(NodeBase):\n    title = 'ROI_CreateMask'\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"img\", type_=\"data\"),\n        NodeInputType(\"canvas\", type_=\"data\"),\n        NodeInputType(\"inverse\", type_=\"data\"),\n        NodeInputType(\"shape\", type_=\"data\"),\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"mask\")\n    ]\n    GUI = guis.CreateMaskGui\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.media_controller = media_controller()\n        # self.shape = [Rectangle(x1=50, y1=50, x2=150, y2=150)] # debug用\n\n    def update_event(self, inp=-1):\n        # exec flow以外は無視\n        if inp == 0:\n            # 実行中表記\n            try:\n                # ヘッドレスモードではguiにアクセスできないのでtry-except\n                self.gui.set_display_title(self.title + \"<<<\")\n            except:\n                pass\n\n            try:\n                inputs = self.get_processed_inputs()\n                _mask = self.create_mask(*inputs)\n\n                if _mask is not None:\n                    self.save_and_output_data(_mask)\n                try:\n                    self.gui.set_display_title(self.title)\n                except:\n                    pass\n\n                # フローをexec\n                self.exec_output(0)\n\n            except Exception as e:\n                # TODO:ヘッドレスモードでエラー箇所をロガーに流せるように仕様を考える\n                try:\n                    self.gui.set_display_title(self.title + \"(err)\")\n                except:\n                    pass\n                print(f\"Error : {e}\")\n\n    # 汎用入力\n    def get_processed_inputs(self):\n        \"\"\"入力を処理してリストを返す\"\"\"\n        inputs = []\n        for i in range(1, len(self.init_inputs)):  # input(0)はexec\n            try:\n                input_payload = self.input(i).payload\n                inputs.append(input_payload)\n            except AttributeError:\n                print(f\"Warning: input({i}) is None\")\n                inputs.append(None)\n        processed_inputs = []\n\n        pattern = r'^(?:[a-zA-Z]:[\\\\/])?(?:[\\w-]+[\\\\/])*[\\w-]+\\.\\w+$'\n        for input_ in inputs:\n            if input_ is None:\n                processed_inputs.append(None)\n            elif bool(re.match(pattern, input_)):\n                processed_input = self.media_controller.read(input_, require_obj=np.ndarray)\n                processed_inputs.append(processed_input)\n            elif isinstance(input_, str):\n                processed_input = self.media_controller.read(input_, require_obj=CvShape)\n                processed_inputs.append(processed_input)\n            else:\n                processed_inputs.append(input_)\n\n        return processed_inputs\n\n    def create_mask(self, img, canvas, inverse, shape):\n        \"\"\"マスク画像を作成\"\"\"\n        return make_mask_img(img=img, canvas=canvas, inverse=inverse, shape=shape)\n        # return make_mask_img(img=img, canvas=canvas, inverse=inverse, shape=self.shape)\n\n    def save_and_output_data(self, data):\n        \"\"\"マスクを保存し、出力に設定\"\"\"\n        formatted_date = datetime.now().strftime('%Y%m%d_%H%M%S%f')\n        path = f\"{server_path}{self.__class__.__name__}_{formatted_date}\"\n        _path = self.media_controller.write(path, data)\n        self.set_output_val(1, Data(_path))\n        self.exec_output(0)\n\n\nexport_nodes([\n    Pre_Create_Mask_Node,\n])\n"
    },
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\node_for_headless": {
        "gui.py": "from ryven.gui_env import *\nfrom PySide2.QtWidgets import QLineEdit\n\nclass BasicInputWidget(NodeInputWidget, QLineEdit):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QLineEdit.__init__(self)\n\n        self.setMinimumWidth(60)\n        self.setMaximumWidth(100)\n        self.setStyleSheet(\"background-color:black;\")\n\n        ## loadしたとき毎回発火してしまう->silent=Trueで解決\n        self.textChanged.connect(lambda: self.text_changed())\n        self.init_value()\n\n    def text_changed(self):\n        self.update_node_input(Data(self.text()), silent=True)\n\n    def get_state(self) -> dict:\n        return {'value': self.text()}\n\n    def set_state(self, data: dict):\n        try:\n            self.setText(data['value'])\n        except:\n            pass\n\n    def init_value(self):\n        # input the default value\n        self.set_state({\"value\": self.input.default})\n\n    def val_update_event(self, val: Data):\n        try:\n            super().val_update_event(val)\n            # 値を取得（画像のパス）\n            data = val.payload\n            self.setText(str(data))\n        except:\n            pass\n\n\nclass ActiveInputWidget(NodeInputWidget, QLineEdit):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QLineEdit.__init__(self)\n\n        self.setMinimumWidth(60)\n        self.setMaximumWidth(100)\n        self.setStyleSheet(\"background-color:black;\")\n\n        ## loadしたとき毎回発火してしまう->silent=Trueで解決\n        self.textChanged.connect(lambda: self.text_changed())\n        self.init_value()\n\n    def text_changed(self):\n        self.update_node_input(Data(self.text()), silent=True)\n        try:\n            self.update_node()\n        except:\n            pass\n\n    def get_state(self) -> dict:\n        return {'value': self.text()}\n\n    def set_state(self, data: dict):\n        try:\n            self.setText(data['value'])\n        except:\n            pass\n\n    def init_value(self):\n        # input the default value\n        self.set_state({\"value\": self.input.default})\n\n    def val_update_event(self, val: Data):\n        try:\n            super().val_update_event(val)\n            # 値を取得（画像のパス）\n            data = val.payload\n            self.setText(str(data))\n        except:\n            pass\n\nclass BasicNodeGui(NodeGUI):\n    input_widget_classes = {'input': BasicInputWidget}\n\n    def add_input(self, name):\n        self.init_input_widgets[len(self.init_input_widgets)] = {'name':'input', 'pos':'below'}\n\n    def __init__(self, params):\n        super().__init__(params)\n\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'input', 'pos': 'besides'}\n\nclass ActiveNodeGui(NodeGUI):\n    input_widget_classes = {'input': ActiveInputWidget}\n\n    def add_input(self, name):\n        self.init_input_widgets[len(self.init_input_widgets)] = {'name':'input', 'pos':'below'}\n\n    def __init__(self, params):\n        super().__init__(params)\n\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'input', 'pos': 'besides'}\n\n\nexport_guis([\n    BasicNodeGui,\n    ActiveNodeGui\n])\n",
        "nodes.py": "from ryven.node_env import *\nimport sys\nimport os\nguis = import_guis(__file__)\n\nclass NodeBase(Node):\n    version = \"v0.1\"\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\nclass Value_Node(NodeBase):\n    title = 'Disp_ShowValue'\n    init_inputs = [\n        NodeInputType(\"name\", type_=\"data\"),\n        NodeInputType(\"val\", type_=\"data\")\n    ]\n    GUI = guis.BasicNodeGui\n    _FUNC = None\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.active = True\n\n    def update_event(self, inp=-1):\n        if self._FUNC is not None:\n            self._FUNC(self)\n\nclass Judge_Node(NodeBase):\n    title = 'Disp_Judge'\n    init_inputs = [\n        NodeInputType(\"name\", type_=\"data\"),\n        NodeInputType(\"val\", type_=\"data\")\n    ]\n    GUI = guis.BasicNodeGui\n    _FUNC = None\n\n    def update_event(self, inp=-1):\n        if self._FUNC is not None:\n            self._FUNC(self)\n\nclass Adjust_Node(NodeBase):\n    title = 'Disp_Adjust'\n    init_inputs = [\n        NodeInputType(\"name\", type_=\"data\"),\n        NodeInputType(\"val\", type_=\"data\")\n    ]\n    init_outputs = [\n        NodeOutputType(\"val\", type_=\"data\")\n    ]\n    GUI = guis.BasicNodeGui\n    _FUNC = None\n\n    def update_event(self, inp=-1):\n        if inp == 1:\n            try:\n                self.set_output_val(0, Data(self.input(1).payload))\n            except:\n                self.set_output_val(0, Data(None))\n\n    def update_value(self, val):\n        self.input(1).set_data(Data(val))\n        self.set_output_val(0, Data(val))\n\n# export custom nodes\nexport_nodes([\n    Value_Node,\n    Judge_Node,\n    Adjust_Node\n])\n\n"
    },
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\roi": {
        "gui.py": "from ryven.gui_env import *\n\nfrom qtpy.QtWidgets import QPushButton, QFileDialog, QLineEdit\nfrom media_plugins.media_controller import media_controller\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nimport platform\nfrom vastlib.utils import get_img_from_fs\n\nimport numpy as np\nfrom roi_rectangle_dialog import BasicROIRectangleDialog\nfrom roi_circle_dialog import BasicROICircleDialog\nfrom roi_ellipse_dialog import BasicROIEllipseDialog\nfrom roi_polygon_dialog import BasicROIPolygonDialog\n\n\n\n# 画像を表示するウィジェット\nclass BasicRoiRectangleWidget(NodeInputWidget, QPushButton):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QPushButton.__init__(self)\n        self.dlg = BasicROIRectangleDialog()\n        self.media_controller = media_controller()\n        self.clicked.connect(lambda: self.show_dialog())\n\n    def show_dialog(self):\n        self.update_node()\n        self.dlg.exec_()\n        # ノードに値をセット\n        self.update_node_input(Data(self.dlg.get_roi()), silent=False)\n        self.update_node()\n\n\n    # ポートの値が更新された際画像であれば\n    def img_update_event(self, val: Data):\n        try:\n            # 値を取得（画像のパス）\n            path = val.payload\n\n            if os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n                # ファイル名でsambaサーバを検索\n                res = get_img_from_fs(path=path, ip_address=os.environ[\"VAST_SERVER\"])\n            else:\n                res = self.media_controller.read(path, np.ndarray)\n\n            # ViewBoxに画像をセット\n            self.set_image(res)\n        except:\n            pass\n\n    def set_image(self, img):\n        try:\n            self.dlg.set_image(img)\n        except Exception as e:\n            print(\"gui.py set_image:\", e)\n\n    def set_roi(self, roi):\n        try:\n            self.dlg.set_roi(roi)\n        except Exception as e:\n            print(\"gui.py set_roi\", e)\n\n\nclass BasicRoiCircleWidget(NodeInputWidget, QPushButton):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        # layout = QVBoxLayout(self)\n        self.media_controller = media_controller()\n        self.dlg = BasicROICircleDialog()\n        self.clicked.connect(lambda: self.show_dialog())\n\n    def show_dialog(self):\n        self.update_node() # 前回値適用\n        self.dlg.exec_()\n        self.update_node_input(Data(self.dlg.get_roi()), silent=False)\n        self.update_node()\n\n    # ポートの値が更新された際に発火するイベント\n    def img_update_event(self, val: Data):\n        try:\n            # 値を取得（画像のパス）\n            path = val.payload\n\n            if os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n                # ファイル名でsambaサーバを検索\n                res = get_img_from_fs(path=path, ip_address=os.environ[\"VAST_SERVER\"])\n            else:\n                res = self.media_controller.read(path, np.ndarray)\n\n            # ViewBoxに画像をセット\n            self.set_image(res)\n        except:\n            pass\n\n    def set_image(self, img):\n        try:\n            self.dlg.set_image(img)\n        except Exception as e:\n            print(\"gui.py set_image:\", e)\n\n    def set_roi(self, roi):\n        try:\n            self.dlg.set_roi(roi)\n        except Exception as e:\n            print(\"gui.py set_roi\", e)\n\n\nclass BasicRoiEllipseWidget(NodeInputWidget, QPushButton):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        # layout = QVBoxLayout(self)\n        self.media_controller = media_controller()\n        self.dlg = BasicROIEllipseDialog()\n        self.clicked.connect(lambda: self.show_dialog())\n\n    def show_dialog(self):\n        self.update_node() # 前回値適用\n        self.dlg.exec_()\n        self.update_node_input(Data(self.dlg.get_roi()), silent=False)\n        self.update_node()\n\n    # ポートの値が更新された際に発火するイベント\n    def img_update_event(self, val: Data):\n        try:\n            # 値を取得（画像のパス）\n            path = val.payload\n\n            if os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n                # ファイル名でsambaサーバを検索\n                res = get_img_from_fs(path=path, ip_address=os.environ[\"VAST_SERVER\"])\n            else:\n                res = self.media_controller.read(path, np.ndarray)\n\n            # ViewBoxに画像をセット\n            self.set_image(res)\n        except:\n            pass\n\n    def set_image(self, img):\n        try:\n            self.dlg.set_image(img)\n        except Exception as e:\n            print(\"gui.py set_image:\", e)\n\n    def set_roi(self, roi):\n        try:\n            self.dlg.set_roi(roi)\n        except Exception as e:\n            print(\"gui.py set_roi\", e)\n\n\nclass BasicRoiPolygonWidget(NodeInputWidget, QPushButton):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        # layout = QVBoxLayout(self)\n        self.media_controller = media_controller()\n        self.dlg = BasicROIPolygonDialog()\n        self.clicked.connect(lambda: self.show_dialog())\n\n    def show_dialog(self):\n        self.update_node() # 前回値適用\n        self.dlg.exec_()\n        self.update_node_input(Data(self.dlg.get_roi()), silent=False)\n        self.update_node()\n\n    # ポートの値が更新された際に発火するイベント\n    def img_update_event(self, val: Data):\n        try:\n            # 値を取得（画像のパス）\n            path = val.payload\n\n            if os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n                # ファイル名でsambaサーバを検索\n                res = get_img_from_fs(path=path, ip_address=os.environ[\"VAST_SERVER\"])\n            else:\n                res = self.media_controller.read(path, np.ndarray)\n\n            # ViewBoxに画像をセット\n            self.set_image(res)\n        except:\n            pass\n\n    def set_image(self, img):\n        try:\n            self.dlg.set_image(img)\n        except Exception as e:\n            print(\"gui.py set_image:\", e)\n\n    def set_roi(self, roi):\n        try:\n            self.dlg.set_roi(roi)\n        except Exception as e:\n            print(\"gui.py set_roi\", e)\n\n\nclass ButtonTriggerWidget(NodeMainWidget, QPushButton):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        self.clicked.connect(self.update_node)\n\nimport paramiko\nclass FileSelectWidget(NodeMainWidget, QPushButton):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        self.file_dialog = QFileDialog()\n        self.clicked.connect(self.update_node)\n\n        if platform.system() == \"Windows\":\n            self.file_dialog.setDirectory(os.getcwd())\n        else:\n            self.file_dialog.setDirectory(\"/media/usb\")\n\n    def dialog_exec(self):\n        path = [\"\"]\n        if self.file_dialog.exec_():\n            path = self.file_dialog.selectedFiles()\n            self.file_dialog.setDirectory(os.path.dirname(path[0]))\n\n        try:\n            if platform.system() == \"Windows\" and os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n                file_name = Path(path[0]).name\n                res = sftp_file_transfer(os.environ[\"VAST_SERVER\"], \"vast\", \"ncpt-vast\", path[0], [f\"/media/usb/files/{file_name}\", f\"/tmp/files/{file_name}\"],\n                                         logger=None)\n                path = [f\"/tmp/files/{file_name}\"]\n        except Exception as e:\n            print(e)\n\n        return path[0]\n\nclass BasicInputWidget(NodeInputWidget, QLineEdit):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QLineEdit.__init__(self)\n\n        self.setMinimumWidth(60)\n        self.setMaximumWidth(100)\n        self.setStyleSheet(\"background-color:black;\")\n\n        ## loadしたとき毎回発火してしまう->silent=Trueで解決\n        self.textChanged.connect(lambda: self.text_changed())\n        self.init_value()\n\n    def text_changed(self):\n        self.update_node_input(Data(self.text()), silent=True)\n\n    def get_state(self) -> dict:\n        return {'value': self.text()}\n\n    def set_state(self, data: dict):\n        try:\n            self.setText(data['value'])\n        except:\n            pass\n\n    def init_value(self):\n        # input the default value\n        self.set_state({\"value\": self.input.default})\n\n    def val_update_event(self, val: Data):\n        try:\n            super().val_update_event(val)\n            # 値を取得（画像のパス）\n            data = val.payload\n            self.setText(str(data))\n            self.update_node_input(Data(self.text()), silent=False)\n        except:\n            pass\n\n# ROI setter\n\n\nclass BasicROIRectangleNodeGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicRoiRectangleWidget,\n    }\n    color = '#99dd55'\n    roi_node = None\n\n    def __init__(self, params):\n        super().__init__(params)\n        for i, inp in enumerate(self.node.inputs):\n            if inp.label_str == 'roi':\n                self.roi_node = inp\n                self.input_widgets[inp] = {'name': 'in', 'pos': 'besides'}\n\n\n\nclass BasicROICircleNodeGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicRoiCircleWidget,\n    }\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for i, inp in enumerate(self.node.inputs):\n            if inp.label_str == 'roi':\n                self.roi_node = inp\n                self.input_widgets[inp] = {'name': 'in', 'pos': 'besides'}\n\n\nclass BasicROIEllipseNodeGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicRoiEllipseWidget,\n    }\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for i, inp in enumerate(self.node.inputs):\n            if inp.label_str == 'roi':\n                self.roi_node = inp\n                self.input_widgets[inp] = {'name': 'in', 'pos': 'besides'}\n\n\nclass BasicROIPolygonNodeGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicRoiPolygonWidget,\n    }\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for i, inp in enumerate(self.node.inputs):\n            if inp.label_str == 'roi':\n                self.roi_node = inp\n                self.input_widgets[inp] = {'name': 'in', 'pos': 'besides'}\n\n\nclass ButtonTrrigerGui(NodeGUI):\n    input_widget_classes = {\n        'in': inp_widgets.Builder.str_line_edit(size='m', resizing=True),\n    }\n    main_widget_class = ButtonTriggerWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'in', 'pos': 'below'}\n\n\nclass FileSelectGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicInputWidget\n    }\n    main_widget_class = FileSelectWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'in', 'pos': 'below'}\n\n    def get_path(self):\n        return self.main_widget().dialog_exec()\n\n\nclass BasicInputGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicInputWidget\n    }\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'in', 'pos': 'beside'}\n\n    def transfar_image(self, path):\n        if platform.system() == \"Windows\" and os.environ[\"VAST_SERVER\"] != \"127.0.0.1\":\n            file_name = Path(path).name\n            res = sftp_file_transfer(os.environ[\"VAST_SERVER\"], \"vast\", \"ncpt-vast\", path[0],\n                                     [f\"/media/usb/files/{file_name}\", f\"/tmp/files/{file_name}\"],\n                                     logger=None)\n            path = [f\"/tmp/files/{file_name}\"]\n\nfrom pathlib import Path\ndef sftp_file_transfer(host_ip, username, password, local_file_path, remote_file_paths, logger=None):\n    try:\n        # SSHクライアントを作成\n        ssh = paramiko.SSHClient()\n        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n        # ホストに接続\n        ssh.connect(hostname=host_ip, username=username, password=password, timeout=5)\n\n        # SFTPクライアントを作成\n        sftp = ssh.open_sftp()\n\n        # リモートディレクトリが存在しない場合は作成する\n        remote_dirs = []\n        for file_path in remote_file_paths:\n            remote_dirs.append(os.path.dirname(file_path))\n        for remote_dir in remote_dirs:\n            create_remote_directory(sftp, ssh, remote_dir)\n\n        # ファイルサイズを取得\n        file_size = os.path.getsize(local_file_path)\n\n        # 進捗表示用の関数\n        def progress_callback(transferred, total):\n            if logger is not None:\n                logger.info(f\"転送中... {transferred}/{total} bytes ({transferred / total * 100:.2f}%)\")\n            else:\n                print(f\"転送中... {transferred}/{total} bytes ({transferred / total * 100:.2f}%)\")\n\n        # ファイルをアップロード\n        # MEMO: USBメモリに直接置こうとするとpermission deniedになるのでデスクトップに置いてからmv\n        for file_path in remote_file_paths:\n            desktop_path = \"/home/vast/Desktop/\" + Path(file_path).name\n            sftp.put(local_file_path, desktop_path, callback=progress_callback, confirm=True)\n            ssh.exec_command(f'sudo mv {desktop_path} {file_path}')\n        ssh.exec_command(f'sudo rm {desktop_path}')\n\n        return (f\"ファイル '{local_file_path}' をアップロードしました\")\n\n    except paramiko.AuthenticationException:\n        return \"認証エラー: ユーザー名またはパスワードが正しくありません\"\n    except paramiko.SSHException as sshException:\n        return f\"SSH接続エラー: {sshException}\"\n    except Exception as ex:\n        return f\"ファイル転送中にエラーが発生しました: {ex}\"\n    finally:\n        # 接続を閉じる\n        ssh.close()\n\ndef create_remote_directory(sftp, ssh, remote_dir_path):\n    try:\n        # ディレクトリが存在するかチェック\n        sftp.stat(remote_dir_path)\n    except IOError:\n        # ディレクトリが存在しない場合は作成する\n        parent_dir = os.path.dirname(remote_dir_path.rstrip('/'))\n        if parent_dir:\n            create_remote_directory(sftp, ssh, parent_dir)\n        # sftp.mkdir(remote_dir_path)\n        ssh.exec_command(f'sudo mkdir {remote_dir_path}')\n\nexport_guis([\n    BasicROIRectangleNodeGui,\n    BasicROIEllipseNodeGui,\n    BasicROICircleNodeGui,\n    BasicROIPolygonNodeGui,\n    ButtonTrrigerGui,\n    FileSelectGui,\n    BasicInputGui\n])\n",
        "nodes.py": "from ryven.node_env import *\nimport sys\nimport os\nimport json\nfrom copy import deepcopy\n\nsys.path.append(os.path.dirname(__file__))\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\n\n\nguis = import_guis(__file__)\n\n\nclass NodeBase(Node):\n    version = \"v0.1\"\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\n\n# QGraphicsLayoutView(pyqtgraph)で画像を確認するノード\nclass BasicROIRectangleNode(NodeBase):\n    title = 'ROI_Rectangle'\n    name = 'ROI_Rectangle'\n\n    GUI = guis.BasicROIRectangleNodeGui\n\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"img\", type_=\"data\"),\n        # save project時、保持するのに必要\n        NodeInputType(\"roi\", type_=\"data\"),\n        NodeInputType(\"offset\", type_=\"data\"),\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"roi\")\n    ]\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.active = True\n\n    def update_event(self, inp_num=-1):\n        print(\"inpu_num\", inp_num)\n        try:\n            # 画像の更新\n            if self.input(1) is not None:\n                for i, inp in enumerate(self.inputs):\n                    if inp.label_str == \"img\":\n                        # debugのThreads & Variablesで探せない超荒業\n                        self.gui.input_widget(2).img_update_event(self.input(i))\n        except:\n            pass\n\n\n        # ROIの更新\n        coord = None\n\n        if self.input(2) is not None:\n            try:\n                roi = self.input(2).payload\n                self.gui.input_widget(2).set_roi(roi[0])\n            except Exception as e:\n                print(e)\n\n            try:\n                # 出力の更新（値はguiの方で更新）\n                coord = deepcopy(self.input(2).payload)\n                if coord is not None:\n                    if self.input(3) is not None:\n                        # オフセット量を取得\n                        if type(self.input(3).payload) == str:\n                            offsets = json.loads(self.input(3).payload)\n                        else:\n                            offsets = self.input(3).payload\n                        # オフセット適用\n                        if coord[0].shape_type == \"rectangle\":\n                            coord[0].x1 += offsets[0]\n                            coord[0].x2 += offsets[0]\n                            coord[0].y1 += offsets[1]\n                            coord[0].y2 += offsets[1]\n                        elif coord[0].shape_type == \"polygon\":\n                            offset_points = []\n                            for point in coord[0].points:\n                                offset_points.append(((point[0] + offsets[0]), (point[1] + offsets[1])))\n                            coord[0].points = offset_points\n            except:\n                pass\n\n            if coord is not None:\n                # オブジェクトを辞書型に変換してアウトプット\n                roi = coord[0].model_dump()\n                self.set_output_val(1, Data(json.dumps(roi)))\n            else:\n                self.set_output_val(1, Data(None))\n\n            # execフローを発行\n            if inp_num == 0:\n                self.exec_output(0)\n\n\nclass BasicROICircleNode(NodeBase):\n    title = 'ROI_Circle'\n    name = 'ROI_Circle'\n\n    GUI = guis.BasicROICircleNodeGui\n\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"img\", type_=\"data\"),\n        NodeInputType(\"roi\", type_=\"data\"),\n        NodeInputType(\"offset\", type_=\"data\"),\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"roi\")\n    ]\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.active = True\n\n    def update_event(self, inp_num=-1):\n        try:\n            # 画像の更新\n            if self.input(1) is not None:\n                for i, inp in enumerate(self.inputs):\n                    if inp.label_str == \"img\":\n                        # debugのThreads & Variablesで探せない超荒業\n                        self.gui.input_widget(2).img_update_event(self.input(i))\n        except:\n            pass\n\n        # ROIの更新\n        coord = None\n        if self.input(2) is not None:\n            try:\n                roi = self.input(2).payload\n                self.gui.input_widget(2).set_roi(roi[0])\n            except Exception as e:\n                print(e)\n            try:\n                # 出力の更新（値はguiの方で更新）\n                coord = deepcopy(self.input(2).payload)\n                if coord is not None:\n                    if self.input(3) is not None:\n                        # オフセット量を取得\n                        if type(self.input(3).payload) == str:\n                            offsets = json.loads(self.input(3).payload)\n                        else:\n                            offsets = self.input(3).payload\n                        # オフセット適用\n                        coord[0].x += offsets[0]\n                        coord[0].y += offsets[1]\n            except:\n                pass\n\n            if coord is not None:\n                # オブジェクトを辞書型に変換してアウトプット\n                roi = coord[0].model_dump()\n                self.set_output_val(1, Data(json.dumps(roi)))\n            else:\n                self.set_output_val(1, Data(None))\n\n            # execフローを発行\n            if inp_num == 0:\n                self.exec_output(0)\n\n\nclass BasicROIEllipseNode(NodeBase):\n    title = 'ROI_Ellipse'\n    name = 'ROI_Ellipse'\n\n    GUI = guis.BasicROIEllipseNodeGui\n\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"img\", type_=\"data\"),\n        NodeInputType(\"roi\", type_=\"data\"),\n        NodeInputType(\"offset\", type_=\"data\"),\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"roi\")\n    ]\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.active = True\n\n    def update_event(self, inp_num=-1):\n        try:\n            # 画像の更新\n            if self.input(1) is not None:\n                for i, inp in enumerate(self.inputs):\n                    if inp.label_str == \"img\":\n                        # debugのThreads & Variablesで探せない超荒業\n                        self.gui.input_widget(2).img_update_event(self.input(i))\n        except:\n            pass\n\n        # ROIの更新\n        coord = None\n\n        if self.input(2) is not None:\n            try:\n                roi = self.input(2).payload\n                self.gui.input_widget(2).set_roi(roi[0])\n            except Exception as e:\n                print(e)\n\n            try:\n                # 出力の更新（値はguiの方で更新）\n                coord = deepcopy(self.input(2).payload)\n                if coord is not None:\n                    if self.input(3) is not None:\n                        # オフセット量を取得\n                        if type(self.input(3).payload) == str:\n                            offsets = json.loads(self.input(3).payload)\n                        else:\n                            offsets = self.input(3).payload\n                        # オフセット適用\n                        coord[0].x += offsets[0]\n                        coord[0].y += offsets[1]\n            except:\n                pass\n\n            if coord is not None:\n                # オブジェクトを辞書型に変換してアウトプット\n                roi = coord[0].model_dump()\n                self.set_output_val(1, Data(json.dumps(roi)))\n            else:\n                self.set_output_val(1, Data(None))\n\n            # execフローを発行\n            if inp_num == 0:\n                self.exec_output(0)\n\n\nclass BasicROIPolygonNode(NodeBase):\n    title = 'ROI_Polygon'\n    name = 'ROI_Polygon'\n\n    GUI = guis.BasicROIPolygonNodeGui\n\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"img\", type_=\"data\"),\n        NodeInputType(\"roi\", type_=\"data\"),\n        NodeInputType(\"offset\", type_=\"data\"),\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"roi\")\n    ]\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.active = True\n\n    def update_event(self, inp_num=-1):\n        try:\n            # 画像の更新\n            if self.input(1) is not None:\n                for i, inp in enumerate(self.inputs):\n                    if inp.label_str == \"img\":\n                        # debugのThreads & Variablesで探せない超荒業\n                        self.gui.input_widget(2).img_update_event(self.input(i))\n        except:\n            pass\n\n        # ROIの更新\n        coord = None\n\n        if self.input(2) is not None:\n            try:\n                roi = self.input(2).payload\n                self.gui.input_widget(2).set_roi(roi[0])\n            except Exception as e:\n                print(e)\n\n            try:\n                # 出力の更新（値はguiの方で更新）\n                coord = deepcopy(self.input(2).payload)\n                if coord is not None:\n                    if self.input(3) is not None:\n                        # オフセット量を取得\n                        if type(self.input(3).payload) == str:\n                            offsets = json.loads(self.input(3).payload)\n                        else:\n                            offsets = self.input(3).payload\n                        # オフセット適用\n                        offset_points = []\n                        for point in coord[0].points:\n                            offset_points.append(((point[0] + offsets[0]), (point[1] + offsets[1])))\n                        coord[0].points = offset_points\n            except:\n                pass\n\n            if coord is not None:\n                # オブジェクトを辞書型に変換してアウトプット\n                roi = coord[0].model_dump()\n                self.set_output_val(1, Data(json.dumps(roi)))\n            else:\n                self.set_output_val(1, Data(None))\n\n            # execフローを発行\n            if inp_num == 0:\n                self.exec_output(0)\n\n\nclass Button_Node(NodeBase):\n    title = 'Trg_Button'\n    init_inputs = [\n        NodeInputType(\"name\", type_=\"data\")\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\")\n    ]\n    GUI = guis.ButtonTrrigerGui\n\n    def update_event(self, inp=-1):\n        if str(inp) != \"0\":\n            self.exec_output(0)\n\n\nclass File_Select_Node(NodeBase):\n    title = 'Utl_FileSelect'\n    init_inputs = [\n        NodeInputType(\"path\", type_=\"data\")\n    ]\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"path\")\n    ]\n    GUI = guis.FileSelectGui\n\n    def update_event(self, inp=-1):\n        if inp == -1:\n            try:\n                path = self.gui.get_path()\n                self.gui.input_widget(0).val_update_event(Data(path))\n            except Exception as e:\n                print(e)\n        else:\n            if self.input(0) is not None:\n                self.set_output_val(1, Data(self.input(0).payload))\n                self.exec_output(0)\n\nfrom media_plugins.media_controller import media_controller\nimport numpy as np\nimport cv2\nclass Image_Save_Node(NodeBase):\n    title = \"Utl_SaveImage\"\n    init_input = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"img\", type_=\"data\"),\n        NodeInputType(\"path\", type_=\"data\")\n    ]\n    init_outputs = [\n        NodeOutputType(\"success\", type_=\"data\")\n    ]\n    GUI = guis.BasicInputGui\n\n    mc = media_controller()\n\n    def update_event(self, inp=-1):\n        if inp == 0:\n            try:\n                img = media_controller.read(self.input(1).payload, np.ndarray)\n                cv2.imwrite(self.input(2).payload, img)\n                try:\n                    self.GUI.transfar_image(self.input(2).payload)\n                except:\n                    pass\n            except Exception as e:\n                print(e)\n\n\nexport_nodes([\n    BasicROIRectangleNode,\n    BasicROICircleNode,\n    BasicROIEllipseNode,\n    BasicROIPolygonNode,\n    Button_Node,\n    File_Select_Node,\n])\n",
        "pyqtgraph_view.py": "# ===============================================================================\n# Name      : pyqtgraph_view.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-09-28 11:51\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\n\nimport pyqtgraph as pg\nimport numpy as np\nimport copy\nimport cv2\nfrom typing import Union, Tuple, Optional\nfrom cv_shapes_lib import Rectangle, Circle, Ellipse, Polygon\nimport math\n\nclass CustomViewBox(pg.ViewBox):\n    \"\"\"\n    ViewBoxのカスタム継承クラス\n\n    Args:\n        pg (_type_): _description_\n    \"\"\"\n\n    def __init__(self, parent=None):\n        super(CustomViewBox, self).__init__(parent)\n        # NOTE: アスペクト比を固定\n        self.setAspectLocked()\n        # NOTE: 描画するアイテムを管理\n        self.img = np.zeros((640, 480, 3), dtype=np.uint8)\n        self.img_item = pg.ImageItem(image=self.img)\n        self.addItem(self.img_item)\n        self.default_state = self.getState()\n        # NOTE: roiのみひとつのviewboxに複数描画する可能性がある\n        self.rois = []\n\n    def set_image(self, img: np.ndarray) -> None:\n        \"\"\"画像を貼り付け\n\n        Args:\n            img (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # NOTE: 3chに変換\n        if img.ndim != 3:\n            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n\n        # NOTE: setConfigOptionsか、dtypeのせいで方向がおかしい気がする\n        img = np.rot90(img, 2)\n        img = cv2.flip(img, 1)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n        self.img = img.copy()\n        # NOTE: レベルを手動調整\n        self.img_item.setImage(image=self.img, autoLevels=False)\n        # self.img_item.setLevels([np.min(self.img), np.max(self.img)])\n        self.img_item.setLevels([0, 255])\n        self.default_state = self.getState()\n        # NOTE: 画像全体が収まるように自動調整\n        self.autoRange()\n        self.set_roi_range()\n\n    def set_roi_range(self):\n        h, w = self.img.shape[:2]\n        #     for roi in self.rois:\n        #         roi.maxBounds = QRectF(0, 0, w, h)\n\n    def set_frame(self, img: np.ndarray) -> None:\n        \"\"\"ストリーミングの貼り付け\n\n        Args:\n            img (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        # NOTE: 3chに変換\n        if img.ndim != 3:\n            img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n\n        # NOTE: setConfigOptionsか、dtypeのせいで方向がおかしい気がする\n        img = np.rot90(img, 2)\n        img = cv2.flip(img, 1)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n        self.img = img.copy()\n        # NOTE: レベルを手動調整\n        self.img_item.setImage(image=self.img, autoLevels=False)\n        self.img_item.setLevels([0, 255])\n        self.default_state = self.getState()\n        self.set_roi_range()\n\n    def reset_vb(self) -> None:\n        \"\"\"vbの状態を画像を貼り付けた初めの状態にリセット\"\"\"\n        self.setState(copy.deepcopy(self.default_state))\n\n    def get_roi_cvimg(self, roi: pg.ROI):\n        success = True\n        try:\n            img_float64 = self.rois[0].getArrayRegion(self.img.copy(), self.img_item)\n            img = img_float64.astype(np.uint8)\n            img = np.rot90(img, 2)\n            img = cv2.flip(img, 1)\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        except Exception as e:\n            print(e)\n            img = -1\n            success = False\n\n        return success, img\n\n    def add_roi(self, roi: pg.ROI) -> None:\n        \"\"\"_summary_\n\n        Args:\n            roi (pg.ROI): _description_\n        \"\"\"\n        self.addItem(roi)\n        self.rois.append(roi)\n\n    def reset_roi(self, img: np.ndarray) -> None:\n        \"\"\"\n        Args:\n            img (np.ndarray): _description_\n        \"\"\"\n        self.clear()\n        img = np.rot90(img, 2)\n        img = cv2.flip(img, 1)\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        self.img_item = pg.ImageItem(image=img)\n        self.addItem(self.img_item)\n\n    def get_pt_rgb(self, src: np.ndarray, pt: tuple) -> Tuple[int, int, int]:\n        \"\"\"RGBの成分を返す\"\"\"\n        h, w = src.shape[:2]\n        if pt[0] < 0 or pt[0] > w - 1:\n            return -1, -1, -1\n        if pt[1] < 0 or pt[1] > h - 1:\n            return -1, -1, -1\n        b, g, r = src[pt[1], pt[0], :]\n        return b, g, r\n\n    def get_pt_gray(self, src: np.ndarray, pt: tuple) -> Tuple[int, int, int]:\n        \"\"\"RGBの成分を返す\"\"\"\n        h, w = src.shape[:2]\n        if pt[0] < 0 or pt[0] > w - 1:\n            return -1, -1, -1\n        if pt[1] < 0 or pt[1] > h - 1:\n            return -1, -1, -1\n        val = src[pt[1], pt[0]]\n        return val, val, val\n\n    @staticmethod\n    def cv2pg(roi: Union[list, np.ndarray], img: np.ndarray) -> Tuple[list, list]:\n        \"\"\" [xmin, ymin, xmax, ymax]をpyqtgraph座標の[x, y] [l_x, l_y]に変換\"\"\"\n        h, _ = img.shape[:2]\n        x = roi[0]\n        l_x = roi[2] - roi[0]\n        l_y = roi[3] - roi[1]\n        y = h - roi[3]  # NOTE: yは正負逆\n        return [x, y], [l_x, l_y]\n\n    @staticmethod\n    def _cv2pg(roi: Union[list, np.ndarray], h: int) -> Tuple[list, list]:\n        x = roi[0]\n        l_x = roi[2] - roi[0]\n        l_y = roi[3] - roi[1]\n        y = h - roi[3]\n        return [x, y], [l_x, l_y]\n\n    @staticmethod\n    def pg2cv_polygon(origin_points: list[pg.Point], img: np.ndarray) -> list:\n        # roi_polygon　[p1(x, y), p2...pn]\n        h, w = img.shape[:2]\n        points = []\n        # print(h, w)\n        # print(origin_points)\n        for (x, y) in origin_points:\n            points.append([int(x), int(h - y)])\n        # x = int(element.x)\n        # y = int(element.y)\n        return points\n\n    @staticmethod\n    def pg2cv(pos: pg.Point, len: pg.Point, img: np.ndarray) -> list:\n        # roi_transition_rect　[ymin, xmin, ymax, xmax]\n        h, _ = img.shape[:2]\n        xmin = int(pos[0])\n        xmax = int(pos[0] + len[0])\n        ymin = int(h - (pos[1] + len[1]))\n        ymax = int(h - pos[1])\n\n        return [ymin, xmin, ymax, xmax]\n\n    @staticmethod\n    def pg2cv_rotate_rect(pos: pg.Point, len: pg.Point, angle: int, img: np.ndarray) -> list[tuple[int, int]]:\n        # roi_transition_rotate_rect　[p1(x, y), p2, p3, p4]\n        h, _ = img.shape[:2]\n        len1 = [len[0], 0]\n        len2 = len\n        len3 = [0, len[1]]\n        rotation_matrix = np.array([[np.cos(np.deg2rad(angle)), -np.sin(np.deg2rad(angle))],\n                                    [np.sin(np.deg2rad(angle)), np.cos(np.deg2rad(angle))]])\n        p1 = np.dot(rotation_matrix, len1) + pos\n        p2 = np.dot(rotation_matrix, len2) + pos\n        p3 = np.dot(rotation_matrix, len3) + pos\n        p4 = pos\n        p1 = (int(p1[0]), int(h - p1[1]))\n        p2 = (int(p2[0]), int(h - p2[1]))\n        p3 = (int(p3[0]), int(h - p3[1]))\n        p4 = (int(p4[0]), int(h - p4[1]))\n        points = [p1, p2, p3, p4]\n        return points\n\n    @staticmethod\n    def _pg2cv(pos: pg.Point, len: pg.Point, h: int) -> list:\n        xmin = int(pos[0])\n        xmax = int(pos[0] + len[0])\n        ymin = int(h - (pos[1] + len[1]))\n        ymax = int(h - pos[1])\n\n        return [xmin, ymin, xmax, ymax]\n\n    @staticmethod\n    def xyr2pg(xyr: Union[list, np.ndarray], img: np.ndarray) -> Tuple[list, list]:\n        h, _ = img.shape[:2]\n        x = xyr[0] - xyr[2]\n        l_x = int(xyr[2] * 2)\n        l_y = int(xyr[2] * 2)\n        y = h - (xyr[1] + xyr[2])\n\n        return [x, y], [l_x, l_y]\n\n    @staticmethod\n    def pg2xyr(pos: pg.Point, len: pg.Point, img: np.ndarray) -> list:\n        # roi_transition_circle　[x, y, r]\n        h, _ = img.shape[:2]\n        r = int(len[0] / 2)\n        x = int(pos[0] + len[0] / 2)\n        y_inv = int(pos[1] + len[1] / 2)\n        y = h - y_inv\n\n        return [x, y, r]\n\n    @staticmethod\n    def pg2xyr_ellipse(pos: pg.Point, len: pg.Point, angle: int, img: np.ndarray) -> list:\n        # roi_transition_ellipse　[x, y, r_h平行軸, r_v垂直軸, angle]\n        h, _ = img.shape[:2]\n        r1 = int(len[0] / 2)\n        r2 = int(len[1] / 2)\n        rotation_matrix = np.array([[np.cos(np.deg2rad(angle)), -np.sin(np.deg2rad(angle))],\n                                    [np.sin(np.deg2rad(angle)), np.cos(np.deg2rad(angle))]])\n        # 中心点\n        rotated_center = np.dot(rotation_matrix, len / 2) + pos\n        # print('center', rotated_center)\n        x = int(rotated_center[0])\n        y = int(h - rotated_center[1])\n        angle = int(-angle)\n        return [x, y, r1, r2, angle]\n\n    @staticmethod\n    def rotate_reset_ellipse(pos: pg.Point, len: pg.Point, angle: int):\n        # roi_transition_ellipse　[x, y, r_h平行軸, r_v垂直軸, angle]\n        r1 = int(len[0] / 2)\n        r2 = int(len[1] / 2)\n        rotation_matrix = np.array([[np.cos(np.deg2rad(angle)), -np.sin(np.deg2rad(angle))],\n                                    [np.sin(np.deg2rad(angle)), np.cos(np.deg2rad(angle))]])\n        # 中心点\n        rotated_center = np.dot(rotation_matrix, len / 2) + pos\n        # print('center', rotated_center)\n        x = int(rotated_center[0])-r1\n        y = int(rotated_center[1])-r2\n        pos=pg.Point(x,y)\n        return pos\n\n    @staticmethod\n    def cv2pg_polygon(polygon: Polygon, img: np.ndarray):\n        h, _ = img.shape[:2]\n        points = []\n        for (x, y) in polygon.points:\n            points.append([int(x), int(h - y)])\n        # polygonROI\n        # movable=False,\n        polygon_roi = pg.PolyLineROI(positions=[points], closed=True, rotatable=False, angle=0)\n        return polygon_roi\n\n    @staticmethod\n    def cv2pg_ellipse(ellipse: Ellipse, img: np.ndarray):\n        h, _ = img.shape[:2]\n        size = ellipse.axis1 * 2, ellipse.axis2 * 2\n        length = pg.Point(ellipse.axis1 * 2, ellipse.axis2 * 2)\n        angle = -ellipse.angle\n        rotation_matrix = np.array([[np.cos(np.deg2rad(angle)), -np.sin(np.deg2rad(angle))],\n                                    [np.sin(np.deg2rad(angle)), np.cos(np.deg2rad(angle))]])\n        pos = ellipse.x, h - ellipse.y\n        rotated_center = -np.dot(rotation_matrix, length / 2) + pos\n        pos = rotated_center\n        ellipse_roi = pg.EllipseROI(pos=pos, size=size, angle=angle)\n        return ellipse_roi\n\n    @staticmethod\n    def cv2pg_rect(rect: Rectangle, img: np.ndarray):\n        # polygonROI\n        # movable=False,\n        h, _ = img.shape[:2]\n        pos = rect.x1, h - rect.y2\n        size = rect.x2 - rect.x1, rect.y2 - rect.y1\n        rect_roi = pg.RectROI(pos=pos, size=size)\n        return rect_roi\n\n    @staticmethod\n    def cv2pg_rect_rotate(rect: Polygon, img: np.ndarray):\n        x = []\n        y = []\n        h, _ = img.shape[:2]\n        for (_x, _y) in rect.points:\n            x.append(_x)\n            y.append(h - _y)\n        pos = x[3], y[3]\n        size = ((x[1] - x[2]) ** 2 + (y[1] - y[2]) ** 2) ** 0.5, ((x[0] - x[1]) ** 2 + (y[0] - y[1]) ** 2) ** 0.5\n        angle = np.arctan2((y[0] - y[3]), (x[0] - x[3]))\n        deg = math.degrees(angle)\n\n        rect_roi = pg.RectROI(pos=pos, size=size, angle=deg)\n        return rect_roi\n\n    @staticmethod\n    def cv2pg_circle(circle: Circle, img: np.ndarray):\n        # polygonROI\n        # movable=False,\n        h, _ = img.shape[:2]\n        size = circle.radius * 2, circle.radius * 2\n        pos = circle.x - (size[0] / 2), h - (circle.y + size[1] / 2)\n        circle_roi = pg.CircleROI(pos=pos, size=size)\n        return circle_roi\n\n\nclass ViewWidget(pg.GraphicsLayoutWidget):\n    pg.setConfigOptions(imageAxisOrder='row-major')\n\n    def __init__(self):\n        super(ViewWidget, self).__init__()\n        self.box_layout = self.addLayout(row=0, col=0)\n        self.box_layout.setContentsMargins(0, 0, 0, 0)\n        self.box_layout.setBorder((255, 255, 255, 255), width=0.8)\n        self.viewboxs = []\n        self.default_state = []\n        self.img_items = []\n        self.imgs = []\n\n    def add_viewbox(self, img: Optional[np.ndarray] = None,\n                    row: int = 0, col: int = 0,\n                    rowspan: int = 1, colspan: int = 1\n                    ) -> CustomViewBox:\n        \"\"\"GraphicsLayoutWidgetにViewBoxとImageItemを追加\"\"\"\n        # NOTE: ViewBoxを追加\n        vb = CustomViewBox()\n        self.box_layout.addItem(vb, row=row, col=col, rowspan=rowspan, colspan=colspan)\n        # NOTE: 画像を加工して追加\n        if img is None:\n            img = np.zeros((640, 480, 3), dtype=np.uint8)\n        vb.set_image(img)\n        return vb\n",
        "roi_circle_dialog.py": "from PySide2.QtWidgets import QPushButton, QDialog, QMainWindow, QApplication, QVBoxLayout\nimport pyqtgraph as pg\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nfrom pyqtgraph_view import ViewWidget\nfrom cv_shapes_lib import Circle\nfrom typing import Union\n\nclass BasicROICircleDialog(QDialog):\n    def __init__(self, pos=[]):\n        QDialog.__init__(self)\n\n        # QFrameを継承し、レイアウトとQGraphicsLayoutViewを載せる\n        layout = QVBoxLayout(self)\n        self.gl = ViewWidget()\n        self.box_layout = self.gl.addLayout(row=0, col=0)\n        self.box_layout.setBorder((255, 255, 255, 255), width=0.8)\n\n        # QGraphicsLayoutViewにViewBoxを追加する\n        self.vb = self.gl.add_viewbox()\n\n        # 矩形ROIの初期座標計算\n        try:\n            if len(pos) == 4:\n                pos, size = self.vb.cv2pg(pos, self.vb.img)\n                size[0] = size[1]\n            else:\n                h, w = self.vb.img.shape[:2]\n                pos = [int(w / 3), int(h / 3)]\n                size = [int(w / 3), int(h / 3)]\n                size[0] = size[1]\n        except:\n            h, w = self.vb.img.shape[:2]\n            pos = [int(w / 3), int(h / 3)]\n            size = [int(w / 3), int(h / 3)]\n            size[0] = size[1]\n\n        # circleROI\n        self.roi = pg.CircleROI(pos=pos, size=size)\n        self.vb.add_roi(self.roi)\n        self.apply_button = QPushButton(text=\"Accept\")\n        self.apply_button.clicked.connect(lambda: self.accept_change())\n        # self.apply_button.clicked.connect(lambda: self.get_roi())\n\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n\n        layout.addWidget(self.gl)\n        layout.addWidget(self.apply_button)\n\n    # when push accept button, keep shape\n    def accept_change(self):\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n        self.accept()\n\n    # when push x button, restore shape\n    def reject(self):\n        self.roi.setPos(self.roi_pos)\n        self.roi.setSize(self.roi_size)\n        super().reject()\n\n    def set_image(self, img):\n        try:\n            self.vb.set_image(img)\n        except:\n            pass\n\n    def get_roi(self):\n        # 円形\n        pos = self.roi.pos()\n        size = self.roi.size()\n        x, y, r = self.vb.pg2xyr(pos, size, self.vb.img)\n        answer = [Circle(x=x, y=y, radius=r)]\n        return answer\n\n    def set_roi(self, shape=Circle):\n        try:\n            roi = self.vb.cv2pg_circle(circle=shape, img=self.vb.img)\n            self.vb.removeItem(self.roi)\n            self.vb.addItem(roi)\n            self.roi = roi\n        except:\n            pass\n\nif __name__ == \"__main__\":\n    app = QApplication()\n    hoge = QMainWindow()\n    hoge = BasicROICircleDialog()\n    ret = hoge.exec_()\n    if ret:\n        print(\"true\")\n    else:\n        print(\"false\")\n",
        "roi_ellipse_dialog.py": "from PySide2.QtWidgets import QPushButton, QDialog, QMainWindow, QApplication, QVBoxLayout\nimport pyqtgraph as pg\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nfrom pyqtgraph_view import ViewWidget\nfrom cv_shapes_lib import Ellipse\n\n\nclass BasicROIEllipseDialog(QDialog):\n    def __init__(self, pos=[]):\n        QDialog.__init__(self)\n\n        # QFrameを継承し、レイアウトとQGraphicsLayoutViewを載せる\n        layout = QVBoxLayout(self)\n        self.gl = ViewWidget()\n        self.box_layout = self.gl.addLayout(row=0, col=0)\n        self.box_layout.setBorder((255, 255, 255, 255), width=0.8)\n\n        # QGraphicsLayoutViewにViewBoxを追加する\n        self.vb = self.gl.add_viewbox()\n\n        # 矩形ROIの初期座標計算\n        try:\n            if len(pos) == 4:\n                pos, size = self.vb.cv2pg(pos, self.vb.img)\n\n            else:\n                h, w = self.vb.img.shape[:2]\n                pos = [int(h / 3), int(w / 3)]\n                size = [int(h / 3), int(w / 3)]\n        except:\n            h, w = self.vb.img.shape[:2]\n            pos = [int(h / 3), int(w / 3)]\n            size = [int(h / 3), int(w / 3)]\n\n        # ellipseROI\n        self.roi = pg.EllipseROI(pos=pos, size=size)\n        # rotatable = False\n        self.vb.add_roi(self.roi)\n        self.apply_button = QPushButton(text=\"Accept\")\n        self.apply_button2 = QPushButton(text=\"reset angle\")\n        self.apply_button.clicked.connect(lambda: self.accept_change())\n        self.apply_button2.clicked.connect(lambda: self.reset_angle())\n        # self.apply_button.clicked.connect(lambda: self.get_roi())\n\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n        layout.addWidget(self.gl)\n        layout.addWidget(self.apply_button)\n        layout.addWidget(self.apply_button2)\n\n    # when push accept button, keep shape\n    def accept_change(self):\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n        self.accept()\n\n    def reset_angle(self):\n        pos = self.vb.rotate_reset_ellipse(self.roi.pos(), self.roi.size(), self.get_rotation_angle())\n        self.roi.setPos(pos)\n        self.roi.setAngle(0)\n\n    # when push x button, restore shape\n    def reject(self):\n        self.roi.setPos(self.roi_pos)\n        self.roi.setSize(self.roi_size)\n        super().reject()\n\n    def set_image(self, img):\n        try:\n            self.vb.set_image(img)\n        except:\n            pass\n\n    def get_roi(self):\n        # 楕円\n        pos = self.roi.pos()\n        size = self.roi.size()\n        # 回転角度\n        angle = self.get_rotation_angle()\n        x, y, r1, r2, rotate_angle = self.vb.pg2xyr_ellipse(pos, size, angle, self.vb.img)\n\n        answer = [Ellipse(x=x, y=y, axis1=r1, axis2=r2, angle=rotate_angle)]\n        return answer\n\n    def set_roi(self, shape=Ellipse):\n        try:\n            roi = self.vb.cv2pg_ellipse(ellipse=shape, img=self.vb.img)\n            self.vb.removeItem(self.roi)\n            self.vb.addItem(roi)\n            self.roi = roi\n        except:\n            pass\n\n    def get_rotation_angle(self):\n        \"\"\" 回転角度 \"\"\"\n        angle = self.roi.state.get('angle', 0) % 360\n        return angle\n\n\nif __name__ == \"__main__\":\n    app = QApplication()\n    hoge = QMainWindow()\n    hoge = BasicROIEllipseDialog()\n    ret = hoge.exec_()\n    if ret:\n        print(\"true\")\n    else:\n        print(\"false\")\n",
        "roi_polygon_dialog.py": "from PySide2.QtWidgets import QPushButton, QDialog, QMainWindow, QApplication, QVBoxLayout\nimport pyqtgraph as pg\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nfrom pyqtgraph_view import ViewWidget\nfrom cv_shapes_lib import Polygon\n\n\nclass BasicROIPolygonDialog(QDialog):\n    def __init__(self, pos=[]):\n        QDialog.__init__(self)\n\n        # QFrameを継承し、レイアウトとQGraphicsLayoutViewを載せる\n        layout = QVBoxLayout(self)\n        self.gl = ViewWidget()\n        self.box_layout = self.gl.addLayout(row=0, col=0)\n        self.box_layout.setBorder((255, 255, 255, 255), width=0.8)\n\n        # QGraphicsLayoutViewにViewBoxを追加する\n        self.vb = self.gl.add_viewbox()\n        n = 5\n        # 矩形ROIの初期座標計算\n        try:\n            if len(pos) == 4:\n                h, w = self.vb.img.shape[:2]\n                pos1 = [int(2 * h / 3), int(w / 3)]\n                pos2 = [int(h / 2), int(2 * w / 3)]\n                pos3 = [int(h / 3), int(w / 3)]\n                pos4 = [int(h / 3), int(w / 4)]\n                size = [int(h / 3), int(h / 3)]\n\n            else:\n                h, w = self.vb.img.shape[:2]\n                pos1 = [int(2 * h / 3), int(w / 3)]\n                pos2 = [int(h / 2), int(2 * w / 3)]\n                pos3 = [int(h / 3), int(w / 3)]\n                pos4 = [int(h / 3), int(w / 4)]\n                size = [int(h / 3), int(h / 3)]\n        except:\n            h, w = self.vb.img.shape[:2]\n            pos1 = [int(2 * h / 3), int(w / 3)]\n            pos2 = [int(h / 2), int(2 * w / 3)]\n            pos3 = [int(h / 3), int(w / 3)]\n            pos4 = [int(h / 3), int(w / 4)]\n            size = [int(h / 3), int(h / 3)]\n\n        # polygonROI\n        # movable=False,\n        self.roi = pg.PolyLineROI(positions=[pos1, pos2, pos3], closed=True, rotatable=False, angle=0)\n        self.vb.add_roi(self.roi)\n        self.apply_button = QPushButton(text=\"Accept\")\n        self.apply_button.clicked.connect(lambda: self.accept_change())\n        # self.apply_button.clicked.connect(lambda: self.get_roi())\n\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n        layout.addWidget(self.gl)\n        layout.addWidget(self.apply_button)\n\n    # when push accept button, keep shape\n    def accept_change(self):\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n        points = self.get_polygon_points()\n        points = self.vb.pg2cv_polygon(points, self.vb.img)\n        self.accept()\n\n    # when push x button, restore shape\n    def reject(self):\n        self.roi.setPos(self.roi_pos)\n        self.roi.setSize(self.roi_size)\n        super().reject()\n\n    def set_image(self, img):\n        try:\n            self.vb.set_image(img)\n        except:\n            pass\n\n    def get_roi(self):\n        points = self.get_polygon_points()\n        final_points = self.vb.pg2cv_polygon(points, self.vb.img)\n        answer = [Polygon(points=final_points)]\n        return answer\n\n    def set_roi(self, shape=Polygon):\n        try:\n            roi = self.vb.cv2pg_polygon(polygon=shape, img=self.vb.img)\n            self.vb.removeItem(self.roi)\n            self.vb.addItem(roi)\n            self.roi = roi\n        except:\n            pass\n\n    def get_rotation_angle(self):\n        \"\"\" 角度 \"\"\"\n        angle = self.roi.state.get('angle', 0) % 360\n        return angle\n\n    def get_polygon_points(self):\n        \"\"\" 多角形端点座標 \"\"\"\n        \"\"\"\n        points = []\n        shape = self.roi.shape()\n        print(\"shape\", shape)\n        pts = self.roi.getSceneHandlePositions()\n        for i in range(shape.elementCount()):\n            element = shape.elementAt(i)\n            if element.type == 1:\n                # x = int(element.x)\n                # y = int(element.y)\n                points += [[element.x, element.y]]\n        \"\"\"\n        pts = self.roi.getSceneHandlePositions()\n        moved_points = []\n        for pt in pts:\n            element = self.roi.mapSceneToParent(pt[1])\n            moved_points += [[element.x(), element.y()]]\n        return moved_points\n\n\nif __name__ == \"__main__\":\n    app = QApplication()\n    hoge = QMainWindow()\n    hoge = BasicROIPolygonDialog()\n    ret = hoge.exec_()\n    if ret:\n        print(\"true\")\n    else:\n        print(\"false\")\n",
        "roi_rectangle_dialog.py": "from PySide2.QtWidgets import QPushButton, QDialog, QMainWindow, QApplication, QVBoxLayout\nimport pyqtgraph as pg\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nfrom pyqtgraph_view import ViewWidget\nfrom cv_shapes_lib import Rectangle, Polygon\nfrom typing import Union\n\nclass BasicROIRectangleDialog(QDialog):\n    def __init__(self, pos=[]):\n        QDialog.__init__(self)\n\n        # QFrameを継承し、レイアウトとQGraphicsLayoutViewを載せる\n        layout = QVBoxLayout(self)\n        self.gl = ViewWidget()\n        self.box_layout = self.gl.addLayout(row=0, col=0)\n        self.box_layout.setBorder((255, 255, 255, 255), width=0.8)\n\n        # QGraphicsLayoutViewにViewBoxを追加する\n        self.vb = self.gl.add_viewbox()\n\n        # 矩形ROIの初期座標計算\n        try:\n            if len(pos) == 4:\n                pos, size = self.vb.cv2pg(pos, self.vb.img)\n                angle = 0\n\n            else:\n                h, w = self.vb.img.shape[:2]\n                pos = [int(w / 3), int(h / 3)]\n                size = [int(w / 3), int(h / 3)]\n        except:\n            h, w = self.vb.img.shape[:2]\n            pos = [int(w / 3), int(h / 3)]\n            size = [int(w / 3), int(h / 3)]\n\n        # rectROI\n        self.roi = pg.RectROI(pos=pos, size=size)\n        self.roi.addRotateHandle([0, 0], [0.5, 0.5])\n        self.vb.add_roi(self.roi)\n        self.apply_button = QPushButton(text=\"Accept\")\n        self.apply_button2 = QPushButton(text=\"reset angle\")\n        self.apply_button.clicked.connect(lambda: self.accept_change())\n        self.apply_button2.clicked.connect(lambda: self.reset_angle())\n        # self.apply_button.clicked.connect(lambda: self.get_roi())\n\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n\n        layout.addWidget(self.gl)\n        layout.addWidget(self.apply_button)\n        layout.addWidget(self.apply_button2)\n\n    # when push accept button, keep shape\n    def accept_change(self):\n        self.roi_pos = self.roi.pos()\n        self.roi_size = self.roi.size()\n        self.accept()\n\n    def reset_angle(self):\n        self.roi.setAngle(0)\n\n    # when push x button, restore shape\n    def reject(self):\n        self.roi.setPos(self.roi_pos)\n        self.roi.setSize(self.roi_size)\n        super().reject()\n\n    def set_image(self, img):\n        try:\n            self.vb.set_image(img)\n        except:\n            pass\n\n    def get_roi(self):\n        angle = self.get_rotation_angle()\n        if angle == 0:\n            # 回転なし矩形\n            pos = self.roi.pos()\n            size = self.roi.size()\n            y1, x1, y2, x2 = self.vb.pg2cv(pos, size, self.vb.img)\n            answer = [Rectangle(x1=x1, y1=y1, x2=x2, y2=y2)]\n            return answer\n        else:\n            # 回転あり矩形\n            pos = self.roi.pos()\n            size = self.roi.size()\n            points = self.vb.pg2cv_rotate_rect(pos, size, angle, self.vb.img)\n            answer = [Polygon(points=points)]\n            return answer\n\n    def set_roi(self, shape=Union[Rectangle, Polygon]):\n        try:\n            if shape.shape_type == \"rectangle\":\n                roi = self.vb.cv2pg_rect(rect=shape, img=self.vb.img)\n                roi.addRotateHandle([0, 0], [0.5, 0.5])\n                self.vb.removeItem(self.roi)\n                self.vb.addItem(roi)\n                self.roi = roi\n            elif shape.shape_type == \"polygon\":\n                roi = self.vb.cv2pg_rect_rotate(rect=shape, img=self.vb.img)\n                roi.addRotateHandle([0, 0], [0.5, 0.5])\n                self.vb.removeItem(self.roi)\n                self.vb.addItem(roi)\n                self.roi = roi\n        except:\n            pass\n\n    def get_rotation_angle(self):\n        \"\"\" 回転角度 \"\"\"\n        angle = self.roi.state.get('angle', 0) % 360\n        return angle\n\n\nif __name__ == \"__main__\":\n    app = QApplication()\n    hoge = QMainWindow()\n    hoge = BasicROIRectangleDialog()\n    ret = hoge.exec_()\n    if ret:\n        print(\"true\")\n    else:\n        print(\"false\")\n"
    },
    "vast-vision-nocode-tool-analysis\\nodes_uncommon\\tcp": {
        "gui.py": "from ryven.gui_env import *\n\nfrom qtpy.QtWidgets import QPushButton, QLabel, QLineEdit\n\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(__file__))\nimport numpy as np\nfrom tcpserver_dialog import TCPDialog\n\n\nclass TCPServerRecvWidget(NodeMainWidget, QPushButton):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        self.dlg = TCPDialog()\n        self.clicked.connect(lambda: self.show_dialog())\n\n    def show_dialog(self):\n        self.dlg.exec_()\n        self.update_node\n\nclass BasicInputWidget(NodeInputWidget, QLineEdit):\n    def __init__(self, params):\n        NodeInputWidget.__init__(self, params)\n        QLineEdit.__init__(self)\n\n        self.setMinimumWidth(60)\n        self.setMaximumWidth(100)\n        self.setStyleSheet(\"background-color:black;\")\n\n        ## loadしたとき毎回発火してしまう->silent=Trueで解決\n        self.textChanged.connect(lambda: self.text_changed())\n        self.init_value()\n\n    def text_changed(self):\n        self.update_node_input(Data(self.text()), silent=True)\n\n    def get_state(self) -> dict:\n        return {'value': self.text()}\n\n    def set_state(self, data: dict):\n        try:\n            self.setText(data['value'])\n        except:\n            pass\n\n    def val_update_event(self, val: Data):\n        try:\n            super().val_update_event(val)\n            # 値を取得（画像のパス）\n            data = val.payload\n            self.setText(str(data))\n        except:\n            pass\n\n    def init_value(self):\n        # input the default value\n        self.set_state({\"value\": self.input.default})\n\nclass TCPServerSendWidget(NodeMainWidget, QLabel):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QLabel.__init__(self)\n\n\nclass VASTTCPServerRecvWidget(NodeMainWidget, QPushButton):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QPushButton.__init__(self)\n\n        self.dlg = TCPDialog()\n        self.clicked.connect(lambda: self.show_dialog())\n\n    def show_dialog(self):\n        self.dlg.exec_()\n        self.update_node\n\n\nclass VASTTCPServerSendWidget(NodeMainWidget, QLabel):\n    def __init__(self, params):\n        NodeMainWidget.__init__(self, params)\n        QLabel.__init__(self)\n\n\nclass TCPServerRecvGui(NodeGUI):\n    main_widget_class = TCPServerRecvWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n\nclass TCPServerSendGui(NodeGUI):\n    input_widget_classes = {\n        'in': BasicInputWidget,\n    }\n    main_widget_class = TCPServerSendWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n    def __init__(self, params):\n        super().__init__(params)\n        for inp in self.node.inputs:\n            self.input_widgets[inp] = {'name': 'in', 'pos': 'besides'}\n\n\nclass VASTTCPServerRecvGui(NodeGUI):\n    main_widget_class = VASTTCPServerRecvWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n\nclass VASTTCPServerSendGui(NodeGUI):\n    main_widget_class = VASTTCPServerSendWidget\n    main_widget_pos = 'between ports'\n    color = '#99dd55'\n\n\nexport_guis([\n    TCPServerRecvGui,\n    TCPServerSendGui,\n    VASTTCPServerRecvGui,\n    VASTTCPServerSendGui\n])\n",
        "nodes.py": "# -*- coding : UTF-8 -*-\n# ===============================================================================\n# Name      : node.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp:2024-09-18 10:44\n# Copyirght 2024 Tatsuya Sugino\n# ===============================================================================\nfrom ryven.node_env import *\nimport sys\nimport os\nimport json\nimport threading\nimport time\nfrom queue import Queue\n\n\nsys.path.append(os.path.dirname(__file__))\n\nscript_path = os.path.abspath(__file__)\nparent_dir = os.path.dirname(os.path.dirname(script_path))\nsys.path.insert(0, parent_dir)\n\n# TCPサーバーのモジュールをインポート\nfrom socket_lib.tcp_connection_class import TCPServerSingleton, load_settings\n# VAST用フォーマットモジュールをインポート\nfrom socket_lib.vast_tcp_format import VastInputValue, create_vast_input_value\n\nguis = import_guis(__file__)\n\n\nclass NodeBase(Node):\n    version = \"v0.1\"\n\n    def have_gui(self):\n        return hasattr(self, 'gui')\n\n\nclass TCP_Server_Recv_Node(NodeBase):\n    title = 'Com_TCP_Server_Recv'\n    init_inputs = []\n    init_outputs = [\n        NodeOutputType(type_=\"exec\"),\n        NodeOutputType(\"message\")\n    ]\n    GUI = guis.TCPServerRecvGui\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.tcp_server = None\n        self.start_tcp_server()\n\n    def start_tcp_server(self):\n        if self.tcp_server is None:\n            settings = load_settings()\n            if settings:\n                self.tcp_server = TCPServerSingleton.get_instance(\n                    settings[\"ip_address\"],\n                    settings[\"port\"],\n                    callback=None,\n                    disconnect_callback=self.handle_disconnect\n                )\n                self.tcp_server._signal.connect(lambda v: self.update_event(v))\n                self.tcp_server.start()\n            else:\n                print(\"Settings not found or failed to load.\")\n\n    def update_event(self, inp=-1):\n        try:\n            message = inp\n            if message:\n                self.set_output_val(1, Data(message))\n                self.exec_output(0)\n        except Exception as e:\n            print(f\"Error receiving message: {e}\")\n\n\n    def handle_disconnect(self):\n        print(\"Client disconnected, restarting server...\")\n        self.start_tcp_server()\n\n    def stop_tcp_server(self):\n        if self.tcp_server:\n            self.tcp_server.stop()\n\n    def __del__(self):\n        self.stop_tcp_server()\n\n\nclass TCP_Server_Send_Node(NodeBase):\n    title = 'Com_TCP_Server_Send'\n    init_inputs = [\n        NodeInputType(type_=\"exec\"),\n        NodeInputType(\"message\")\n    ]\n    init_outputs = []\n    GUI = guis.TCPServerSendGui\n\n    def __init__(self, params):\n        super().__init__(params)\n        self.tcp_server = None\n        self.start_tcp_server()\n\n    def start_tcp_server(self):\n        if self.tcp_server is None:\n            settings = load_settings()\n            if settings:\n                self.tcp_server = TCPServerSingleton.get_instance(\n                    settings[\"ip_address\"],\n                    settings[\"port\"],\n                    callback=None,\n                    disconnect_callback=self.handle_disconnect\n                )\n                self.tcp_server.start()\n            else:\n                print(\"Settings not found or failed to load.\")\n\n    def update_event(self, inp=-1):\n        if inp == 0:\n            print(\"SEND EXEC!!\")\n            try:\n                message = self.input(1).payload\n                print(\"@\", message)\n                if not isinstance(message, str):\n                    message = str(message)\n                if message:\n                    for client_socket in self.tcp_server.server_thread.clients:\n                        self.tcp_server.server_thread.send_to_client(client_socket, message)\n            except Exception as e:\n                print(f\"Error sending message: {e}\")\n            print(\"SEND FINISH\")\n            \n\n    def handle_disconnect(self):\n        print(\"Client disconnected, restarting server...\")\n        self.start_tcp_server()\n\n    def stop_tcp_server(self):\n        if self.tcp_server:\n            self.tcp_server.stop()\n\n    def __del__(self):\n        self.stop_tcp_server()\n\n\n# export_nodes([\n#     TCP_Server_Recv_Node,\n#     TCP_Server_Send_Node,\n# ])\n",
        "tcpserver_dialog.py": "# -*- coding : UTF-8 -*-\n# ===============================================================================\n# Name      : tcpserver_dialog.py\n# Version   : 1.0.0\n# Brief     : \n# Time-stamp:2024-09-17 14:37\n# Copyirght 2024 Tatsuya Sugino\n# ===============================================================================\nfrom PySide2.QtWidgets import (QPushButton, QDialog, QVBoxLayout, QHBoxLayout, QLineEdit, QLabel, QApplication)\nimport json\nimport os\nimport sys\nimport platform\n\nfrom socket_lib.tcp_connection_class import COM_PATH\n\n# SETTINGS_FILE = os.path.join(os.path.dirname(__file__), \"../config/communication.json\")\n        \nclass TCPDialog(QDialog):\n    \n    def __init__(self):\n        super().__init__()\n\n        self.setWindowTitle('TCP Settings')\n\n        # レイアウトの設定\n        layout = QVBoxLayout(self)\n\n        # IPアドレス入力フィールド\n        ip_layout = QHBoxLayout()\n        ip_label = QLabel(\"IP Address:\")\n        self.ip_input = QLineEdit()\n        ip_layout.addWidget(ip_label)\n        ip_layout.addWidget(self.ip_input)\n\n        # ポート入力フィールド\n        port_layout = QHBoxLayout()\n        port_label = QLabel(\"Port:\")\n        self.port_input = QLineEdit()\n        port_layout.addWidget(port_label)\n        port_layout.addWidget(self.port_input)\n\n        # タイムアウト入力フィールド\n        timeout_layout = QHBoxLayout()\n        timeout_label = QLabel(\"Timeout:\")\n        self.timeout_input = QLineEdit()\n        timeout_layout.addWidget(timeout_label)\n        timeout_layout.addWidget(self.timeout_input)\n\n        # ボタンの設定\n        button_layout = QHBoxLayout()\n        self.save_button = QPushButton(\"SAVE\")\n        self.save_button.clicked.connect(self.save_settings)\n        self.cancel_button = QPushButton(\"Cancel\")\n        self.cancel_button.clicked.connect(self.reject)\n        button_layout.addWidget(self.save_button)\n        button_layout.addWidget(self.cancel_button)\n\n        # レイアウトにウィジェットを追加\n        layout.addLayout(ip_layout)\n        layout.addLayout(port_layout)\n        layout.addLayout(timeout_layout)\n        layout.addLayout(button_layout)\n\n        # 設定ファイルの読み込み\n        self.load_settings()\n\n    def load_settings(self):\n        if os.path.exists(COM_PATH):\n            try:\n                with open(COM_PATH, \"r\") as f:\n                    settings = json.load(f)\n                    self.ip_input.setText(settings.get(\"ip_address\", \"\"))\n                    self.port_input.setText(str(settings.get(\"port\", \"\")))\n                    self.timeout_input.setText(str(settings.get(\"timeout\", \"\")))\n            except Exception as e:\n                print(f\"Error loading settings: {e}\")\n\n    def save_settings(self):\n        try:\n            settings = {\n                \"ip_address\": self.ip_input.text(),\n                \"port\": int(self.port_input.text()),\n                \"timeout\": float(self.timeout_input.text())\n            }\n            \n            os.makedirs(os.path.dirname(COM_PATH), exist_ok=True)\n            with open(COM_PATH, \"w\") as f:\n                json.dump(settings, f, indent=4)\n            \n\n            self.accept()\n        except ValueError as e:\n            print(f\"Error converting values: {e}\")\n            self.reject()\n        except Exception as e:\n            print(f\"Error saving settings: {e}\")\n            self.reject()\n\n\nif __name__ == \"__main__\":\n    app = QApplication(sys.argv)\n    dialog = TCPDialog()\n    if dialog.exec_():\n        print(\"Settings saved\")\n    else:\n        print(\"Settings not saved\")\n    sys.exit(app.exec_())"
    },
    "vast-vision-nocode-tool-analysis\\user_functions": {
        "gray.py": "from vast_base_objects import BaseInputs, BaseOutputs\nimport cv2\nimport numpy as np\n\nclass TEST_GrayScaleInputs(BaseInputs, enable=True):\n    img: np.ndarray = None\n    def run(self):\n        return grayscaling(self)\n\nclass TEST_GrayScaleOutputs(BaseOutputs, enable=True):\n    dst: np.ndarray = None\n\n\ndef grayscaling(param:TEST_GrayScaleInputs):\n    dst = cv2.cvtColor(param.img, cv2.COLOR_BGR2GRAY)\n    return TEST_GrayScaleOutputs(\n        dst=dst\n    )",
        "line_distance_function.py": "from vast_base_objects import BaseInputs, BaseOutputs\nimport numpy as np\nimport cv2\nimport math\n\n\nclass Det_LineDistanceInputs(BaseInputs, enable=True):\n    img: np.ndarray\n    px:  float\n    py:  float\n    y1:  float\n\n    def run(self):\n        super().run()\n        return line_distance(self)\n\nclass Det_LineDistanceOutputs(BaseOutputs, enable=True):\n    dst: np.ndarray\n    rsme: int\n\n\ndef line_distance(param: Det_LineDistanceInputs):\n    distance = abs(int(param.py) - int(param.y1))\n\n    # 基準点を描画\n    out_img = cv2.circle(param.img, (int(param.px), int(param.py)), 5, (0, 0, 255), thickness=-1)\n    out_img = cv2.circle(out_img, (int(param.px), int(param.y1)), 5, (0, 0, 255), thickness=-1)\n\n    # 線を描画\n    out_img = cv2.line(out_img, (int(param.px - 100), int(param.y1)), (int(param.px + 100), int(param.y1)), (0, 255, 0), thickness=2)\n    out_img = cv2.line(out_img, (int(param.px), int(param.py)), (int(param.px), int(param.y1)), (0, 255, 0), thickness=2)\n\n    out_img = cv2.line(out_img, (int(param.px - 100), 845), (int(param.px + 100), 845), (0, 255, 0), thickness=2)\n\n    # 距離を書き込み\n    out_img = cv2.putText(out_img, text=str(distance), org=(int(param.px - 200), int((param.py + param.y1) / 2)),\n                      fontFace=cv2.FONT_HERSHEY_PLAIN, fontScale=4,\n                      color=(0, 0, 255), thickness=2, lineType=cv2.LINE_AA)\n\n\n    return Det_LineDistanceOutputs(dst=out_img,rsme=distance)",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib": {
        "affine_h.py": "# ===============================================================================\n# Name      : henkan.py\n# Version   : 1.0.0\n# Brief     : 座標の回転に関わる計算\n# Time-stamp: 2023-09-22 14:16\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nfrom typing import List, Union, Optional, Tuple\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef affine_rotation(matrix_in: Union[np.ndarray, list, tuple],\n                    rot_center: List[int],\n                    rot_angle: float,\n                    ) -> np.ndarray:\n    \"\"\"回転座標変換\n\n    Args:\n        matrix_in (Union[np.ndarray, list, tuple]): _description_\n        rot_center (List[int]): [x_c, y_c]\n        rot_angle (float): degree\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n\n    # NOTE: 回転中心(x,y)\n    [xc, yc] = rot_center\n    # NOTE: 回転角度(r)\n    dr = rot_angle * np.pi / 180\n\n    # NOTE: list or tupleの場合np.arrayにキャスト\n    if isinstance(matrix_in, list) or isinstance(matrix_in, tuple):\n        matrix_in = np.array(matrix_in)\n\n    row, col = matrix_in.shape[:2]\n\n    # NOTE: 入力が n x 2\n    # [[x1,y1], [x2,y2], ... , [xn, yn]]\n    if col == 2 and row != 2:\n        mat_in = np.vstack((matrix_in.T, np.ones(row)))\n\n    # NOTE: 入力が 2 x n\n    # [[x1,x2,...,xn], [y1,y2,...,yn]]\n    elif row == 2 and col != 2:\n        mat_in = np.vstack((matrix_in, np.ones(col)))\n\n    else:\n        # TODO: 例外処理を加えろ\n        return np.array([0])\n\n    # NOTE: 指定の軸を中心に座標変換する行列\n    # [cos -sin t1]\n    # [sin cos t2]\n    rotation_matrix = np.array([\n        [np.cos(dr), -np.sin(dr), xc - xc * np.cos(dr) + yc * np.sin(dr)],\n        [np.sin(dr), np.cos(dr), yc - xc * np.sin(dr) - yc * np.cos(dr)]\n    ])\n\n    # NOTE: 2 x n で出力\n    # [[x1,x2,...,xn], [y1,y2,...,yn]]\n    matrix_out = np.dot(rotation_matrix, mat_in)\n\n    # NOTE: n x 2 で出力\n    # [[x1,y1], [x2,y2], ... , [xn, yn]]\n    return matrix_out.T\n\n\ndef rotate_point(pt: list,\n                 rot_center: list,\n                 rot_angle: float) -> Tuple[float, float]:\n    matrix_out = affine_rotation(\n        matrix_in=np.array([pt]),\n        rot_center=rot_center,\n        rot_angle=rot_angle,\n    )\n    m_ = np.round(matrix_out, decimals=2)\n    return m_[0][0], m_[0][1]  # type:ignore\n\n\ndef rotate_rectangle(rectangle: list,\n                     rot_center: list,\n                     rot_angle: float,\n                     *,\n                     convert_int: bool = False) -> np.ndarray:\n    \"\"\"矩形座標の回転\n\n    Args:\n        rectangle (List[int]): [ymin,xmin,ymax,xmax]\n        rot_center (List[int]): [x_c, y_c]\n        rot_angle (float): degree\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n\n    [ymin, xmin, ymax, xmax] = rectangle\n    matrix_in = np.array([\n        [xmin, ymin],\n        [xmin, ymax],\n        [xmax, ymax],\n        [xmax, ymin]\n    ])\n\n    matrix_out = affine_rotation(\n        matrix_in=matrix_in,\n        rot_center=rot_center,\n        rot_angle=rot_angle,\n    )\n\n    if convert_int:\n        return np.round(matrix_out).astype(np.int32)  # type:ignore\n    else:\n        return np.round(matrix_out, decimals=2)\n\n\ndef rotate_polygon(polygon: Union[np.ndarray, list],\n                   rot_center: List[int],\n                   rot_angle: float) -> np.ndarray:\n    \"\"\"ポリゴンの座標回転\n\n    Args:\n        polygon (Union[np.ndarray, list]): [[x1,y1], [x2,y2]...]\n        rot_center (List[int]): [x_c, y_c]\n        rot_angle (float): degree\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n\n    matrix_out = affine_rotation(\n        matrix_in=polygon,\n        rot_center=rot_center,\n        rot_angle=rot_angle,\n    )\n\n    return np.round(matrix_out, decimals=2)\n\n\ndef rotate_image(src: np.ndarray,\n                 angle: float,\n                 *,\n                 rotation_point: Optional[list] = None\n                 ) -> np.ndarray:\n    \"\"\"画像の回転\\n\n    rotation_pointを入力しない場合,画像の中心で回転\n\n    Args:\n        src (np.ndarray): _description_\n        angle (float): _description_\n        rotation_point (Optional[list], optional): _description_. Defaults to None.\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    h, w = src.shape[:2]\n    if h == 0 or w == 0:\n        logger.error('Image has zero Dimention')\n\n    if rotation_point is None:\n        trans = cv2.getRotationMatrix2D(center=(int(w / 2), int(h / 2)),\n                                        angle=angle, scale=1)\n    else:\n        trans = cv2.getRotationMatrix2D(center=(rotation_point[0], rotation_point[1]),\n                                        angle=angle, scale=1)\n\n    img = cv2.warpAffine(src, trans, (w, h))\n\n    return img\n\n\ndef _find_homography(src_pts: np.ndarray, dst_pts: np.ndarray):\n    \"\"\"ホモグラフィ行列の計算\"\"\"\n    matrix, _ = cv2.findHomography(src_pts, dst_pts, method=cv2.RANSAC, ransacReprojThreshold=5.0)\n    return matrix\n\n\ndef calculate_homography(src_pts: np.ndarray, dst_pts: np.ndarray):\n    \"\"\"ホモグラフィ行列の計算\"\"\"\n    # matches = _bf_match(src_pts, dst_pts)\n    # print(matches)\n    matrix = _find_homography(src_pts, dst_pts)\n    return matrix\n\n\nif __name__ == '__main__':\n    rect = [0, 0, 200, 200]\n    poly = [[100, 100]]\n    rotc = [0, 0]\n    angle = 90\n    pts = rotate_rectangle(rect, rotc, angle)\n    print(pts)\n    pts = rotate_polygon(poly, rotc, angle)\n    print(pts)\n",
        "blob_lib.py": "# ===============================================================================\n# Name      : blob_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-11-20 15:47\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nimport copy\nfrom pydantic import BaseModel\nfrom typing import Tuple, Optional, Union\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass BlobResults(CustomBaseModel):\n    dst: np.ndarray\n    num_blob: int = 0\n    points: list = []  # NOTE: 重心リスト\n    areas: list = []\n    circularitys: list = []\n    msg: str = ''\n    contours: list = []\n\n\nclass MaxBlobResult(CustomBaseModel):\n    dst: np.ndarray\n    contour: np.ndarray\n    point: tuple = (-1.0, -1.0)\n    area: float = -1.0\n    circularity: float = -1.0\n    msg: str = ''\n\n\ndef _fast_find_contours(src: np.ndarray) -> tuple:\n    \"\"\"ブロブのデータ取得(内側の輪郭も取ってしまう)\"\"\"\n    # NOTE: https://imagingsolution.net/program/python/opencv-python/opencv-python-findcontours/\n    # NOTE: cv2.__version__ < 4.0\n    # cv2.__version__ > 4.0 => contours, hierarchy = cv2.findContours(src, 1, 2)\n    contours, _ = cv2.findContours(src, mode=cv2.RETR_LIST, method=cv2.CHAIN_APPROX_SIMPLE)\n    return contours  # type: ignore\n\n\ndef _find_contours(src: np.ndarray) -> tuple:\n    \"\"\"外側の輪郭のみ抽出、内径は検出されない\"\"\"\n    # src = np.zeros_like(src)\n    contours, hierarchy = cv2.findContours(src, mode=cv2.RETR_CCOMP, method=cv2.CHAIN_APPROX_SIMPLE)\n    # NOTE: hierarchy[0][輪郭番号][次の輪郭番号, 前の輪郭番号, 最初子供(内側)の輪郭番号, 親(外側)の輪郭番号]\n    outer_contours = []\n    # NOTE: 輪郭情報が一つもない場合\n    if not contours:\n        return ()\n\n    contour_index = 0\n    while True:\n        outer_contours.append(copy.deepcopy(contours[contour_index]))\n        contour_index = hierarchy[0][contour_index][0]\n        if contour_index == -1:\n            break\n\n    return tuple(outer_contours)\n\n\ndef _get_moment(contour: np.ndarray) -> Tuple[float, float]:\n    \"\"\"ブロブの重心計算\"\"\"\n    m = cv2.moments(contour)\n    try:\n        x, y = (m['m10'] / m['m00'], m['m01'] / m['m00'])\n    except ZeroDivisionError:\n        return -1.0, -1.0\n    return x, y\n\n\ndef _get_blob_info(contour: np.ndarray) -> Tuple[bool, float, float, float, float]:\n    \"\"\"ブロブの重心と面積計算\"\"\"\n    x, y = _get_moment(contour)\n    if x < 0 and y < 0:\n        return False, -1.0, -1.0, -1, -1\n    area = cv2.contourArea(contour)\n    length = cv2.arcLength(contour, True)\n    return True, x, y, area, length\n\n\ndef calculate_gp(points: list) -> Tuple[float, float]:\n    \"\"\"全ブロブの重心\"\"\"\n    [x_mean, y_mean] = np.mean(np.array(points), axis=0)  # type: ignore\n    return round(x_mean, 2), round(y_mean, 2)\n\n\n# def calc_gp(points: list, scores: list) -> Tuple[float, float]:\n#     \"\"\"ブロブの大きさで重み付を行った重心,加重平均\"\"\"\n#     pts_np = np.array(points).T\n#     x_mean = np.average(pts_np[0], weigths=scores)\n#     y_mean = np.average(pts_np[1], weights=scores)\n#     return round(x_mean, 2), round(y_mean, 2)\n\n\ndef calc_circularity(area: float, length: float) -> float:\n    \"\"\"真円度を計算\"\"\"\n    score = 4 * np.pi * area / length / length\n    return round(score, 2)\n\n\ndef contour2polygon(contour: np.ndarray) -> np.ndarray:\n    \"\"\"輪郭を多角形に変換\"\"\"\n    polygon = np.squeeze(contour)\n    return polygon\n\n\ndef contours2polygons(contours: Union[np.ndarray, list]) -> list:\n    \"\"\"輪郭リストを多角形リストに変換\"\"\"\n    polygons = list(map(np.squeeze, contours))\n    return polygons\n\n\ndef draw_contour(src: np.ndarray, contour: np.ndarray,\n                 *, color: tuple = (0, 128, 0), thickness: int = 3) -> np.ndarray:\n    \"\"\"輪郭を描画\"\"\"\n    dst = src.copy()\n    dst = cv2.drawContours(dst, [contour], -1, color=color, thickness=thickness)\n    return dst\n\n\ndef blob_filter(binary_image: np.ndarray,\n                *,\n                min_size: int = -1, max_size: int = -1,\n                inv: bool = False) -> np.ndarray:\n\n    img = binary_image.copy()\n    if inv:\n        img = cv2.bitwise_not(img)\n\n    # NOTE:\n    h, w = img.shape[:2]\n    dst = np.zeros((h, w, 3), dtype=np.uint8)\n\n    contours = _fast_find_contours(img)\n    contours_ls = []\n\n    for contour in contours:\n        ret, _, _, area, _ = _get_blob_info(contour)\n        # NOTE: ブロブが見つからない\n        if not (ret):\n            continue\n        # NOTE: 面積が小さい\n        if min_size > 0 and area < min_size:\n            continue\n        # NOTE: 面積が大きい\n        if max_size > 0 and area > max_size:\n            continue\n\n        # # NOTE: 真円度が足りない\n        # circularity = calc_circularity(area, length)\n        # if circularity_th > 0:\n        #     if circularity < circularity_th:\n        #         continue\n\n        contours_ls.append(copy.deepcopy(contour))\n\n    dst = cv2.drawContours(dst, contours_ls, -1, color=(255, 255, 255), thickness=-1)\n    dst = cv2.cvtColor(dst, cv2.COLOR_BGR2GRAY)\n    # masked_img = cv2.bitwise_and(binary_image, mask)\n    return dst\n\n\ndef get_blob(binary_image: np.ndarray,\n             *,\n             min_size: int = -1, max_size: int = -1,\n             inv: bool = False,\n             draw_value: bool = False,\n             canvas_image: Optional[np.ndarray] = None,\n             thickness: int = 2,\n             marker_size: int = 5,\n             circularity_th: float = -1.0) -> BlobResults:\n    \"\"\"ブロブ検出\n\n    Args:\n        binary_image (np.ndarray): 二値化画像\n        min_size (int, optional): ブロブ検出する面積の下限\n        max_size (int, optional): ブロブ検出する面積の上限\n        inv (bool, optional): ネガ画像で入力\n        draw_value (bool, optional): 出力画像に面積を描画する\n        canvas_image (np.ndarray, optional): ブロブを描画するキャンバス画像\n        thickness (int, optional): ブロブを描画する線の太さ\n        marker_size (int, optional): ブロブの中心マーカの大きさ\n        circularity_th (float, optional): 真円度の閾値\n\n    Returns:\n        BlobResults: 描画画像,ブロブの重心,ブロブの面積\n    \"\"\"\n    img = binary_image.copy()\n    if inv:\n        img = cv2.bitwise_not(img)\n\n    contours = _find_contours(img)\n\n    if canvas_image is not None:\n        dst = canvas_image.copy()\n    else:\n        dst = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n\n    num_blob = 0\n    contours_ls = []\n    scores = []\n    points = []\n    circularity_ls = []\n\n    for contour in contours:\n        ret, x, y, area, length = _get_blob_info(contour)\n        # NOTE: ブロブが見つからない\n        if not (ret):\n            continue\n        # NOTE: 面積が小さい\n        if min_size > 0 and area < min_size:\n            continue\n        # NOTE: 面積が大きい\n        if max_size > 0 and area > max_size:\n            continue\n\n        # NOTE: 真円度が足りない\n        circularity = calc_circularity(area, length)\n        if circularity_th > 0:\n            if circularity < circularity_th:\n                continue\n\n        contours_ls.append(copy.deepcopy(contour))\n        points.append([x, y])\n        scores.append(np.round(area))\n        circularity_ls.append(circularity)\n        num_blob += 1\n\n        dst = cv2.drawMarker(dst, (round(x), round(y)), (0, 255, 0), markerSize=marker_size)\n\n    dst = cv2.drawContours(dst, contours_ls, -1, color=(0, 0, 255), thickness=thickness)\n\n    # NOTE:ブロブ面積の描画\n    if draw_value:\n        for pt, score in zip(points, scores):\n            dst = cv2.putText(dst, text=str(int(score)), org=(round(pt[0]), round(pt[1])),\n                              fontFace=cv2.FONT_HERSHEY_PLAIN, fontScale=1,\n                              color=(255, 255, 0), thickness=1, lineType=cv2.LINE_AA)\n\n    return BlobResults(dst=dst,\n                       num_blob=round(num_blob),\n                       points=points,\n                       areas=scores,\n                       contours=contours_ls,\n                       circularitys=circularity_ls)\n\n\ndef get_max_blob(binary_image: np.ndarray, *,\n                 min_size: int = -1, max_size: int = -1,\n                 inv: bool = False,\n                 draw_value: bool = False,\n                 canvas_image: Optional[np.ndarray] = None,\n                 thickness: int = 2,\n                 marker_size: int = 5,\n                 circularity_th: float = -1.0) -> MaxBlobResult:\n    \"\"\"最大ブロブ検出\n\n    Args:\n        binary_image (np.ndarray): 二値化画像\n        min (int, optional): ブロブ検出する面積の下限\n        max (int, optional): ブロブ検出する面積の上限\n        inv (bool, optional): ネガ画像で入力\n        draw_value (bool, optional): 出力画像に面積を描画する\n        canvas_image (np.ndarray, optional): ブロブを描画するキャンバス画像\n        thickness (int, optional): ブロブを描画する線の太さ\n        marker_size (int, optional): ブロブの中心マーカの大きさ\n        circularity_th (float, optional): 真円度の閾値\n\n    Returns:\n        BlobResult 描画画像,ブロブの重心,ブロブの面積\n    \"\"\"\n    img = binary_image.copy()\n    if inv:\n        img = cv2.bitwise_not(img)\n\n    contours = _find_contours(img)\n\n    if canvas_image is not None:\n        dst = canvas_image.copy()\n        if dst.ndim != 3:\n            dst = cv2.cvtColor(dst, cv2.COLOR_GRAY2BGR)\n    else:\n        dst = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n\n    champ_contour = None\n    champ_area = 0\n    champ_point = None\n    champ_circularity = -1.0\n\n    for contour in contours:\n        ret, x, y, area, length = _get_blob_info(contour)\n        # NOTE: ブロブが見つからない\n        if not (ret):\n            continue\n        # NOTE: 面積が小さい\n        if min_size > 0 and area < min_size:\n            continue\n        # NOTE: 面積が大きい\n        if max_size > 0 and area > max_size:\n            continue\n\n        # NOTE: 真円度が足りない\n        if circularity_th > 0:\n            circularity = calc_circularity(area, length)\n            if circularity < circularity_th:\n                continue\n\n        # NOTE: 大きさ更新ならず\n        if area < champ_area:\n            continue\n\n        champ_contour = copy.deepcopy(contour)\n        champ_point = (x, y)\n        champ_area = round(area)\n        champ_circularity = calc_circularity(area, length)\n        # dst = cv2.drawMarker(dst, (round(x), round(y)), (0, 255, 0), markerSize=marker_size)\n        # dst = cv2.drawContours(dst, [contour], -1, color=(0, 0, 255), thickness=thickness)\n\n    if champ_contour is None or champ_point is None:\n        return MaxBlobResult(dst=dst, contour=np.array([0]), area=-1)\n\n    dst = cv2.drawMarker(dst, (round(champ_point[0]), round(champ_point[1])),\n                         (0, 255, 0), markerSize=marker_size)\n    dst = cv2.drawContours(dst, [champ_contour], -1, color=(0, 0, 255), thickness=thickness)\n\n    # NOTE:ブロブ面積の描画\n    if draw_value:\n        dst = cv2.putText(dst, text=str(int(champ_area)),\n                          org=(round(champ_point[0]), round(champ_point[1])),\n                          fontFace=cv2.FONT_HERSHEY_PLAIN, fontScale=1,\n                          color=(255, 255, 0), thickness=1, lineType=cv2.LINE_AA)\n\n    return MaxBlobResult(dst=dst,\n                         point=champ_point,\n                         area=champ_area,\n                         circularity=champ_circularity,\n                         contour=champ_contour)\n\n\nif __name__ == '__main__':\n    pass\n",
        "calcurator.py": "# 四則演算、論理演算など\n\n# エリア内に含まれるか等\n",
        "circle_lib.py": "# ===============================================================================\n# Name      : circle_lib.py\n# Version   : 1.0.0\n# Brief     : 円検出\n# Time-stamp: 2023-12-25 14:59\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport cv2\nimport numpy as np\nfrom typing import Tuple, Optional, Union\n\nfrom . import pole_h\nfrom .edge_lib import edge_detection\ntry:\n    from ..rv_lib.calibration_h import circle_estimation, EstimatedCircle\nexcept Exception:\n    from rv_lib.calibration_h import circle_estimation, EstimatedCircle  # type: ignore\nfrom pydantic import BaseModel\nfrom .affine_h import rotate_rectangle\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass CircleResult(CustomBaseModel):\n    success: bool = False\n    dst: np.ndarray\n    x: float = -1.0\n    y: float = -1.0\n    r: float = -1.0\n    rmse: float = -1.0\n    msg: str = ''\n    polor_image: Optional[np.ndarray] = None\n    edge_points: list = []  # NOTE: 円のエッジ\n    edge_points_removed_outlier: list = []  # NOTE: 外れ値除去後のエッジ\n    roi_regions: list = []  # NOTE: 検査枠\n\n\ndef get_roi_regions(angle_list: list, center_pt: Union[tuple, list],\n                    radius: int, box_width: int, box_height: int) -> list:\n    \"\"\"検査矩形を計算\"\"\"\n    if isinstance(center_pt, tuple):\n        _center_pt = list(center_pt)\n    else:\n        _center_pt = center_pt\n\n    # NOTE: 検出幅(描画用に大きめにしてます)\n    # NOTE: 描画用に大きめにしてます\n    box_w_offset = int((box_width - 1) / 2 + 4)\n    # NOTE: エッジの探索領域(min-max)\n    min_radius = radius - int(box_height / 2)\n    max_radius = radius + int(box_height / 2)\n    # NOTE: 0度の検査矩形を生成\n    xmin = center_pt[0] + min_radius\n    xmax = center_pt[0] + max_radius\n    ymin = center_pt[1] - box_w_offset\n    ymax = center_pt[1] + box_w_offset\n    region = [ymin, xmin, ymax, xmax]\n    roi_regions = []  # NOTE: 検査領域の座標リスト\n    for angle in angle_list:\n        poly = rotate_rectangle(rectangle=region,\n                                rot_center=_center_pt,\n                                rot_angle=angle,\n                                convert_int=True)\n        roi_regions.append(poly.tolist())\n\n    return roi_regions\n\n\ndef calc_angles(num_pt: int) -> list:\n    \"\"\"点群数から角度のリストを生成\"\"\"\n    itv = 360.0 / num_pt\n    return [round(itr * itv, 1) for itr in range(num_pt)]\n\n\ndef angle2xpt(angle_list: list, circuit_length: int, offset_length: int = 0) -> list:\n    \"\"\"角度のリストから極座標変換時のxのリストを生成\"\"\"\n    point_list = []\n    itv = circuit_length / 360.0\n    for angle in angle_list:\n        x = round(itv * angle) + offset_length\n        point_list.append(int(x))\n    return point_list\n\n\ndef remove_outlier(x_data: list,\n                   y_data: list,\n                   min_num_edge: int) -> Tuple[Optional[EstimatedCircle], list, list]:\n    \"\"\"min_num_edgeの個数まで減らしていく外れ値除去\"\"\"\n    num_edge = len(x_data)\n    min_rmse = 65535.0\n    champion_x_data: list = []\n    champion_y_data: list = []\n\n    # NOTE: 指定の数までポイントを減らしたら推定結果を返す\n    if num_edge <= min_num_edge:\n        result = circle_estimation(x_data=x_data, y_data=y_data)\n        return result, x_data, y_data\n\n    else:\n        for i in range(num_edge):\n            # NOTE: 元データをコピー\n            x_list = x_data.copy()\n            y_list = y_data.copy()\n\n            # NOTE: 順番にiの要素のデータを削除\n            del x_list[i]\n            del y_list[i]\n\n            # NOTE: 円推定\n            result = circle_estimation(x_data=x_list, y_data=y_list)\n            # NOTE: 計算に失敗したらNoneを返す\n            if result is None:\n                return result, [], []\n\n            # NOTE: RMSEが小さいデータセットを残していく\n            if result.rmse < min_rmse:\n                min_rmse = result.rmse\n                champion_x_data = x_list\n                champion_y_data = y_list\n\n        # NOTE: RMSEが一番小さいデータセットで次のフェーズに移行（再帰）\n        return (\n            remove_outlier(\n                champion_x_data,\n                champion_y_data,\n                min_num_edge\n            )\n        )\n\n\ndef remove_outlier2(pts: list,\n                    min_num_edge: int) -> Tuple[Optional[EstimatedCircle], list]:\n    \"\"\"min_num_edgeの個数まで減らしていく外れ値除去\"\"\"\n    num_edge = len(pts)\n    min_rmse = 65535.0\n    champion_pts: list = []\n\n    # NOTE: 指定の数までポイントを減らしたら推定結果を返す\n    if num_edge <= min_num_edge:\n        result = circle_estimation(pts=pts)\n        return result, pts\n\n    else:\n        for i in range(num_edge):\n            # NOTE: 元データをコピー\n            _pts = pts.copy()\n\n            # NOTE: 順番にiの要素のデータを削除\n            del _pts[i]\n\n            # NOTE: 円推定\n            result = circle_estimation(pts=_pts)\n            # NOTE: 計算に失敗したらNoneを返す\n            if result is None:\n                return result, []\n\n            # NOTE: RMSEが小さいデータセットを残していく\n            if result.rmse < min_rmse:\n                min_rmse = result.rmse\n                champion_pts = _pts.copy()\n\n        # NOTE: RMSEが一番小さいデータセットで次のフェーズに移行（再帰）\n        return (\n            remove_outlier2(\n                champion_pts,\n                min_num_edge\n            )\n        )\n\n\ndef remove_outlier_op(x_data: list,\n                      y_data: list,\n                      min_num_edge: int,\n                      radius: float,\n                      acceptable_rate: float) -> Tuple[Optional[EstimatedCircle], list, list]:\n    \"\"\"min_num_edgeの個数まで減らしていく外れ値除去\"\"\"\n    num_edge = len(x_data)\n    min_rmse = 65535.0\n    champion_x_data: list = []\n    champion_y_data: list = []\n    if acceptable_rate < 5:\n        result = circle_estimation(x_data=x_data, y_data=y_data)\n        return result, x_data, y_data\n    r_upper = round(radius * (1.0 + acceptable_rate / 100), 1)\n    r_lower = round(radius * (1.0 - acceptable_rate / 100), 1)\n\n    # NOTE: 指定の数までポイントを減らしたら推定結果を返す\n    if num_edge <= min_num_edge:\n        result = circle_estimation(x_data=x_data, y_data=y_data)\n        return result, x_data, y_data\n\n    else:\n        for i in range(num_edge):\n            # NOTE: 元データをコピー\n            x_list = x_data.copy()\n            y_list = y_data.copy()\n\n            # NOTE: 順番にiの要素のデータを削除\n            del x_list[i]\n            del y_list[i]\n\n            # NOTE: 円推定\n            result = circle_estimation(x_data=x_list, y_data=y_list)\n            # NOTE: 計算に失敗したらNoneを返す\n            if result is None:\n                return result, [], []\n\n            # NOTE: 共用幅\n            if result.r > r_upper:\n                continue\n            elif result.r < r_lower:\n                continue\n\n            # NOTE: RMSEが小さいデータセットを残していく\n            if result.rmse < min_rmse:\n                min_rmse = result.rmse\n                champion_x_data = x_list\n                champion_y_data = y_list\n\n        # NOTE: RMSEが一番小さいデータセットで次のフェーズに移行（再帰）\n        return (\n            remove_outlier(\n                champion_x_data,\n                champion_y_data,\n                min_num_edge\n            )\n        )\n\n\ndef circle_detection(src: np.ndarray,\n                     center_pt: tuple,\n                     radius: int,\n                     *,\n                     canvas: Optional[np.ndarray] = None,\n                     box_width: int = 5,\n                     box_height: int = 15,\n                     num_pt: int = -1,\n                     angle_list: list = [],\n                     edge_type: str = 'positive',\n                     peak_position: str = 'maximum',\n                     enable_outlier_removal: bool = False,\n                     removal_rate: int = 0,\n                     sigma_gain: float = 1.5,\n                     convert_int: bool = False,\n                     draw_edges: bool = False,\n                     thickness: int = 3) -> CircleResult:\n    \"\"\"円検出\\n\n    検出角度の指定方法\\n\n    点数で指定: num_pt\\n\n    角度のリストで指定: angle_list\n\n    Args:\n        src (np.ndarray): _description_\n        center_pt (tuple): 円の中心\n        box_width (int, optional): 検出幅 奇数限定\n        num_pt (int, optional): _description_. Defaults to -1.\n        angle_list (list, optional): _description_. Defaults to [].\n    \"\"\"\n    img = src.copy()\n    if canvas is None:\n        canvas = src.copy()\n\n    # NOTE: 入力チェック\n    # NOTE: アングルリストを生成\n    if num_pt > 3:\n        angle_list = calc_angles(num_pt=num_pt)\n\n    # NOTE: angle_listが空っぽの時\n    if len(angle_list) < 4:\n        return CircleResult(dst=img, msg='Lack of input data')\n\n    # NOTE: 検出幅\n    box_w_offset = (box_width - 1) / 2\n    # NOTE: エッジの探索領域(min-max)\n    min_r = radius - int(box_height / 2)\n    max_r = radius + int(box_height / 2)\n\n    # NOTE: 検出枠の計算\n    roi_regions = get_roi_regions(angle_list=angle_list,\n                                  center_pt=center_pt,\n                                  radius=radius,\n                                  box_width=box_width,\n                                  box_height=box_height)\n\n    # NOTE: 極座標変換\n    polar_img = pole_h.warp_polar(img, center_pt=center_pt, min_r=min_r, max_r=max_r)\n    box_height, circuit_length = polar_img.shape[:2]\n    polar_img, offset_length = pole_h.expand_polar_image(polar_img, 0.2)\n\n    # NOTE: 極座標時のx座標を計算\n    x_pts_polar = angle2xpt(angle_list, circuit_length, offset_length)\n    y_pts_polar = []\n\n    if polar_img.ndim == 3:\n        gray = cv2.cvtColor(polar_img, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = polar_img\n\n    for x in x_pts_polar:\n        roi_data = [0, x - box_w_offset, box_height, x + box_w_offset]\n        roi_data = [int(val) for val in roi_data]\n        ret, pt = edge_detection(src=gray, roi_data=roi_data, direction_axis='vertical',\n                                 edge_type=edge_type, peak_position=peak_position,\n                                 sigma_gain=sigma_gain)\n        if not ret:\n            return CircleResult(dst=img, msg='Failed to process in edge detection')\n\n        y_pts_polar.append(int(pt[1]))\n\n    # NOTE: 極座標から直交座標に変換\n    r_list, theta_list = pole_h.xy2pole(x_pts_polar, y_pts_polar, circuit_length, max_r, offset_length=offset_length)\n    x_pts, y_pts = pole_h.pole2xy(r_list, theta_list, center_pt=center_pt)\n\n    # NOTE: 外れ値除去\n    if enable_outlier_removal:\n        num_pt_ = len(x_pts.tolist())\n        min_edge_ = int(num_pt_ * (removal_rate / 100))\n        res, x_pts_removed_outlier, y_pts_removed_outlier = remove_outlier(x_data=x_pts.tolist(),\n                                                                           y_data=y_pts.tolist(),\n                                                                           min_num_edge=min_edge_,\n                                                                           )\n        if res is None:\n            return CircleResult(dst=img, msg='Failed to estimate circle')\n    else:\n        # NOTE: 除去しない\n        res = circle_estimation(x_data=x_pts.tolist(), y_data=y_pts.tolist())\n        x_pts_removed_outlier, y_pts_removed_outlier = [], []\n        if res is None:\n            return CircleResult(dst=img, msg='Failed to estimate circle')\n\n    # NOTE: 描画のために3チャンネルに復元\n    if polar_img.ndim != 3:\n        polar_img = cv2.cvtColor(polar_img, cv2.COLOR_GRAY2BGR)\n\n    dst = canvas.copy()\n    if dst.ndim != 3:\n        dst = cv2.cvtColor(dst, cv2.COLOR_GRAY2BGR)\n\n    # NOTE: 極座標画像に描画\n    dst_polar = draw_points(polar_img, x_pts_polar, y_pts_polar, thickness=thickness)\n\n    # NOTE: 描画\n    dst = draw_point(dst, (int(res.x), int(res.y)), thickness=thickness)  # NOTE: 中心\n    dst = draw_point(dst, (int(res.x), int(res.y)), radius=int(res.r),\n                     thickness=thickness, color=(0, 255, 0))  # NOTE: 円\n    dst = draw_points(dst, x_pts.tolist(), y_pts.tolist(),\n                      thickness=thickness)  # NOTE: エッジ\n    dst = draw_roi_regions(dst, roi_regions, thickness=thickness)  # NOTE: キャリパ\n\n    # NOTE: 検出点\n    pts_e = np.array([x_pts, y_pts])\n    pts_e = pts_e.T\n\n    # NOTE: 外れ値除去後の検出点\n    pts_removed_outlier = np.array([x_pts_removed_outlier, y_pts_removed_outlier])\n    pts_removed_outlier = pts_removed_outlier.T\n\n    return CircleResult(success=True, dst=dst, x=res.x, y=res.y, r=res.r,\n                        rmse=res.rmse, polor_image=dst_polar,\n                        edge_points=pts_e.tolist(),\n                        edge_points_removed_outlier=pts_removed_outlier.tolist(),\n                        roi_regions=roi_regions)\n\n\n##############\n# NOTE: 描画\n##############\ndef draw_marker(dst: np.ndarray, pt: tuple):\n    \"\"\"中心を描画\"\"\"\n    dst = cv2.drawMarker(dst,\n                         position=pt,\n                         color=(0, 255, 0),\n                         markerType=cv2.MARKER_CROSS,\n                         markerSize=20,\n                         thickness=2,\n                         line_type=cv2.LINE_4\n                         )\n    return dst\n\n\ndef draw_point(dst: np.ndarray, pt: tuple, radius: int = 1,\n               thickness: int = 1, color: tuple = (255, 0, 0)) -> np.ndarray:\n    \"\"\"点を描画\"\"\"\n    dst = cv2.circle(dst,\n                     center=pt,\n                     radius=radius,\n                     color=color,\n                     thickness=thickness,\n                     lineType=cv2.LINE_4,\n                     shift=0)\n    return dst\n\n\ndef draw_points(dst: np.ndarray, x_pts: list, y_pts: list,\n                thickness: int = 1, color: tuple = (255, 0, 0)) -> np.ndarray:\n    \"\"\"円エッジの描画\"\"\"\n    for x, y in zip(x_pts, y_pts):\n        dst = draw_point(dst, (int(x), int(y)), thickness=thickness, color=color)\n    return dst\n\n\ndef draw_roi_regions(dst: np.ndarray, roi_regions: list,\n                     thickness: int = 3, color: tuple = (255, 0, 0)) -> np.ndarray:\n    \"\"\"検査枠を描画\"\"\"\n    for region in roi_regions:\n        dst = cv2.polylines(dst, [np.array(region)], isClosed=True, color=color, thickness=thickness)\n    return dst\n\n\nif __name__ == '__main__':\n    # import matplotlib.pyplot as plt\n\n    # def imshow(src: np.ndarray):\n    #     if src.ndim == 3:\n    #         plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n    #         plt.show()\n    #     else:\n    #         plt.imshow(cv2.cvtColor(src, cv2.COLOR_GRAY2RGB))  # type: ignore\n    #         plt.show()\n\n    # impath = r'C:\\Users\\J100048001\\Desktop\\robot_vision\\data\\tray\\model\\Tray_1\\templ.jpg'\n    impath = r'C:\\Users\\Owner\\Desktop\\robot_vision\\data\\tray\\model\\Tray_1\\orig.bmp'\n    img = cv2.imread(impath)\n",
        "color_lib.py": "# ===============================================================================\n# Name      : blob_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2024-01-25 17:27\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\nfrom __future__ import (\n    division, absolute_import, print_function, unicode_literals)\nimport cv2\nimport numpy as np\nfrom typing import Tuple, Optional, Union\nfrom pydantic import BaseModel\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass ColorJudgeResults(CustomBaseModel):\n    dst: np.ndarray\n    bin: np.ndarray\n    offset_region: list = []\n    n_pixel: int = 0\n    n_pixel_in_region: int = 0\n    rect: list = []\n    msg: str = ''\n\n\ndef _find_contours(src: np.ndarray) -> tuple:\n    \"\"\"ブロブのデータ取得(内側の輪郭も取ってしまう)\"\"\"\n    # NOTE: https://imagingsolution.net/program/python/opencv-python/opencv-python-findcontours/\n    # NOTE: cv2.__version__ < 4.0\n    # cv2.__version__ > 4.0 => contours, hierarchy = cv2.findContours(src, 1, 2)\n    contours, _ = cv2.findContours(src, mode=cv2.RETR_LIST, method=cv2.CHAIN_APPROX_SIMPLE)\n    return contours  # type:ignore\n\n# def _contours2polygons(contours: Union[np.ndarray, list]) -> list:\n#     \"\"\"輪郭リストを多角形リストに変換\"\"\"\n#     polygons = list(map(np.squeeze, contours))\n#     return polygons\n\n\ndef _draw_contours(src: np.ndarray, contours: Union[np.ndarray, list, tuple], *,\n                   color: tuple = (0, 0, 255), thickness: int = 3) -> np.ndarray:\n    \"\"\"輪郭リストを多角形リストに変換\"\"\"\n    dst = cv2.drawContours(src, contours, -1, color=color, thickness=thickness)  # type:ignore\n    return dst\n\n\ndef crop_roi(src: np.ndarray, box: list) -> np.ndarray:\n    \"\"\"画像の切り抜き\"\"\"\n    return src[box[0]:box[2], box[1]:box[3]]\n\n\ndef average_lab_value(target_image: np.ndarray) -> Tuple[np.ndarray, float, float, float]:\n    \"\"\"labの平均値を取得\"\"\"\n    result = cv2.cvtColor(target_image, cv2.COLOR_BGR2LAB)\n    avg_l = np.average(result[:, :, 0])\n    avg_a = np.average(result[:, :, 1])\n    avg_b = np.average(result[:, :, 2])\n\n    return result, avg_l, avg_a, avg_b\n\n\ndef calc_wb_parameters(target_image: np.ndarray) -> list:\n    \"\"\"パラメータを計算(with Gray Paper)\"\"\"\n    _, avg_l, avg_a, avg_b = average_lab_value(target_image)\n    wb_parameters = [255 / avg_l, 128 / avg_a, 128 / avg_b]\n    return wb_parameters\n\n\ndef adjust_wb(target_image: np.ndarray, wb_parameters: list) -> np.ndarray:\n    \"\"\"ゲイン調整\"\"\"\n    lab_image = cv2.cvtColor(target_image, cv2.COLOR_BGR2LAB)\n    proc_img = np.array(wb_parameters) * lab_image[:, :, ]\n    proc_img = np.where(proc_img > 255, 255, proc_img)\n    proc_img = proc_img.astype(np.uint8)\n    proc_img = cv2.cvtColor(proc_img, cv2.COLOR_LAB2BGR)\n    return proc_img\n\n\ndef edit_incoming_image(target_image: np.ndarray,\n                        data: list,\n                        *,\n                        l_val: int = 1) -> np.ndarray:\n    \"\"\"パラメータを適用\"\"\"\n    parameters = [l_val, data[1], data[2]]\n    result = adjust_wb(target_image, parameters)\n    return result\n\n\ndef create_mask_image(image: np.ndarray, polygons: Union[np.ndarray, list]) -> np.ndarray:\n    \"\"\"マスク生成\"\"\"\n    h, w = image.shape[:2]\n    mask = np.zeros((h, w, 3), dtype=np.uint8)\n    for poly in polygons:\n        mask = cv2.fillPoly(img=mask, pts=[np.array(poly)], color=(255, 255, 255))\n    return cv2.cvtColor(mask, cv2.COLOR_BGR2GRAY)  # NOTE: 一次元化\n\n\ndef calc_hist(img: np.ndarray, mask: Optional[np.ndarray] = None) -> np.ndarray:\n    \"\"\"ROIの画素ヒストグラムを生成\n    \"\"\"\n    hist = cv2.calcHist([img], [0], mask, [256], [0, 256])\n    return hist\n\n\ndef count_zero_pixel(bin: np.ndarray) -> int:\n    \"\"\"ゼロピクセルをカウント\"\"\"\n    zero_pixels = cv2.countNonZero(bin)\n    zero_pixels = bin.size - zero_pixels\n    return zero_pixels\n\n\ndef count_non_zero_pixel(bin: np.ndarray) -> int:\n    \"\"\"ゼロ以外のピクセルをカウント\"\"\"\n    zero_pixels = cv2.countNonZero(bin)\n    return zero_pixels\n\n\ndef get_hist_in_region(image: np.ndarray, polygons: Optional[Union[np.ndarray, list]] = None,\n                       ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"領域内のヒストグラムを計算\n\n    Args:\n        image (np.ndarray): _description_\n        polygons (Union[np.ndarray, list]): _description_\n\n    Returns:\n        ch1_hist: blue, hue\n        ch2_hist: green, saturation\n        ch3_hist: red, value\n    \"\"\"\n    ch1, ch2, ch3 = cv2.split(image)\n    if polygons is None:\n        mask = None\n    else:\n        mask = create_mask_image(image, polygons=polygons)\n    ch1_hist = calc_hist(ch1, mask)\n    ch2_hist = calc_hist(ch2, mask)\n    ch3_hist = calc_hist(ch3, mask)\n    return ch1_hist, ch2_hist, ch3_hist\n\n\ndef get_region(src: np.ndarray,\n               lower: Union[tuple, list],\n               upper: Union[tuple, list]) -> np.ndarray:\n    \"\"\"領域を取得\"\"\"\n    if isinstance(lower, list) or isinstance(upper, list):\n        lower_ = tuple(lower)\n        upper_ = tuple(upper)\n    else:\n        lower_ = lower\n        upper_ = upper\n    bin_img = cv2.inRange(src, lower_, upper_)\n    return bin_img\n\n\ndef visualize_edge(img: np.ndarray, lower: Union[list, tuple], upper: Union[list, tuple],\n                   *, color: tuple = (0, 255, 0), thickness: int = 3\n                   ) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"色抽出した領域のエッジを可視化\"\"\"\n    if isinstance(lower, list):\n        lower = tuple(lower)\n    if isinstance(upper, list):\n        upper = tuple(upper)\n\n    bin_img = get_region(img, lower=lower, upper=upper)\n    contours = _find_contours(bin_img)\n    dst = _draw_contours(img, contours,\n                         color=color, thickness=thickness)\n    return dst, bin_img\n\n\ndef get_rect_region_include_polygon(region: list) -> list:\n    \"\"\"多角形が入った矩形エリアを返す->min,maxを取得して加工\"\"\"\n    # NOTE: 転置してx[] y[]に分離\n    arr = np.array(region).T\n    x_, y_ = arr[0], arr[1]\n    xmin, xmax = round(x_.min()), round(x_.max())\n    ymin, ymax = round(y_.min()), round(y_.max())\n    return [ymin, xmin, ymax, xmax]\n\n\ndef convert_color_space(image: np.ndarray, mode: str) -> np.ndarray:\n    if mode == 'rgb':\n        return image\n    elif mode == 'hsv':\n        return cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    elif mode == 'lab':\n        return cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    else:\n        return image\n\n\ndef offset_polygon(region: list, rect: list) -> list:\n    ofs_arr = np.array(region) - np.array([rect[1], rect[0]])\n    ofs_arr_i = ofs_arr.astype(np.uint32)\n    return ofs_arr_i.tolist()\n\n\ndef judge_region(src: np.ndarray,\n                 region: list,\n                 mode: str,\n                 lower_value: Union[tuple, list],\n                 upper_value: Union[tuple, list]) -> ColorJudgeResults:\n\n    img = src.copy()\n    # NOTE: 変換\n    if isinstance(lower_value, list):\n        lower_value = tuple(lower_value)\n    if isinstance(upper_value, list):\n        upper_value = tuple(upper_value)\n\n    # NOTE: ROIを作成\n    rect = get_rect_region_include_polygon(region)\n    roi = crop_roi(img, rect)\n    roi_converted = convert_color_space(roi, mode)\n    # NOTE: ROI内で特定の色エリアを抽出\n    roi_1ch = get_region(src=roi_converted, lower=lower_value, upper=upper_value)\n    # NOTE: MASKを作成\n    mask = create_mask_image(img, [region])\n    mask = crop_roi(mask, rect)\n    # NOTE: 領域のピクセル数\n    n_pixel_in_region = count_non_zero_pixel(mask)\n    # NOTE: ROIとMASKでANDをとる\n    bin = cv2.bitwise_and(roi_1ch, mask)\n    # NOTE: 領域内の指定範囲の色のピクセル数\n    n_pixel = count_non_zero_pixel(bin)\n    # NOTE: オフセットされたポリゴンを計算\n    ofs_region = offset_polygon(region, rect)\n    # NOTE: 描画\n    dst = roi.copy()\n    dst[mask == 255] = cv2.cvtColor(bin, cv2.COLOR_GRAY2BGR)[mask == 255]\n\n    return ColorJudgeResults(\n        dst=dst,\n        bin=bin,\n        n_pixel=n_pixel,\n        n_pixel_in_region=n_pixel_in_region,\n        offset_region=ofs_region,\n        rect=rect\n    )\n\n\ndef remap(gray: np.ndarray, lower_v: int, upper_v: int) -> np.ndarray:\n    if lower_v == 0 and upper_v == 0:\n        # NOTE: 255を返す（FH仕様）\n        # return np.clip(gray, 0, 0)  # type: ignore\n        return np.zeros_like(gray) + 255\n    elif lower_v == 255 and upper_v == 255:\n        # NOTE: 0を返す（FH仕様）\n        # return np.clip(gray, 255, 255)  # type:ignore\n        return np.zeros_like(gray)\n    elif lower_v == upper_v:\n        return np.clip((gray - lower_v) * 255.0, 0, 255)\n    else:\n        return np.clip((gray - lower_v) * (255.0 / (upper_v - lower_v)), 0, 255)\n\n\ndef map_range(img: np.ndarray, lower: list, upper: list) -> np.ndarray:\n    # NOTE: BGR画像をチャンネルごとに分割\n    b, g, r = cv2.split(img.astype(np.float32))\n    # NOTE: 各チャンネルをマッピング\n    b_mapped = remap(b, lower[0], upper[0])\n    g_mapped = remap(g, lower[1], upper[1])\n    r_mapped = remap(r, lower[2], upper[2])\n\n    # NOTE: マッピングされた各チャンネルを結合\n    img_mapped = cv2.merge([b_mapped, g_mapped, r_mapped])\n\n    return img_mapped.astype(np.uint8)\n\n\nif __name__ == '__main__':\n    pass\n",
        "count_lib.py": "# ===============================================================================\n# Name      : template_matching_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-08-18 10:11\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nfrom pydantic import BaseModel\nimport matplotlib.pyplot as plt\nfrom typing import Tuple, Optional\nfrom PIL import Image, ImageDraw, ImageFont\n\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass MultiBoxesResult(CustomBaseModel):\n    num_box: int = 0\n    bboxes: list = []\n    scores: list = []\n    classes: list = []\n    heatmap: np.ndarray = np.ndarray([0])\n    message: str = ''\n\n\ndef create_graph_image(fig: plt.Figure) -> np.ndarray:\n    fig.canvas.draw()  # type: ignore\n    graph_image = np.array(fig.canvas.renderer.buffer_rgba())  # type: ignore\n    graph_image = cv2.cvtColor(graph_image, cv2.COLOR_RGBA2BGR)\n    return graph_image\n\n\ndef preprocess(src: np.ndarray, templ: np.ndarray,\n               mask: Optional[np.ndarray] = None,\n               scale: float = 1.0) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n    \"\"\"前処理(次元,スケール合わせ)\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        mask (Optional[np.ndarray], optional): _description_. Defaults to None.\n        scale (float, optional): _description_. Defaults to 1.0.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]: _description_\n    \"\"\"\n    # NOTE: 前処理\n    h, w = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n\n    # NOTE: コピー処理\n    img = src.copy()\n    t_img = templ.copy()\n\n    # NOTE: リスケ―ル\n    if scale < 0.999:\n        img = cv2.resize(img, (int(scale * w), int(scale * h)))\n        t_img = cv2.resize(t_img, (int(scale * t_w), int(scale * t_h)))\n\n    # NOTE: 次元数チェック\n    if img.ndim == 3:\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    if t_img.ndim == 3:\n        t_img = cv2.cvtColor(t_img, cv2.COLOR_BGR2GRAY)\n\n    # NOTE: マスクのチェック\n    if mask is not None:\n        m_img = mask.copy()\n        m_img = cv2.resize(mask, (int(scale * t_w), int(scale * t_h)))\n        if m_img.ndim == 3:\n            m_img = cv2.cvtColor(m_img, cv2.COLOR_BGR2GRAY)\n        return img, t_img, m_img\n\n    else:\n        # NOTE: mask = Noneで返す\n        return img, t_img, None\n\n\ndef rescale_roi(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        return [int(val * scale) for val in roi]\n    else:\n        return roi\n\n\ndef get_heatmap(match_result: np.ndarray) -> np.ndarray:\n    \"\"\"ヒートマップ取得\n\n    Args:\n        match_result (np.ndarray): _description_\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    img = create_graph_image(fig)\n    return img\n\n\ndef iou_np(box: np.ndarray, other_boxes: np.ndarray,\n           box_area: int, other_box_areas: np.ndarray) -> np.ndarray:\n    \"\"\"矩形Aと他の矩形BのIoUを計算\n\n    Args:\n        box: array([xmin, ymin, xmax, ymax])\n        other_boxes: array([box1, box2, box3,...])\n        box_area: int\n        other_box_areas: [a1, a2, ....]\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # NOTE: 対象矩形Aと他矩形Bの共通部分(intersection)の面積を計算するために、\n    # N個のBについて、Aとの共通部分のxmin, ymin, xmax, ymaxを一気に計算\n    abx_mn = np.maximum(box[0], other_boxes[:, 0])  # xmin\n    aby_mn = np.maximum(box[1], other_boxes[:, 1])  # ymin\n    abx_mx = np.minimum(box[2], other_boxes[:, 2])  # xmax\n    aby_mx = np.minimum(box[3], other_boxes[:, 3])  # ymax\n    # NOTE: 共通部分の幅を計算。共通部分が無ければ0\n    w = np.maximum(0, abx_mx - abx_mn + 1)\n    # NOTE: 共通部分の高さを計算。共通部分が無ければ0\n    h = np.maximum(0, aby_mx - aby_mn + 1)\n    # NOTE: 共通部分の面積を計算。共通部分が無ければ0\n    intersect = w * h\n    # NOTE: N個のBについて、AとのIoUを一気に計算\n    iou_np = intersect / (box_area + other_box_areas - intersect)\n    return iou_np\n\n\ndef nms_fast(bboxes: list, scores: list, classes: list = [],\n             iou_thresh: float = 0.5\n             ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Non-Maximum-Suppression\n\n    Args:\n        bboxes (list): _description_\n        scores (list): _description_\n        classes (list, optional): _description_. Defaults to [].\n        iou_thresh (float, optional): _description_. Defaults to 0.5.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    bboxes_ = np.array(bboxes)\n    scores_ = np.array(scores)\n    classes_ = np.array(classes)\n\n    # NOTE: bboxesの矩形の面積を一気に計算\n    areas = (bboxes_[:, 2] - bboxes_[:, 0] + 1) \\\n        * (bboxes_[:, 3] - bboxes_[:, 1] + 1)\n\n    # NOTE: scoreの昇順(小さい順)の矩形インデックスのリストを取得\n    sort_index = np.argsort(scores_)\n\n    i = -1  # NOTE: 未処理の矩形のindex\n    while (len(sort_index) >= 2 - i):\n        # NOTE: score最大のindexを取得\n        max_score_index = sort_index[i]\n        # NOTE: score最大以外のindexを取得\n        index_list = sort_index[:i]\n        # NOTE: score最大の矩形それ以外の矩形のIoUを計算\n        iou = iou_np(bboxes_[max_score_index], bboxes_[index_list],\n                     areas[max_score_index], areas[index_list])\n\n        # NOTE: IoUが閾値iou_threshold以上の矩形を計算\n        del_index = np.where(iou >= iou_thresh)\n        # NOTE: IoUが閾値iou_threshold以上の矩形を削除\n        sort_index = np.delete(sort_index, del_index)\n        i -= 1  # NOTE: 未処理の矩形のindexを1減らす\n\n    # NOTE: bboxes, scores, classesから削除されなかった矩形のindexのみを抽出\n    bboxes_ = bboxes_[sort_index]\n    scores_ = scores_[sort_index]\n    if classes:\n        classes_ = classes_[sort_index]\n\n    return bboxes_, scores_, classes_\n\n\ndef multi_matching(src: np.ndarray, templ: np.ndarray, mask: Optional[np.ndarray],\n                   score_th: float, iou_th: float, view_heatmap: bool = False\n                   ) -> MultiBoxesResult:\n\n    h, w = templ.shape[:2]\n    heatmap = np.ndarray([0])\n\n    match = cv2.matchTemplate(src, templ, cv2.TM_CCOEFF_NORMED, mask=mask)\n\n    if view_heatmap:\n        heatmap = get_heatmap(match)\n\n    boxes: list = []\n    loc = np.where((match >= score_th) & (match < 1.0))\n\n    # NOTE: 各領域のスコア\n    scores = match[loc]\n\n    # NOTE: スコアのサイズがゼロの場合、該当領域なし\n    if scores.size == 0:\n        return MultiBoxesResult()\n\n    # NOTE: 左上の座標とテンプレート幅から矩形情報を作成\n    for pt in zip(*loc[::-1]):\n        y_min = pt[1]\n        x_min = pt[0]\n        boxes.append([y_min, x_min, y_min + h, x_min + w])\n\n    # NOTE: 重なった矩形を削除\n    _boxes, _scores, _classes = nms_fast(bboxes=boxes, scores=scores, iou_thresh=iou_th)\n    num_box = _boxes.shape[0]\n\n    return MultiBoxesResult(num_box=num_box,\n                            bboxes=_boxes.tolist(),\n                            scores=np.round(_scores, decimals=2).tolist(),\n                            classes=_classes.tolist(),\n                            heatmap=heatmap)\n\n\ndef m_match(src: np.ndarray,\n            templ: np.ndarray,\n            *,\n            search_area: Optional[list] = None,\n            mask: Optional[np.ndarray] = None,\n            compression_ratio: float = 100,\n            score_th: float = 0,\n            iou_th: float = 0,\n            view_heatmap: bool = False\n            ) -> MultiBoxesResult:\n\n    # NOTE: 圧縮率の設定　低いほど解像度が悪くなり処理速度が早くなる\n    if compression_ratio > 1.0:\n        compression_ratio = compression_ratio / 100.0\n\n    # NOTE: 画像と座標をリサイズ\n    img, t_img, m_img = preprocess(src, templ, mask, compression_ratio)\n    if search_area is not None:\n        search_area = rescale_roi(search_area, compression_ratio)\n\n    # NOTE: マッチング\n    res = multi_matching(src=img,\n                         templ=t_img,\n                         mask=m_img,\n                         score_th=score_th,\n                         iou_th=iou_th,\n                         view_heatmap=view_heatmap)\n\n    # NOTE: スケール調整\n    res.bboxes = [rescale_roi(box, 1.0 / compression_ratio) for box in res.bboxes]\n    return res\n\n\ndef vis_bbox_cv2(dst: np.ndarray, bbox: list, label: str, score: float):\n    dst = cv2.rectangle(dst, (bbox[1], bbox[0]), (bbox[3], bbox[2]), (0, 0, 255), 2, 1)\n    dst = cv2.rectangle(dst, (int(bbox[1]), int(bbox[0] - 25)), (bbox[3], bbox[0]), (255, 255, 255), -1)\n    p_str = f'{label}:{score:0.3f}'\n    dst = cv2.putText(dst, p_str, (bbox[1], int(bbox[0] - 5)), cv2.FONT_HERSHEY_COMPLEX, 0.7, (0, 0, 0), 1)\n    return dst\n\n\ndef draw_multi_bbox(dst: np.ndarray, bboxes: list, scores: list, classes: list = []):\n    LABEL_DATA = ['0deg', '90deg', '180deg', '270deg']\n    if not classes:\n        classes = [0] * len(scores)\n\n    for bbox, score, cls in zip(bboxes, scores, classes):\n        label = LABEL_DATA[cls]\n        dst = vis_bbox_cv2(dst, bbox, label, score)\n\n    return dst\n\n\ndef get_text_color(color: tuple) -> str:\n    r, g, b, _ = color\n    brightness = r * 0.299 + g * 0.587 + b * 0.114\n    return \"black\" if brightness > 180 else \"white\"\n\n\ndef draw_boxes(src: np.ndarray, bboxes: list, scores: list, classes: list = [], classlabels: list = []):\n    if not classlabels:\n        classlabels = ['0deg', '90deg', '180deg', '270deg']\n    if not classes:\n        classes = [0] * len(scores)\n\n    # NOTE: numpy -> Image\n    img = Image.fromarray(src)\n    draw = ImageDraw.Draw(img, mode=\"RGBA\")\n\n    # NOTE: 色の一覧を作成する。\n    cmap = plt.cm.get_cmap(\"hsv\", len(classlabels) + 1)  # type:ignore\n\n    # NOTE: フォントを作成する。\n    fontsize = max(15, int(0.03 * min(img.size)))\n    fontname = \"meiryo.ttc\"\n    font = ImageFont.truetype(fontname, size=fontsize)\n\n    for bbox, score, class_id in zip(bboxes, scores, classes):\n        # NOTE: 色を取得する\n        color = cmap(class_id, bytes=True)\n        # NOTE: ラベル\n        caption = classlabels[class_id]\n        # NOTE: ラベルにスコアを追加\n        caption += f\" {score:.0%}\"  # \"score\" が存在する場合はパーセントで表示する。\n        # NOTE: 矩形を描画する。\n        draw.rectangle(\n            (bbox[1], bbox[0], bbox[3], bbox[2]), outline=color, width=3\n        )\n\n        # NOTE: ラベルを描画する。\n        text_w, text_h = draw.textsize(caption, font=font)\n        text_x2 = bbox[1] + text_w - 1\n        text_y2 = bbox[0] + text_h - 1\n\n        # NOTE: テキストカラーを取得\n        text_color = get_text_color(color)\n        draw.rectangle((bbox[1], bbox[0], text_x2, text_y2), fill=color)\n        draw.text((bbox[1], bbox[0]), caption, fill=text_color, font=font)\n\n    return np.array(img)\n\n\nif __name__ == '__main__':\n    # import os\n    # import time\n    pass\n",
        "edge_lib.py": "# ===============================================================================\n# Name      : edge_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-12-25 15:04\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\n\nimport numpy as np\nimport cv2\nfrom scipy.signal import find_peaks\nfrom typing import Tuple, List, Any, Union\n\n\ndef crop_roi(src: np.ndarray, box: list) -> np.ndarray:\n    return src[box[0]:box[2], box[1]:box[3]]\n\n\ndef calculate_subpixel(val1: float,\n                       val2: float,\n                       *,\n                       interval: int = 1) -> float:\n    \"\"\"小数点のシフト量を計算\"\"\"\n    if np.sign(val1) != np.sign(val2):\n        subpixel = abs(val1) / (abs(val1) + abs(val2))\n        subpixel = subpixel / interval\n        return subpixel\n    else:\n        return -1.0\n\n\ndef fine_search(roi_1d: Union[Any, np.ndarray],\n                base_idx: int,\n                *,\n                search_len: int = 4) -> Tuple[bool, float]:\n    \"\"\"サブピクセルの計算 \\n\n        2重微分のゼロ交点(極)を見つける\n    \"\"\"\n    search_area: np.ndarray = np.array(roi_1d)\n    # NOTE: 配列が一次元でない場合\n    if search_area.ndim != 1:\n        return False, 0.0\n\n    # NOTE: エッジ位置が探索領域の端の場合\n    # サブピクセルを計算する領域を確保できないのでそのまま値を返す\n    if base_idx - search_len < 0:\n        return True, base_idx\n\n    # NOTE: 2重微分のゼロ交点（極）を見つける\n    search_area = search_area[base_idx - search_len:base_idx + search_len]\n    dy = np.gradient(search_area)\n    ddy = np.gradient(dy)\n\n    # NOTE: 端でサブピクセルを誤検出しないように符号を統一\n    ddy[0] = ddy[1]\n    ddy[-1] = ddy[-2]\n\n    # NOTE: 符号が変わる場所を探索\n    signs = np.sign(ddy)\n    indices = np.where(signs[:-1] != signs[1:])[0]\n\n    # NOTE: 符号が変わらない場合\n    if indices.size == 0:\n        return True, base_idx\n\n    if len(indices) == 1:\n        # NOTE: 符号が変わる箇所が1個の場合\n        peak_idx = indices[0]\n    else:\n        # NOTE: 符号が変わる箇所が複数個の場合\n        # ギャップが最大の箇所を選択する\n        max_val = 0\n        for ix in indices:\n            gap = abs(ddy[ix] - ddy[ix + 1])\n            if gap > max_val:\n                max_val = gap\n                peak_idx = ix\n\n    subpixel = calculate_subpixel(val1=ddy[peak_idx],\n                                  val2=ddy[peak_idx + 1])\n\n    # NOTE: シフト量が計算できない場合そのまま返す\n    if subpixel == -1:\n        return True, base_idx\n\n    edge_position = base_idx + peak_idx - search_len + subpixel\n\n    return True, edge_position\n\n\ndef find_side_peak(input_array: np.ndarray,\n                   edge_type: str,\n                   peak_position: str,\n                   sigma_gain: float) -> Tuple[int, float]:\n    \"\"\"最初・最後のピークを検出\"\"\"\n    threshold = 0\n    mu = np.average(input_array)\n    sigma = np.std(input_array)\n    sigma_min = 1.0\n\n    # NOTE: 閾値以上のピークの中から最初・最後のピークを探索\n    while sigma_gain > sigma_min:\n        if edge_type == 'positive':\n            threshold = mu + (sigma_gain * sigma)\n            # peak_list = np.where(input_array > threshold)\n            peak_idx_list, _ = find_peaks(input_array, height=threshold)\n        elif edge_type == 'negative':  # peak == 'low':\n            # threshold = mu - (sigma_gain * sigma)\n            # peak_list = np.where(input_array < threshold)\n            threshold = mu - (sigma_gain * sigma)\n            peak_idx_list, _ = find_peaks(-input_array, height=-threshold)\n        else:\n            return -1, 0\n\n        # NOTE: ピークが見つかればループから抜け出す\n        if peak_idx_list.size > 0:\n            break\n\n        # NOTE: 閾値を下げてもう一度検出\n        sigma_gain -= 0.5\n\n    if peak_idx_list.size == 0:\n        return -1, 0\n\n    # NOTE: ピークのINDEXを返す\n    if peak_position == 'first':\n        peak_idx = peak_idx_list[0]\n    elif peak_position == 'last':\n        peak_idx = peak_idx_list[-1]\n    else:\n        return -1, 0\n\n    return peak_idx, threshold\n\n\ndef format_roi_data(roi_data: list, w: int, h: int) -> list:\n    # NOTE: 検査領域の一部が枠外に設定された際にリサイズを行う\n    if roi_data[0] < 0:\n        roi_data[0] = 1\n    if roi_data[1] < 0:\n        roi_data[1] = 1\n    if roi_data[2] > h:\n        roi_data[2] = int(h - 1)\n    if roi_data[3] > w:\n        roi_data[3] = int(w - 1)\n\n    return roi_data\n\n\ndef edge_detection(src: np.ndarray,\n                   roi_data: List[int],\n                   *,\n                   direction_axis: str = 'horizontal',\n                   edge_type: str = 'positive',\n                   inverse: bool = False,\n                   peak_position: str = 'maximum',\n                   kernel: np.ndarray = np.array([0.25, 0.5, 0.25]),\n                   subpixel: bool = False,\n                   sigma_gain: float = 3.0,\n                   ) -> Tuple[bool, list]:\n    \"\"\"エッジ検出\n\n    Args:\n        src (np.ndarray): _description_\n        roi_data (List[int]): _description_\n        direction (str, optional): 検出方向(水平or垂直).\n        edge_type (str, optional): 黒->白(positive), 白->黒(negative).\n        inverse (bool, optional): 検出方向を画像軸と逆転させる.\n        peak_position (str, optional): 検出するピーク位置(maximum, first, last)\n        kernel (np.ndarray, optional): ノイズ対策用カーネル\n        subpixel (bool, optional): サブピクセル使うかどうか\n        sigma_gain (float, optional): 検出するピーク位置の閾値パラメータ(first, lastの時使用)\n\n    Returns:\n        Tuple[bool, float, float]: _description_\n    \"\"\"\n\n    search_area = src.copy()\n\n    # NOTE: 探索エリア\n    search_area = crop_roi(search_area, roi_data)\n    x = round(((roi_data[1] + roi_data[3]) / 2), 2)\n    y = round(((roi_data[0] + roi_data[2]) / 2), 2)\n    x_bias = roi_data[1]\n    y_bias = roi_data[0]\n\n    # NOTE: サーチ方向\n    if direction_axis == 'horizontal':  # >>\n        axis = 0\n    elif direction_axis == 'vertical':  # vv\n        axis = 1\n\n    # NOTE: 領域を一次元に畳み込み\n    # NOTE: axis=0, 垂直方向にsum\n    # NOTE: axis=1, 水平方向にsum\n    conv_data = search_area.sum(axis=axis)\n\n    # NOTE: サーチ方向を逆にする\n    if inverse:\n        conv_data = conv_data[::-1]\n\n    # NOTE: 勾配を計算\n    grad_data = np.gradient(conv_data)\n    # NOTE: 次元そのままでカーネルで畳み込み\n    grad_data = np.convolve(grad_data, kernel, mode='same')\n\n    # NOTE: 端の誤検出防ぐために0で初期化\n    grad_data[0] = 0.0\n    grad_data[1] = 0.0\n    grad_data[-1] = 0.0\n    grad_data[-2] = 0.0\n\n    # NOTE: bothの処理\n    if edge_type == 'both':\n        # NOTE: 勾配データを絶対値に\n        grad_data = np.abs(grad_data)\n        # NOTE: 検出ピークをpositiveに変更\n        edge_type = 'positive'\n\n    if peak_position == 'maximum':\n        if edge_type == 'positive':\n            # NOTE: 最大勾配のINDEX取得\n            edge_idx = int(np.argmax(grad_data))\n        elif edge_type == 'negative':\n            # NOTE: 最小勾配のINDEX取得\n            edge_idx = int(np.argmin(grad_data))\n        else:\n            return False, [-1, -1]\n    else:\n        edge_idx, peak_thresh = find_side_peak(input_array=grad_data,\n                                               edge_type=edge_type,\n                                               peak_position=peak_position,\n                                               sigma_gain=sigma_gain)\n\n        # NOTE: 計算失敗した時の保険\n        if edge_idx < 0:\n            if edge_type == 'positive':\n                edge_idx = int(np.argmax(grad_data))\n            elif edge_type == 'negative':\n                edge_idx = int(np.argmin(grad_data))\n            else:\n                return False, [-1, -1]\n\n    if direction_axis == 'horizontal':\n        # NOTE: 水平方向のエッジ検出\n        if subpixel:\n            # NOTE: サブピクセル処理\n            _, edge_pos = fine_search(roi_1d=conv_data,\n                                      base_idx=int(edge_idx))\n            edge_pixel = edge_pos\n        else:\n            edge_pixel = float(edge_idx)\n\n        # NOTE: 逆転\n        if inverse:\n            edge_pixel = grad_data.size - edge_pixel\n\n        # NOTE: 全体座標に変換\n        x = round(x_bias + edge_pixel, 2)\n\n    else:\n        # NOTE: 垂直方向のエッジ検出\n        if subpixel:\n            # NOTE: サブピクセル処理\n            _, edge_pos = fine_search(roi_1d=conv_data,\n                                      base_idx=int(edge_idx))\n            edge_pixel = edge_pos\n        else:\n            edge_pixel = float(edge_idx)\n\n        # NOTE: 逆転\n        if inverse:\n            edge_pixel = grad_data.size - edge_pixel\n\n        # NOTE: 全体座標に変換\n        y = round(y_bias + edge_pixel, 2)\n\n    return True, [x, y]\n\n\ndef line_detection(src: np.ndarray,\n                   roi_data: List[int],  # [ymin, xmin, ymax, xmax]\n                   *,\n                   scan_direction: str = 'right',\n                   edge_type: str = 'positive',\n                   num_pt: int = 10,\n                   search_width: int = 3,\n                   peak_position: str = 'maximum',\n                   kernel: np.ndarray = np.array([0.25, 0.5, 0.25]),\n                   subpixel: bool = False,\n                   sigma_gain: float = 3.0,\n                   plot_gradient: bool = False) -> Tuple[bool, list]:\n    \"\"\"_summary_\n\n    Args:\n        src (np.ndarray): _description_\n        roi_data (List[int]): 検査領域\n        scan_direction (str, optional): スキャン方向(right, left, up, down)\n        edge_type (str, optional): 黒->白(positive), 白->黒(negative).\n        num (int, optional): 検出する点の個数\n        search_width (int, optional): 点1個あたりの検査幅\n        peak_position (str, optional): 検出するピーク位置(maximum, first, last)\n        kernel (np.ndarray, optional): ノイズ対策\n        subpixel (bool, optional): _description_. Defaults to False.\n        sigma_gain (float, optional): _description_. Defaults to 3.0.\n        plot_gradient (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        Tuple[bool, list]: _description_\n    \"\"\"\n\n    height, width = src.shape[:2]\n\n    if search_width < 3:\n        #return False, []\n        search_width = 3\n\n    # NOTE: ROIの整形 枠外超えないように\n    roi_data = format_roi_data(roi_data, width, height)\n\n    # NOTE: 探索領域を切り取り\n    roi = crop_roi(src, roi_data)\n\n    # NOTE: 3チャンネルで入力されたときにグレイスケールに変換\n    if roi.ndim == 3:\n        roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)\n\n    roi_height, roi_width = roi.shape[:2]\n\n    # NOTE: スキャン方向\n    if scan_direction == 'right':\n        direction_axis = 'horizontal'\n        inverse = False\n    elif scan_direction == 'left':\n        direction_axis = 'horizontal'\n        inverse = True\n    elif scan_direction == 'down':\n        direction_axis = 'vertical'\n        inverse = False\n    elif scan_direction == 'up':\n        direction_axis = 'vertical'\n        inverse = True\n    else:\n        return False, []\n\n    # NOTE: インターバルを計算 両端無視するためnum+1\n    if direction_axis == 'horizontal':  # >\n        interval = (roi_data[2] - roi_data[0]) / (num_pt + 1)\n    elif direction_axis == 'vertical':  # v\n        interval = (roi_data[3] - roi_data[1]) / (num_pt + 1)\n    else:\n        return False, []\n\n    # NOTE: インターバルが2ピクセル以下の時\n    if interval < 2:\n        # TODO: エラーにしろ\n        num_pt = 1\n\n    # NOTE: エッジ検出幅\n    ofs_width = int(search_width / 2)\n\n    edge_points: list = []\n\n    for i in range(num_pt):\n        # NOTE: 水平方向のエッジ検出\n        if direction_axis == 'horizontal':\n            # NOTE: 点一個の時の特別処理\n            if num_pt == 1:\n                search_roi = [\n                    int(roi_height / 2) - ofs_width,\n                    0,\n                    int(roi_height / 2) + ofs_width,\n                    roi_width\n                ]\n            else:\n                # NOTE: 水平方向のエッジ検出\n                search_roi = [\n                    int((i + 1.0) * interval) - ofs_width,\n                    0,\n                    int((i + 1.0) * interval) + ofs_width,\n                    roi_width\n                ]\n\n                # NOTE: ROI外の点で終了 保険\n                if search_roi[0] < 0:\n                    continue\n                elif search_roi[2] > roi_height:\n                    continue\n\n        # NOTE: 垂直方向のエッジ検出\n        elif direction_axis == 'vertical':\n            # NOTE: 点一個の時の特別処理\n            if num_pt == 1:\n                search_roi = [\n                    0,\n                    int(roi_width / 2) - ofs_width,\n                    roi_height,\n                    int(roi_width / 2) + ofs_width,\n                ]\n            else:\n                search_roi = [\n                    0,\n                    int((i + 1.0) * interval) - ofs_width,\n                    roi_height,\n                    int((i + 1.0) * interval) + ofs_width,\n                ]\n\n                # NOTE: ROI外の点で終了 保険\n                if search_roi[1] < 0:\n                    continue\n                elif search_roi[3] > roi_width:\n                    continue\n\n        # NOTE: エッジ検出\n        ret, pt = edge_detection(src=roi,\n                                 roi_data=search_roi,\n                                 direction_axis=direction_axis,\n                                 edge_type=edge_type,\n                                 peak_position=peak_position,\n                                 kernel=kernel,\n                                 inverse=inverse,\n                                 subpixel=subpixel,\n                                 sigma_gain=sigma_gain)\n\n        if direction_axis == 'horizontal':\n            # NOTE: 水平方向の座標オフセット\n            x = round(roi_data[1] + pt[0], 2)\n            y = round(roi_data[0] + pt[1], 2)\n\n            # NOTE: 点一個の時の特別処理\n            if num_pt == 1:\n                edge_points.append([x, y - ofs_width])\n                edge_points.append([x, y])\n                edge_points.append([x, y + ofs_width])\n                return True, edge_points\n\n        elif direction_axis == 'vertical':\n            # NOTE: 垂直方向の座標オフセット\n            y = round(roi_data[0] + pt[1], 2)\n            x = round(roi_data[1] + pt[0], 2)\n\n            # NOTE: 点一個の時の特別処理\n            if num_pt == 1:\n                edge_points.append([x - ofs_width, y])\n                edge_points.append([x, y])\n                edge_points.append([x + ofs_width, y])\n                return True, edge_points\n\n        else:\n            return False, []\n\n        edge_points.append([x, y])\n\n    # edge_points = np.array([x_points, y_points]).T\n    return True, edge_points\n\n\ndef draw_scan_direction(dst: np.ndarray, rect: list, scan_direction: str, *,\n                        thickness: int = 5, color: tuple = (20, 20, 200)) -> np.ndarray:\n    ymin, xmin, ymax, xmax = rect\n    if scan_direction == 'right':\n        pt1 = (xmin, ymin)\n        pt2 = (xmax, ymin)\n    elif scan_direction == 'left':\n        pt1 = (xmax, ymin)\n        pt2 = (xmin, ymin)\n    elif scan_direction == 'down':\n        pt1 = (xmin, ymin)\n        pt2 = (xmin, ymax)\n    elif scan_direction == 'up':\n        pt1 = (xmin, ymax)\n        pt2 = (xmin, ymin)\n    else:\n        return dst\n    return cv2.arrowedLine(dst,\n                           pt1=pt1,\n                           pt2=pt2,\n                           color=color,\n                           thickness=thickness,\n                           line_type=cv2.LINE_4,\n                           shift=0,\n                           tipLength=0.6)\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    def imshow(src: np.ndarray):\n        if src.ndim == 3:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n            plt.show()\n        else:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_GRAY2RGB))  # type: ignore\n            plt.show()\n\n    def draw_rect(img: np.ndarray, box: list):\n        dst = cv2.rectangle(img, (box[1], box[0]), (box[3], box[2]), (0, 255, 0), 3)\n        return dst\n\n    sample_image = np.zeros((1000, 1000, 3), dtype=np.uint8)\n    sample_image = cv2.rectangle(sample_image, (300, 300), (700, 700), (255, 255, 255), -1)\n    imshow(sample_image)\n\n    roi_data = [400, 200, 600, 500]\n\n    dst = sample_image.copy()\n    dst = draw_rect(dst, roi_data)\n    imshow(dst)\n\n    ret, points = line_detection(sample_image, roi_data=roi_data)\n    for pt in points:\n        cv2.circle(dst, (round(pt[0]), round(pt[1])), radius=3, color=(0, 0, 255), thickness=3)\n\n    imshow(dst)\n",
        "filter_h.py": "# ===============================================================================\n# Name      : filter_h.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-07-31 11:05\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nfrom typing import Tuple\n\n# NOTE: フィルタリスト\n# 先鋭化フィルタ\n# 平滑化フィルタ\n# ノイズ除去フィルタ\n# リアルタイム差分フィルタ\n# モルフォロジー処理\n# ヒストグラム平坦化\n# ラプラシアンフィルタ\n# ソーベルフィルタ\n# MeanShiftフィルタ\n# マスクを考慮した大津の二値化\n\n\ndef load_image(path) -> np.ndarray:\n    img = cv2.imread(path)\n    return img\n\n\ndef sharpening_fileter(image: np.ndarray, k: int = 1) -> np.ndarray:\n    \"\"\"先鋭化フィルタ\n\n    Args:\n        image (np.ndarray): 入力画像\n        k (int, optional): ゲイン\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    proc_image = image.copy()\n    kernel = np.array([\n        [-k / 9, -k / 9, -k / 9],\n        [-k / 9, 1 + 8 * k / 9, -k / 9],\n        [-k / 9, -k / 9, -k / 9]\n    ], dtype=np.float32)\n\n    proc_image = cv2.filter2D(proc_image, -1, kernel).astype(np.uint8)\n    return proc_image\n\n\ndef noise_smoothing_filter(image: np.ndarray, ksize: int = 5) -> np.ndarray:\n    \"\"\"平滑化フィルタ\n\n    Args:\n        image (np.ndarray): 入力画像\n        ksize (int, optional): カーネルサイズ\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    proc_image = image.copy()\n    proc_image = cv2.blur(src=proc_image, ksize=(ksize, ksize))\n    proc_image = cv2.medianBlur(src=proc_image, ksize=ksize)\n\n    return proc_image\n\n\ndef noise_removal_filter(image: np.ndarray,\n                         h: int = 10,\n                         template_patch_size: int = 7,\n                         window_size: int = 21) -> np.ndarray:\n    \"\"\"ノイズ除去フィルタ\n\n    Args:\n        image (np.ndarray): 入力画像(グレースケール)\n        h (int, optional): ノイズ除去の強弱\n        template_patch_size (int, optional): テンプレート窓の大きさ(奇数)\n        window_size (int, optional): 探索窓の大きさ(奇数)\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    proc_image = image.copy()\n    image = cv2.fastNlMeansDenoising(\n        src=image,\n        dst=None,\n        h=h,  # noise strength\n        templateWindowSize=template_patch_size,\n        searchWindowSize=window_size\n    )\n\n    return proc_image\n\n\ndef realtime_difference_filter(image: np.ndarray,\n                               itr: int = 1,\n                               ksize: int = 3,\n                               noise: str = 'black',\n                               threshold: int = 100) -> np.ndarray:\n    \"\"\"リアルタイム差分フィルタ\n\n    Args:\n        image (np.ndarray): 入力画像\n        itr (int, optional): モルフォロジー処理の試行回数\n        ksize (int, optional): カーネルサイズ\n        noise (str, optional): ノイズの色. Defaults to 'black'.\n        threshold (int, optional): 差分閾値. Defaults to 100.\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    proc_image = image.copy()\n\n    if noise == 'black':\n        op1 = cv2.MORPH_OPEN\n        op2 = cv2.MORPH_CLOSE\n    else:  # white\n        op1 = cv2.MORPH_CLOSE\n        op2 = cv2.MORPH_OPEN\n\n    kernel = np.ones((ksize, ksize), np.uint8)\n\n    proc_image = cv2.morphologyEx(src=proc_image,\n                                  op=op1,\n                                  kernel=kernel,\n                                  iterations=itr)\n    proc_image = cv2.morphologyEx(src=proc_image,\n                                  op=op2,\n                                  kernel=kernel,\n                                  iterations=itr)\n    # NOTE: 差分フィルタ\n    diff_image = image.astype(np.float32) - proc_image.astype(np.float32)\n    diff_map_image = np.where((np.abs(diff_image) > threshold), 255, 0)\n    return diff_map_image.astype(np.uint8)\n\n\ndef contrast_enhancement_filter(image: np.ndarray, grid_size: int,\n                                clip_limit: float) -> np.ndarray:\n    \"\"\"ヒストグラム平坦化\n\n    Args:\n        image (np.ndarray): 入力画像(グレイスケール)\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    proc_image = image.copy()\n    clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=(grid_size, grid_size))\n    proc_image = clahe.apply(proc_image)\n    return proc_image\n\n\ndef laplacian_filter(image: np.ndarray) -> np.ndarray:\n    \"\"\"ラプラシアンフィルタ\n\n    Args:\n        image (np.ndarray): 入力画像(グレイスケール)\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    proc_image = image.copy()\n\n    kernel = np.array([\n        [1, 1, 1],\n        [1, -8, 1],\n        [1, 1, 1]\n    ], dtype=np.float32)\n\n    proc_image = cv2.filter2D(proc_image, -1, kernel).astype(np.uint8)\n    return proc_image\n\n\ndef sobel_filter(image: np.ndarray, axis:str=\"x\") -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"ソーベルフィルタ\n\n    Args:\n        image (np.ndarray): 入力画像(グレイスケール)\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n\n    proc_image = image.copy()\n\n    if axis == \"x\":\n        kernel_x = np.array([\n            [-1, 0, 1],\n            [-2, 0, 2],\n            [-1, 0, 1]\n        ], dtype=np.float32)\n\n        sobel = cv2.filter2D(proc_image, -1, kernel_x)\n\n    else:\n        kernel_y = np.array([\n            [-1, -2, -1],\n            [0, 0, 0],\n            [1, 2, 1]\n        ], dtype=np.float32)\n\n        sobel = cv2.filter2D(proc_image, -1, kernel_y)\n\n    return sobel\n\n\ndef mean_shift_filter(image: np.ndarray, sp: float, sr: float) -> np.ndarray:\n    \"\"\"Mean-Shift法による画像セグメンテーション(減色処理)\n\n    Args:\n        image (np.ndarray): 入力画像\n        sp (float): 空間窓の半径\n        sr (float): 色空間窓の半径\n\n    Returns:\n        np.ndarray: 出力画像\n    \"\"\"\n\n    proc_image = image.copy()\n    shifted = cv2.pyrMeanShiftFiltering(src=proc_image, sp=sp, sr=sr)\n    return shifted\n\n\ndef distance_transform(binary_image: np.ndarray, mask_size: int = 5) -> np.ndarray:\n    \"\"\"距離変換\n\n    Args:\n        binary_image (np.ndarray): 入力画像(二値化)\n        mask_size (int, optional): マスクサイズ. Defaults to 5.\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    dist_transform = cv2.distanceTransform(src=binary_image,\n                                           distanceType=cv2.DIST_L2,\n                                           maskSize=mask_size)\n    return dist_transform\n\n\ndef watershed(image: np.ndarray, markers: np.ndarray) -> np.ndarray:\n    \"\"\"領域分割\n\n    Args:\n        image (np.ndarray): 入力画像\n        markers (np.ndarray): マーカー画像\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    img = image.copy()\n    mker = cv2.watershed(img, markers)\n    # NOTE: 背景塗りつぶし\n    img[mker == -1] = [255, 0, 0]\n    return img\n\n\ndef search_threshold(img_gray: np.ndarray,\n                     mask: np.ndarray,\n                     min_th: int = 0,\n                     max_th: int = 256,\n                     high_contrast_ratio: float = 1.0,\n                     low_limit_th: int = 125) -> int:\n    \"\"\" Search threshold by Otsu method with mask.\n    This function is referenced this site.\n    https://www.programmersought.com/article/32286738061/\n\n    Parameters\n    -------------------\n    img_gray : np.ndarray\n    mask : np.ndarray\n        Mask image contains only 0 and 255\n    min_th : int = 0\n    max_th : int = 256\n    high_contrast_ratio : float = 1.0\n        If this value < 1.0, percentage of cumsum histgram will be checked.\n    lowest_th : int = 125\n\n    Returns\n    -------------------\n    int\n        Detected thresholed\n    \"\"\"\n\n    px_counts = np.count_nonzero(mask)\n\n    hist = cv2.calcHist(images=[img_gray], channels=[0], mask=mask,\n                        histSize=[256], ranges=[0, 256])\n\n    # NOTE: ヒストグラムの累積和を先に求めることで、ループ中の合計計算を省く\n    cum_hist = np.cumsum(hist)\n\n    # NOTE: カウントがなかったbinは0、それ以外の画素値だけが残る\n    pixel_sum_hist = [hist[i] * i for i in range(256)]\n    cum_pixel_sum_hist = np.cumsum(pixel_sum_hist)\n\n    # NOTE: ループ回数削減のため最も明るい画素チェック\n    # NOTE: max値より0.3%おちる値を閾値探索上限にすることで、\n    # 黒一色の画像をはじく準備をする\n    cum_hist_ratio = cum_pixel_sum_hist / np.max(cum_pixel_sum_hist)\n    eval_cum_hist = np.where(cum_hist_ratio <= high_contrast_ratio)\n    max_th = eval_cum_hist[0][-1]\n\n    if max_th < low_limit_th:  # NOTE: 暗い色一色なので人間の直感と反する閾値が検出されかねない\n        suitable_th = low_limit_th\n        return suitable_th\n\n    max_g = 0\n    suitable_th = min_th\n\n    # NOTE: If you can determine the approximate range of the threshold,\n    # you can set it here to reduce the number of threshold traversals\n    th_list = [i for i in range(min_th, max_th) if int(hist[i][0]) != 0]\n    for th in th_list:\n\n        # NOTE: 累積和を使ってthを境にしたクラスそれぞれ画素値合計を計算\n        fore_pix = cum_hist[-1] - cum_hist[th]\n        back_pix = cum_hist[th]\n        if 0 == fore_pix:\n            break\n        if 0 == back_pix:\n            continue\n\n        # NOTE: 藤城にはこの計算式導出過程が理解できなかった\n        w0 = float(fore_pix) / px_counts\n        u0 = float(cum_pixel_sum_hist[-1]\n                   - cum_pixel_sum_hist[th]) / fore_pix\n        w1 = float(back_pix) / px_counts\n        u1 = float(cum_pixel_sum_hist[th]) / back_pix\n\n        # NOTE: intra-class variance\n        g = w0 * w1 * (u0 - u1) * (u0 - u1)\n        if g > max_g:\n            max_g = g\n            suitable_th = th\n\n    return suitable_th\n\n\nif __name__ == '__main__':\n    # import matplotlib.pyplot as plt\n    #\n    # def imshow(src):\n    #     plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n    #     plt.show()\n    #\n    # # myfilter = FilterClass()\n    # img = load_image(\"test.jpg\")\n    # img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    # imshow(img)\n    # # dst = myfilter.realtime_difference_filter(img)\n    # # dst = myfilter.sharpening_fileter(img)\n    # # dst = myfilter.contrast_enhancement_filter(img)\n    # # laplacian = cv2.Laplacian(img.astype(np.float32), cv2.CV_64F)\n    # # dst1, dst2 = myfilter.sobel(img)\n    # # dst = dst1 + dst2\n    # dst = noise_removal_filter(img)\n    # imshow(dst.astype(np.uint8))\n\n    img = np.load(\"../sample.npy\")\n    if img.ndim == 3:\n        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    hoge = contrast_enhancement_filter(img, 8, 40.0)",
        "fitting_lib.py": "# ===============================================================================\n# Name      : fitting_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-08-18 10:25\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nfrom typing import Union, Tuple\n\n\ndef calc_vector_angle(u: np.ndarray, *, deg=False) -> float:\n    \"\"\"ベクトルの角度を求める\n\n    Args:\n        u (np.ndarray): ベクトル\n        deg (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        float: _description_\n    \"\"\"\n    if deg:\n        return np.rad2deg(np.arctan2(u[1], u[0]))\n    return np.arctan2(u[1], u[0])\n\n\ndef classify_angle(angle_deg: float) -> float:\n    \"\"\"鈍角を鋭角に変換\"\"\"\n\n    # NOTE: 鋭角判定\n    if abs(angle_deg) < 90:\n        return abs(angle_deg)\n    # NOTE: 正の鈍角判定\n    if angle_deg > 0:\n        return 180 - angle_deg\n    # NOTE: 負の鈍角判定\n    if angle_deg < 0:\n        return 180 + angle_deg\n    return angle_deg\n\n\ndef calc_angle_formed_by_two_vector(u: np.ndarray, v: np.ndarray, *, deg=False) -> float:\n    \"\"\"ベクトルのなす角\n\n    Args:\n        u (np.ndarray): ベクトル１\n        v (np.ndarray): ベクトル２\n        deg (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        float: _description_\n    \"\"\"\n    numerator = np.inner(u, v)\n    denominator = np.linalg.norm(u) * np.linalg.norm(v)  # type: ignore\n    ans = numerator / denominator  # NOTE: radian\n    if deg:\n        theta = np.rad2deg(np.arccos(np.clip(ans, -1.0, 1.0)))\n        return classify_angle(theta)\n\n    return np.arccos(np.clip(ans, -1.0, 1.0))\n\n\ndef fit_line(pts: Union[np.ndarray, list]) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"線形の最小二乗法(M推定)\\n\n\n    Args:\n        pts (Union[np.ndarray, list]): _description_\n\n    Returns:\n        座標, 単位ベクトル\n    \"\"\"\n    # NOTE: vx, vy 正規化された直線方向ベクトル\\n\n    # NOTE: x0, y0 直線上の点\n    pts = np.array(pts)\n    vx, vy, x0, y0 = cv2.fitLine(points=pts,\n                                 distType=cv2.DIST_L2,\n                                 param=0,\n                                 reps=0.01,\n                                 aeps=0.01)\n    # NOTE: 直線上の点\n    coord = np.array([x0[0], y0[0]])\n    # NOTE: 単位ベクトル\n    u = np.array([vx[0], vy[0]])\n    return coord, u\n\n\ndef distance_point_to_line(pt: Union[np.ndarray, list],\n                           coord: Union[np.ndarray, list],\n                           vec: Union[np.ndarray, list]) -> Tuple[float, Tuple[float, float]]:\n    \"\"\"点と直線の距離を求める\n    Args:\n        x1 (float): 点のx座標\n        y1 (float): 点のy座標\n        x2 (float): 直線上の点のx座標\n        y2 (float): 直線上の点のy座標\n        u (float): 直線の単位ベクトルのx成分\n        v (float): 直線の単位ベクトルのy成分\n\n    Returns:\n        tuple: 距離と交点の座標\n    \"\"\"\n    x1, y1 = pt[0], pt[1]\n    x2, y2 = coord[0], coord[1]\n    u, v = vec[0], vec[1]\n\n    # NOTE: ベクトルQを正規化\n    q_normalized = np.array([u, v]) / np.linalg.norm([u, v])\n\n    # NOTE: 点Pから点Cへのベクトルを計算\n    vector_to_point = np.array([x1 - x2, y1 - y2])\n\n    # NOTE: 法線ベクトルBを計算\n    normal_vector_b = np.array([-q_normalized[1], q_normalized[0]])\n\n    # NOTE: 点Eの座標を計算\n    intersection_point = np.array([x1, y1]) - np.dot(vector_to_point, normal_vector_b) * normal_vector_b\n\n    # NOTE: 距離を計算\n    distance = np.linalg.norm(pt - intersection_point)\n\n    return distance, tuple(intersection_point)\n\n# def get_closs_point(coord1: Union[np.ndarray, list],\n#                     uv1: Union[np.ndarray, list],\n#                     coord2: Union[np.ndarray, list],\n#                     uv2: Union[np.ndarray, list]) -> Tuple[bool, tuple]:\n#     \"\"\"交点算出\n\n#     Args:\n#         coord1 (Union[np.ndarray, list]): Line1上の点\n#         uv1 (Union[np.ndarray, list]): Line1の単位ベクトル\n#         coord2 (Union[np.ndarray, list]): Line2上の点\n#         uv2 (Union[np.ndarray, list]): Line2の単位ベクトル\n\n#     Returns:\n#         _type_: _description_\n#     \"\"\"\n#     # NOTE: Line1の2点\n#     x1, y1 = np.array(coord1)\n#     x2, y2 = np.array(coord1) + np.array(100 * uv1)\n#     # NOTE: Line2の2点\n#     x3, y3 = np.array(coord2)\n#     x4, y4 = np.array(coord2) + np.array(100 * uv2)\n\n#     # NOTE: 値が0のとき、ベクトルは平行\n#     denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n#     if abs(denom) < 0.001:\n#         return False, (-1, -1)\n\n#     nua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n#     # nub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n\n#     ua = nua / denom\n#     # ub = nub / denom\n\n#     x = x1 + ua * (x2 - x1)\n#     y = y1 + ua * (y2 - y1)\n\n#     return True, (np.round(x, 2), np.round(y, 2))\n\n\ndef get_closs_point(coord1: Union[np.ndarray, list],\n                    u1: Union[np.ndarray, list],\n                    coord2: Union[np.ndarray, list],\n                    u2: Union[np.ndarray, list]) -> Tuple[bool, tuple]:\n    \"\"\"交点算出\n\n    Args:\n        coord1 (Union[np.ndarray, list]): Line1上の点\n        uv1 (Union[np.ndarray, list]): Line1の単位ベクトル\n        coord2 (Union[np.ndarray, list]): Line2上の点\n        uv2 (Union[np.ndarray, list]): Line2の単位ベクトル\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # NOTE: Line1の2点\n    x1, y1 = np.array(coord1)\n    # NOTE: Line2の2点\n    x2, y2 = np.array(coord2)\n\n    # NOTE: 値が0のとき、ベクトルは平行\n    denom = u2[1] * u1[0] - u2[0] * u1[1]\n    if abs(denom) < 0.001:\n        return False, (-1, -1)\n\n    nua = u2[0] * (y1 - y2) - u2[1] * (x1 - x2)\n\n    ua = nua / denom\n    # ub = nub / denom\n\n    x = x1 + ua * (u1[0])\n    y = y1 + ua * (u1[1])\n\n    return True, (np.round(x, 2), np.round(y, 2))\n\n\n# ===============================================================================\n# NOTE: 外れ値除去関連\n# ===============================================================================\n\ndef estimate_points(coord: Union[tuple, list, np.ndarray],\n                    u: Union[tuple, list, np.ndarray],\n                    pts: np.ndarray) -> list:\n    \"\"\"近似線から点を推定\"\"\"\n    predict_pts = []\n    vec = pts.T\n    vx, vy = u[0], u[1]\n    x0, y0 = coord[0], coord[1]\n\n    if abs(vx) > abs(vy):\n        # NOTE: x軸方向で等間隔な点\n        for x_ in vec[0]:\n            dx = x0 - x_\n            ey = y0 - (vy / vx) * dx\n            predict_pts.append([x_, ey])\n    else:\n        # NOTE: y軸方向で等間隔な点\n        for y_ in vec[1]:\n            dy = y0 - y_\n            ex = x0 - (vx / vy) * dy\n            predict_pts.append([ex, y_])\n\n    return predict_pts\n\n\ndef get_rmse(coord: np.ndarray,\n             uv: np.ndarray,\n             pts: Union[list, np.ndarray]) -> Tuple[float, list]:\n    \"\"\"RMSEの計算\"\"\"\n    errors = []\n    cross_pts = []\n    pts = np.array(pts)\n    angle = calc_vector_angle(uv, deg=True)\n    nv = np.array([np.cos(np.radians(angle + 90)), np.sin(np.radians(angle + 90))])\n\n    # # NOTE: 角度が指定されておらず、|a| > 1の場合y誤差を計算\n    # if abs(uv[0]) > abs(uv[1]):\n    #     nv = np.array([0, 1])\n    # # NOTE: 角度が指定されておらず、|a| < 1の場合x誤差を計算\n    # else:\n    #     nv = np.array([1, 0])\n\n    for pt in pts:\n        ret, res = get_closs_point(pt, nv, coord, uv)\n        error_vec = pt - res\n        cross_pts.append(res)\n        errors.append(np.linalg.norm(error_vec)**2)  # type: ignore\n\n    rmse = np.average(errors)\n    rmse = np.sqrt(rmse)\n\n    return rmse, cross_pts\n\n\ndef remove_outlier(pts: np.ndarray):\n    \"\"\"外れ値除去\"\"\"\n    pass\n\n\n# ===============================================================================\n# NOTE: 描画関数\n# ===============================================================================\n\ndef draw_predict_line(dst: np.ndarray,\n                      coord: Union[tuple, list, np.ndarray],\n                      u: Union[tuple, list, np.ndarray],\n                      *,\n                      color=(0, 255, 0),\n                      thickness=3\n                      ) -> np.ndarray:\n    \"\"\"近似直線の描画\"\"\"\n    h, w = dst.shape[:2]\n    if thickness < 0:\n        thickness = int((h + w) / 500)\n    p1 = (int(u[0] * (h + w) + coord[0]),\n          int(u[1] * (h + w) + coord[1]))\n    p2 = (int(u[0] * -(h + w) + coord[0]),\n          int(u[1] * -(h + w) + coord[1]))\n    dst = cv2.line(dst, p1, p2, color, thickness=thickness)\n    return dst\n\n\ndef draw_points(dst: np.ndarray,\n                points: list,\n                *,\n                thickness: int = 1,\n                color: tuple = (0, 255, 255),\n                radius: int = 1) -> np.ndarray:\n    \"\"\"検出点を描画\"\"\"\n    for pt in points:\n        dst = cv2.circle(dst, center=(round(pt[0]), round(pt[1])),\n                         radius=radius,\n                         color=color,\n                         thickness=thickness,\n                         lineType=cv2.LINE_4,\n                         shift=0)\n    return dst\n\n\ndef draw_rectangles(dst: np.ndarray,\n                    rects: list,\n                    *,\n                    thickness: int = 3,\n                    color: tuple = (0, 255, 255)) -> np.ndarray:\n    \"\"\"矩形描画\"\"\"\n    for rect in rects:\n        dst = cv2.rectangle(img=dst, pt1=(rect[1], rect[0]), pt2=(rect[3], rect[2]),\n                            color=color, thickness=thickness)\n    return dst\n\n\ndef draw_error_norm(dst: np.ndarray, pts: Union[list, np.ndarray], cross_pts: Union[list, np.ndarray],\n                    *, color=(0, 0, 255)) -> np.ndarray:\n    \"\"\"誤差ノルムの描画\"\"\"\n    pts = np.array(pts)\n    cross_pts = np.array(cross_pts)\n    h, w = dst.shape[:2]\n    size = int((h + w) / 500)\n    for i in range(pts.shape[0]):\n        p1 = (round(pts[i][0]), round(pts[i][1]))\n        p2 = (round(cross_pts[i][0]), round(cross_pts[i][1]))\n        dst = cv2.line(dst, p1, p2, color, thickness=size)\n    return dst\n\n\ndef line_fitting(\n        pts: Union[np.ndarray, list],\n        direction: str = None,\n        least_num: int = None,\n        img: np.ndarray = None,\n        origin_pts: Union[np.ndarray, list] = None) -> dict:\n\n    # 外れ値除去されたポイントの描画に利用\n    if origin_pts is None:\n        origin_pts = pts.copy()\n\n    # np.ndarrayに変換\n    pts = np.array(pts)\n\n    # 変数の準備\n    pts_count = len(pts)\n    champion_pts = []\n    champion_line = []\n    errors = []\n    min_rmse = 65535\n\n    if least_num is None:\n        least_num = pts_count\n\n    # 外れ値除去計算のループ\n    for i in range(pts_count):\n        # 外れ値除去しない場合\n        if pts_count <= least_num:\n            pts_ = pts\n        else:\n            pts_ = np.delete(pts, i, 0)\n        # 極と単位ベクトルを取得\n        coord, uv = fit_line(pts_)\n\n        if direction is None:\n            # 角度が指定されておらず、|a| > 1の場合y誤差を計算\n            if abs(uv[0]) > abs(uv[1]):\n                nv = np.array([0, 1])\n            # 角度が指定されておらず、|a| < 1の場合x誤差を計算\n            else:\n                nv = np.array([1, 0])\n        else:\n            if direction == \"up\" or direction == \"down\":\n                #print(direction)\n                nv = np.array([0, 1])\n            else:\n                #print(direction)\n                nv = np.array([1, 0])\n\n        # 正しい座標との誤差を計算\n        for j, pt in enumerate(pts_):\n            #uv_var = np.array([-uv[1], uv[0]])\n            ret, res = get_closs_point(pt, nv, coord, uv)\n            error_vec = pt - np.array([res[0], res[1]])\n            errors.append(np.linalg.norm(error_vec))\n\n        rmse = np.average(errors)\n\n        # rmseが最も小さくなるように外れ値を選択\n        if rmse < min_rmse:\n            min_rmse = rmse\n            champion_pts = pts_\n            champion_line = {\"coord\": coord, \"uv\": uv}\n            outlier_index = i\n\n    # 既定の数まで入力座標数が減っていれば結果を返す\n    if len(champion_pts) <= least_num:\n        # 全ての座標を黄色で描画\n        if img is not None:\n            for i, cpt in enumerate(origin_pts):\n                h, w = img.shape[:2]\n                size = int((h + w) / 500)\n                cv2.circle(img, (int(cpt[0]), int(cpt[1])), size, (0, 255, 255), thickness=-1)\n        # 直線を描画\n        if img is not None:\n            h, w = img.shape[:2]\n            size = int((h + w) / 500)\n            p1 = (int(champion_line[\"uv\"][0] * (h + w) + champion_line[\"coord\"][0]),\n                  int(champion_line[\"uv\"][1] * (h + w) + champion_line[\"coord\"][1]))\n            p2 = (int(champion_line[\"uv\"][0] * -(h + w) + champion_line[\"coord\"][0]),\n                  int(champion_line[\"uv\"][1] * -(h + w) + champion_line[\"coord\"][1]))\n            cv2.line(img, p1, p2, (255, 0, 0), thickness=size)\n            # 採用した座標を緑色で描画\n            for i, cpt in enumerate(champion_pts):\n                cv2.circle(img, (int(cpt[0]), int(cpt[1])), size, (0, 255, 0), thickness=-1)\n\n                #debug\n                # rett, ress = get_closs_point(cpt, nv, champion_line[\"coord\"], champion_line[\"uv\"])\n                # cv2.line(img, (int(cpt[0]), int(cpt[1])), (int(ress[0]), int(ress[1])), (255, 0, 0), thickness=size)\n\n        return {\"coord\": champion_line[\"coord\"],\n                \"uv\": champion_line[\"uv\"],\n                \"rmse\": min_rmse,\n                \"pts\": champion_pts,\n                \"img\": img\n                }\n\n    # 既定の数まで減っていなければ再起呼び出し\n    return (\n        line_fitting(\n            pts=champion_pts,\n            least_num=least_num,\n            direction=direction,\n            img=img,\n            origin_pts=origin_pts\n        )\n    )\n\n# ===============================================================================\n# NOTE: メイン関数\n# ===============================================================================\n\ndef all_function(pts: Union[np.ndarray, list]):\n    \"\"\"オールインワン関数の予定地\"\"\"\n    pts = np.array(pts)\n    coord, uv = fit_line(pts)\n\n\nif __name__ == '__main__':\n    \"\"\"test\"\"\"\n    import matplotlib.pyplot as plt\n\n    def imshow(src: np.ndarray):\n        if src.ndim == 3:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n            plt.show()\n        else:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_GRAY2RGB))  # type: ignore\n            plt.show()\n\n    NOISE_MIN = -50\n    NOISE_MAX = 50\n\n    # pt1 = np.array([[100, 100], [100, 1000]])\n    # pt2 = np.array([[100, 1000], [1000, 1000]])\n\n    pt1 = np.array([[100, 100], [1000, 1000]])\n    pt2 = np.array([[100, 1000], [1000, 1000]])\n\n    # NOTE: ノイズを含んだ点群を生成\n    coord1, u1 = fit_line(pt1)\n    coord2, u2 = fit_line(pt2)\n    dummy_array = np.concatenate([[np.arange(1, 1000, 10)], [np.arange(1, 1000, 10)]], 0)\n    dummy_array = dummy_array.T\n    pts1 = estimate_points(coord1, u1, dummy_array)\n    pts2 = estimate_points(coord2, u2, dummy_array)\n    noise = np.random.randint(NOISE_MIN, NOISE_MAX, (len(pts1), 2))  # type: ignore\n    pts1 = np.array(pts1) - noise\n    pts2 = np.array(pts2) - noise\n\n    # NOTE: 線近似\n    coord1, u1 = fit_line(pts1)\n    coord2, u2 = fit_line(pts2)\n\n    # NOTE: 描画用の画像を用意\n    img = np.zeros([1100, 1100, 3], dtype=np.uint8)\n\n    # NOTE: 点群を描画\n    for i in range(len(pts1)):\n        img = cv2.circle(img, center=(int(pts1[i][0]), int(pts1[i][1])),\n                         radius=1,\n                         color=(0, 255, 0),\n                         thickness=3,\n                         lineType=cv2.LINE_4,\n                         shift=0)\n\n        img = cv2.circle(img, center=(int(pts2[i][0]), int(pts2[i][1])),\n                         radius=1,\n                         color=(255, 0, 0),\n                         thickness=3,\n                         lineType=cv2.LINE_4,\n                         shift=0)\n\n    # NOTE: 近似線を描画\n    img = draw_predict_line(img, coord1, u1)\n    img = draw_predict_line(img, coord2, u2)\n\n    a = calc_angle_formed_by_two_vector(u1, u2, deg=True)\n    ret, cross_pt = get_closs_point(coord1, u1, coord2, u2)\n\n    img = cv2.circle(img, center=(int(cross_pt[0]), int(cross_pt[1])),\n                     radius=1,\n                     color=(0, 0, 255),\n                     thickness=3,\n                     lineType=cv2.LINE_4,\n                     shift=0)\n    # rmse1, cross_pt1 = get_rmse(coord1, u1, pts1)\n    # rmse2, cross_pt2 = get_rmse(coord2, u2, pts2)\n\n    # img = draw_error_norm(img, pts1, cross_pt1)\n    # img = draw_error_norm(img, pts2, cross_pt2)\n\n    print(f'二直線の為す角：{a}deg')\n    # print(f'RMSE1: {rmse1}')\n    # print(f'RMSE2: {rmse2}')\n\n    imshow(img)\n",
        "get_windows_id.py": "import winreg\n\nnum = \"0x12345678\"\n\ndef get_windows_product_id():\n    \"\"\"\n    WindowsのプロダクトIDを取得する\n    \"\"\"\n    try:\n        # レジストリキーを開く\n        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\")\n\n        # プロダクトIDを取得\n        product_id, _ = winreg.QueryValueEx(key, \"ProductId\")\n\n        # レジストリキーを閉じる\n        winreg.CloseKey(key)\n\n        return product_id\n    except WindowsError:\n        return \"Unable to retrieve product ID.\"\n\nimport os\n\ndef get_computer_name():\n    return os.environ.get('COMPUTERNAME', 'Unknown')\n\n\ndef convert_computer_name_to_number(computer_name):\n    \"\"\"\n    コンピューター名の文字列を数値に変換する\n    \"\"\"\n    # 文字列をバイト列に変換\n    byte_name = computer_name.encode('utf-8')\n\n    # バイト列の各バイトを数値に変換し、合計する\n    total = sum(byte_name)\n\n    return total\n\ndef convert_to_ascii_codes(input_string):\n    \"\"\"\n    数字とアルファベットが含まれる文字列に対して、アルファベットをアスキーコードナンバーに変換する\n    \"\"\"\n    result = \"\"\n    for char in input_string:\n        if char.isalpha():\n            result += str(ord(char))\n        else:\n            result += char\n    return result\n\nimport re\n\ndef get_vast_id():\n    pattern = r'[^a-zA-Z0-9\\s]'\n\n    pid = get_windows_product_id()\n    pid = re.sub(pattern, '', pid)\n    pid_ascii = convert_to_ascii_codes(pid)\n\n    comp_name = get_computer_name()\n    comp_name = re.sub(pattern, '', comp_name)\n    comp_name_ascii = convert_to_ascii_codes(comp_name)\n\n    id_num = pid_ascii + comp_name_ascii\n\n    total = 0\n    for i, char in enumerate(id_num):\n        total += int(char, 16)\n\n    # convert to hexdecimal\n    vast_id = hex(total + int(num, 16))\n\n    return vast_id\n\nimport json\n\nimport hashlib\ndef get_vast_cipher(vast_id):\n    # calculate two's complement\n    cipher = \"0x\"\n    for i, char in enumerate(vast_id[2:]):\n        cipher += hex(15 - int(char, 16))[2:]\n\n    cipher = hex(int(cipher, 16) + 1)\n\n    # SHA-256 hash\n    hashed = hashlib.sha256(vast_id.encode('utf-8')).hexdigest()\n\n    return hashed\ndef check_id_authentication():\n    id_path = \"./authentication/id.json\"\n    key_path = \"./authentication/key.json\"\n    _dir = os.path.dirname(id_path)\n\n    if not os.path.exists(_dir):\n        os.makedirs(_dir)\n\n    if not os.path.isfile(id_path):\n        vastid = get_vast_id()\n        # 初期設定値\n        _config = {\n            \"id\": vastid\n        }\n        with open(id_path, 'w') as f:\n            json.dump(_config, f, indent=4)\n\n    if not os.path.isfile(key_path):\n        raise SystemError(\"ID authentication key is not found.\")\n    else:\n        with open(key_path, \"r\") as fr:\n            _key = json.load(fr)\n\n        correct_key = get_vast_cipher(get_vast_id())\n\n        if _key[\"HASH\"] != correct_key:\n            raise SystemError(\"ID authentication key is incorrect.\")\n\n    return",
        "match_lib.py": "# ===============================================================================\n# Name      : template_matching_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2024-01-06 15:41\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nfrom typing import Tuple, Optional, List, Union\nfrom pydantic import BaseModel, Field\nfrom concurrent.futures import ThreadPoolExecutor\n\ntry:\n    from .affine_h import (\n        rotate_image,\n        rotate_rectangle,\n        rotate_polygon,\n        rotate_point\n    )\nexcept Exception:\n    from affine_h import (  # type: ignore\n        rotate_image,\n        rotate_rectangle,\n        rotate_polygon,\n        rotate_point\n    )\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass SearchAngleRange(BaseModel):\n    min_angle: float = -5.0\n    max_angle: float = 5.0\n    step: float = 1.0\n\n\nclass MatchResult(CustomBaseModel):\n    pt: list = [-1.0, -1.0]\n    angle: float = 0.0\n    score: float = -1.0\n    polygon: np.ndarray = Field(default_factory=lambda: np.array([[0, 0], [0, 0], [0, 0], [0, 0]]))\n    rect: list = [0, 0, 0, 0]\n    heatmap: np.ndarray = Field(default_factory=lambda: np.zeros((10, 10), dtype=np.uint8))\n    pick_point: list = [0, 0]  # NOTE: マスクの中心、ワークの中心で座標を考慮する\n    mask_poly_list: list = []  # NOTE: 多角形のリスト[poly1, poly2]\n\n\n# ===============================================================================\n# NOTE: 便利メソッド\n# ===============================================================================\n\ndef crop_roi(src: np.ndarray, box: list) -> np.ndarray:\n    return src[box[0]:box[2], box[1]:box[3]]\n\n\ndef ave_pt(polygon: np.ndarray) -> list:\n    \"\"\"重心算出\"\"\"\n    [x_mean, y_mean] = np.mean(polygon, axis=0)  # type: ignore\n    return [round(x_mean, 2), round(y_mean, 2)]\n\n\ndef imshow(src: np.ndarray) -> None:\n    if src.ndim == 3:\n        plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n        plt.show()\n    else:\n        plt.imshow(cv2.cvtColor(src, cv2.COLOR_GRAY2RGB))  # type: ignore\n        plt.show()\n\n\ndef show_heatmap(match_result: np.ndarray) -> None:\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    plt.show()\n\n\ndef create_graph_image(fig: plt.Figure) -> np.ndarray:\n    fig.canvas.draw()  # type: ignore\n    graph_image = np.array(fig.canvas.renderer.buffer_rgba())  # type: ignore\n    graph_image = cv2.cvtColor(graph_image, cv2.COLOR_RGBA2BGR)\n    return graph_image\n\n\ndef get_heatmap(match_result: np.ndarray) -> np.ndarray:\n    \"\"\"ヒートマップ取得\n\n    Args:\n        match_result (np.ndarray): _description_\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    fig = plt.figure()  # 新しいFigureオブジェクトを作成\n    ax = fig.add_subplot(111)\n    # fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    img = create_graph_image(fig)\n    # NOTE: 解放しないとメモリリーク\n    plt.close()\n    return img\n\n\ndef get_mask_center(mask: np.ndarray) -> Tuple[float, float]:\n    mu = cv2.moments(array=cv2.cvtColor(mask, cv2.COLOR_BGR2GRAY), binaryImage=False)\n    x, y = int(mu[\"m10\"] / mu[\"m00\"]), int(mu[\"m01\"] / mu[\"m00\"])\n    return x, y\n\n\ndef _conv_grayscale(src: np.ndarray, color: str = 'gray') -> np.ndarray:\n    \"\"\"\n    グレイスケール化\n    \"\"\"\n    if color == 'gray':\n        return cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)\n    elif color == 'red':\n        _, _, red = cv2.split(src)\n        return red\n    elif color == 'green':\n        _, green, _ = cv2.split(src)\n        return green\n    elif color == 'blue':\n        blue, _, _ = cv2.split(src)\n        return blue\n    elif color == 'hue':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        hue, _, _ = cv2.split(hsv)\n        return hue\n    elif color == 'saturation':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        _, saturation, _ = cv2.split(hsv)\n        return saturation\n    elif color == 'value':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        _, _, value = cv2.split(hsv)\n        return value\n    else:\n        return src\n\n\ndef _preprocess(src: np.ndarray, templ: np.ndarray,\n                mask: Optional[np.ndarray] = None,\n                scale: float = 1.0) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n    \"\"\"前処理(次元,スケール合わせ)\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        mask (Optional[np.ndarray], optional): _description_. Defaults to None.\n        scale (float, optional): _description_. Defaults to 1.0.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]: _description_\n    \"\"\"\n    # NOTE: 前処理\n    h, w = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n\n    # NOTE: コピー処理\n    img = src.copy()\n    t_img = templ.copy()\n\n    # NOTE: リスケ―ル\n    if scale < 0.999:\n        img = cv2.resize(img, (int(scale * w), int(scale * h)))\n        t_img = cv2.resize(t_img, (int(scale * t_w), int(scale * t_h)))\n\n    # NOTE: 次元数チェック\n    if img.ndim == 3:\n        img = _conv_grayscale(img)\n    if t_img.ndim == 3:\n        t_img = _conv_grayscale(t_img)\n\n    # NOTE: マスクのチェック\n    if mask is not None:\n        m_img = mask.copy()\n        m_img = cv2.resize(mask, (int(scale * t_w), int(scale * t_h)))\n        if m_img.ndim == 3:\n            m_img = cv2.cvtColor(m_img, cv2.COLOR_BGR2GRAY)\n        return img, t_img, m_img\n\n    else:\n        # NOTE: mask = Noneで返す\n        return img, t_img, None\n\n\ndef rescale_roi(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        return [int(val * scale) for val in roi]\n    else:\n        return roi\n\n\ndef rescale_search_area(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        w = roi[3] - roi[1]\n        h = roi[2] - roi[0]\n        r_w = (scale * w)\n        r_h = (scale * h)\n        dw = w - r_w\n        dh = h - r_h\n        xmin = int(roi[1] + dw / 2.0)\n        ymin = int(roi[0] + dh / 2.0)\n        return [ymin, xmin, int(ymin + r_h), int(xmin + r_w)]\n\n    else:\n        return roi\n\n\ndef get_best_match_pos(match: np.ndarray, t_size: tuple,\n                       scale: float = 1.0, score_th: float = 0.1) -> Tuple[list, float]:\n    \"\"\"一致度が最大の座標を取得\n\n    Args:\n        match (np.ndarray): _description_\n        t_size (tuple): _description_\n        scale (float, optional): _description_. Defaults to 1.0.\n        score_th (float, optional): _description_. Defaults to 0.1.\n\n    Returns:\n        Tuple[list, float]: _description_\n    \"\"\"\n\n    # NOTE: マスク有りだとたまにスコア1以上が出現するため、1以下を取得\n    # NOTE: スコア1以上は変な場所を検出している気がする\n    loc = np.where((match > score_th) & (match < 1.0))\n    scores = match[loc]\n    # NOTE: 何も見つからなかったとき\n    if scores.size == 0:\n        return [0, 0, 0, 0], -1.0\n\n    idx = np.argmax(scores)\n    max_score = scores[idx]\n\n    max_pt = [loc[1][idx], loc[0][idx]]\n    x_min = max_pt[0]\n    y_min = max_pt[1]\n\n    if scale < 0.99:\n        x_min = round(x_min / scale)\n        y_min = round(y_min / scale)\n\n    roi = [y_min, x_min, y_min + t_size[0], x_min + t_size[1]]\n\n    return roi, max_score\n\n\ndef match4para(theta: float, img: np.ndarray, t_img: np.ndarray, m_img: Optional[np.ndarray],\n               t_size: tuple, use_mask: bool, scale: float) -> Tuple[float, list, float]:\n    \"\"\"並列処理用テンプレートマッチング関数\n\n    Args:\n        theta (float): _description_\n        img (np.ndarray): _description_\n        t_img (np.ndarray): _description_\n        m_img (Optional[np.ndarray]): _description_\n        t_size (tuple): _description_\n        search_area (Optional[list]): _description_\n        use_mask (bool): _description_\n        scale (float): _description_\n\n    Returns:\n        Tuple[float, list, float]: _description_\n    \"\"\"\n    # NOTE: 回転させてからcropすることで回転軸を同じにする\n    # => 処理は遅くなるが座標変換の手間を省く\n    input = rotate_image(img, theta)\n\n    # NOTE: マッチング\n    if use_mask:\n        # match = cv2.matchTemplate(input, t_img, cv2.TM_CCORR_NORMED, mask=m_img)\n        # NOTE: こっちの方がよい\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED, mask=m_img)\n    else:\n        # match = cv2.matchTemplate(input, t_img, cv2.TM_CCORR_NORMED)\n        # NOTE: こっちの方がよい\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED)\n\n    roi, max_score = get_best_match_pos(match=match, t_size=t_size, scale=scale)\n\n    return round(max_score, 3), roi, round(theta, 3)\n\n\ndef calc_heatmap(img: np.ndarray, t_img: np.ndarray, m_img: Optional[np.ndarray],\n                 theta: float, use_mask: bool) -> np.ndarray:\n    \"\"\"ヒートマップ取得用\n    \"\"\"\n    input = rotate_image(img, theta)\n\n    # NOTE: マッチング\n    if use_mask:\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED, mask=m_img)\n    else:\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED)\n\n    heatmap = get_heatmap(match)\n\n    return heatmap\n\n\ndef proc_for_chamfer_matching(img: np.ndarray,\n                              templ: np.ndarray,\n                              thresh: int = 100) -> Tuple[np.ndarray, np.ndarray]:\n    # NOTE: 二値化前提\n    img_ = img.copy()\n    # NOTE: 一次元化\n    if img_.ndim == 3:\n        img_ = _conv_grayscale(img_)\n    _, img_ = cv2.threshold(img_, thresh, 255, cv2.THRESH_BINARY)\n    img_ = cv2.bitwise_not(img_)\n    img_ = cv2.distanceTransform(img_, cv2.DIST_L2, 3)\n    templ_ = templ.copy()\n    # NOTE: 一次元化\n    if templ_.ndim == 3:\n        templ_ = _conv_grayscale(templ_)\n    _, templ_ = cv2.threshold(templ_, thresh, 255, cv2.THRESH_BINARY)\n    templ_ = cv2.bitwise_not(templ_).astype(np.float32)\n    return img_, templ_\n\n\ndef rotation_matching(src: np.ndarray,\n                      templ: np.ndarray,\n                      angle_range_table: List[SearchAngleRange],\n                      pick_point: tuple,\n                      *,\n                      mask: Optional[np.ndarray] = None,\n                      mask_poly_list: Optional[list] = None,\n                      compression_ratio: float = 100,\n                      use_chamfer: bool = False,\n                      view_heatmap: bool = False\n                      ) -> MatchResult:\n    \"\"\"回転マッチング\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        search_area (list, optional): _description_. Defaults to None.\n        mask (np.ndarray, optional): _description_. Defaults to None.\n        scale (float, optional): _description_. Defaults to 100.\n        min_angle (float, optional): _description_. Defaults to -3.0.\n        max_angle (float, optional): _description_. Defaults to 3.0.\n        step_angle (float, optional): _description_. Defaults to 0.1.\n        view_heatmap (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        MatchResult: _description_\n    \"\"\"\n    champ_score: float = 0\n    champ_angle: float = 0\n    champ_roi: list = [0, 0, 0, 0]\n    futures: list = []\n\n    height, width = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n    t_size = (t_h, t_w)\n\n    # NOTE: マスク有無\n    if mask is None:\n        use_mask = False\n    else:\n        use_mask = True\n\n    # NOTE: リスケ―ル\n    if compression_ratio > 1.0:\n        compression_ratio = compression_ratio / 100.0\n\n    if use_chamfer:\n        src_c, templ_c = proc_for_chamfer_matching(src, templ)\n        img, t_img, m_img = _preprocess(src_c, templ_c, mask, scale=compression_ratio)\n    else:\n        # NOTE: リサイズ、次元削減の前処理\n        img, t_img, m_img = _preprocess(src, templ, mask, scale=compression_ratio)\n\n    # NOTE: 並列処理用に検出を行う角度のリストを作成\n    a_list_table = []\n\n    for a_info in angle_range_table:\n        a_list = [round((val * a_info.step), 2) for val in\n                  range(int(a_info.min_angle / a_info.step),\n                        int(a_info.max_angle / a_info.step) + 1, 1)]\n        a_list_table.append(a_list.copy())\n\n    result_list: List[list] = []\n\n    # NOTE: 実行\n    for a_list_ in a_list_table:\n        # NOTE: 並列処理でタクト短縮\n        with ThreadPoolExecutor(max_workers=4, thread_name_prefix=\"thread\") as pool:\n            for angle in a_list_:\n                future = pool.submit(match4para, angle, img, t_img, m_img, t_size, use_mask, compression_ratio)\n                futures.append(future)\n\n        # NOTE: 並列処理で取得したデータから最大スコアの情報を抜き出す\n        max_score = -10.0\n        for future in futures:\n            # NOTE: スコア,位置,角度を取得\n            score, roi, theta = future.result()\n            # NOTE: スコア更新ならず\n            if score < max_score:\n                continue\n            max_score = score\n            champ_score = score\n            champ_angle = theta\n            champ_roi = roi\n\n        result_list.append([champ_score, champ_roi, champ_angle])\n\n    # NOTE: 異なる角度レンジの最高スコア同士を比較\n    max_score = -10.0\n    for res in result_list:\n        score, roi, theta = res\n        # NOTE: スコア更新ならず\n        if score < max_score:\n            continue\n        max_score = score\n        champ_score = score\n        champ_angle = theta\n        champ_roi = roi\n\n    # NOTE: 何も見つからなかったとき\n    if max_score < 0.0:\n        logger.debug('Not found Matching Area')\n        return MatchResult()\n\n    # NOTE: ptを抜き出し\n    ymin, xmin, _, _ = champ_roi\n\n    # NOTE: 回転した検出枠を計算\n    polygon = rotate_rectangle(rectangle=champ_roi,\n                               rot_center=[round(width / 2), round(height / 2)],\n                               rot_angle=champ_angle)\n\n    # NOTE: 回転したマスク領域を計算\n    m_p_list = []\n    if mask_poly_list is not None:\n        for mask_poly_ in mask_poly_list:\n            poly_ = rotate_polygon(np.array(mask_poly_) + np.array([xmin, ymin]),\n                                   rot_center=[round(width / 2), round(height / 2)],\n                                   rot_angle=champ_angle)\n            m_p_list.append(poly_.copy().tolist())\n\n    # NOTE: グローバルで計算\n    m_x, m_y = rotate_point(pt=[xmin + pick_point[0], ymin + pick_point[1]],\n                            rot_center=[round(width / 2), round(height / 2)],\n                            rot_angle=champ_angle)\n\n    # NOTE: ヒートマップの計算\n    if view_heatmap:\n        heatmap_ = calc_heatmap(img=img, t_img=t_img, m_img=m_img,\n                                theta=champ_angle, use_mask=use_mask)\n    else:\n        heatmap_ = np.array([0])\n\n    return MatchResult(pt=[xmin, ymin], angle=champ_angle,\n                       score=champ_score, polygon=polygon,\n                       rect=champ_roi, heatmap=heatmap_,\n                       pick_point=[m_x, m_y],\n                       mask_poly_list=m_p_list)\n\n\ndef draw_rotation_rectangle(src: np.ndarray,\n                            rectangle: List[int],\n                            *,\n                            polygon: Optional[np.ndarray] = None,\n                            rot_center: Optional[List[int]] = None,\n                            rot_angle: float = 0.0,\n                            color: tuple = (0, 255, 0),\n                            thickness: Optional[int] = None) -> np.ndarray:\n    dst = src.copy()\n\n    height, width = dst.shape[:2]\n    # NOTE: 入力の指定がなければ、画像中心で回転\n    if rot_center is None:\n        rot_center = [int(width / 2), int(height / 2)]\n    # NOTE: 入力の指定がなければ、自動で太さを計算\n    if thickness is None:\n        thickness = int((height + width) / 400)\n\n    # NOTE: 入力がrectの時\n    if polygon is None:\n        # NOTE: 回転角度が0.1以上であれば回転、そうでなければ0度として描画\n        if abs(rot_angle) >= 0.1:\n            polygon = rotate_rectangle(rectangle=rectangle,\n                                       rot_center=rot_center,\n                                       rot_angle=rot_angle)\n        else:\n            (ymin, xmin, ymax, xmax) = rectangle\n            polygon = np.array([[xmin, ymin], [xmin, ymax],\n                                [xmax, ymax], [xmax, ymin]])\n\n    polygon_ = np.round(polygon).astype(np.int32)  # type: ignore\n\n    dst = cv2.polylines(\n        img=dst,\n        pts=[polygon_],\n        isClosed=True,\n        color=color,\n        thickness=thickness\n    )\n\n    return dst\n\n\ndef get_rotate_polygon(template_size: tuple,  # NOTE: テンプレート画像のサイズ(w, h)\n                       detected_polygon: Union[np.ndarray, list],  # NOTE: 見つかったテンプレートの枠座標\n                       mask_polygon: Union[np.ndarray, list],  # NOTE: マスクの座標\n                       rot_angle: float) -> list:\n\n    # NOTE: オフセットで対応できないので検出された領域（回転矩形の中心を使って計算）\n    # NOTE: rotation_matchingにマスクの点データを渡すのが一番早いかも？\n    rot_center = [int(template_size[0] / 2), int(template_size[1] / 2)]\n    # NOTE: 多角形の回転(マスクのポリゴンは複数のポリゴンを持つ)\n    center_point_of_detected_polygon = ave_pt(np.array(detected_polygon))\n    rotated_poly_list = []\n    for msk_poly in mask_polygon:\n        poly = rotate_polygon(polygon=msk_poly,\n                              rot_angle=rot_angle,\n                              rot_center=rot_center)\n\n        # NOTE: 中心からのベクトルに変換した後、検出されたポリゴンの中心点を加算\n        vec_polygon = poly - np.array(rot_center)\n        n_polygon = vec_polygon + np.array(center_point_of_detected_polygon)\n        n_polygon = np.round(n_polygon).astype(np.int32)\n        rotated_poly_list.append(n_polygon.copy())\n\n    return rotated_poly_list\n\n\ndef draw_rotate_polygon(src: np.ndarray,\n                        template_size: tuple,  # NOTE: テンプレート画像のサイズ(w, h)\n                        detected_polygon: Union[np.ndarray, list],  # NOTE: 見つかったテンプレートの枠座標\n                        mask_polygon: Union[np.ndarray, list],  # NOTE: マスクの座標\n                        rot_angle: float,\n                        *,\n                        color: tuple = (0, 255, 0),\n                        thickness: Optional[int] = None) -> np.ndarray:\n\n    dst = src.copy()\n\n    height, width = dst.shape[:2]\n    # NOTE: 入力の指定がなければ、自動で太さを計算\n    if thickness is None:\n        thickness = int((height + width) / 400)\n\n    rot_center = [int(template_size[0] / 2), int(template_size[1] / 2)]\n\n    # NOTE: 多角形の回転(マスクのポリゴンは複数のポリゴンを持つ)\n    center_point_of_detected_polygon = ave_pt(np.array(detected_polygon))\n    rotated_poly_list = []\n    for msk_poly in mask_polygon:\n        poly = rotate_polygon(polygon=msk_poly,\n                              rot_angle=rot_angle,\n                              rot_center=rot_center)\n\n        # NOTE: 中心からのベクトルに変換した後、検出されたポリゴンの中心点を加算\n        vec_polygon = poly - np.array(rot_center)\n        n_polygon = vec_polygon + np.array(center_point_of_detected_polygon)\n        n_polygon = np.round(n_polygon).astype(np.int32)\n        rotated_poly_list.append(n_polygon.copy())\n\n    for pll in rotated_poly_list:\n        dst = cv2.polylines(\n            img=dst,\n            pts=[pll],\n            isClosed=True,\n            color=color,\n            thickness=thickness\n        )\n\n    return dst\n\n\nif __name__ == '__main__':\n    import os\n    import time\n    DATA_DIR = '../../data/connector/model/-H008-C-X5'\n    ORIG_IMG = os.path.join(DATA_DIR, 'sss.bmp')\n    TEMPL_IMG = os.path.join(DATA_DIR, 'templ.jpg')\n    MASK_IMG = os.path.join(DATA_DIR, 'mask.png')\n\n    t1 = time.time()\n    src = cv2.imread(ORIG_IMG)\n    templ = cv2.imread(TEMPL_IMG)\n    mask = cv2.imread(MASK_IMG)\n\n    h, w = src.shape[:2]\n",
        "operation_lib.py": "'''\nノーコードツールの論理演算ブロック用関数\n'''\n\n\n",
        "path_headless.py": "import sys\nimport platform\n\nCONFIG_PATH = None\nHEADLESS_CONFIG_PATH = None\nMAIN_UI = None\nADJUSTER_UI = None\nJUDGE_UI = None\nKEYBOARD_UI = None\nNUMPAD_UI = None\nLOGO = None\n\nif platform.system() == \"Windows\":\n    # Windowsの場合\n    CONFIG_PATH = \"./config/config.json\"\n    HEADLESS_CONFIG_PATH = \"./config/headless_config.json\"\n    if getattr(sys, 'frozen', False):\n        # exeの場合\n        MAIN_UI = \"./_internal/headless/gui/mainwindow.ui\"\n        ADJUSTER_UI = \"./_internal/headless/gui/adjuster_dialog.ui\"\n        JUDGE_UI = \"./_internal/headless/gui/judge_widget.ui\"\n        KEYBOARD_UI = \"./_internal/headless/gui/u_keyboard.ui\"\n        NUMPAD_UI = \"./_internal/headless/gui/u_numpad.ui\"\n        LOGO = \"./_internal/headless/gui/logo_mini5.svg\"\n    else:\n        # .pyを叩く場合\n        MAIN_UI = \"./headless/gui/mainwindow.ui\"\n        ADJUSTER_UI = \"./headless/gui/adjuster_dialog.ui\"\n        JUDGE_UI = \"./headless/gui/judge_widget.ui\"\n        KEYBOARD_UI = \"./headless/gui/u_keyboard.ui\"\n        NUMPAD_UI = \"./headless/gui/u_numpad.ui\"\n        LOGO = \"./headless/gui/logo_mini5.svg\"\nelse:\n    # Linuxの場合\n    MAIN_UI = \"./headless/gui/mainwindow.ui\"\n    CONFIG_PATH = \"/media/usb/Nocode/config.json\"\n    HEADLESS_CONFIG_PATH = \"/media/usb/NoCode/headless_config.json\"\n    ADJUSTER_UI = \"./headless/gui/adjuster_dialog.ui\"\n    JUDGE_UI = \"./headless/gui/judge_widget.ui\"\n    KEYBOARD_UI = \"./headless/gui/u_keyboard.ui\"\n    NUMPAD_UI = \"./headless/gui/u_numpad.ui\"\n    LOGO = \"./headless/gui/logo_mini5.svg\"\n\n",
        "path_main.py": "import platform\nimport sys\nimport os\n\nFUNCTION_DIRECTORIES = None\nUSER_FUNCTION_DIRECTORY = None\nUI_PATH = None\n\nif platform.system() == \"Windows\":\n    # Windowsの場合\n    pass\n    if getattr(sys, 'frozen', False):\n        # exeの場合\n        FUNCTION_DIRECTORIES = ['./_internal/function_blocks', './user_functions']\n        USER_FUNCTION_DIRECTORY = None\n        UI_PATH = './_internal/pyside/main_window.ui'\n        sys.path.append(os.getcwd())\n    else:\n        # .pyを叩く場合\n        FUNCTION_DIRECTORIES = ['./function_blocks', './user_functions']\n        USER_FUNCTION_DIRECTORY = None\n        UI_PATH = './pyside/main_window.ui'\nelse:\n    # Linuxの場合\n    FUNCTION_DIRECTORIES = ['./function_blocks', './_function_blocks']\n    USER_FUNCTION_DIRECTORY = '/media/usb/function_blocks'\n    UI_PATH = './pyside/main_window.ui'\n    pass\n",
        "path_ryven.py": "import sys\nimport platform\n\nCONFIG_PATH = None\nNODES_COMMON = None\nNODES_UNCOMMON = None\n\nif platform.system() == \"Windows\":\n    # Windowsの場合\n    CONFIG_PATH = \"./config/config.json\"\n    if getattr(sys, 'frozen', False):\n        # exeの場合\n        NODES_COMMON = \"./_internal/nodes_common\"\n        NODES_UNCOMMON = \"./_internal/nodes_uncommon\"\n    else:\n        # .pyを叩く場合\n        NODES_COMMON = \"./nodes_common\"\n        NODES_UNCOMMON = \"./nodes_uncommon\"\nelse:\n    # Linuxの場合\n    CONFIG_PATH = \"/media/usb/Nocode/config.json\"\n    NODES_COMMON = \"./nodes_common\"\n    NODES_UNCOMMON = \"./nodes_uncommon\"\n\n",
        "pole_h.py": "# ===============================================================================\n# Name      : pole_h.py\n# Version   : 1.0.0\n# Brief     : 極座標変換\n# Time-stamp: 2023-12-05 12:37\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport cv2\nimport numpy as np\nfrom typing import Tuple, Union\n\n\ndef crop_roi(src: np.ndarray, box: list) -> np.ndarray:\n    return src[box[0]:box[2], box[1]:box[3]]\n\n\ndef pixel2angle(pixel_pos: int, circuit_length: int, *, offset_length: int = 0) -> float:\n    itv = 360.0 / circuit_length\n    angle = (pixel_pos - offset_length) * itv\n    return angle\n\n\ndef xy2pole(x_pts: list, y_pts: list, circuit_length: int, max_r: int, *, offset_length: int = 0) -> Tuple[list, list]:\n    \"\"\"極座標変換後のx,yから直交座標のradius,theta\n\n    Args:\n        x_pts (list): _description_\n        y_pts (list): _description_\n        circuit_length (int): _description_\n        max_r (int): _description_\n        offset_length (int, optional): _description_. Defaults to 0.\n\n    Returns:\n        Tuple[list, list]: _description_\n        r_list, theta_list\n    \"\"\"\n    theta_list = []\n    for x in x_pts:\n        theta_list.append(pixel2angle(x, circuit_length, offset_length=offset_length))\n\n    r_np = max_r - np.array(y_pts)\n    r_list = r_np.tolist()\n\n    return r_list, theta_list\n\n\ndef pole2xy(radius: Union[list, np.ndarray], theta: Union[list, np.ndarray],\n            center_pt: Union[list, tuple]) -> Tuple[np.ndarray, np.ndarray]:\n    radius = np.array(radius)\n    theta = np.deg2rad(theta)\n    x = center_pt[0] + radius * np.cos(theta)\n    y = center_pt[1] + radius * np.sin(theta)\n    return x, y\n\n\ndef get_nearest_value(candidate_: list, val: int) -> int:\n    \"\"\"候補の中から近い値を返す\"\"\"\n    idx = np.abs(np.asarray(candidate_) - val).argmin()\n    return candidate_[idx]\n\n\ndef calc_length(radius: int, use_raw_value: bool = True) -> int:\n    \"\"\"外周を何ピクセルとして計算するか選択\"\"\"\n    # NOTE: 角度高精度で計算しやすくするため候補を設定\n    candidate_ = [180, 360, 540, 720, 900]\n    circuit_length = int(2 * radius * np.pi)\n    if use_raw_value:\n        return circuit_length\n    return get_nearest_value(candidate_, circuit_length)\n\n\ndef warp_polar(src: np.ndarray, center_pt: Union[tuple, list], min_r: int, max_r: int) -> np.ndarray:\n    \"\"\"\n    極座標変換\n\n    Args:\n        src (np.ndarray): 画像\n        center_pt (Union[tuple, list]): 円の中心\n        min_r (int): 内円の半径\n        max_r (int): 外円の半径\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    img = src.copy()\n    radius = max_r\n    circuit_length = calc_length(max_r)\n\n    if isinstance(center_pt, list):\n        center_pt = tuple(center_pt)\n\n    # NOTE: キュービック補間 + 外れ値塗りつぶし + 極座標へリニアマッピング\n    flags = cv2.INTER_CUBIC + cv2.WARP_FILL_OUTLIERS + cv2.WARP_POLAR_LINEAR\n\n    # NOTE: 円周をwidthとして極座標変換\n    p_img = cv2.warpPolar(src=img,\n                          dsize=(radius, circuit_length),\n                          center=center_pt,\n                          maxRadius=radius,\n                          flags=flags)\n\n    p_img = cv2.rotate(p_img, cv2.ROTATE_90_COUNTERCLOCKWISE)\n\n    diff_r = max_r - min_r\n    p_img = crop_roi(p_img, [0, 0, diff_r, circuit_length])\n    return p_img\n\n\ndef inv_warp_polar(src: np.ndarray, center_pt: Union[tuple, list],\n                   im_shape: Union[tuple, list], min_r: int, max_r: int,\n                   *, offset_length: int = -1) -> np.ndarray:\n    \"\"\"\n    逆極座標変換\n\n    Args:\n        src (np.ndarray): _description_\n        center_pt (Union[tuple, list]): (x, y)\n        im_shape (Union[tuple, list]): (width, height)\n        radius (int): r\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    img = src.copy()\n\n    if isinstance(center_pt, list):\n        center_pt = tuple(center_pt)\n\n    if isinstance(im_shape, list):\n        im_shape = tuple(im_shape)\n\n    # NOTE: 左右のトリミング処理\n    if offset_length > 0:\n        h_, w_ = img.shape[:2]\n        img = crop_roi(img, [0, offset_length, h_, w_ - offset_length])\n\n    # NOTE: 削った分追加\n    _, w = img.shape[:2]\n    blank_img = np.zeros((min_r, w, 3), np.uint8)\n\n    p_img = cv2.vconcat([img, blank_img])\n\n    # NOTE: 逆変換\n    flags = cv2.INTER_CUBIC + cv2.WARP_FILL_OUTLIERS + cv2.WARP_POLAR_LINEAR + cv2.WARP_INVERSE_MAP\n    p_img = cv2.rotate(p_img, cv2.ROTATE_90_CLOCKWISE)\n    p_img = cv2.warpPolar(src=p_img,\n                          dsize=im_shape,\n                          center=center_pt,\n                          maxRadius=max_r,\n                          flags=flags)\n    return p_img\n\n\ndef expand_polar_image(src: np.ndarray, expansion_rate: float) -> Tuple[np.ndarray, int]:\n    \"\"\"\n    極座標画像の拡張\n\n    Args:\n        src (np.ndarray): 極座標画像\n        expansion_rate (float): 拡張率\n\n    Returns:\n        Tuple[np.ndarray, int]: _description_\n        拡張画像、オフセットの長さ\n    \"\"\"\n    h, w = src.shape[:2]\n    offset_length = int(w * expansion_rate)\n\n    # NOTE: 前後のイメージを作成\n    header_img = crop_roi(src, [0, w - offset_length, h, w])\n    footer_img = crop_roi(src, [0, 0, h, offset_length])\n\n    img_join = cv2.hconcat([header_img, src, footer_img])\n\n    return img_join, offset_length\n\n\nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n\n    def imshow(src: np.ndarray):\n        if src.ndim == 3:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n            plt.show()\n        else:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_GRAY2RGB))  # type: ignore\n            plt.show()\n\n    impath = r'C:\\Users\\J100048001\\Desktop\\robot_vision\\data\\tray\\model\\Tray_1\\templ.jpg'\n    img = cv2.imread(impath)\n    imshow(img)\n\n    h, w = img.shape[:2]\n\n    center_pt = (85, 78)\n    r_min = 20\n    r_max = 65\n\n    im = warp_polar(img, center_pt, r_min, r_max)\n    imshow(im)\n    im, ofs = expand_polar_image(im, 0.2)\n    imshow(im)\n    im = inv_warp_polar(im, center_pt, (w, h), r_min, r_max, offset_length=ofs)\n    imshow(im)\n",
        "README.md": "# モジュール概要\n\n画像処理に関する以下の機能を提供しています。\n\n## 計算モジュール\n\n- affine_h.py\n  座標の回転計算\n- pole_h.py\n  極座標の計算\n- fitting_lib.py\n  交点や傾きの計算\n- fileter_h.py\n  フィルタに関する処理\n\n## 画像処理モジュール\n\n- match_lib.py\n  回転テンプレートマッチングのライブラリ\n- blob_lib.py\n  ブロブ検出のライブラリ\n- circle_lib.py\n  円検出のライブラリ\n- color_lib.py\n  色抽出のライブラリ\n- edge_lib.py\n  線検出のライブラリ\n",
        "t_matching_lib.py": "# ===============================================================================\n# Name      : template_matching_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-11-10 09:47\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nfrom typing import Tuple, Optional, List, Union\nfrom pydantic import BaseModel, Field\nfrom concurrent.futures import ThreadPoolExecutor\n\ntry:\n    from .affine_h import (\n        rotate_image,\n        rotate_rectangle,\n        rotate_polygon,\n        rotate_point\n    )\nexcept Exception:\n    from affine_h import (  # type: ignore\n        rotate_image,\n        rotate_rectangle,\n        rotate_polygon,\n        rotate_point\n    )\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass MatchResult(CustomBaseModel):\n    pt: list = [-1.0, -1.0]\n    angle: float = 0.0\n    score: float = -1.0\n    polygon: np.ndarray = Field(default_factory=lambda: np.array([[0, 0], [0, 0], [0, 0], [0, 0]]))\n    rect: list = [0, 0, 0, 0]\n    heatmap: np.ndarray = Field(default_factory=lambda: np.zeros((10, 10), dtype=np.uint8))\n    center_pt: list = [0, 0]  # NOTE: マスクの中心、ワークの中心で座標を考慮する\n\n\n# ===============================================================================\n# NOTE: 便利メソッド\n# ===============================================================================\n\ndef crop_roi(src: np.ndarray, box: list):\n    return src[box[0]:box[2], box[1]:box[3]]\n\n\ndef ave_pt(polygon: np.ndarray) -> list:\n    \"\"\"重心算出\"\"\"\n    [x_mean, y_mean] = np.mean(polygon, axis=0)  # type: ignore\n    return [round(x_mean, 2), round(y_mean, 2)]\n\n\ndef imshow(src):\n    plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n    plt.show()\n\n\ndef show_heatmap(match_result: np.ndarray) -> None:\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    plt.show()\n\n\ndef create_graph_image(fig: plt.Figure) -> np.ndarray:\n    fig.canvas.draw()  # type: ignore\n    graph_image = np.array(fig.canvas.renderer.buffer_rgba())  # type: ignore\n    graph_image = cv2.cvtColor(graph_image, cv2.COLOR_RGBA2BGR)\n    return graph_image\n\n\ndef get_heatmap(match_result: np.ndarray) -> np.ndarray:\n    \"\"\"ヒートマップ取得\n\n    Args:\n        match_result (np.ndarray): _description_\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    img = create_graph_image(fig)\n    # NOTE: 解放しないとメモリリーク\n    plt.close()\n    return img\n\n\ndef get_mask_center(mask: np.ndarray):\n    mu = cv2.moments(array=cv2.cvtColor(mask, cv2.COLOR_BGR2GRAY), binaryImage=False)\n    x, y = int(mu[\"m10\"] / mu[\"m00\"]), int(mu[\"m01\"] / mu[\"m00\"])\n    return x, y\n\n\ndef _conv_grayscale(src: np.ndarray, color: str = 'gray') -> np.ndarray:\n    \"\"\"\n    グレイスケール化\n    \"\"\"\n    if color == 'gray':\n        return cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)\n    elif color == 'red':\n        _, _, red = cv2.split(src)\n        return red\n    elif color == 'green':\n        _, green, _ = cv2.split(src)\n        return green\n    elif color == 'blue':\n        blue, _, _ = cv2.split(src)\n        return blue\n    elif color == 'hue':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        hue, _, _ = cv2.split(hsv)\n        return hue\n    elif color == 'saturation':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        _, saturation, _ = cv2.split(hsv)\n        return saturation\n    elif color == 'value':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        _, _, value = cv2.split(hsv)\n        return value\n    else:\n        return src\n\n\ndef _preprocess(src: np.ndarray, templ: np.ndarray,\n                mask: Optional[np.ndarray] = None,\n                scale: float = 1.0) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n    \"\"\"前処理(次元,スケール合わせ)\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        mask (Optional[np.ndarray], optional): _description_. Defaults to None.\n        scale (float, optional): _description_. Defaults to 1.0.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]: _description_\n    \"\"\"\n    # NOTE: 前処理\n    h, w = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n\n    # NOTE: コピー処理\n    img = src.copy()\n    t_img = templ.copy()\n\n    # NOTE: リスケ―ル\n    if scale < 0.999:\n        img = cv2.resize(img, (int(scale * w), int(scale * h)))\n        t_img = cv2.resize(t_img, (int(scale * t_w), int(scale * t_h)))\n\n    # NOTE: 次元数チェック\n    # if img.ndim == 3:\n    #     img = _conv_grayscale(img)\n    # if t_img.ndim == 3:\n    #     t_img = _conv_grayscale(t_img)\n    if img.ndim != t_img.ndim:\n        if img.ndim == 3:\n            img = _conv_grayscale(img)\n        if t_img.ndim == 3:\n            t_img = _conv_grayscale(t_img)\n\n    # NOTE: マスクのチェック\n    if mask is not None:\n        m_img = mask.copy()\n        m_img = cv2.resize(mask, (int(scale * t_w), int(scale * t_h)))\n        if m_img.ndim == 3:\n            m_img = cv2.cvtColor(m_img, cv2.COLOR_BGR2GRAY)\n        return img, t_img, m_img\n\n    else:\n        # NOTE: mask = Noneで返す\n        return img, t_img, None\n\n\ndef rescale_roi(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        return [int(val * scale) for val in roi]\n    else:\n        return roi\n\n\ndef rescale_search_area(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        w = roi[3] - roi[1]\n        h = roi[2] - roi[0]\n        r_w = (scale * w)\n        r_h = (scale * h)\n        dw = w - r_w\n        dh = h - r_h\n        xmin = int(roi[1] + dw / 2.0)\n        ymin = int(roi[0] + dh / 2.0)\n        return [ymin, xmin, int(ymin + r_h), int(xmin + r_w)]\n\n    else:\n        return roi\n\n\ndef get_best_match_pos(match: np.ndarray, t_size: tuple, shift: tuple,\n                       scale: float = 1.0, score_th: float = 0.1) -> Tuple[list, float]:\n    \"\"\"一致度が最大の座標を取得\n\n    Args:\n        match (np.ndarray): _description_\n        t_size (tuple): _description_\n        shift (tuple): _description_\n        scale (float, optional): _description_. Defaults to 1.0.\n        score_th (float, optional): _description_. Defaults to 0.1.\n\n    Returns:\n        Tuple[list, float]: _description_\n    \"\"\"\n\n    # NOTE: マスク有りだとたまにスコア1以上が出現するため、1以下を取得\n    # NOTE: スコア1以上は変な場所を検出している気がする\n    loc = np.where((match > score_th) & (match < 1.0))\n    scores = match[loc]\n    # NOTE: 何も見つからなかったとき\n    if scores.size == 0:\n        return [0, 0, 0, 0], -1.0\n\n    idx = np.argmax(scores)\n    max_score = scores[idx]\n\n    max_pt = [loc[1][idx], loc[0][idx]]\n    x_min = max_pt[0] + shift[0]\n    y_min = max_pt[1] + shift[1]\n\n    if scale < 0.99:\n        x_min = round(x_min / scale)\n        y_min = round(y_min / scale)\n\n    roi = [y_min, x_min, y_min + t_size[0], x_min + t_size[1]]\n\n    return roi, max_score\n\n\ndef match4para(theta: float, img: np.ndarray, t_img: np.ndarray, m_img: Optional[np.ndarray],\n               t_size: tuple, search_area: Optional[list], use_mask: bool, scale: float) -> Tuple[float, list, float]:\n    \"\"\"並列処理用テンプレートマッチング関数\n\n    Args:\n        theta (float): _description_\n        img (np.ndarray): _description_\n        t_img (np.ndarray): _description_\n        m_img (Optional[np.ndarray]): _description_\n        t_size (tuple): _description_\n        search_area (Optional[list]): _description_\n        use_mask (bool): _description_\n        scale (float): _description_\n\n    Returns:\n        Tuple[float, list, float]: _description_\n    \"\"\"\n    # NOTE: 回転させてからcropすることで回転軸を同じにする\n    # => 処理は遅くなるが座標変換の手間を省く\n    input = rotate_image(img, theta)\n    if search_area is not None:\n        input = crop_roi(input, search_area)\n\n    # NOTE: マッチング\n    if use_mask:\n        # match = cv2.matchTemplate(input, t_img, cv2.TM_CCORR_NORMED, mask=m_img)\n        # NOTE: こっちの方がよい\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED, mask=m_img)\n    else:\n        # match = cv2.matchTemplate(input, t_img, cv2.TM_CCORR_NORMED)\n        # NOTE: こっちの方がよい\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED)\n\n    # NOTE: シフト量設定\n    if search_area is None:\n        shift = (0, 0)\n    else:\n        shift = (search_area[1], search_area[0])\n\n    roi, max_score = get_best_match_pos(match=match, t_size=t_size, shift=shift, scale=scale)\n\n    return round(max_score, 3), roi, round(theta, 3)\n\n\ndef calc_heatmap(img: np.ndarray, t_img: np.ndarray, m_img: Optional[np.ndarray],\n                 theta: float, use_mask: bool) -> np.ndarray:\n    \"\"\"ヒートマップ取得用\n    \"\"\"\n    input = rotate_image(img, theta)\n\n    # NOTE: マッチング\n    if use_mask:\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED, mask=m_img)\n    else:\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED)\n\n    heatmap = get_heatmap(match)\n\n    return heatmap\n\n\ndef rotation_matching(src: np.ndarray,\n                      templ: np.ndarray,\n                      *,\n                      search_area: Optional[list] = None,\n                      mask: Optional[np.ndarray] = None,\n                      compression_ratio: float = 100,\n                      min_angle: float = -3.0,\n                      max_angle: float = 3.0,\n                      step_angle: float = 0.1,\n                      #   subpixel: bool = False,\n                      view_heatmap: bool = False\n                      ) -> MatchResult:\n    \"\"\"回転マッチング\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        search_area (list, optional): _description_. Defaults to None.\n        mask (np.ndarray, optional): _description_. Defaults to None.\n        scale (float, optional): _description_. Defaults to 100.\n        min_angle (float, optional): _description_. Defaults to -3.0.\n        max_angle (float, optional): _description_. Defaults to 3.0.\n        step_angle (float, optional): _description_. Defaults to 0.1.\n        view_heatmap (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        MatchResult: _description_\n    \"\"\"\n    champ_score: float = 0\n    champ_angle: float = 0\n    champ_roi: list = [0, 0, 0, 0]\n    futures: list = []\n\n    height, width = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n    t_size = (t_h, t_w)\n\n    # NOTE: マスク有無\n    if mask is None:\n        use_mask = False\n        m_x, m_y = 0.0, 0.0\n    else:\n        use_mask = True\n        # NOTE: マスクの中心座標を計算（アライメント時に必要）\n        m_x, m_y = get_mask_center(mask)\n\n    # NOTE: リスケ―ル\n    if compression_ratio > 1.0:\n        compression_ratio = compression_ratio / 100.0\n\n    # NOTE: リサイズ、次元削減の前処理\n    img, t_img, m_img = _preprocess(src, templ, mask,\n                                    scale=compression_ratio)\n\n    # NOTE: リサイズに合わせて検査領域もリサイズ\n    if search_area is not None:\n        search_area = rescale_roi(search_area, compression_ratio)\n\n    # NOTE: 並列処理用に検出を行う角度のリストを作成\n    angles = [round((val * step_angle), 2) for val in range(int(min_angle / step_angle), int(max_angle / step_angle) + 1, 1)]\n\n    # NOTE: 並列処理でタクト短縮\n    with ThreadPoolExecutor(max_workers=4, thread_name_prefix=\"thread\") as pool:\n        for angle in angles:\n            future = pool.submit(match4para, angle, img, t_img, m_img, t_size, search_area, use_mask, compression_ratio)\n            futures.append(future)\n\n    # NOTE: 並列処理で取得したデータから最大スコアの情報を抜き出す\n    max_score = -10.0\n    for future in futures:\n        score, roi, theta = future.result()\n        if score > max_score:\n            max_score = score\n            champ_score = score\n            champ_angle = theta\n            champ_roi = roi\n\n    # NOTE: 何も見つからなかったとき\n    if max_score < 0.0:\n        logger.debug('Not found Matching Area')\n        return MatchResult()\n\n    # NOTE: ptを抜き出し\n    ymin, xmin, _, _ = champ_roi\n\n    # NOTE: 回転した検出枠を計算\n    polygon = rotate_rectangle(rectangle=champ_roi,\n                               rot_center=[round(width / 2), round(height / 2)],\n                               rot_angle=champ_angle)\n\n    if mask is not None:\n        m_x, m_y = rotate_point(pt=[xmin + m_x, ymin + m_y],\n                                rot_center=[round(width / 2), round(height / 2)],\n                                rot_angle=champ_angle)\n\n    # NOTE: ヒートマップの計算\n    if view_heatmap:\n        heatmap_ = calc_heatmap(img=img, t_img=t_img, m_img=m_img,\n                                theta=champ_angle, use_mask=use_mask)\n    else:\n        heatmap_ = np.array([0])\n\n    return MatchResult(pt=[xmin, ymin], angle=champ_angle,\n                       score=champ_score, polygon=polygon,\n                       rect=champ_roi, heatmap=heatmap_,\n                       center_pt=[m_x, m_y])\n\n\ndef no_rot_matching(src: np.ndarray,\n                    templ: np.ndarray,\n                    *,\n                    search_area: Optional[list] = None,\n                    mask: Optional[np.ndarray] = None,\n                    compression_ratio: float = 100,\n                    view_heatmap: bool = False\n                    ) -> MatchResult:\n    \"\"\"無回転マッチング\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        search_area (list, optional): _description_. Defaults to None.\n        mask (np.ndarray, optional): _description_. Defaults to None.\n        compression_ratio (float, optional): _description_. Defaults to 100.\n        view_heatmap (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        MatchResult: _description_\n    \"\"\"\n\n    # height, width = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n    t_size = (t_h, t_w)\n\n    if mask is None:\n        use_mask = False\n    else:\n        use_mask = True\n\n    # NOTE: リスケ―ル\n    if compression_ratio > 1.0:\n        compression_ratio = compression_ratio / 100.0\n\n    img, t_img, m_img = _preprocess(src, templ, mask, compression_ratio)\n\n    if search_area is not None:\n        search_area = rescale_roi(search_area, compression_ratio)\n\n    score, box, _ = match4para(0, img, t_img, m_img, t_size, search_area, use_mask, compression_ratio)\n\n    # NOTE: 何も見つからなかったとき\n    if score < 0.0:\n        logger.debug('Not found Mathcing Area')\n        return MatchResult()\n\n    ymin, xmin, _, _ = box\n\n    # NOTE: ヒートマップの計算\n    if view_heatmap:\n        heatmap = calc_heatmap(img=img, t_img=t_img, m_img=m_img,\n                               theta=0, use_mask=use_mask)\n    else:\n        heatmap = np.array([0])\n\n    return MatchResult(pt=[xmin, ymin], angle=0,\n                       score=score,\n                       polygon=np.array([[0, 0], [0, 0], [0, 0], [0, 0]]),\n                       rect=box, heatmap=heatmap)\n\n\ndef draw_rotation_rectangle(src: np.ndarray,\n                            rectangle: List[int],\n                            *,\n                            polygon: Optional[np.ndarray] = None,\n                            rot_center: Optional[List[int]] = None,\n                            rot_angle: float = 0.0,\n                            color: tuple = (0, 255, 0),\n                            thickness: Optional[int] = None) -> np.ndarray:\n    dst = src.copy()\n\n    height, width = dst.shape[:2]\n    # NOTE: 入力の指定がなければ、画像中心で回転\n    if rot_center is None:\n        rot_center = [int(width / 2), int(height / 2)]\n    # NOTE: 入力の指定がなければ、自動で太さを計算\n    if thickness is None:\n        thickness = int((height + width) / 400)\n\n    # NOTE: 入力がrectの時\n    if polygon is None:\n        # NOTE: 回転角度が0.1以上であれば回転、そうでなければ0度として描画\n        if abs(rot_angle) >= 0.1:\n            polygon = rotate_rectangle(rectangle=rectangle,\n                                       rot_center=rot_center,\n                                       rot_angle=rot_angle)\n        else:\n            (ymin, xmin, ymax, xmax) = rectangle\n            polygon = np.array([[xmin, ymin], [xmin, ymax],\n                                [xmax, ymax], [xmax, ymin]])\n\n    polygon_ = np.round(polygon).astype(np.int32)  # type: ignore\n\n    dst = cv2.polylines(\n        img=dst,\n        pts=[polygon_],\n        isClosed=True,\n        color=color,\n        thickness=thickness\n    )\n\n    return dst\n\n\ndef draw_rotate_polygon(src: np.ndarray,\n                        template_size: tuple,  # NOTE: テンプレート画像のサイズ(w, h)\n                        detected_polygon: Union[np.ndarray, list],  # NOTE: 見つかったテンプレートの枠座標\n                        mask_polygon: Union[np.ndarray, list],  # NOTE: マスクの座標\n                        rot_angle: float,\n                        *,\n                        color: tuple = (0, 255, 0),\n                        thickness: Optional[int] = None) -> np.ndarray:\n\n    dst = src.copy()\n\n    height, width = dst.shape[:2]\n    # NOTE: 入力の指定がなければ、自動で太さを計算\n    if thickness is None:\n        thickness = int((height + width) / 400)\n\n    rot_center = [int(template_size[0] / 2), int(template_size[1] / 2)]\n\n    # NOTE: 多角形の回転(マスクのポリゴンは複数のポリゴンを持つ)\n    center_point_of_detected_polygon = ave_pt(np.array(detected_polygon))\n    rotated_poly_list = []\n    for msk_poly in mask_polygon:\n        poly = rotate_polygon(polygon=msk_poly,\n                              rot_angle=rot_angle,\n                              rot_center=rot_center)\n\n        # NOTE: 中心からのベクトルに変換した後、検出されたポリゴンの中心点を加算\n        vec_polygon = poly - np.array(rot_center)\n        n_polygon = vec_polygon + np.array(center_point_of_detected_polygon)\n        n_polygon = np.round(n_polygon).astype(np.int32)\n        rotated_poly_list.append(n_polygon.copy())\n\n    for pll in rotated_poly_list:\n        dst = cv2.polylines(\n            img=dst,\n            pts=[pll],\n            isClosed=True,\n            color=color,\n            thickness=thickness\n        )\n\n    return dst\n\n\nif __name__ == '__main__':\n    import os\n    import time\n    DATA_DIR = '../../data/connector/model/-H008-C-X5'\n    ORIG_IMG = os.path.join(DATA_DIR, 'sss.bmp')\n    TEMPL_IMG = os.path.join(DATA_DIR, 'templ.jpg')\n    MASK_IMG = os.path.join(DATA_DIR, 'mask.png')\n\n    t1 = time.time()\n    src = cv2.imread(ORIG_IMG)\n    templ = cv2.imread(TEMPL_IMG)\n    mask = cv2.imread(MASK_IMG)\n\n    h, w = src.shape[:2]\n\n    data = no_rot_matching(src=src,\n                           templ=templ,\n                           mask=mask,\n                           view_heatmap=True)\n\n    imshow(data.heatmap)\n",
        "utils.py": "import traceback\nimport sys\nfrom vast_base_objects import Errors, BaseInputs\nfrom datetime import datetime\nimport numpy as np\nimport cv2\nimport json\nimport platform\nif platform.system() == \"Windows\":\n    from smb import SMBConnection\nimport io\nimport os\n\n# ファイルパス情報を抜いたトレースバックを取得\n# Errorオブジェクトをリターン\n# tracebackで直前のエラーを取得するので、try-exceptしたらすぐ呼び出すこと\ndef get_error(obj: BaseInputs):\n    t, v, tb = sys.exc_info()\n    messages = traceback.format_exception(t, v, tb)\n    message = messages[1].splitlines()[1] + \": \" + messages[2]\n\n    err = Errors(\n        module=obj.__class__.__name__.lower(),\n        input_id=obj.id,\n        date=datetime.now(),\n        message=message\n    )\n    return err\n\n\ndef get_image(file_path, grayscale: bool = False):\n    # if argument is array, return that.\n    if isinstance(file_path, np.ndarray):\n        return file_path\n    # if argument is str, read array.\n    try:\n        if \".npy\" in file_path:\n            img = np.load(file_path, allow_pickle=True)\n            if grayscale and len(img.shape) == 3:\n                img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        else:\n            if grayscale:\n                img = cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)\n            else:\n                img = cv2.imread(file_path, cv2.IMREAD_COLOR)\n\n        return img\n\n    except Exception as e:\n        return e\n\n\ndef write_array(name, array, input_source):\n    # if argument is array, return that.\n    if isinstance(input_source, np.ndarray):\n        return input_source\n    # TODO: avoid hard cording\n    server_path = \"/opt/.VAST/file_server/\"\n    date = datetime.now()\n    path = server_path + name + date.strftime(\"%Y-%m-%d_%H-%M-%S.%f\") + \".npy\"\n    np.save(path, array)\n    return path, date\n\ndef read_json(path):\n    try:\n        with open(path, 'r') as f:\n            data = json.load(f)\n        return data\n    except Exception as e:\n        return e\n\ndef get_image(username, password, my_name, remote_name, domain, ip_address, img_path, service_name):\n    try:\n        conn = SMBConnection.SMBConnection(\n            username=username,\n            password=password,\n            my_name=my_name,\n            remote_name=remote_name,\n            domain=domain\n        )\n        # Sambaに接続\n        conn.connect(ip_address, 139)\n\n        # 画像ファイルをバイト列としてメモリ上に取得（fileオブジェクトを渡すとローカルに保存してしまう）\n        with io.BytesIO() as file_obj:\n            conn.retrieveFile(service_name, img_path, file_obj)\n            # ndarrayにデコード\n            #image_array = np.frombuffer(file_obj.getvalue(), dtype=np.uint8)\n            file_obj.seek(0)\n            image_array = np.load(file_obj)\n\n        # コネクション終了\n        conn.close()\n        #print(image_array)\n\n        # OpenCVで扱える形にデコード\n        #image = cv2.imdecode(image_array, cv2.IMREAD_COLOR)\n\n        return image_array\n\n    except Exception as e:\n        try:\n            conn.close()\n        except:\n            pass\n        print(e)\n\ndef get_img_from_fs(path, ip_address):\n    file_name = os.path.basename(path)\n    res = get_image(\n        username=\"vast\",\n        password=\"vast\",\n        my_name=\"pysmb\",\n        remote_name=\"vast\",\n        domain=\"\",\n        ip_address=ip_address,\n        img_path=file_name,\n        service_name=\"share\"\n    )\n    return res\n\n\ndef init_main():\n    pass\n\ndef init_dev():\n    pass\ndef init_run():\n    pass",
        "_t_matching_lib.py": "# ===============================================================================\n# Name      : template_matching_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-11-10 09:47\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\nfrom typing import Tuple, Optional, List, Union\nfrom pydantic import BaseModel, Field\nfrom concurrent.futures import ThreadPoolExecutor\n\ntry:\n    from .affine_h import (\n        rotate_image,\n        rotate_rectangle,\n        rotate_polygon,\n        rotate_point\n    )\nexcept Exception:\n    from affine_h import (  # type: ignore\n        rotate_image,\n        rotate_rectangle,\n        rotate_polygon,\n        rotate_point\n    )\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass CustomBaseModel(BaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass MatchResult(CustomBaseModel):\n    pt: list = [-1.0, -1.0]\n    angle: float = 0.0\n    score: float = -1.0\n    polygon: np.ndarray = Field(default_factory=lambda: np.array([[0, 0], [0, 0], [0, 0], [0, 0]]))\n    rect: list = [0, 0, 0, 0]\n    heatmap: np.ndarray = Field(default_factory=lambda: np.zeros((10, 10), dtype=np.uint8))\n    center_pt: list = [0, 0]  # NOTE: マスクの中心、ワークの中心で座標を考慮する\n\n\n# ===============================================================================\n# NOTE: 便利メソッド\n# ===============================================================================\n\ndef crop_roi(src: np.ndarray, box: list):\n    return src[box[0]:box[2], box[1]:box[3]]\n\n\ndef ave_pt(polygon: np.ndarray) -> list:\n    \"\"\"重心算出\"\"\"\n    [x_mean, y_mean] = np.mean(polygon, axis=0)  # type: ignore\n    return [round(x_mean, 2), round(y_mean, 2)]\n\n\ndef imshow(src):\n    plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n    plt.show()\n\n\ndef show_heatmap(match_result: np.ndarray) -> None:\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    plt.show()\n\n\ndef create_graph_image(fig: plt.Figure) -> np.ndarray:\n    fig.canvas.draw()  # type: ignore\n    graph_image = np.array(fig.canvas.renderer.buffer_rgba())  # type: ignore\n    graph_image = cv2.cvtColor(graph_image, cv2.COLOR_RGBA2BGR)\n    return graph_image\n\n\ndef get_heatmap(match_result: np.ndarray) -> np.ndarray:\n    \"\"\"ヒートマップ取得\n\n    Args:\n        match_result (np.ndarray): _description_\n\n    Returns:\n        np.ndarray: _description_\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(10, 5))\n    im = ax.imshow(match_result, cmap=\"jet\")\n    fig.colorbar(im)  # type: ignore\n    img = create_graph_image(fig)\n    # NOTE: 解放しないとメモリリーク\n    plt.close()\n    return img\n\n\ndef get_mask_center(mask: np.ndarray):\n    mu = cv2.moments(array=cv2.cvtColor(mask, cv2.COLOR_BGR2GRAY), binaryImage=False)\n    x, y = int(mu[\"m10\"] / mu[\"m00\"]), int(mu[\"m01\"] / mu[\"m00\"])\n    return x, y\n\n\ndef _conv_grayscale(src: np.ndarray, color: str = 'gray') -> np.ndarray:\n    \"\"\"\n    グレイスケール化\n    \"\"\"\n    if color == 'gray':\n        return cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)\n    elif color == 'red':\n        _, _, red = cv2.split(src)\n        return red\n    elif color == 'green':\n        _, green, _ = cv2.split(src)\n        return green\n    elif color == 'blue':\n        blue, _, _ = cv2.split(src)\n        return blue\n    elif color == 'hue':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        hue, _, _ = cv2.split(hsv)\n        return hue\n    elif color == 'saturation':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        _, saturation, _ = cv2.split(hsv)\n        return saturation\n    elif color == 'value':\n        hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)\n        _, _, value = cv2.split(hsv)\n        return value\n    else:\n        return src\n\n\ndef _preprocess(src: np.ndarray, templ: np.ndarray,\n                src_mask: Optional[np.ndarray], templ_mask: Optional[np.ndarray] = None,\n                scale: float = 1.0) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray], Optional[np.ndarray]]:\n    \"\"\"前処理(次元,スケール合わせ)\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        mask (Optional[np.ndarray], optional): _description_. Defaults to None.\n        scale (float, optional): _description_. Defaults to 1.0.\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]: _description_\n    \"\"\"\n    # NOTE: 前処理\n    h, w = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n\n    # NOTE: コピー処理\n    img = src.copy()\n    t_img = templ.copy()\n\n    # NOTE: リスケ―ル\n    if scale < 0.999:\n        img = cv2.resize(img, (int(scale * w), int(scale * h)))\n        t_img = cv2.resize(t_img, (int(scale * t_w), int(scale * t_h)))\n\n    # NOTE: 次元数チェック\n    if img.ndim != t_img.ndim:\n        if img.ndim == 3:\n            img = _conv_grayscale(img)\n        if t_img.ndim == 3:\n            t_img = _conv_grayscale(t_img)\n\n    m_img = None # srcマスク\n    tm_img = None # tmplマスク\n    # NOTE: マスクのチェック\n    if src_mask is not None:\n        m_img = src_mask.copy()\n        m_img = cv2.resize(m_img, (int(scale * w), int(scale * h)))\n        if m_img.ndim == 3:\n            m_img = cv2.cvtColor(m_img, cv2.COLOR_BGR2GRAY)\n\n    if templ_mask is not None:\n        tm_img = templ_mask.copy()\n        tm_img = cv2.resize(tm_img, (int(scale * t_w), int(scale * t_h)))\n        if tm_img.ndim == 3:\n            tm_img = cv2.cvtColor(tm_img, cv2.COLOR_BGR2GRAY)\n\n    return img, t_img, m_img, tm_img\n\n\n\n\ndef rescale_roi(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        return [int(val * scale) for val in roi]\n    else:\n        return roi\n\n\ndef rescale_search_area(roi: list, scale: float) -> list:\n    \"\"\"ROIスケール調整\"\"\"\n    if scale < 0.99 or scale > 1.01:\n        w = roi[3] - roi[1]\n        h = roi[2] - roi[0]\n        r_w = (scale * w)\n        r_h = (scale * h)\n        dw = w - r_w\n        dh = h - r_h\n        xmin = int(roi[1] + dw / 2.0)\n        ymin = int(roi[0] + dh / 2.0)\n        return [ymin, xmin, int(ymin + r_h), int(xmin + r_w)]\n\n    else:\n        return roi\n\n\ndef get_best_match_pos(match: np.ndarray, t_size: tuple, shift: tuple,\n                       scale: float = 1.0, score_th: float = 0.1, mask: np.ndarray = None) -> Tuple[list, float]:\n    \"\"\"一致度が最大の座標を取得\n\n    Args:\n        match (np.ndarray): _description_\n        t_size (tuple): _description_\n        shift (tuple): _description_\n        scale (float, optional): _description_. Defaults to 1.0.\n        score_th (float, optional): _description_. Defaults to 0.1.\n        mask (np.ndarray, optional): _description_.\n    Returns:\n        Tuple[list, float]: _description_\n    \"\"\"\n\n    max_score = None\n    if mask is not None:\n        try:\n            # マスク上のマッチングスコアを0に下げる\n            mask = cv2.resize(mask, match.shape[:2][::-1])\n            mask_zero = mask == 0\n            match[mask_zero] = 0\n            # maping = get_heatmap(match)\n            # print(\"shape:\", match.shape[:2][::-1])\n            # print(\"zero:\", mask_zero)\n            # cv2.imshow(\"test\", maping)\n            # cv2.imshow(\"mask\", mask)\n            # cv2.waitKey(0)\n            # cv2.destroyAllWindows()\n        except:\n            pass\n        # 矩形中心がマスク上にある場合は無視\n        # mh, mw = mask.shape[:2]\n        # while not np.all(scores == 0):\n        #     idx = np.argmax(scores)\n        #     #cv2.destroyAllWindows()\n        #     if mh < loc[0][idx] + int(t_size[0]/2) or mw < loc[1][idx] + int(t_size[1]):\n        #         scores[idx] = 0\n        #         continue\n        #\n        #     test = cv2.circle(cv2.cvtColor(mask.copy(), cv2.COLOR_GRAY2BGR), (loc[1][idx] + int(t_size[1]/2), loc[0][idx] + int(t_size[0])), 5,\n        #                       (255, 0, 0), thickness=-1)\n        #     # cv2.imshow(\"test\", test)\n        #     # cv2.waitKey(1)\n        #     try:\n        #         if mask[loc[0][idx] + int(t_size[0]/2)][loc[1][idx] + int(t_size[1])] == 255:\n        #             max_pt = [loc[1][idx], loc[0][idx]]\n        #             max_score = scores[idx]\n        #             break\n        #         else:\n        #             scores[idx] = 0\n        #             continue\n        #     except Exception as e:\n        #         print(e)\n    # else:\n\n    # NOTE: マスク有りだとたまにスコア1以上が出現するため、1以下を取得\n    # NOTE: スコア1以上は変な場所を検出している気がする\n    loc = np.where((match > score_th) & (match < 1.0))\n    scores = match[loc]\n    # NOTE: 何も見つからなかったとき\n    if scores.size == 0:\n        return [0, 0, 0, 0], -1.0\n\n    idx = np.argmax(scores)\n    max_score = scores[idx]\n    max_pt = [loc[1][idx], loc[0][idx]]\n\n    if max_score is None:\n        return [0, 0, 0, 0], -1.0\n\n    x_min = max_pt[0] + shift[0]\n    y_min = max_pt[1] + shift[1]\n\n    if scale < 0.99:\n        x_min = round(x_min / scale)\n        y_min = round(y_min / scale)\n\n    roi = [y_min, x_min, y_min + t_size[0], x_min + t_size[1]]\n\n    return roi, max_score\n\n\ndef match4para(theta: float, img: np.ndarray, t_img: np.ndarray, m_img: Optional[np.ndarray],\n               tm_img: Optional[np.ndarray], t_size: tuple, search_area: Optional[list], use_mask: bool,\n               scale: float) -> Tuple[float, list, float]:\n    \"\"\"並列処理用テンプレートマッチング関数\n\n    Args:\n        theta (float): _description_\n        img (np.ndarray): _description_\n        t_img (np.ndarray): _description_\n        tm_img (np.ndarray): _description_\n        m_img (Optional[np.ndarray]): _description_\n        t_size (tuple): _description_\n        search_area (Optional[list]): _description_\n        use_mask (bool): _description_\n        scale (float): _description_\n\n    Returns:\n        Tuple[float, list, float]: _description_\n    \"\"\"\n    # NOTE: 回転させてからcropすることで回転軸を同じにする\n    # => 処理は遅くなるが座標変換の手間を省く\n    input = rotate_image(img, theta)\n    if search_area is not None:\n        input = crop_roi(input, search_area)\n        if m_img is not None:\n            m_img = crop_roi(m_img, search_area)\n\n    # NOTE: マッチング\n    if tm_img is not None:\n        # match = cv2.matchTemplate(input, t_img, cv2.TM_CCORR_NORMED, mask=m_img)\n        # NOTE: こっちの方がよい\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED, mask=tm_img)\n    else:\n        # match = cv2.matchTemplate(input, t_img, cv2.TM_CCORR_NORMED)\n        # NOTE: こっちの方がよい\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED)\n\n    # NOTE: シフト量設定\n    if search_area is None:\n        shift = (0, 0)\n    else:\n        shift = (search_area[1], search_area[0])\n\n    roi, max_score = get_best_match_pos(match=match, t_size=t_size, shift=shift, scale=scale, mask=m_img)\n\n    return round(max_score, 3), roi, round(theta, 3)\n\n\ndef calc_heatmap(img: np.ndarray, t_img: np.ndarray, m_img: Optional[np.ndarray],\n                 theta: float, use_mask: bool) -> np.ndarray:\n    \"\"\"ヒートマップ取得用\n    \"\"\"\n    input = rotate_image(img, theta)\n\n    # NOTE: マッチング\n    if use_mask:\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED, mask=m_img)\n    else:\n        match = cv2.matchTemplate(input, t_img, cv2.TM_CCOEFF_NORMED)\n\n    heatmap = get_heatmap(match)\n\n    return heatmap\n\n\ndef rotation_matching(src: np.ndarray,\n                      templ: np.ndarray,\n                      *,\n                      src_mask: [np.ndarray] = None,\n                      search_area: Optional[list] = None,\n                      templ_mask: Optional[np.ndarray] = None,\n                      compression_ratio: float = 100,\n                      min_angle: float = -3.0,\n                      max_angle: float = 3.0,\n                      step_angle: float = 0.1,\n                      #   subpixel: bool = False,\n                      view_heatmap: bool = False\n                      ) -> MatchResult:\n    \"\"\"回転マッチング\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        src_mask (list, optional): _description_. Defaults to None.\n        search_area (list, optional): _description_. Defaults to None.\n        templ_mask (np.ndarray, optional): _description_. Defaults to None.\n        compression_ratio (float, optional): _description_. Defaults to 100.\n        min_angle (float, optional): _description_. Defaults to -3.0.\n        max_angle (float, optional): _description_. Defaults to 3.0.\n        step_angle (float, optional): _description_. Defaults to 0.1.\n        view_heatmap (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        MatchResult: _description_\n    \"\"\"\n    champ_score: float = 0\n    champ_angle: float = 0\n    champ_roi: list = [0, 0, 0, 0]\n    futures: list = []\n\n    height, width = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n    t_size = (t_h, t_w)\n\n    # NOTE: マスク有無\n    if templ_mask is None:\n        use_mask = False\n        m_x, m_y = 0.0, 0.0\n    else:\n        use_mask = True\n        # NOTE: マスクの中心座標を計算（アライメント時に必要）\n        m_x, m_y = get_mask_center(templ_mask)\n\n    # NOTE: リスケ―ル\n    if compression_ratio > 1.0:\n        compression_ratio = compression_ratio / 100.0\n\n    # NOTE: リサイズ、次元削減の前処理\n    img, t_img, m_img, mt_img = _preprocess(src, templ, src_mask, templ_mask,\n                                    scale=compression_ratio)\n\n    # NOTE: リサイズに合わせて検査領域もリサイズ\n    if search_area is not None:\n        search_area = rescale_roi(search_area, compression_ratio)\n\n    # NOTE: 並列処理用に検出を行う角度のリストを作成\n    angles = [round((val * step_angle), 2) for val in range(int(min_angle / step_angle), int(max_angle / step_angle) + 1, 1)]\n\n    # NOTE: 並列処理でタクト短縮\n    with ThreadPoolExecutor(max_workers=4, thread_name_prefix=\"thread\") as pool:\n        for angle in angles:\n            future = pool.submit(match4para, angle, img, t_img, m_img, mt_img, t_size, search_area, use_mask, compression_ratio)\n            futures.append(future)\n\n    # NOTE: 並列処理で取得したデータから最大スコアの情報を抜き出す\n    max_score = -10.0\n    for future in futures:\n        score, roi, theta = future.result()\n        if score > max_score:\n            max_score = score\n            champ_score = score\n            champ_angle = theta\n            champ_roi = roi\n\n    # NOTE: 何も見つからなかったとき\n    if max_score < 0.0:\n        logger.debug('Not found Matching Area')\n        return MatchResult()\n\n    # NOTE: ptを抜き出し\n    ymin, xmin, _, _ = champ_roi\n\n    # NOTE: 回転した検出枠を計算\n    polygon = rotate_rectangle(rectangle=champ_roi,\n                               rot_center=[round(width / 2), round(height / 2)],\n                               rot_angle=champ_angle)\n\n    if templ_mask is not None:\n        m_x, m_y = rotate_point(pt=[xmin + m_x, ymin + m_y],\n                                rot_center=[round(width / 2), round(height / 2)],\n                                rot_angle=champ_angle)\n\n    # NOTE: ヒートマップの計算\n    if view_heatmap:\n        heatmap_ = calc_heatmap(img=img, t_img=t_img, m_img=m_img,\n                                theta=champ_angle, use_mask=use_mask)\n    else:\n        heatmap_ = np.array([0])\n\n    return MatchResult(pt=[xmin, ymin], angle=champ_angle,\n                       score=champ_score, polygon=polygon,\n                       rect=champ_roi, heatmap=heatmap_,\n                       center_pt=[m_x, m_y])\n\n\ndef no_rot_matching(src: np.ndarray,\n                    templ: np.ndarray,\n                    *,\n                    search_area: Optional[list] = None,\n                    mask: Optional[np.ndarray] = None,\n                    compression_ratio: float = 100,\n                    view_heatmap: bool = False\n                    ) -> MatchResult:\n    \"\"\"無回転マッチング\n\n    Args:\n        src (np.ndarray): _description_\n        templ (np.ndarray): _description_\n        search_area (list, optional): _description_. Defaults to None.\n        mask (np.ndarray, optional): _description_. Defaults to None.\n        compression_ratio (float, optional): _description_. Defaults to 100.\n        view_heatmap (bool, optional): _description_. Defaults to False.\n\n    Returns:\n        MatchResult: _description_\n    \"\"\"\n\n    # height, width = src.shape[:2]\n    t_h, t_w = templ.shape[:2]\n    t_size = (t_h, t_w)\n\n    if mask is None:\n        use_mask = False\n    else:\n        use_mask = True\n\n    # NOTE: リスケ―ル\n    if compression_ratio > 1.0:\n        compression_ratio = compression_ratio / 100.0\n\n    img, t_img, m_img = _preprocess(src, templ, mask, compression_ratio)\n\n    if search_area is not None:\n        search_area = rescale_roi(search_area, compression_ratio)\n\n    score, box, _ = match4para(0, img, t_img, m_img, t_size, search_area, use_mask, compression_ratio)\n\n    # NOTE: 何も見つからなかったとき\n    if score < 0.0:\n        logger.debug('Not found Mathcing Area')\n        return MatchResult()\n\n    ymin, xmin, _, _ = box\n\n    # NOTE: ヒートマップの計算\n    if view_heatmap:\n        heatmap = calc_heatmap(img=img, t_img=t_img, m_img=m_img,\n                               theta=0, use_mask=use_mask)\n    else:\n        heatmap = np.array([0])\n\n    return MatchResult(pt=[xmin, ymin], angle=0,\n                       score=score,\n                       polygon=np.array([[0, 0], [0, 0], [0, 0], [0, 0]]),\n                       rect=box, heatmap=heatmap)\n\n\ndef draw_rotation_rectangle(src: np.ndarray,\n                            rectangle: List[int],\n                            *,\n                            polygon: Optional[np.ndarray] = None,\n                            rot_center: Optional[List[int]] = None,\n                            rot_angle: float = 0.0,\n                            color: tuple = (0, 255, 0),\n                            thickness: Optional[int] = None) -> np.ndarray:\n    dst = src.copy()\n\n    height, width = dst.shape[:2]\n    # NOTE: 入力の指定がなければ、画像中心で回転\n    if rot_center is None:\n        rot_center = [int(width / 2), int(height / 2)]\n    # NOTE: 入力の指定がなければ、自動で太さを計算\n    if thickness is None:\n        thickness = int((height + width) / 400)\n\n    # NOTE: 入力がrectの時\n    if polygon is None:\n        # NOTE: 回転角度が0.1以上であれば回転、そうでなければ0度として描画\n        if abs(rot_angle) >= 0.1:\n            polygon = rotate_rectangle(rectangle=rectangle,\n                                       rot_center=rot_center,\n                                       rot_angle=rot_angle)\n        else:\n            (ymin, xmin, ymax, xmax) = rectangle\n            polygon = np.array([[xmin, ymin], [xmin, ymax],\n                                [xmax, ymax], [xmax, ymin]])\n\n    polygon_ = np.round(polygon).astype(np.int32)  # type: ignore\n\n    dst = cv2.polylines(\n        img=dst,\n        pts=[polygon_],\n        isClosed=True,\n        color=color,\n        thickness=thickness\n    )\n\n    return dst\n\n\ndef draw_rotate_polygon(src: np.ndarray,\n                        template_size: tuple,  # NOTE: テンプレート画像のサイズ(w, h)\n                        detected_polygon: Union[np.ndarray, list],  # NOTE: 見つかったテンプレートの枠座標\n                        mask_polygon: Union[np.ndarray, list],  # NOTE: マスクの座標\n                        rot_angle: float,\n                        *,\n                        color: tuple = (0, 255, 0),\n                        thickness: Optional[int] = None) -> np.ndarray:\n\n    dst = src.copy()\n\n    height, width = dst.shape[:2]\n    # NOTE: 入力の指定がなければ、自動で太さを計算\n    if thickness is None:\n        thickness = int((height + width) / 400)\n\n    rot_center = [int(template_size[0] / 2), int(template_size[1] / 2)]\n\n    # NOTE: 多角形の回転(マスクのポリゴンは複数のポリゴンを持つ)\n    center_point_of_detected_polygon = ave_pt(np.array(detected_polygon))\n    rotated_poly_list = []\n    for msk_poly in mask_polygon:\n        poly = rotate_polygon(polygon=msk_poly,\n                              rot_angle=rot_angle,\n                              rot_center=rot_center)\n\n        # NOTE: 中心からのベクトルに変換した後、検出されたポリゴンの中心点を加算\n        vec_polygon = poly - np.array(rot_center)\n        n_polygon = vec_polygon + np.array(center_point_of_detected_polygon)\n        n_polygon = np.round(n_polygon).astype(np.int32)\n        rotated_poly_list.append(n_polygon.copy())\n\n    for pll in rotated_poly_list:\n        dst = cv2.polylines(\n            img=dst,\n            pts=[pll],\n            isClosed=True,\n            color=color,\n            thickness=thickness\n        )\n\n    return dst\n\n\nif __name__ == '__main__':\n    import os\n    import time\n    DATA_DIR = '../../data/connector/model/-H008-C-X5'\n    ORIG_IMG = os.path.join(DATA_DIR, 'sss.bmp')\n    TEMPL_IMG = os.path.join(DATA_DIR, 'templ.jpg')\n    MASK_IMG = os.path.join(DATA_DIR, 'mask.png')\n\n    t1 = time.time()\n    src = cv2.imread(ORIG_IMG)\n    templ = cv2.imread(TEMPL_IMG)\n    mask = cv2.imread(MASK_IMG)\n\n    h, w = src.shape[:2]\n\n    data = no_rot_matching(src=src,\n                           templ=templ,\n                           mask=mask,\n                           view_heatmap=True)\n\n    imshow(data.heatmap)\n",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection": {
        "main.py": "import asyncio\n# from multiprocessing import Process, Pool, Queue, active_children, Manager\n\n# from multiprocessing.managers import BaseManager\nimport multiprocessing\n\nimport time\nimport random\nimport os\nimport re\nfrom pydantic import BaseModel\n\nimport redis\n\nfrom collections import defaultdict\n\nfrom typing import Pattern\n\ndef try_except(data: dict, key: str, *, exception=None):\n    try:\n        return data[key]\n    except Exception:\n        return exception\n\n\ng_check_name_list = {}\n\nclass Regexes(BaseModel):\n    bit: Pattern = re.compile(r\"(bit|boolean)\")\n    word: Pattern = re.compile(r\"(word|short)\")\n    dword: Pattern = re.compile(r\"(dword|doubleword|integer)\")\n    string: Pattern = re.compile(r\"string\")\n    fraction: Pattern = re.compile(r\"\\\\.\")\n    signed: Pattern = re.compile(r\"(\\\\-|\\\\±|s_|signed_)\")\n\n    tcp: Pattern = re.compile(r\"tcp\", flags=re.IGNORECASE)\n    udp: Pattern = re.compile(r\"udp\", flags=re.IGNORECASE)\n\n    fins: Pattern = re.compile(r\"fins\", flags=re.IGNORECASE)\n    slmp: Pattern = re.compile(r\"(slmp|mc_protocol_3e_frame)\", flags=re.IGNORECASE)\n    focas2: Pattern = re.compile(r\"focas2\", flags=re.IGNORECASE)\n    mtlinki: Pattern = re.compile(r\"(mtlinki|mtlink_i|mt-linki)\", flags=re.IGNORECASE)\n    ncprotocol2: Pattern = re.compile(r\"(NC専用通信装置通信プロトコル方式2|nc2|ncprotocol2|nc protocol 2|nc protocol2)\", flags=re.IGNORECASE)\n    smb: Pattern = re.compile(r\"smb\", flags=re.IGNORECASE)\n    localfolder: Pattern = re.compile(r\"localfolder\", flags=re.IGNORECASE)\n\n\nclass Configure(BaseModel):\n    ip_address: str = \"127.0.0.1\"\n    port: int = 0\n    type: str = \"PLC\"\n    manufacturer: str = \"Omron\"\n    series: str = \"NJ\"\n    protocol: str = \"FINS/UDP\"\n    attributes: dict = {}\n\n\ndef communication(configure: dict, *, strage: list = [], test_mode: bool = False):\n    \"\"\"\n\n    \"\"\"\n    network = try_except(configure, \"network\")\n    controller = try_except(configure, \"controller\")\n    conf = Configure(**network, **controller)\n    regexes = Regexes()\n\n    data = try_except(configure, \"data\", exception=None)\n    print(f\"=-=-=-=-= DATA LOCATION: {data} =-=-=-=-= \")\n\n    # =========================================\n    # DEVICE MEMORY\n    # FINS\n    if regexes.fins.search(conf.protocol):\n        try:\n            import protocols.fins.main as fins\n        except Exception:\n            try:\n                import connection.protocols.fins.main as fins\n            except Exception:\n                import src.connection.protocols.fins.main as fins\n\n        con = fins.Communication(configure=configure)\n        con.set_connection(timeout=5)\n\n        identification = con.identification_unit()\n        print(f\"identification: {identification}\")\n\n        con.set_request_message_randam_read()\n        con.set_request_message_bulk_read()\n\n        # TODO timeout時の返答\n        try:\n            con.open()\n            recv = con.connection()\n            con.close()\n            print(f\"DEBUG, recv: {recv}\")\n\n        except Exception as e:\n            data_list = None\n            error_info = [{\n                \"code\": 10060,\n                \"message\": f\"Connection Error: {e}\"\n            }]\n        else:\n            error_info = [x for x in recv if x[\"connection\"][\"code\"] != 0]\n            if error_info:\n                data_list = None\n            else:\n                randam_res = con.divided_response_random_read()\n                bulk_res = con.divided_response_bulk_read()\n                data_list = con.divided_read()\n                error_info = con.extract_error_connection([randam_res, bulk_res])\n\n        return {\n            \"data_list\": data_list,\n            \"error\": error_info\n        }\n\n    # SLMP\n    elif regexes.slmp.search(conf.protocol):\n        try:\n            import protocols.slmp.main as slmp\n        except Exception:\n            try:\n                import connection.protocols.slmp.main as slmp\n            except Exception:\n                import src.connection.protocols.slmp.main as slmp\n\n        con = slmp.Communication(configure=configure)\n        con.set_connection(timeout=5)\n        con.identification_unit()\n\n        con.set_request_random_read()\n        con.set_request_bulk_read()\n\n        try:\n            con.open()\n            recv = con.connection()\n            con.close()\n            print(f\"DEBUG, recv: {recv}\")\n        except Exception as e:\n            data_list = None\n            error_info = [{\n                \"code\": 10060,\n                \"message\": f\"Connection Error: {e}\"\n            }]\n        else:\n            error_info = [x for x in recv if x[\"connection\"][\"code\"] != 0]\n            if error_info:\n                data_list = None\n            else:\n                randam_res = con.divided_response_randam_read()\n                bulk_res = con.divided_response_bulk_read()\n                print(f'randam_res: {randam_res[\"metainfo\"]}')\n                print(f'bulk_res: {bulk_res[\"metainfo\"]}')\n                data_list = con.divided_read()\n                error_info = con.extract_error_connection([randam_res, bulk_res])\n\n        return {\n            \"data_list\": data_list,\n            \"error\": error_info\n        }\n\n    # =========================================\n    # COMMANDS\n    # MTLINKi\n    elif regexes.mtlinki.search(conf.protocol):\n        try:\n            import protocols.mtlinki.main as mtlinki\n        except Exception:\n            try:\n                import connection.protocols.mtlinki.main as mtlinki\n            except Exception:\n                import src.connection.protocols.mtlinki.main as mtlinki\n\n        try:\n            result = mtlinki.main(connection=configure)\n            # for x in result[\"data_list\"]:\n            #     if try_except(x, key=\"updatedate\"):\n            #         x[\"time\"] = x[\"updatedate\"]\n            print(f\"MTLINKi RESULT: {result}\")\n        except Exception as e:\n            result = {\n                \"data_list\": [],\n                \"error\": str(e)\n            }\n            print(e)\n\n        print(f'MTLINKi datalist: {result[\"data_list\"]}, error:{result[\"error\"]}')\n        return result\n\n    # FOCAS2\n    # TODO\n    elif regexes.focas2.search(conf.protocol):\n        try:\n            import protocols.focas2.main as focas2\n        except Exception:\n            try:\n                import connection.protocols.focas2.main as focas2\n            except Exception:\n                import src.connection.protocols.focas2.main as focas2\n\n        try:\n            # print(f\"FOCAS2 CONF: {configure}\")\n            dllpath = os.path.dirname(os.path.abspath(__file__))\n            dllname = 'fwlibe64.dll'\n            # host = '10.7.56.38:8193'\n            # host = '127.0.0.1:0'\n            host = connection[\"network\"][\"ip_address\"] + \":\" + str(connection[\"network\"][\"port\"])\n            con = focas2.Connect(dllpath, dllname, host).get_connection(dllpath, dllname, host)\n            # print(f\"test:{con}\")\n\n            cmd = defaultdict(list)\n            data = try_except(configure, key=\"data\", exception=None)\n            for item in data:\n                # cmd[f'{item[\"command\"]},{item[\"param\"][\"number\"]}'].append(item)\n                cmd[f'{item[\"command\"]}'].append(item)\n\n            data_list = []\n            for key, value in cmd.items():\n                command_result = None\n\n                # CNCステータス情報のリード(2)\n                if key == \"statinfo2\":\n                    command_result = con.statinfo2()\n                    \"\"\"\n                    {\n                        \"result\": 0, \"hdck\": 0, \"tmmode\": 0, \"aut\": 4, \"run\": 0, \"motion\": 0, \"mstb\": 0, \"emergency\": 0, \"alarm\": 0, \"edit\": 0, \"warning\": 0, \"o3dchk\": 0, \"ext_opt\": 0, \"restart\": 0\n                    }\n                    \"\"\"\n\n                # アラームステータスのリード(2)\n                if key == \"alarm2\":\n                    command_result = con.alarm2()\n                    \"\"\"\n                    {\n                        \"result\": 0, \"alarm\": 0\n                    }\n                    \"\"\"\n\n                #  CNC用エラー詳細の取得\n                if key == \"getdtailerr\":\n                    command_result = con.getdtailerr()\n                    \"\"\"\n                    {\n                        'result': 0, 'err_no': 0, 'err_dtno': 0\n                    }\n                    \"\"\"\n\n                # CNCシステム情報のリード\n                if key == \"sysinfo\":\n                    command_result = con.sysinfo()\n                    \"\"\"\n                    {\n                        'result': 0, 'addinfo': 514, 'max_axis': 32, 'cnc_type': b'31', 'mt_type': b'MM', 'series': b'G433', 'version': b'32.4', 'axes': b'06'\n                    }\n                    \"\"\"\n\n                for item in value:\n                    _arguments = try_except(item, key=\"arguments\", exception=None)\n                    arguments = _arguments.copy()\n                    regist_flg = True\n\n                    # パラメータのリード\n                    if key == \"rdparam\":\n                        maxaxis = try_except(arguments, key=\"maxaxis\", exception=32)\n                        axisnum = try_except(arguments, key=\"axisnum\", exception=-1)\n                        datalen = try_except(arguments, key=\"datalen\", exception=132)\n                        paranum = try_except(arguments, key=\"paranum\", exception=None)\n                        if paranum is None:\n                            item[\"error\"] = 20001  # コマンドの引数が不正＿引数入力を1つ以上確認できないため取得実行せず\n                            regist_flg = False\n                        else:\n                            for i in [\"maxaxis\", \"axisnum\", \"datalen\", \"paranum\"]:\n                                try:\n                                    del arguments[i]\n                                except Exception:\n                                    pass\n                            command_result = con.rdparam(maxaxis, paranum, axisnum, datalen)\n                            \"\"\"\n                            {\n                                \"result\": 0, \"datano\": 6750, \"type\": 0, \"cdata\": b'\\x04', \"idata\": -3068, \"ldata\": 1897476, \"prm_val\": 1897476, \"dec_val\": 0, \"cdatas\": b'\\x04\\xf4\\x1c', \"idatas[0]\": -3068, \"ldatas[0]\": 1897476, \"prm_val[0]\": 1897476, \"dec_val[0]\": 0\n                            }\n                            \"\"\"\n\n                    # タイマーデータ\n                    if key == \"rdtimer\":\n                        typenum = try_except(arguments, key=\"typenum\", exception=None)\n                        if typenum is None:\n                            item[\"error\"] = 20001  # コマンドの引数が不正＿引数入力を1つ以上確認できないため取得実行せず\n                            regist_flg = False\n                        else:\n                            del arguments['typenum']\n                            command_result = con.rdparam(maxaxis, paranum, axisnum, datalen)\n                            \"\"\"\n                            {\n                                \"result\": 0, \"minute\": 1897465, \"msec\": 0\n                            }\n                            \"\"\"\n\n                    # アラームメッセージの一括リード(2)\n                    if key == \"rdalmmsg2\":\n                        typenum = try_except(arguments, key=\"typenum\", exception=None)\n                        pointnum = try_except(arguments, key=\"pointnum\", exception=None)\n                        if typenum is None or pointnum is None:\n                            item[\"error\"] = 20001  # コマンドの引数が不正＿引数入力を1つ以上確認できないため取得実行せず\n                            regist_flg = False\n                        else:\n                            del arguments['typenum'], arguments['pointnum']\n                            \"\"\"\n                            {\n                                'result': 0, 'num': 0, 'alm_no': 0, 'type': 0, 'axis': 0, 'dummy': 0, 'msg_len': 0, 'alm_msg': b''\n                            }\n                            \"\"\"\n\n                    if regist_flg and command_result is None:\n                        item[\"error\"] = 20004  # コマンド指定が不正＿command入力値が実行コマンド名に一致しない\n                    else:\n                        # データ取得処理\n                        if regist_flg and arguments:\n                            for arg_key, arg_value in arguments.items():\n                                r_data = try_except(command_result, key=arg_key, exception=None)\n                                if r_data is not None:\n                                    if str(r_data) != str(arg_value):\n                                        if float(r_data) != float(arg_value):\n                                            if int(r_data) != int(arg_value):\n                                                regist_flg = False\n                                                item[\"error\"] = 20000  # 取得スキップ＿データがarguments指定条件に一致しない\n                                    break\n                            if r_data is None:\n                                regist_flg = False\n                                item[\"error\"] = 20003  # arguments指定が不正＿引数以外のatguments入力値が返答データに含まれない\n\n                        if regist_flg:\n                            r_result = try_except(command_result, key=\"result\", exception=None)\n                            if r_result != 0:\n                                item[\"error\"] = command_result  # 完了コード＿コマンド実行部でエラー\n                            else:\n                                r_data = try_except(command_result, key=item[\"field\"], exception=None)\n                                if r_data is None:\n                                    item[\"error\"] = 20002  # 取得データ指定が不正＿field入力値が返答データに含まれない\n                                else:\n                                    item[\"response\"] = r_data\n                                    item[\"error\"] = None\n\n                data_list.extend(value)\n                result = {\n                    \"data_list\": data_list,\n                    \"error\": None\n                }\n\n        except Exception as e:\n            result = {\n                \"data_list\": [],\n                \"error\": str(e)\n            }\n        print(f'FOCAS2 datalist: {result[\"data_list\"]}, error:{result[\"error\"]}')\n        return result\n\n    # NC Protocol 2\n    elif regexes.ncprotocol2.search(conf.protocol):\n        try:\n            import protocols.nc_protocol2.ncunit_protocol2 as ncunit_protocol2\n        except Exception:\n            try:\n                import connection.protocols.nc_protocol2.ncunit_protocol2 as ncunit_protocol2\n            except Exception:\n                import src.connection.protocols.nc_protocol2.ncunit_protocol2 as ncunit_protocol2\n\n        from collections import defaultdict\n\n        try:\n            # Create a dictionary to store lists by command\n            grouped_by_command = defaultdict(list)\n\n            # Iterate over each item and group by 'command'\n            data = try_except(configure, key=\"data\", exception=None)\n            for item in data:\n                grouped_by_command[item['command']].append(item)\n\n            # Convert defaultdict to a regular dict if needed\n            grouped_by_command = dict(grouped_by_command)\n\n            # print(grouped_by_command)\n            con = ncunit_protocol2.Connect(conf.ip_address, conf.port)\n            data_list = []\n            for key, value in grouped_by_command.items():\n                # print(key, value)\n                command_result = None\n\n                # 生産データ2(時間表示)\n                if key == \"PRDC2\":\n                    command_result = con.load_prdc2(flag=True)\n                    \"\"\"\n                        {\n                            'L01': {'cycletime1': '000000256', 'cuttingtime1': '000000173', 'cycletime2': '000000000',\n                                'cuttingtime2': '000000000', 'prg1': '5000', 'prg2': '0000', 'prgfolder1': \"'/       '\",\n                                'prgfolder2': \"'        '\", 'memstaus1': '0', 'memstaus2': '0'\n                                },\n                            'N00': {'date': '20230731', 'time': '000107', 'count': '2', 'energization': ' 65849'},\n                            'result': 0\n                        }\n                    \"\"\"\n\n                # 生産データ2（時間表示）\n                if key == \"PRDD2\":\n                    command_result = con.load_prdd2()\n                    \"\"\"\n                        {\n                            \"L01\": {\n                                    \"cycletime1\": \"000005005\", \"cuttingtime1\": \"000003531\", \"othertime1\": \"049\",\n                                    \"cycletime2\": \"000000000\", \"cuttingtime2\": \"000000000\", \"othertime2\": \"000\",\n                                    \"prg1\": \"8000                            \", \"prg2\": \"0000                            \",\n                                    \"prgfolder1\": \"CK3MQBREV1                       \", \"prgfolder2\": \"                                 \",\n                                    \"prgstatus1\": \"0\", \"prgstatus2\": \"0\", \"memstatus1\": \"0\", \"memstatus2\": \"0\", \"count\": \"8055\"\n                                },\n                            'result': 0\n                        }\n                    \"\"\"\n\n                # 生産データ3(状態履歴)\n                if key == \"PRD3\":\n                    command_result = con.load_prd3()\n                    \"\"\"\n                    {\n                        'C01': {'currtime': '20230731104231', 'currstatus': '5', 'currlang': '0',\n                            'currstatinfo': '050518', 'currfolder': \"'        '\", 'memstatus': '0'},\n                        'result': 0\n                    }\n                    \"\"\"\n\n                # 生産データ3(状態履歴)\n                if key == \"PRDD3\":\n                    command_result = con.load_prdd3()\n                    \"\"\"\n                    {\n                        \"C01\": {\"currtime\": \"20240627170138\", \"currstatus\": \"5\", \"currlang\": \"0\",\n                            \"currstatinfo\": \"900500                          \", \"currfolder\": \"                                 \", \"memstatus\": \"0\"},\n                        'result': 0\n                    }\n                    \"\"\"\n\n                # 機械モニタ用データ（生産データ4）\n                if key == \"MONTR\":\n                    command_result = con.load_montr()\n                    \"\"\"\n                    {\n                        \"T01\": {\"actualtime\": \"046725542\", \"energization\": \"114900041\", \"operating\": \"046635210\"},\n                        'result': 0\n                    }\n                    \"\"\"\n\n                for item in value:\n                    _arguments = try_except(item, key=\"arguments\", exception=None)\n                    arguments = _arguments.copy()\n                    regist_flg = True\n\n                    # 工具データ(タイプ1)\n                    if key == \"TOLN\":\n                        toolunit = try_except(arguments, key=\"tool_unit\", exception=None)\n                        toolno = try_except(arguments, key=\"tool_no\", exception=None)\n                        if toolunit is None or toolno is None:\n                            item[\"error\"] = 20001   # コマンドの引数が不正＿引数入力を1つ以上確認できないため取得実行せず\n                            regist_flg = False\n                        else:\n                            command_result = con.load_toln(unit=toolunit, num=toolno)\n                            del arguments['tool_unit'], arguments['tool_no']\n\n                    # PLC信号データ (TEST)\n                    if key == \"PLCD\":\n                        devicename = try_except(arguments, key=\"device_name\", exception=None)\n                        devicenum = try_except(arguments, key=\"device_num\", exception=None)\n                        if toolunit is None or toolno is None:\n                            item[\"error\"] = 20001   # コマンドの引数が不正＿引数入力を1つ以上確認できないため取得実行せず\n                            regist_flg = False\n                        else:\n                            command_result = con.read_plcd(devicename, devicenum)\n                            del arguments['device_name'], arguments['device_num']\n\n                    # データ取得処理\n                    if regist_flg and command_result is None:\n                        item[\"error\"] = 20004  # コマンド指定が不正＿command入力値が実行コマンド名に一致しない\n                    else:\n                        if regist_flg and arguments:\n                            for arg_key, arg_value in arguments.items():\n                                for r_key, r_value in command_result.items():\n                                    if r_key != \"result\":\n                                        r_data = try_except(r_value, key=arg_key, exception=None)\n                                        if r_data is not None:\n                                            if str(r_data) != str(arg_value):\n                                                if float(r_data) != float(arg_value):\n                                                    if int(r_data) != int(arg_value):\n                                                        regist_flg = False\n                                                        item[\"error\"] = 20000  # 取得スキップ＿データがarguments指定条件に一致しない\n                                            break\n                                if r_data is None:\n                                    regist_flg = False\n                                    item[\"error\"] = 20003  # 引数以外のatguments入力値が返答データに含まれない\n\n                        if regist_flg:\n                            for r_key, r_value in command_result.items():\n                                if r_key != \"result\":\n                                    r_data = try_except(r_value, key=item[\"field\"], exception=None)\n                                    if r_data is None:\n                                        item[\"error\"] = 20002  # 取得データ指定が不正＿field入力値が返答データに含まれない\n                                    else:\n                                        item[\"response\"] = r_data\n                                        item[\"error\"] = None\n                                        break\n                                else:\n                                    if r_value != 0:\n                                        item[\"error\"] = r_value  # コマンド実行部でエラーの場合は完了コード\n                                        break\n                data_list.extend(value)\n                result = {\n                    \"data_list\": data_list,\n                    \"error\": None\n                }\n\n        except Exception as e:\n            result = {\n                \"data_list\": [],\n                \"error\": str(e)\n            }\n\n        print(f'NC Protocol 2 datalist: {result[\"data_list\"]}, error:{result[\"error\"]}')\n        return result\n\n    # =========================================\n    # FILE ACCESS\n    # SMB\n    elif regexes.smb.search(conf.protocol):\n        try:\n            import protocols.smb.main as smb\n        except Exception:\n            try:\n                import connection.protocols.smb.main as smb\n            except Exception:\n                import src.connection.protocols.smb.main as smb\n\n        result = smb.main(configure=configure, strage=strage, mode=\"diff\")\n        print(f\"==== SMB: {result}\")\n        return result\n\n    # local file\n    elif regexes.localfolder.search(conf.protocol):\n        try:\n            import protocols.smb.main as smb\n        except Exception:\n            try:\n                import connection.protocols.smb.main as smb\n            except Exception:\n                import src.connection.protocols.smb.main as smb\n\n        result = smb.main(configure=configure, strage=strage, mode=\"diff\")\n        print(f\"==== LocalFolderFile: {result}\")\n        return result\n\n    else:\n        print(f\"None Communication: {conf}\")\n\n\n# プロセス強制終了\ndef process_terminate(process):\n    \"\"\"\n        各プロセスに対してTerminateを送信して強制終了させる\n    \"\"\"\n    # redis set stop\n    redis.set(process.name, \"stop\")\n    print(f\"Terminate Process: {process.name}\")\n\n    process.terminate()\n\n\n\nif __name__ == \"__main__\":\n    connections = [\n        {\n            \"network\": {\n                \"ip_address\": \"192.168.250.10\",\n                \"port\": 9000,\n            },\n            \"controller\": {\n                \"type\": \"PLC\",\n                \"manufacturer\": \"KEYENCE\",\n                \"series\": \"KV\",\n                \"protocol\": \"SLMP/TCP\",\n                \"attributes\": {}\n            },\n            \"data\": [\n                {\n                    \"execute\": \"read\",\n                    \"machine_id\": 1,\n                    \"group\": \"count\",\n                    \"datatype\": \"input\",\n                    \"device\": \"D\",\n                    \"address\": \"100\",\n                    \"data_unit\": \"integer\",\n                    \"trigger\": None,\n                    \"item\": None,\n                },\n                {\n                    \"machine_id\": 2,\n                    \"group\": \"count\",\n                    \"datatype\": \"input\",\n                    \"device\": \"D\",\n                    \"address\": \"102\",\n                    \"data_unit\": \"integer\",\n                    \"trigger\": None,\n                    \"item\": None,\n                },\n                {\n                    \"machine_id\": 1,\n                    \"group\": \"count\",\n                    \"datatype\": \"cycletime\",\n                    \"device\": \"D\",\n                    \"address\": \"200\",\n                    \"data_unit\": \"float\",\n                    \"trigger\": None,\n                    \"item\": None,\n                },\n                {\n                    \"machine_id\": 1,\n                    \"group\": \"error\",\n                    \"datatype\": \"error_trigger\",\n                    \"device\": \"D\",\n                    \"address\": \"300\",\n                    \"data_unit\": \"boolean\",\n                    \"trigger\": 1,\n                    \"item\": None,\n                },\n                {\n                    \"machine_id\": 1,\n                    \"group\": \"error\",\n                    \"datatype\": \"error_item\",\n                    \"device\": \"D\",\n                    \"address\": \"301\",\n                    \"data_unit\": \"integer\",\n                    \"trigger\": 100,\n                    \"item\": \"Machine Error 1\",\n                },\n                {\n                    \"machine_id\": 1,\n                    \"group\": \"custom\",\n                    \"datatype\": \"date\",\n                    \"device\": \"D\",\n                    \"address\": \"400\",\n                    \"data_unit\": \"integer\",\n                    \"bcd\": True,\n                    \"trigger\": None,\n                    \"item\": None,\n                },\n                {\n                    \"machine_id\": 1,\n                    \"group\": \"custom\",\n                    \"datatype\": \"x-field\",\n                    \"device\": \"D\",\n                    \"address\": \"500\",\n                    \"data_unit\": \"s_integer\",\n                    \"trigger\": None,\n                    \"item\": None,\n                },\n            ],\n        },\n        # {\n        #     \"network\": {\n        #         \"ip_address\": \"192.168.250.1\",\n        #         \"port\": 9600,\n        #     },\n        #     \"controller\": {\n        #         \"type\": \"PLC\",\n        #         \"manufacturer\": \"Omron\",\n        #         \"series\": \"NJ101\",\n        #         \"protocol\": \"FINS/UDP\",\n        #         \"attributes\": {}\n        #     },\n        #     \"data\": [\n        #         {\n        #             \"execute\": \"read\",\n        #             \"machine_id\": 1,\n        #             \"group\": \"count\",\n        #             \"datatype\": \"input\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"100\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 2,\n        #             \"group\": \"count\",\n        #             \"datatype\": \"input\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"102\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"count\",\n        #             \"datatype\": \"cycletime\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"200\",\n        #             # \"data_unit\": \"float\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"error\",\n        #             \"datatype\": \"error_trigger\",\n        #             \"device\": \"wr\",\n        #             \"address\": \"300\",\n        #             \"data_unit\": \"boolean\",\n        #             \"trigger\": 1,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"error\",\n        #             \"datatype\": \"error_item\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"301\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": 100,\n        #             \"item\": \"Machine Error 1\",\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"custom\",\n        #             \"datatype\": \"date\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"400\",\n        #             \"data_unit\": \"integer\",\n        #             \"bcd\": True,\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"custom\",\n        #             \"datatype\": \"x-field\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"500\",\n        #             \"data_unit\": \"s_integer\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #     ],\n        # },\n        # {\n        #     \"network\": {\n        #         \"ip_address\": \"192.168.250.2\",\n        #         \"port\": 9600,\n        #     },\n        #     \"controller\": {\n        #         \"type\": \"PLC\",\n        #         \"manufacturer\": \"Omron\",\n        #         \"series\": \"NJ101\",\n        #         \"protocol\": \"FINS/UDP\",\n        #         \"attributes\": {}\n        #     },\n        #     \"data\": [\n        #         {\n        #             \"execute\": \"read\",\n        #             \"machine_id\": 1,\n        #             \"group\": \"count\",\n        #             \"datatype\": \"input\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"100\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 2,\n        #             \"group\": \"count\",\n        #             \"datatype\": \"input\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"102\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"count\",\n        #             \"datatype\": \"cycletime\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"200\",\n        #             \"data_unit\": \"float\",\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"error\",\n        #             \"datatype\": \"error_trigger\",\n        #             \"device\": \"wr\",\n        #             \"address\": \"300\",\n        #             \"data_unit\": \"boolean\",\n        #             \"trigger\": 1,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"error\",\n        #             \"datatype\": \"error_item\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"301\",\n        #             \"data_unit\": \"integer\",\n        #             \"trigger\": 100,\n        #             \"item\": \"Machine Error 1\",\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"custom\",\n        #             \"datatype\": \"date\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"400\",\n        #             \"data_unit\": \"integer\",\n        #             \"bcd\": True,\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #         {\n        #             \"machine_id\": 1,\n        #             \"group\": \"custom\",\n        #             \"datatype\": \"x-field\",\n        #             \"device\": \"dm\",\n        #             \"address\": \"500\",\n        #             \"data_unit\": \"s_integer\",\n        #             \"length\": 2,\n        #             \"trigger\": None,\n        #             \"item\": None,\n        #         },\n        #     ],\n        # },\n        # {\n        #     \"network\": {\n        #         \"ip_address\": \"192.168.10.1\",\n        #         \"port\": 500,\n        #     },\n        #     \"controller\": {\n        #         \"type\": \"cnc\",\n        #         \"manufacturer\": \"fanuc\",\n        #         \"series\": \"i31\",\n        #         \"protocol\": \"focas2\",\n        #         \"attributes\": {}\n        #     },\n        #     \"data\": [\n        #         {\n        #             \"machine_id\": 10,\n        #             \"group\": \"custom\",\n        #             \"datatype\": \"file_name\",\n        #             # \"file_comments\", \"file_type\", \"file_size\", \"file_updatedtime\"\n        #             \"command\": \"ds_rdhdddir\",\n        #             \"field\": \"\",\n        #             \"key\": \"\",\n        #             \"trigger\": None,\n        #             \"item\": None\n        #         },\n        #     ]\n        # },\n        # {\n        #     \"network\": {\n        #         \"ip_address\": \"192.168.20.2\",\n        #         \"port\": 9000,\n        #     },\n        #     \"controller\": {\n        #         \"type\": \"pc\",\n        #         \"manufacturer\": \"fanuc\",\n        #         \"series\": \"i31\",\n        #         \"protocol\": \"MT-LINKi\",\n        #         \"attributes\": {\n        #             \"authsource\": \"MTLINKi\",\n        #             \"username\": \"mtlinki\",\n        #             \"password\": \"password123456\"\n        #         }\n        #     },\n        #     \"data\": [\n        #         {\n        #             \"machine_id\": 20,\n        #             \"group\": \"input\",\n        #             \"datatype\": None,\n        #             \"command\": \"\",\n        #             \"field\": \"\",\n        #             \"key\": \"\",\n        #             \"trigger\": None,\n        #             \"item\": None\n        #         },\n        #     ]\n        # },\n        # {\n        #     \"network\": {\n        #         \"ip_address\": \"192.168.20.3\",\n        #         \"port\": 9000,\n        #     },\n        #     \"controller\": {\n        #         \"type\": \"pc\",\n        #         \"manufacturer\": \"microsoft\",\n        #         \"series\": \"windows10\",\n        #         \"protocol\": \"SMB\",\n        #         \"attributes\": {\n        #             \"remotename\": \"n0013034\",\n        #             \"domain\": \"jp\",\n        #             \"username\": \"j100046119\",\n        #             \"password\": \"password123456\",\n        #             \"directory\": \"/\"\n        #         }\n        #     },\n        #     \"data\": [\n        #         {\n        #             \"machine_id\": 21,\n        #             \"group\": \"input\",\n        #             \"datatype\": None,\n        #             \"sharefolder\": \"share12\",\n        #             \"path\": \"/data/\",\n        #             \"fileregex\": \"20*_123456.csv\",\n        #             \"culumnname\": \"INPUT\",\n        #             \"trigger\": None,\n        #             \"item\": None\n        #         },\n        #     ]\n\n        # }\n    ]\n\n    stop_event = multiprocessing.Event()\n    # Process Start\n    for connection in connections:\n        process_start(connection, stop_event)\n\n    while True:\n        active_processes = multiprocessing.active_children()\n        print(f\"ACTIVE PROCESSES: {active_processes}\")\n        if active_processes == []:\n            break\n\n        time.sleep(3)\n\n        # # 指定した名前のプロセスのみ停止させるテスト\n        # terminate_process_name = active_processes[0].name\n        # print(f\"Terminate: {terminate_process_name}\")\n        # process_terminate(process_name=terminate_process_name)\n        # time.sleep(3)\n\n    # connections = [\n    #     {\n    #         \"network\": {\n    #             \"ip_address\": \"192.168.1.0\",\n    #             \"port\": 9000,\n    #         },\n    #         \"controller\": {\n    #             \"type\": \"PLC\",\n    #             \"manufacturer\": \"Mitsubisi Electric\",\n    #             \"series\": \"MELSEC iQ-R\",\n    #             \"protocol\": \"SLMP/TCP\",\n    #             \"attributes\": {}\n    #         },\n    #         \"data\": [{\n    #             \"execute\": \"read\",\n    #             \"machine_id\": 1,\n    #             \"group\": \"count\",\n    #             \"datatype\": \"input\",\n    #             \"command\": \"cnc_alart\",\n    #             \"field\": \"alartvalue\",\n    #             \"param\": {\n    #                 \"alm_type\": \"\",\n    #                 \"length\": \"\"\n    #             },\n    #             # \"trigger_value\": None,\n    #             # \"item_value\": None,\n    #         }]\n    #     }\n    # ]\n    # result = process_test(connections)\n    # print(result)\n",
        "test.py": "from main import communication\nimport time\n\nif __name__==\"__main__\":\n    hoge = {\n        \"network\": {\n            \"ip_address\": \"192.168.250.10\",\n            \"port\": 5000,\n        },\n        \"controller\": {\n            \"type\": \"PLC\",\n            \"manufacturer\": \"KEYENCE\",\n            \"series\": \"KV\",\n            \"protocol\": \"SLMP/TCP\",\n            \"attributes\": {}\n        },\n        \"data\":\n        [\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                \"group\": \"\",\n                \"datatype\": \"\",\n                \"device\": \"MR\",\n                \"address\": \"10\",\n                \"data_unit\": \"integer\",\n                \"trigger\": None,\n                \"item\": None,\n            },\n        ],\n    }\n    s = time.time()\n    for i in range(100):\n        res = communication(hoge)\n        print(res)\n    print(time.time() - s)",
        "__init__.py": "import logging\nimport os\nimport dotenv\n\n\ndef get_module_logger(modname, *, level=None):\n    logger = logging.getLogger(modname)\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        'Time:%(asctime)s, %(name)s, Level:%(levelname)s, Func:%(funcName)s, Line:%(lineno)s, %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    dotenv.load_dotenv(override=True)\n    if level is None:\n        LOGGER_LEVEL = os.getenv('LOGGER_LEVEL')\n    elif level in [\"CRITICAL\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"]:\n        LOGGER_LEVEL = level\n    else:\n        LOGGER_LEVEL = \"INFO\"\n\n    if (LOGGER_LEVEL == 'CRITICAL'):\n        logger.setLevel(logging.CRITICAL)\n    elif (LOGGER_LEVEL == 'ERROR'):\n        logger.setLevel(logging.ERROR)\n    elif (LOGGER_LEVEL == 'WARNING'):\n        logger.setLevel(logging.WARNING)\n    elif (LOGGER_LEVEL == 'INFO'):\n        logger.setLevel(logging.INFO)\n    elif (LOGGER_LEVEL == 'DEBUG'):\n        logger.setLevel(logging.DEBUG)\n    else:\n        logger.setLevel(logging.NOTSET)\n    return logger\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\database": {
        "common.py": "import re\nimport datetime\nimport time\nfrom dateutil.relativedelta import relativedelta\nimport pytz\nfrom tzlocal import get_localzone\nimport psycopg2\nfrom psycopg2 import sql\nimport psycopg2.extras\nimport threading\nimport itertools\n\nfrom logging import getLogger\nlogger = getLogger(__name__)\n\n\n# Get DB Connection\ndef get_connection(db_info: dict, *, rdbms: str = 'postgresql'):\n    # postgresql://{username}:{password}@{hostname}:{port}/{database}\n    # dsn = '{}://{}:{}@{}:{}/{}'.format(rdbms, db_info['db_name'], db_info['user'],\n    #                                    db_info['ip_address'], db_info['port'], db_info['password'])\n    dsn = '{}://{}:{}@{}:{}/{}'.format(\n        rdbms, db_info['user'],\n        db_info['password'],\n        db_info['ip_address'],\n        db_info['port'],\n        db_info['db_name']\n    )\n    return psycopg2.connect(dsn)\n\n\ndef query_filter(data: dict, *, flg_where=True):\n    query = \"\"\n    if data is not None:\n        filter_arr = []\n        for k, v in data.items():\n            if v is None:\n                filter_arr.append(\n                    f\"{k} is null\"\n                )\n            else:\n                if isinstance(v, list) or isinstance(v, tuple) or isinstance(v, dict):\n                    _v = tuple(v)\n                    filter_arr.append(\n                        f\"{k} in {_v}\"\n                    )\n                else:\n                    filter_arr.append(\n                        f\"{k} = {_v}\"\n                    )\n        if filter_arr != []:\n            if flg_where:\n                query = f\"WHERE {' AND '.join(filter_arr)}\"\n            else:\n                query = f\"AND {' AND '.join(filter_arr)}\"\n    return query\n\n\ndef get_data(db_info, query, various):\n    with get_connection(db_info) as conn:\n        with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:\n            cur.execute(sql.SQL(query), various)\n            rows = cur.fetchall()\n    return rows\n\n\ndef commit_data(db_info, query, various):\n    with get_connection(db_info) as conn:\n        with conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:\n            try:\n                if isinstance(various, list):\n                    psycopg2.extras.execute_values(cur, query, various)\n                    conn.commit()\n                    res = {'code': 0, 'message': \"SUCCESS\"}\n                else:\n                    cur.execute(query, various)\n                    conn.commit()\n                    res = {'code': 0, 'message': \"SUCCESS\"}\n            except Exception as e:\n                logger.warning(e)\n                conn.rollback()\n                res = {'code': 20122, 'message': str(e)}\n    return res\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "__init__.py": "# This modules need to be imported after the above api is defined, because the \"api\" variable is imported in each file\nfrom . import common\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\old": {},
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\old\\plc": {
        ".gitignore": "Unsupported file type",
        "plc_base_class.py": "# ===============================================================================\n# Name      : plc_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-04-19 12:00\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\n\nfrom time import perf_counter\nfrom typing import Tuple, Union\nfrom pydantic import BaseModel\ntry:\n    from .api import plc_comm\n    from .api.command_checker import check_command\nexcept Exception:\n    from api import plc_comm  # type: ignore\n    from api.command_checker import check_command  # type: ignore\n# from vastlib.connection.old.plc.api import plc_comm\n# from vastlib.connection.old.plc.api.command_checker import check_command\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass PLCParam(BaseModel):\n    ip: str\n    port: str\n    manufacturer: str\n    series: str\n    plc_protocol: str\n    transport_protocol: str\n    bit: str   # NOTE: ビットデバイス\n    word: str   # NOTE: ワードデバイス\n    double_word: str  # NOTE: ダブルワード\n\n\ndef word2byte(word: str) -> str:\n    byte = '{:016b}'.format(int(word))\n    register = byte[::-1]\n    return register\n\n\nclass BasePLC:\n    __version__ = '1.0.0'\n\n    def __init__(self):\n        pass\n\n    def load_param(self, data: dict) -> None:\n        \"\"\"\n        PLCの通信設定を読込\n\n        Args:\n            data (dict): dict型のパラメータ\n        \"\"\"\n        self.param = PLCParam(**data)\n        self.plc_network = dict(ip=self.param.ip,\n                                port=self.param.port)\n\n        self.plc_protocol = dict(manufacture=self.param.manufacturer,\n                                 series=self.param.series,\n                                 protocol=self.param.plc_protocol,\n                                 transport_layer=self.param.transport_protocol)\n\n        # NOTE: OMRON-FINSの場合は公式サポート外なのでコマンドチェックを通す\n        if self.param.manufacturer == 'omron' and self.param.plc_protocol == 'fins':\n            self._omron_fins_flag = True\n        else:\n            self._omron_fins_flag = False\n\n    def get_time_from_plc(self) -> dict:\n        \"\"\"\n        PLCから時刻取得\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        results = plc_comm.single_communication_to_plc(\n            self.plc_network,\n            self.plc_protocol,\n            dict(device='D', min='0', max='0'),\n            dict(cmd='read', data=[], option='time')\n        )\n        return results\n\n    def get_device(self, d_type: str) -> str:\n        \"\"\"\n        デバイス名を取得\n\n        Args:\n            d_type (str): レジスタのデバイスの種類\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if d_type == 'bit':\n            return self.param.bit\n        elif d_type == \"word\":\n            return self.param.word\n        else:\n            return \"\"\n\n    def write_data_to_plc(self,\n                          d_type: str = 'bit',\n                          addr: Union[str, int] = '0',\n                          addr_min: Union[str, int] = '0',\n                          addr_max: Union[str, int] = '0',\n                          data: list = None,\n                          multi: bool = False,\n                          timeout: int = 1000) -> bool:\n        \"\"\"\n        PLCのレジスタに値を書き込む関数\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類\n            addr (Union[str, int], optional): 1word分書き込むときのアドレス.\n            addr_min (Union[str, int], optional): 連番で書き込むときの最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で書き込むときの最後のアドレス.\n            data (list, optional): 書き込むデータ(list形式).\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms).\n\n        Returns:\n            bool: 通信成功ならTrue.\n        \"\"\"\n\n        device = self.get_device(d_type)\n        if multi:\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            # NOTE: 複数のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            if isinstance(addr, int):\n                addr = str(addr)\n            # NOTE: 1個のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        # NOTE: タイムアウトまで通信トライ\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='write', data=data, option='')\n            )\n\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True\n                else:\n                    return True\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Write to plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False\n\n    def read_data_from_plc(self,\n                           d_type: str = 'bit',\n                           addr: Union[str, int] = '0',\n                           addr_min: Union[str, int] = '0',\n                           addr_max: Union[str, int] = '0',\n                           multi: bool = False,\n                           timeout: int = 1000) -> Tuple[bool, list]:\n        \"\"\"\n        PLCのレジスタを読み込む関数\n\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類.\n            addr (Union[str, int], optional): 1word分読み込む時ののアドレス.\n            addr_min (Union[str, int], optional): 連番で読み込む時の最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で読み込む時の最後のアドレス.\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms)\n\n        Returns:\n            Tuple[bool, list]: 通信成功ならTrue, data.\n        \"\"\"\n\n        device = self.get_device(d_type)\n\n        if multi:\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            # NOTE: 複数のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            if isinstance(addr, int):\n                addr = str(addr)\n            # NOTE: 1個のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='read', data=[], option='')\n            )\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True, results['exists_data']\n                else:\n                    return True, results['exists_data']\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Read plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False, []\n\n\nif __name__ == \"__main__\":\n\n    config = dict(\n        ip='192.168.250.10',\n        port='5000',\n        manufacturer='keyence',\n        series='KV-7500',\n        plc_protocol='slmp',\n        transport_protocol='udp',\n        bit='R',\n        word='DM',\n        double_word='DM'\n    )\n\n    plc = BasePLC()\n    plc.load_param(config)\n\n    success = plc.write_data_to_plc(d_type='word',\n                                    # addr='30',\n                                    addr_min='0',\n                                    addr_max='1',\n                                    multi=True,\n                                    data=[0, 0])\n    print(success)\n\n    success, data = plc.read_data_from_plc(d_type='bit',\n                                           # addr='30',\n                                           addr_min='10',\n                                           addr_max='20',\n                                           multi=True)\n    #  data=[?1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    # data=[1])\n    print(data)\n    # print(success)\n\n    # success, data = plc.read_data_from_plc(d_type='word',\n    #                                        addr='5000',\n    #                                        )\n\n    # print(data)\n",
        "plc_seq.py": "# ===============================================================================\n# Name      : plc_sequence.py\n# Version   : 1.0.0\n# Brief     : NTSZ\n# Time-stamp: 2023-05-16 17:40\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport copy\nfrom typing import List, Tuple\nfrom time import perf_counter\n\nfrom .plc_base_class import BasePLC\nfrom .api.plc_comm import convert_signed\nfrom . import read_excel as g_set\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef word2bit(input_word_data: int) -> List[int]:\n    \"\"\"数値を16bitに変換\"\"\"\n    word_data_str = format(input_word_data, '016b')\n    word_data_ary = list(word_data_str)\n    word_data_ary.reverse()\n    # strのリストを数値に変換()\n    return list(map(int, word_data_ary))\n\n\ndef bit2word(input_binary_data: list) -> int:\n    \"\"\"16bitのlistを数値に変換\"\"\"\n    input_binary_data_buf = copy.deepcopy(input_binary_data)\n    input_binary_data_buf.reverse()\n    binary_data_str = str(input_binary_data_buf)\n    revised_binary_data_str = '0b' + binary_data_str[1:len(binary_data_str) - 1].replace(', ', '')\n    word_data = eval(revised_binary_data_str)\n    return word_data\n\n\n# ===============================================================================\n# NOTE: エクセルのアドレス関連\n# ===============================================================================\ndef get_device_map(xlsx_file: str, map_id: int) -> dict:\n    \"\"\"デバイスのINDEXを取得\"\"\"\n    if map_id == 0:\n        return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n    elif map_id == 1:\n        # NOTE: PLC->PCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n    elif map_id == 2:\n        # NOTE: PLC->PCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n    elif map_id == 3:\n        # NOTE: PC->PLCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n    elif map_id == 4:\n        # NOTE: PC->PLCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n    else:\n        return {}\n\n\ndef get_address_map(device_map: dict, header_address: int) -> dict:\n    \"\"\"アドレスマップを取得\"\"\"\n    data = {}\n    for key in device_map.keys():\n        data[key] = header_address + device_map[key]\n    return data\n\n\nclass PlcSeq(BasePLC):\n    __version__ = '1.0.0'\n\n    def __init__(self, excel_path: str):\n        super().__init__()\n        self.load_excel(excel_path)\n\n    def load_excel(self, path: str):\n        \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n        # NOTE: キーと相対アドレス0-15\n        header_address = get_device_map(path, 0)\n        self.IN_BIT_IDX = get_device_map(path, 1)\n        self.IN_WORD_IDX = get_device_map(path, 2)\n        self.OUT_BIT_IDX = get_device_map(path, 3)\n        self.OUT_WORD_IDX = get_device_map(path, 4)\n\n        # NOTE: キーと絶対アドレス\n        self.IN_BIT_AD = get_address_map(self.IN_BIT_IDX, header_address['IN_BIT_NO'])\n        self.IN_WORD_AD = get_address_map(self.IN_WORD_IDX, header_address['IN_WORD_NO'])\n        self.OUT_BIT_AD = get_address_map(self.OUT_BIT_IDX, header_address['OUT_BIT_NO'])\n        self.OUT_WORD_AD = get_address_map(self.OUT_WORD_IDX, header_address['OUT_WORD_NO'])\n\n        # NOTE: 内部保持変数 0で初期化\n        # TODO: VASTから見たOUTのBITリスト 今は6Word確保\n        self._pub_word_list = [[0 for i in range(16)] for j in range(6)]\n\n        # NOTE: エクセルからPLCのパラメータ(IP,Port,Protocol)を取得&反映\n        self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n        self.load_param(self.plc_config)\n\n    def get_plc_config(self) -> dict:\n        return self.plc_config\n\n    def update_bit_as_word(self, tag: str, key: str, val: int) -> None:\n        \"\"\"内部管理しているbitを更新\"\"\"\n        self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n    def read_bit_list(self, tag: str) -> Tuple[bool, list]:\n        \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n        ret, data = self.read_data_from_plc(d_type='bit',\n                                            addr=self.IN_BIT_AD[tag])\n        if ret:\n            bit_16 = word2bit(data[0])\n            return True, bit_16\n        else:\n            return False, [0]\n\n    def read_bit(self, tag: str, key: str) -> int:\n        \"\"\"Wordで読み取ってBitに分解\"\"\"\n        ret, data = self.read_bit_list(tag)\n        if ret:\n            s_bit = data[self.IN_BIT_IDX[key]]\n            return s_bit\n        else:\n            return -1\n\n    def write_bit_as_word(self, data: list, tag: str) -> bool:\n        \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n        bit_16 = data[self.OUT_BIT_IDX[tag]]\n        send_data = bit2word(bit_16)\n        addr = self.OUT_BIT_AD[tag]\n        ret = self.write_data_to_plc(d_type='bit',\n                                     addr=addr,\n                                     data=[send_data])\n        return ret\n\n    def check_bit(self, tag: str, key: str,\n                  val: int, timeout: int = 1000) -> bool:\n        \"\"\"PLC側のリクエスト、ステータスを確認\n\n        Args:\n            tag (str): bitの属性 request, status, complete\n            key (str): bitの名前\n            val (int): bitの値(0 or 1)が一致すればTrue\n            timeout (int, optional): タイムアウト(ms)\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        timer_count = 0\n        start_time = perf_counter()\n        addr = self.IN_BIT_AD[tag]\n        success = False\n        while timer_count < timeout:\n            # NOTE: dataはリストで返却\n            ret, data = self.read_data_from_plc(d_type='bit', addr=addr, timeout=timeout)\n\n            # NOTE: 通信失敗したらcontinue\n            if not ret:\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n\n            # NOTE: 通信に成功したら値を確認\n            bit_16 = word2bit(data[0])\n            s_bit = bit_16[self.IN_BIT_IDX[key]]\n            if s_bit == val:\n                # NOTE: 一致\n                success = True\n                break\n            else:\n                # NOTE: 不一致\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n        return success\n\n    def send_camera_status(self, capturing: bool) -> bool:\n        \"\"\"撮像ステータスの送信\"\"\"\n        # NOTE: 撮像中はcapturing = True\n        if capturing:\n            self.update_bit_as_word('STATUS_COMMON', 'CAPTURING', 1)\n        else:\n            self.update_bit_as_word('STATUS_COMMON', 'CAPTURING', 0)\n\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def send_inspection_start(self) -> None:\n        \"\"\"検査中の信号を送信\"\"\"\n        # NOTE: W(x_out).08 検査フラグ送信\n        self.update_bit_as_word('STATUS_COMMON', 'INSPECTING', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n\n    def get_inspection_config(self) -> Tuple[bool, List[int]]:\n        \"\"\"各種検査に関する番号の取得\"\"\"\n        # NOTE: DM(x_in+1,+2,+3) ワーク機種\n        # NOTE: int(self.IN_WORD_AD['MODEL_NO']+1)はPOSITION_NOがない場合の配慮\n        ret, data = self.read_data_from_plc(d_type='word',\n                                            addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n                                            addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n                                            multi=True)\n        if ret:\n            return True, data\n        else:\n            return False, [-1, -1, -1, -1]\n\n    def send_alignment_data(self, data: list) -> bool:\n        \"\"\"補正量を送信\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_base_align_data(self, data: list) -> bool:\n        \"\"\"基準量を送付\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_num_work(self, num: int) -> bool:\n        try:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NUM_WORK'],\n                data=[int(num)]\n            )\n        except Exception:\n            return False\n\n        return ret\n\n    def send_inspection_results(self,\n                                status: int,\n                                align_data: list,\n                                b_align_data: list = [],\n                                ng_code: int = 1,\n                                err_code: int = 1,\n                                ) -> bool:\n        \"\"\"結果を送信する\n\n        Args:\n            status (int): 判定結果 ok:1 ng:2 err:3\n            align_data (list): 検出した座標\n            b_align_data (list, optional): マスター登録した座標\n            ng_code (int, optional): 画像処理のNGコード\n            err_code (int, optional): 画像処理のERRORコード\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        # NOTE: 現在位置書き込み\n        ret = self.send_alignment_data(align_data)\n        # NOTE: 基準位置書き込み\n        if b_align_data:\n            ret = self.send_base_align_data(b_align_data)\n\n        # NOTE: 判定がNGの場合NGコードを出力\n        if status == 2:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NG_CODE'],\n                data=[int(ng_code)]\n            )\n        # NOTE: 判定がERRの場合ERRコードを出力\n        elif status == 3:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['ERR_CODE'],\n                data=[int(err_code)]\n            )\n\n        # NOTE: ジャッジリストを更新\n        judge_list = [0, 0, 0, 0]\n        judge_list[status] = 1\n\n        # NOTE: 検査判定を書き込み\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_OK', judge_list[1])\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_NG', judge_list[2])\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_ERR', judge_list[3])\n        self.write_bit_as_word(self._pub_word_list, 'COMPLETE_COMMON')\n        # NOTE: 検査終了を伝令\n        self.update_bit_as_word('STATUS_COMMON', 'INSPECTING', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n\n        # NOTE: PLC側で検査結果を受けとれたか確認\n        ret = self.check_bit('COMPLETE_COMMON', 'INSPECT_RECV_COMP', 1, timeout=5000)\n        if not ret:\n            return False\n\n        # NOTE: 検査結果を初期化\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_OK', 0)\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_NG', 0)\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_ERR', 0)\n        self.write_bit_as_word(self._pub_word_list, 'COMPLETE_COMMON')\n        return True\n\n    def post_pc_error(self, err_code: int = 1) -> bool:\n        \"\"\"エラー出力\"\"\"\n        # NOTE: エラーコードを出力\n        self.update_bit_as_word('STATUS_COMMON', 'PC_ERR', 1)\n        ret1 = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        # NOTE: エラー信号を出力\n        ret2 = self.write_data_to_plc(d_type='word',\n                                      addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n                                      data=[int(err_code)])\n        if ret1 and ret2:\n            return True\n        return False\n\n    def reset_pc_error(self) -> bool:\n        \"\"\"PCエラーをリセット\"\"\"\n        # NOTE: エラーコードを初期化\n        self.update_bit_as_word('STATUS_COMMON', 'PC_ERR', 0)\n        ret1 = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        # NOTE: エラー信号を初期化\n        ret2 = self.write_data_to_plc(d_type='word',\n                                      addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n                                      data=[0])\n        if ret1 and ret2:\n            return True\n        return False\n\n    def pc_online(self, on: bool = True) -> bool:\n        if on:\n            self.update_bit_as_word('STATUS_COMMON', 'PC_ONLINE', 1)\n        else:\n            self.update_bit_as_word('STATUS_COMMON', 'PC_ONLINE', 0)\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def heart_beat(self, pre_beat: bool) -> bool:\n        \"\"\"ラズパイの生存をPLC側に通達\"\"\"\n        if pre_beat:\n            self.pc_online(False)\n            return False\n        else:\n            self.pc_online(True)\n            return True\n\n    # def calibration_seq(self) -> None:\n    #     # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n    #     self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n    #     self.update_bit_as_word('STATUS', 'PC_READY', 0)\n    #     self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n    #     # NOTE: キャリブレーションスタート\n    #     self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n    #     self.update_bit_as_word('STATUS', 'PC_READY', 0)\n    #     self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n\ndef _main():\n    # NOTE: トーソク用テストコード\n    import time\n    e_path = r'C:\\Users\\J100048001\\Desktop\\rv_vast\\vision_setting.xlsx'\n    plc = PlcSeq(e_path)\n\n    param = dict(ip='192.168.250.10',\n                 port='5000',\n                 manufacturer='keyence',\n                 series='',\n                 plc_protocol='slmp',\n                 transport_protocol='udp',\n                 bit='DM',\n                 word='DM',\n                 double_word='')  # NOTE: ダブルワード\n\n    plc.load_param(param)\n    pre_bit = [False]\n    pre_beat = False\n    # NOTE: 周期設定\n    _count = 0  # NOTE: 計測用カウンター\n    WAIT_TIME = 0.1  # NOTE: ループ周期(second)\n    BEAT_TIME = 1  # NOTE: ハートビート周期(second)\n    COUNT_TH = int(BEAT_TIME / WAIT_TIME)\n    pre_beat = plc.heart_beat(pre_beat)\n\n    try:\n        while True:\n            # NOTE: PLCのメモリの値（OUTPUT）を取得\n            ret, data = plc.read_bit_list(tag='REQUEST_COMMON')\n            if not ret:\n                # NOTE: 次にメモリを読みに行くまで所定の時間sleep\n                # 負荷低減のため\n                _count += 1\n                time.sleep(WAIT_TIME)\n                continue\n\n            # NOTE: 検査信号のトリガー\n            if data[plc.IN_BIT_IDX['CAPTURE_START']] == 1:\n                # NOTE: 立ち上がりでなければ再度読み込み\n                if pre_bit[0]:\n                    _count += 1\n                    time.sleep(WAIT_TIME)\n                    continue\n                # NOTE: 検査開始の電文をメインスレッドにシグナルとして送付\n\n                r = plc.send_camera_status(True)\n                time.sleep(0.5)\n                r = plc.send_camera_status(False)\n                r = plc.check_bit(tag='COMPLETE_COMMON', key='CAPTURE_RECV_COMP', val=1, timeout=5000)\n                if not r:\n                    print('errr1')\n                    break\n                r = plc.check_bit(tag='REQUEST_COMMON', key='INSPECT_START', val=1, timeout=5000)\n                if not r:\n                    print('errr2')\n\n                plc.send_inspection_start()\n                r, number_list = plc.get_inspection_config()\n                print(number_list)\n\n                plc.send_inspection_results(1, [-1111, -65000, 0, -1000])\n                # NOTE: prebitを更新\n                pre_bit[0] = True\n\n            # NOTE: 不定期にON,OFFを繰り返す\n            if _count > COUNT_TH:\n                # print('sss')\n                pre_beat = plc.heart_beat(pre_beat)\n                _count = 0\n\n            # NOTE: pre bitをオフにする\n            pre_bit[0] = False\n\n            # NOTE: カウント\n            _count += 1\n\n            # NOTE: 負荷低減のため\n            time.sleep(WAIT_TIME)\n\n    except KeyboardInterrupt:\n        pass\n\n\nif __name__ == \"__main__\":\n    # print(RANGE)\n    _main()\n",
        "plc_seq_nmoj.py": "# ===============================================================================\n# Name      : plc_sequence.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-04-19 17:16\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport copy\nfrom typing import List, Tuple\nfrom time import perf_counter, sleep\nfrom .plc_base_class import BasePLC\nfrom .api.plc_comm import convert_signed\nfrom . import read_excel as g_set\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef word2bit(input_word_data: int) -> List[int]:\n    \"\"\"数値を16bitに変換\"\"\"\n    word_data_str = format(input_word_data, '016b')\n    word_data_ary = list(word_data_str)\n    word_data_ary.reverse()\n    # strのリストを数値に変換()\n    return list(map(int, word_data_ary))\n\n\ndef bit2word(input_binary_data: list) -> int:\n    \"\"\"16bitのlistを数値に変換\"\"\"\n    input_binary_data_buf = copy.deepcopy(input_binary_data)\n    input_binary_data_buf.reverse()\n    binary_data_str = str(input_binary_data_buf)\n    revised_binary_data_str = '0b' + binary_data_str[1:len(binary_data_str) - 1].replace(', ', '')\n    word_data = eval(revised_binary_data_str)\n    return word_data\n\n\n# ===============================================================================\n# NOTE: エクセルのアドレス関連\n# ===============================================================================\ndef get_device_map(xlsx_file: str, map_id: int) -> dict:\n    \"\"\"デバイスのINDEXを取得\"\"\"\n    if map_id == 0:\n        return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n    elif map_id == 1:\n        # NOTE: PLC->PCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n    elif map_id == 2:\n        # NOTE: PLC->PCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n    elif map_id == 3:\n        # NOTE: PC->PLCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n    elif map_id == 4:\n        # NOTE: PC->PLCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n    else:\n        return {}\n\n\ndef get_address_map(device_map: dict, header_address: int) -> dict:\n    \"\"\"アドレスマップを取得\"\"\"\n    data = {}\n    for key in device_map.keys():\n        data[key] = header_address + device_map[key]\n    return data\n\n\nclass PlcSeq(BasePLC):\n    __version__ = '1.0.0'\n\n    def __init__(self, excel_path: str = './vision_setting.xlsx'):\n        super().__init__()\n        self.load_excel(excel_path)\n\n    def load_excel(self, path: str):\n        \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n        # NOTE: 各キー、タグのインデックス\n        header_address = get_device_map(path, 0)\n        self.IN_BIT_IDX = get_device_map(path, 1)\n        self.IN_WORD_IDX = get_device_map(path, 2)\n        self.OUT_BIT_IDX = get_device_map(path, 3)\n        self.OUT_WORD_IDX = get_device_map(path, 4)\n\n        # NOTE: 各キー、タグのアドレス\n        self.IN_BIT_AD = get_address_map(self.IN_BIT_IDX, header_address['IN_BIT_NO'])\n        self.IN_WORD_AD = get_address_map(self.IN_WORD_IDX, header_address['IN_WORD_NO'])\n        self.OUT_BIT_AD = get_address_map(self.OUT_BIT_IDX, header_address['OUT_BIT_NO'])\n        self.OUT_WORD_AD = get_address_map(self.OUT_WORD_IDX, header_address['OUT_WORD_NO'])\n\n        # NOTE: 内部保持変数 0で初期化\n        # TODO: レンジをエクセルからとってくる、今は３\n        self._pub_word_list = [[0 for i in range(16)] for j in range(3)]\n\n        self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n        self.load_param(self.plc_config)\n\n    def get_plc_config(self) -> dict:\n        return self.plc_config\n\n    def update_bit_as_word(self, tag: str, key: str, val: int) -> None:\n        \"\"\"内部管理しているbitを更新\"\"\"\n        self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n    def read_bit_list(self, tag: str = 'REQ') -> Tuple[bool, list]:\n        \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n        ret, data = self.read_data_from_plc(d_type='bit',\n                                            addr=self.IN_BIT_AD[tag])\n        if ret:\n            bit_16 = word2bit(data[0])\n            return True, bit_16\n        else:\n            return False, [0]\n\n    def read_bit(self, tag: str = 'REQ', key: str = 'INSPECT_START') -> int:\n        \"\"\"Wordで読み取ってBitに分解\"\"\"\n        ret, data = self.read_bit_list(tag)\n        if ret:\n            s_bit = data[self.IN_BIT_IDX[key]]\n            return s_bit\n        else:\n            return -1\n\n    def write_bit_as_word(self, data: list, tag: str) -> bool:\n        \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n        bit_16 = data[self.OUT_BIT_IDX[tag]]\n        send_data = bit2word(bit_16)\n        addr = self.OUT_BIT_AD[tag]\n        ret = self.write_data_to_plc(d_type='bit',\n                                     addr=addr,\n                                     data=[send_data])\n        return ret\n\n    def check_bit(self, tag: str, key: str, val: int, timeout: int = 1000) -> bool:\n        \"\"\"Bitの状態確認\"\"\"\n        timer_count = 0\n        start_time = perf_counter()\n        _match = False\n        addr = self.IN_BIT_AD[tag]\n        while timer_count < timeout:\n            # NOTE: dataはリストで返却\n            success, data = self.read_data_from_plc(d_type='bit', addr=addr, timeout=timeout)\n            if success:\n                bit_16 = word2bit(data[0])\n                s_bit = bit_16[self.IN_BIT_IDX[key]]\n                if s_bit == val:\n                    _match = True\n                    break\n                else:\n                    # NOTE: 不一致\n                    timer_count = int((perf_counter() - start_time) * 1000)\n                    continue\n            # TODO: タイムアウトと通信失敗を切り分けできるように\n            else:\n                # NOTE: 通信失敗\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n        return _match\n\n    # ===============================================================================\n    # NOTE: 通信確認\n    # ===============================================================================\n\n    def communication_confirmation(self) -> bool:\n        \"\"\"Ready信号に対する応答\"\"\"\n        # NOTE: 初回起動時、原点復帰後に実施\n\n        # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_out).08-11 <Write> プログラム起動時に初期化（検査系）\n        self.update_bit_as_word('STATUS', 'INSPECTING', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_OK', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_NG', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_ERR', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE:  W(x_out).00 <Write> PCの電源がONであることをPLCに通達\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_in).01 <Read> Request Readyがオンになっていることを確認\n        ret = self.check_bit('REQ', 'READY', 1, timeout=5000)\n        if not ret:\n            logger.debug('Timeout Request Ready [on]')\n            return False\n\n        # NOTE: W(x_out).01 <Write> PLC側のW(2).01を確認したことを通達\n        self.update_bit_as_word('STATUS', 'PC_READY', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_in).01 <Read> PLC側が通達を確認\n        ret = self.check_bit('REQ', 'READY', 0, timeout=5000)\n        if not ret:\n            logger.debug('Timeout Request Ready [off]')\n            return False\n\n        # NOTE: W(x_out).01 <Write> 初期通信確認終了\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        logger.debug('Ready Sequence Complete')\n\n        return True\n\n    def send_camera_status(self, capturing: bool) -> bool:\n        \"\"\"撮像ステータスの送信\"\"\"\n        # NOTE: 撮像中はcapturing = True\n        if capturing:\n            self.update_bit_as_word('STATUS', 'CAPTURE', 1)\n        else:\n            self.update_bit_as_word('STATUS', 'CAPTURE', 0)\n\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS')\n        return ret\n\n    def send_inspection_start(self) -> None:\n        \"\"\"検査中の信号を送信\"\"\"\n        # NOTE: W(x_out).08 検査フラグ送信\n        self.update_bit_as_word('STATUS', 'INSPECTING', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n    def get_inspection_config(self) -> Tuple[bool, int, int, int]:\n        \"\"\"検査番号の取得\"\"\"\n        # NOTE: DM(x_in+1,+2,+3) ワーク機種\n        ret, data = self.read_data_from_plc(d_type='word',\n                                            addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n                                            addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n                                            multi=True)\n        if ret:\n            return True, data[0], data[1], data[2]\n        else:\n            return False, -1, -1, -1\n\n    def send_alignment_data(self, data: list) -> bool:\n        \"\"\"補正量を送信\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_base_align_data(self, data: list) -> bool:\n        \"\"\"基準量を送付\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_num_work(self, num: int) -> bool:\n        try:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NUM_WORK'],\n                data=[int(num)]\n            )\n        except Exception:\n            return False\n\n        return ret\n\n    def send_inspection_results(self,\n                                status: int,\n                                data: list,\n                                b_data: list = [0, 0, 0, 0],\n                                ngcode: int = 0\n                                ) -> bool:\n        \"\"\"検査結果を送信\"\"\"\n        # NOTE: status : ok:1 ng:2 err:3\n\n        # NOTE: 現在位置書き込み\n        ret = self.send_alignment_data(data)\n        # NOTE: 基準位置書き込み\n        ret = self.send_base_align_data(b_data)\n\n        # NOTE: post NG Code\n        if status == 2:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NG_CODE'],\n                data=[int(ngcode)]\n            )\n\n        judge_list = [0, 0, 0, 0]\n        judge_list[status] = 1\n\n        # NOTE: W(x_out).08-11 検査フラグ送信\n        self.update_bit_as_word('STATUS', 'INSPECTING', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_OK', judge_list[1])\n        self.update_bit_as_word('STATUS', 'INSPECT_NG', judge_list[2])\n        self.update_bit_as_word('STATUS', 'INSPECT_ERR', judge_list[3])\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_in).09 検査終了確認\n        ret = self.check_bit('REQ', 'INSPECT_RCV', 1, timeout=5000)\n        if not ret:\n            logger.debug('Timeout Inspection Recv [on]')\n            return False\n\n        # NOTE: W(x_out).09-11 検査結果削除\n        self.update_bit_as_word('STATUS', 'INSPECT_OK', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_NG', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_ERR', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        logger.debug('Inspection Sequence Complete')\n\n        return True\n\n    def post_error_code(self, error_code: int) -> None:\n        \"\"\"エラーを吐く\"\"\"\n        self.success = self.write_data_to_plc(\n            d_type='word',\n            addr=self.OUT_WORD_AD['ERR_CODE'],\n            data=[int(error_code)]\n        )\n\n        self.update_bit_as_word('STATUS', 'PC_ERR', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # # TODO: ここは無限タイムアウトじゃないと\n        # ret = self.check_bit('REQ', 'RST_PC_ERR', 1, timeout=1000)\n        # if not ret:\n        #     return\n\n        # self.update_bit_as_word('STATUS', 'PC_ERR', 0)\n        # self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n    def pc_online(self, on: bool = True) -> bool:\n        \"\"\"PC Online\"\"\"\n        if on:\n            self.update_bit_as_word('STATUS', 'PC_ONLINE', 1)\n        else:\n            self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS')\n        return ret\n\n    def calibration_seq(self) -> None:\n        # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: キャリブレーションスタート\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n\ndef _main():\n    plc = PlcSeq()\n\n    param = dict(ip='192.168.14.1',\n                 port='9600',\n                 manufacturer='omron',\n                 series='',\n                 plc_protocol='fins',\n                 transport_protocol='udp',\n                 bit='W',\n                 word='DM',\n                 double_word='')  # NOTE: ダブルワード\n\n    plc.load_param(param)\n\n    in_w = get_device_map('./setting_Vision_W.xlsx', 1)\n\n    try:\n        while True:\n            # NOTE: 一括読取\n            ret, data = plc.read_bit_list()\n            if ret:\n                if data[in_w['INSPECT_START']] == 1:\n\n                    print('inspection_start')\n                    plc.send_camera_status(True)\n                    sleep(1)\n                    plc.send_camera_status(False)\n                    plc.get_inspection_config()\n                    # NOTE: 単位はum\n                    ret = plc.send_inspection_results(1, [-1, 2, 3, -4])\n                    if ret:\n                        print('inspection success')\n                    else:\n                        print('inspection failed')\n\n                elif data[in_w['READY']] == 1:\n\n                    print('Communication Confirmation')\n                    ret = plc.communication_confirmation()\n                    if ret:\n                        print('commconfirm success')\n                    else:\n                        print('commconfirm failed')\n\n            plc.pc_online()\n    except KeyboardInterrupt:\n        pass\n\n\nif __name__ == \"__main__\":\n    # print(RANGE)\n    _main()\n",
        "README.md": "# NOTE: あああ\n",
        "read_excel.py": "# ===============================================================================\n# Name      : read_excel.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-05-06 16:09\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport openpyxl\nimport io\n\n\ndef getHeaderAddress(book_name: str, sheet_name: str) -> dict:\n    \"\"\"指定されたExcelファイルとシートから先頭アドレスを取得する\"\"\"\n    REF_ROW_NO = 8\n    REF_COL_NO = 2\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    in_bit = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO).value\n    in_word = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 1).value\n    out_bit = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 2).value\n    out_word = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 3).value\n    wb.close()\n    address_data = dict(IN_BIT_NO=in_bit,\n                        IN_WORD_NO=in_word,\n                        OUT_BIT_NO=out_bit,\n                        OUT_WORD_NO=out_word,\n                        )\n    return address_data\n\n\ndef getBitData(book_name: str, sheet_name: str) -> dict:\n    \"\"\"Bitのキーワードを取得\"\"\"\n    REF_ROW_NO = 3\n    REF_COL_NO = 3\n    MAX_COL_NO = 16\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    dict_data = {}\n    # 行走査\n    for row_i in range(0, sheet.max_row):\n        cell = sheet.cell(row=row_i + REF_ROW_NO, column=REF_COL_NO)\n        # 値があれば\n        if cell.value is not None:\n            # word用連想配列作成(Word要タグのID)\n            dict_data[cell.value] = row_i\n            # 列走査\n            for col_i in range(0, MAX_COL_NO):\n                cell = sheet.cell(row=row_i + REF_ROW_NO, column=REF_COL_NO + col_i)\n                # 値があれば\n                if (cell.value is not None) and (col_i != 0):\n                    # bit用連想配列作成\n                    dict_data[cell.value] = col_i - 1\n    wb.close()\n    return dict_data\n\n\ndef getWordData(book_name: str, sheet_name: str) -> dict:\n    \"\"\"Wordのキーワードを取得\"\"\"\n    REF_ROW_NO = 3\n    REF_COL_NO = 3\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    dict_data = {}\n    # 行走査\n    for row_i in range(0, sheet.max_row):\n        cell = sheet.cell(row=row_i + REF_ROW_NO, column=REF_COL_NO)\n        # 値があれば\n        if cell.value is not None:\n            # word用連想配列作成\n            dict_data[cell.value] = row_i\n    wb.close()\n    return dict_data\n\n\ndef getPLCParam(book_name: str, sheet_name: str) -> dict:\n    \"\"\"PLCの通信設定を取得\"\"\"\n    REF_ROW_NO = 4\n    REF_COL_NO = 2\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    # NOTE:行走査\n    ip_address = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO).value\n    port = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 1).value\n    manufacturer = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 2).value\n    series = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 3).value\n    plc_protocol = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 4).value\n    transport_protocol = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 5).value\n    bit = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 6).value\n    word = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 7).value\n\n    plc_param = dict(ip=ip_address,\n                     port=str(port),\n                     manufacturer=manufacturer,\n                     series=series,\n                     plc_protocol=plc_protocol,\n                     transport_protocol=transport_protocol,\n                     bit=bit,\n                     word=word,\n                     double_word='')\n    wb.close()\n    return plc_param\n\n\ndef getParamDict(book_name: str, sheet_name: str) -> dict:\n    \"\"\"RangeSheet読込\"\"\"\n    # NOTE: NMOJ 用\n    REF_COL_NO = 2\n    MAX_COL_NO = 2\n    wb = openpyxl.load_workbook(book_name, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    dict_data = {}\n    # 行走査\n    for row_i in range(1, sheet.max_row + 1):\n        cell_1 = sheet.cell(row=row_i, column=REF_COL_NO)\n        # 値があれば\n        if cell_1.value is not None:\n            # 列走査\n            for col_i in range(1, MAX_COL_NO):\n                cell_2 = sheet.cell(row=row_i, column=REF_COL_NO + col_i)\n                # 値があれば\n                if cell_2.value is not None:\n                    # bit用連想配列作成\n                    dict_data[cell_1.value] = cell_2.value\n    wb.close()\n    return dict_data\n\n\ndef getIdTable(book_name: str, sheet_name: str = 'IDTABLE') -> list:\n    # NOTE: NMOJ用\n    REF_ROW_NO = 3\n    REF_COL_NO = 2\n    # NOTE:データオンリー\n    wb = openpyxl.load_workbook(book_name, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    data_list = []\n    # NOTE:行走査\n    for row_i in range(REF_ROW_NO, sheet.max_row + 1):\n        program_no = sheet.cell(row=row_i, column=REF_COL_NO).value\n        config_no = sheet.cell(row=row_i, column=REF_COL_NO + 1).value\n        model_no = sheet.cell(row=row_i, column=REF_COL_NO + 2).value\n        model_type = sheet.cell(row=row_i, column=REF_COL_NO + 3).value\n        model_name = sheet.cell(row=row_i, column=REF_COL_NO + 4).value\n        if program_no is None:\n            # NOTE: Noneであればbreak\n            break\n        data_list.append(\n            dict(config=config_no,\n                 program=program_no,\n                 model=model_no,\n                 mdl_type=model_type,\n                 mdl_name=model_name)\n        )\n\n    wb.close()\n    return data_list\n",
        "revision.md": "# ver1.0.0",
        "vast_plc_comm.py": "# ===============================================================================\n# Name      : plc_sequence.py\n# Version   : 1.0.0\n# Brief     : NTSZ\n# Time-stamp: 2024-01-06 15:36\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport copy\nfrom typing import List, Tuple, Union\nfrom time import perf_counter\nfrom pydantic import BaseModel\n\ntry:\n    from .api import plc_comm\n    from .api.command_checker import check_command\n    from .api.plc_comm import convert_signed\n    from . import read_excel as g_set\nexcept Exception:\n    from api import plc_comm  # type: ignore\n    from api.command_checker import check_command  # type: ignore\n    from api.plc_comm import convert_signed  # type: ignore\n    import read_excel as g_set  # type: ignore\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass PLCConfiguration(BaseModel):\n    ip: str = ''\n    port: str = ''\n    manufacturer: str = ''\n    series: str = ''\n    plc_protocol: str = ''\n    transport_protocol: str = ''\n    bit: str = ''   # NOTE: ビットデバイス\n    word: str = ''   # NOTE: ワードデバイス\n    double_word: str = ''  # NOTE: ダブルワード\n\n\ndef word2bit(input_word_data: int) -> List[int]:\n    \"\"\"数値を16bitに変換\"\"\"\n    word_data_str = format(input_word_data, '016b')\n    word_data_ary = list(word_data_str)\n    word_data_ary.reverse()\n    return list(map(int, word_data_ary))\n\n\ndef bit2word(input_binary_data: list) -> int:\n    \"\"\"16bitのlistを数値に変換\"\"\"\n    input_binary_data_buf = copy.deepcopy(input_binary_data)\n    input_binary_data_buf.reverse()\n    binary_data_str = str(input_binary_data_buf)\n    revised_binary_data_str = '0b' + binary_data_str[1:len(binary_data_str) - 1].replace(', ', '')\n    word_data = eval(revised_binary_data_str)\n    return word_data\n\n\ndef bool2int(bool_val: bool) -> int:\n    if bool_val:\n        return 1\n    else:\n        return 0\n\n\nclass BasePLCCommunication:\n    \"\"\"\n    PLCとの通信に使う基本関数\n    \"\"\"\n    __version__ = '1.0.0'\n\n    # def __init__(self):\n    #     self._vis_address: bool = False\n\n    # def enableAddress(self, enabled: bool) -> None:\n    #     self._vis_address = enabled\n\n    def loadPLCConfiguration(self, data: Union[dict, PLCConfiguration]) -> bool:\n        \"\"\"\n        PLCとの通信設定の読込\n\n        Args:\n            data (Union[dict, PLCConfiguration]): 通信設定のパラメータ\n\n        Returns:\n            bool: 入力フォーマットが間違っていた場合False\n        \"\"\"\n        if isinstance(data, dict):\n            self.param = PLCConfiguration(**data)\n        elif isinstance(data, PLCConfiguration):\n            self.param = data\n        else:\n            return False\n\n        self.plc_network = dict(ip=self.param.ip,\n                                port=self.param.port)\n\n        self.plc_protocol = dict(manufacture=self.param.manufacturer,\n                                 series=self.param.series,\n                                 protocol=self.param.plc_protocol,\n                                 transport_layer=self.param.transport_protocol)\n\n        # NOTE: OMRON-FINSの場合は公式サポート外なのでコマンドチェックを適用\n        if self.param.manufacturer == 'omron' and self.param.plc_protocol == 'fins':\n            self._omron_fins_flag = True\n        else:\n            self._omron_fins_flag = False\n\n        return True\n\n    def getTimeFromPLC(self) -> dict:\n        \"\"\"\n        PLCから時刻取得(Omronのみ対応?)\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        results = plc_comm.single_communication_to_plc(\n            self.plc_network,\n            self.plc_protocol,\n            dict(device='D', min='0', max='0'),\n            dict(cmd='read', data=[], option='time')\n        )\n        return results\n\n    def getPLCDeviceName(self, d_type: str) -> str:\n        \"\"\"\n        デバイス名を取得\n\n        Args:\n            d_type (str): レジスタのデバイスの種類\n\n        Returns:\n            str: デバイス名\n        \"\"\"\n        if d_type == 'bit':\n            return self.param.bit\n        elif d_type == \"word\":\n            return self.param.word\n        else:\n            return \"\"\n\n    def writeDataToPLCDevice(self,\n                             d_type: str = 'bit',\n                             addr: Union[str, int] = '0',\n                             addr_min: Union[str, int] = '0',\n                             addr_max: Union[str, int] = '0',\n                             data: list = None,\n                             multi: bool = False,\n                             timeout: int = 1000) -> bool:\n        \"\"\"\n        PLCのレジスタに値を書き込む関数\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類\n            addr (Union[str, int], optional): 1word分書き込むときのアドレス.\n            addr_min (Union[str, int], optional): 連番で書き込むときの最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で書き込むときの最後のアドレス.\n            data (list, optional): 書き込むデータ(list形式).\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms).\n\n        Returns:\n            bool: 通信成功ならTrue.\n        \"\"\"\n\n        device = self.getPLCDeviceName(d_type)\n        if multi:\n            # NOTE: 複数のデータレジスタを書き込む場合\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            # NOTE: 1個のデータレジスタを書き込む場合\n            if isinstance(addr, int):\n                addr = str(addr)\n\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        # NOTE: タイムアウトまで通信トライ\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='write', data=data, option='')\n            )\n\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True\n                else:\n                    return True\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Write to plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False\n\n    def readDataFromPLCDevice(self,\n                              d_type: str = 'bit',\n                              addr: Union[str, int] = '0',\n                              addr_min: Union[str, int] = '0',\n                              addr_max: Union[str, int] = '0',\n                              multi: bool = False,\n                              timeout: int = 1000) -> Tuple[bool, list]:\n        \"\"\"\n        PLCのレジスタを読み込む関数\n\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類.\n            addr (Union[str, int], optional): 1word分読み込む時ののアドレス.\n            addr_min (Union[str, int], optional): 連番で読み込む時の最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で読み込む時の最後のアドレス.\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms)\n\n        Returns:\n            Tuple[bool, list]: 通信成功ならTrue, data.\n        \"\"\"\n\n        device = self.getPLCDeviceName(d_type)\n\n        if multi:\n            # NOTE: 複数のデータレジスタを読み込む場合\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            # NOTE: 1個のデータレジスタを読み込む場合\n            if isinstance(addr, int):\n                addr = str(addr)\n\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='read', data=[], option='')\n            )\n\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True, results['exists_data']\n                else:\n                    return True, results['exists_data']\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Read plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False, []\n\n\nclass PLCCommunication(BasePLCCommunication):\n    __version__ = '1.0.0'\n    \"\"\"\n    PLC通信@NPSZ&メカトロチームラダー\n    \"\"\"\n\n    def __init__(self, excel_path: str):\n        super().__init__()\n        self.updateAddressMapFromExcel(excel_path)\n        self.bit_eq_word: bool = True\n\n    # ===============================================================================\n    # NOTE: Excelからパラメータを取得する関数\n    # ===============================================================================\n\n    def getPLCDeviceMapFromExcel(self, xlsx_file: str, map_id: int) -> dict:\n        \"\"\"デバイスのINDEXを取得\"\"\"\n        if map_id == 0:\n            return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n        elif map_id == 1:\n            # NOTE: PLC->PCのBitデバイス\n            return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n        elif map_id == 2:\n            # NOTE: PLC->PCのWordデバイス\n            return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n        elif map_id == 3:\n            # NOTE: PC->PLCのBitデバイス\n            return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n        elif map_id == 4:\n            # NOTE: PC->PLCのWordデバイス\n            return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n        else:\n            return {}\n\n    def convertDeviceMapToAddressMap(self, device_map: dict, header_address: int) -> dict:\n        \"\"\"アドレスマップを取得\"\"\"\n        data = {}\n        for key in device_map.keys():\n            data[key] = header_address + device_map[key]\n        return data\n\n    def updateAddressMapFromExcel(self, path: str) -> None:\n        \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n        # NOTE: キーと相対アドレス0-15\n        header_address = self.getPLCDeviceMapFromExcel(path, 0)\n        self.IN_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 1)\n        self.IN_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 2)\n        self.OUT_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 3)\n        self.OUT_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 4)\n\n        # NOTE: キーと絶対アドレス\n        self.IN_BIT_AD = self.convertDeviceMapToAddressMap(self.IN_BIT_IDX,\n                                                           header_address['IN_BIT_NO'])\n        self.IN_WORD_AD = self.convertDeviceMapToAddressMap(self.IN_WORD_IDX,\n                                                            header_address['IN_WORD_NO'])\n        self.OUT_BIT_AD = self.convertDeviceMapToAddressMap(self.OUT_BIT_IDX,\n                                                            header_address['OUT_BIT_NO'])\n        self.OUT_WORD_AD = self.convertDeviceMapToAddressMap(self.OUT_WORD_IDX,\n                                                             header_address['OUT_WORD_NO'])\n\n        # NOTE: 内部保持変数 0で初期化\n        # TODO: VASTから見たOUTのBITリスト 今は6Word確保\n        self._pub_word_list = [[0 for i in range(16)] for j in range(6)]\n\n        # NOTE: エクセルからPLCのパラメータ(IP,Port,Protocol)を取得&反映\n        self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n        self.loadPLCConfiguration(self.plc_config)\n\n    def getPLCConfiguration(self) -> dict:\n        return self.plc_config\n\n    # ===============================================================================\n    # NOTE: ステータス管理の関数（内部ではBit管理、出力はWord出力）\n    # ===============================================================================\n\n    def setBitInWord(self, tag: str, key: str, val: int) -> None:\n        \"\"\"内部管理しているbitを更新\"\"\"\n        self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n    def readBitList(self, tag: str) -> Tuple[bool, list]:\n        \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n        ret, data = self.readDataFromPLCDevice(d_type='word',\n                                               addr=self.IN_BIT_AD[tag])\n        if not ret:\n            return False, [0]\n\n        bit_16 = word2bit(data[0])\n        return True, bit_16\n\n    def readBitState(self, tag: str, key: str) -> int:\n        \"\"\"Wordで読み取ってBitに分解\"\"\"\n        ret, data = self.readBitList(tag)\n        if ret:\n            s_bit = data[self.IN_BIT_IDX[key]]\n            return s_bit\n        else:\n            return -1\n\n    def writeBitsStateToWord(self, data: list, tag: str) -> bool:\n        \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n        bit_16 = data[self.OUT_BIT_IDX[tag]]\n        send_data = bit2word(bit_16)\n        addr = self.OUT_BIT_AD[tag]\n        ret = self.writeDataToPLCDevice(d_type='word',\n                                        addr=addr,\n                                        data=[send_data])\n        return ret\n\n    # ===============================================================================\n    # NOTE: 外部用のメソッド\n    # ===============================================================================\n\n    def setPcOnline(self, bit_on: bool) -> bool:\n        self.setBitInWord('STATUS_COMMON', 'PC_ONLINE', bool2int(bit_on))\n        return self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n\n    def setInspectionNGCode(self, ng_code: int) -> bool:\n        return self.writeDataToPLCDevice(d_type='word',\n                                         addr=self.OUT_WORD_AD['NG_CODE'],\n                                         data=[ng_code])\n\n    def setInspectionErrorCode(self, error_code: int) -> bool:\n        return self.writeDataToPLCDevice(d_type='word',\n                                         addr=self.OUT_WORD_AD['ERR_CODE'],\n                                         data=[error_code])\n\n    def setPcErrorCode(self, error_code: int) -> bool:\n        return self.writeDataToPLCDevice(d_type='word',\n                                                addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n                                                data=[error_code])\n\n    def setPcError(self, bit_on: bool) -> bool:\n        self.setBitInWord('STATUS_COMMON', 'PC_ERR', bool2int(bit_on))\n        return self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n\n    def sendCaptureInProgressSignalToPLC(self, in_progress: bool) -> bool:\n        \"\"\"撮像ステータスの送信\"\"\"\n        # NOTE: 撮像中はcapturing = True\n        self.setBitInWord('STATUS_COMMON', 'CAPTURING', bool2int(in_progress))\n        ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def sendInspectionInProgressSignalToPLC(self, in_progress: bool) -> bool:\n        \"\"\"検査中の信号を送信\"\"\"\n        # NOTE: W(x_out).08 検査フラグ送信\n        self.setBitInWord('STATUS_COMMON', 'INSPECTING', bool2int(in_progress))\n        ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def initializeStatus(self) -> None:\n        \"\"\"値の初期化\"\"\"\n        self.sendCaptureInProgressSignalToPLC(in_progress=False)\n        self.sendInspectionInProgressSignalToPLC(in_progress=False)\n        self.setInspectionNGCode(ng_code=0)\n        self.setInspectionErrorCode(error_code=0)\n        self.setPcErrorCode(error_code=0)\n        self.setPcError(bit_on=False)\n\n    def checkPLCAcknowledgement(self, tag: str, key: str,\n                                val: int, timeout: int = 1000) -> bool:\n        \"\"\"PLC側のリクエスト、ステータスを確認\n\n        Args:\n            tag (str): bitの属性 request, status, complete\n            key (str): bitの名前\n            val (int): bitの値(0 or 1)が一致すればTrue\n            timeout (int, optional): タイムアウト(ms)\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        timer_count = 0\n        start_time = perf_counter()\n        addr = self.IN_BIT_AD[tag]\n        success = False\n        while timer_count < timeout:\n            # NOTE: dataはリストで返却\n            ret, data = self.readDataFromPLCDevice(d_type='word', addr=addr, timeout=timeout)\n\n            # NOTE: 通信失敗したらcontinue\n            if not ret:\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n\n            # NOTE: 通信に成功したら値を確認\n            bit_16 = word2bit(data[0])\n            s_bit = bit_16[self.IN_BIT_IDX[key]]\n            if s_bit == val:\n                # NOTE: 一致\n                success = True\n                break\n            else:\n                # NOTE: 不一致\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n        return success\n\n    def getInspectionDataFromPLC(self) -> Tuple[bool, List[int]]:\n        \"\"\"各種検査に関する番号の取得\"\"\"\n        # NOTE: DM(x_in+1,+2,+3) ワーク機種\n        # NOTE: int(self.IN_WORD_AD['MODEL_NO']+1)はPOSITION_NOがない場合の配慮\n        ret, data = self.readDataFromPLCDevice(d_type='word',\n                                               addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n                                               addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n                                               multi=True)\n        if ret:\n            return True, data\n        else:\n            return False, [-1, -1, -1, -1]\n\n    def sendAlignmentDataToPLC(self, data: list) -> bool:\n        \"\"\"補正量を送信\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.writeDataToPLCDevice(d_type='word',\n                                        addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n                                        addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n                                        multi=True,\n                                        data=send_data)\n        return ret\n\n    def sendBasePositionDataToPLC(self, data: list) -> bool:\n        \"\"\"基準量を送付\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.writeDataToPLCDevice(d_type='word',\n                                        addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n                                        addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n                                        multi=True,\n                                        data=send_data)\n        return ret\n\n    def sendInspectionResultToPLC(self,\n                                  status: int,\n                                  align_data: list,\n                                  b_align_data: list = [],\n                                  ng_code: int = 1,\n                                  err_code: int = 1,\n                                  ) -> bool:\n        \"\"\"結果を送信する\n\n        Args:\n            status (int): 判定結果 ok:1 ng:2 err:3\n            align_data (list): 検出した座標\n            b_align_data (list, optional): マスター登録した座標\n            ng_code (int, optional): 画像処理のNGコード\n            err_code (int, optional): 画像処理のERRORコード\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        # NOTE: 現在位置書き込み\n        ret = self.sendAlignmentDataToPLC(align_data)\n        # NOTE: 基準位置書き込み\n        if b_align_data:\n            ret = self.sendBasePositionDataToPLC(b_align_data)\n\n        # NOTE: 判定がNGの場合NGコードを出力\n        if status == 2:\n            ret = self.setInspectionNGCode(ng_code=ng_code)\n        # NOTE: 判定がERRの場合ERRコードを出力\n        elif status == 3:\n            ret = self.setInspectionErrorCode(error_code=err_code)\n\n        # NOTE: ジャッジリストを更新\n        judge_list = [0, 0, 0, 0]\n        judge_list[status] = 1\n\n        # NOTE: 検査判定を書き込み\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_OK', judge_list[1])\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_NG', judge_list[2])\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_ERR', judge_list[3])\n        self.writeBitsStateToWord(self._pub_word_list, 'COMPLETE_COMMON')\n        # NOTE: 検査終了を伝令\n        self.sendInspectionInProgressSignalToPLC(in_progress=False)\n\n        # NOTE: PLC側で検査結果を受けとれたか確認\n        ret = self.checkPLCAcknowledgement('COMPLETE_COMMON', 'INSPECT_RECV_COMP', 1, timeout=5000)\n\n        # NOTE: Timeoutすることがたまにある、ラダー側の問題？\n        if not ret:\n            return False\n\n        # NOTE: 検査結果を初期化\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_OK', 0)\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_NG', 0)\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_ERR', 0)\n        self.writeBitsStateToWord(self._pub_word_list, 'COMPLETE_COMMON')\n\n        return True\n\n    def sendPcErrorSignalToPLC(self, error_code: int = 1) -> bool:\n        \"\"\"エラー出力\"\"\"\n        # NOTE: エラーコードを出力\n        ret1 = self.setPcErrorCode(error_code=error_code)\n        # NOTE: PCエラーステータスをON\n        ret2 = self.setPcError(bit_on=True)\n\n        if ret1 and ret2:\n            return True\n        return False\n\n    def sendPcErrorResetSignalToPLC(self) -> bool:\n        \"\"\"PCエラーをリセット\"\"\"\n        # NOTE: ステータス初期化\n        self.initializeStatus()\n        return True\n\n    def sendHeartbeatSignalToPLC(self, pre_beat: bool) -> bool:\n        \"\"\"ラズパイの生存をPLC側に通達\"\"\"\n        if pre_beat:\n            self.setPcOnline(bit_on=False)\n            return False\n        else:\n            self.setPcOnline(bit_on=True)\n            return True\n\n    def sendCustomDataToPLC(self, data: list) -> bool:\n        \"\"\"カスタムデータ(int)を送信 9x2 = 18\"\"\"\n        # NOTE: 一応intに変換\n        try:\n            data = [int(v) for v in data]\n            # NOTE: 符号付きの形式に変換\n            send_data = convert_signed(list_negative=data, word_count=2)\n            ret = self.writeDataToPLCDevice(d_type='word',\n                                            addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'] + 18,\n                                            addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'] + 35,\n                                            multi=True,\n                                            data=send_data)\n            return ret\n        except Exception as e:\n            print(e)\n            return False\n\n\n# class PLCCommunicationForNMOJ(BasePLCCommunication):\n#     __version__ = '1.0.0'\n#     \"\"\"\n#     PLC通信@NMOJ&昔のラダー\n#     サッサとラダーを更新して捨て去りたい\n#     \"\"\"\n\n#     def __init__(self, excel_path: str):\n#         super().__init__()\n#         self.updateAddressMapFromExcel(excel_path)\n\n#     # ===============================================================================\n#     # NOTE: Excelからパラメータを取得する関数\n#     # ===============================================================================\n\n#     def getPLCDeviceMapFromExcel(self, xlsx_file: str, map_id: int) -> dict:\n#         \"\"\"デバイスのINDEXを取得\"\"\"\n#         if map_id == 0:\n#             return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n#         elif map_id == 1:\n#             # NOTE: PLC->PCのBitデバイス\n#             return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n#         elif map_id == 2:\n#             # NOTE: PLC->PCのWordデバイス\n#             return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n#         elif map_id == 3:\n#             # NOTE: PC->PLCのBitデバイス\n#             return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n#         elif map_id == 4:\n#             # NOTE: PC->PLCのWordデバイス\n#             return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n#         else:\n#             return {}\n\n#     def convertDeviceMapToAddressMap(self, device_map: dict, header_address: int) -> dict:\n#         \"\"\"アドレスマップを取得\"\"\"\n#         data = {}\n#         for key in device_map.keys():\n#             data[key] = header_address + device_map[key]\n#         return data\n\n#     def updateAddressMapFromExcel(self, path: str) -> None:\n#         \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n#         # NOTE: キーと相対アドレス0-15\n#         header_address = self.getPLCDeviceMapFromExcel(path, 0)\n#         self.IN_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 1)\n#         self.IN_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 2)\n#         self.OUT_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 3)\n#         self.OUT_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 4)\n\n#         # NOTE: キーと絶対アドレス\n#         self.IN_BIT_AD = self.convertDeviceMapToAddressMap(self.IN_BIT_IDX,\n#                                                            header_address['IN_BIT_NO'])\n#         self.IN_WORD_AD = self.convertDeviceMapToAddressMap(self.IN_WORD_IDX,\n#                                                             header_address['IN_WORD_NO'])\n#         self.OUT_BIT_AD = self.convertDeviceMapToAddressMap(self.OUT_BIT_IDX,\n#                                                             header_address['OUT_BIT_NO'])\n#         self.OUT_WORD_AD = self.convertDeviceMapToAddressMap(self.OUT_WORD_IDX,\n#                                                              header_address['OUT_WORD_NO'])\n\n#         # NOTE: 内部保持変数 0で初期化\n#         # TODO: VASTから見たOUTのBITリスト 今は6Word確保\n#         self._pub_word_list = [[0 for i in range(16)] for j in range(6)]\n\n#         # NOTE: エクセルからPLCのパラメータ(IP,Port,Protocol)を取得&反映\n#         self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n#         self.loadPLCConfiguration(self.plc_config)\n\n#     def getPLCConfiguration(self) -> dict:\n#         return self.plc_config\n\n#     # ===============================================================================\n#     # NOTE: ステータス管理の関数（内部ではBit管理、出力はWord出力）\n#     # ===============================================================================\n\n#     def setBitInWord(self, tag: str, key: str, val: int) -> None:\n#         \"\"\"内部管理しているbitを更新\"\"\"\n#         self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n#     def readBitList(self, tag: str) -> Tuple[bool, list]:\n#         \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n#         # NOTE: NMOJのラダーはbitデバイスで読取\n#         ret, data = self.readDataFromPLCDevice(d_type='bit',\n#                                                addr=self.IN_BIT_AD[tag])\n#         if not ret:\n#             return False, [0]\n\n#         bit_16 = word2bit(data[0])\n#         return True, bit_16\n\n#     def readBitState(self, tag: str, key: str) -> int:\n#         \"\"\"Wordで読み取ってBitに分解\"\"\"\n#         ret, data = self.readBitList(tag)\n#         if ret:\n#             s_bit = data[self.IN_BIT_IDX[key]]\n#             return s_bit\n#         else:\n#             return -1\n\n#     def writeBitsStateToWord(self, data: list, tag: str) -> bool:\n#         \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n#         bit_16 = data[self.OUT_BIT_IDX[tag]]\n#         send_data = bit2word(bit_16)\n#         addr = self.OUT_BIT_AD[tag]\n#         # NOTE: NMOJのラダーはbitデバイスに書き込み\n#         ret = self.writeDataToPLCDevice(d_type='bit',\n#                                         addr=addr,\n#                                         data=[send_data])\n#         return ret\n\n#     # ===============================================================================\n#     # NOTE: 外部用のメソッド\n#     # ===============================================================================\n\n#     def setPcOnline(self, bit_on: bool) -> bool:\n#         self.setBitInWord('STATUS', 'PC_ONLINE', bool2int(bit_on))\n#         return self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#     def setInspectionNGCode(self, ng_code: int) -> bool:\n#         return self.writeDataToPLCDevice(d_type='word',\n#                                          addr=self.OUT_WORD_AD['NG_CODE'],\n#                                          data=[ng_code])\n\n#     def setInspectionErrorCode(self, error_code: int) -> bool:\n#         return self.writeDataToPLCDevice(d_type='word',\n#                                          addr=self.OUT_WORD_AD['ERR_CODE'],\n#                                          data=[error_code])\n\n#     def setPcErrorCode(self, error_code: int) -> bool:\n#         return self.writeDataToPLCDevice(d_type='word',\n#                                                 addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n#                                                 data=[error_code])\n\n#     def setPcError(self, bit_on: bool) -> bool:\n#         self.setBitInWord('STATUS', 'PC_ERR', bool2int(bit_on))\n#         return self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n\n#     def sendCaptureInProgressSignalToPLC(self, in_progress: bool) -> bool:\n#         \"\"\"撮像ステータスの送信\"\"\"\n#         # NOTE: 撮像中はcapturing = True\n#         self.setBitInWord('STATUS', 'CAPTURE', bool2int(in_progress))\n#         ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         return ret\n\n#     def sendInspectionInProgressSignalToPLC(self, in_progress: bool) -> bool:\n#         \"\"\"検査中の信号を送信\"\"\"\n#         # NOTE: W(x_out).08 検査フラグ送信\n#         self.setBitInWord('STATUS', 'INSPECTING', bool2int(in_progress))\n#         ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         return ret\n\n#     def initializeStatus(self) -> None:\n#         \"\"\"値の初期化\"\"\"\n#         self.sendCaptureInProgressSignalToPLC(in_progress=False)\n#         self.sendInspectionInProgressSignalToPLC(in_progress=False)\n#         self.setInspectionNGCode(ng_code=0)\n#         self.setInspectionErrorCode(error_code=0)\n#         self.setPcErrorCode(error_code=0)\n#         self.setPcError(bit_on=False)\n\n#     def checkPLCAcknowledgement(self, tag: str, key: str,\n#                                 val: int, timeout: int = 1000) -> bool:\n#         \"\"\"PLC側のリクエスト、ステータスを確認\n\n#         Args:\n#             tag (str): bitの属性 request, status, complete\n#             key (str): bitの名前\n#             val (int): bitの値(0 or 1)が一致すればTrue\n#             timeout (int, optional): タイムアウト(ms)\n\n#         Returns:\n#             bool: _description_\n#         \"\"\"\n#         timer_count = 0\n#         start_time = perf_counter()\n#         addr = self.IN_BIT_AD[tag]\n#         success = False\n#         while timer_count < timeout:\n#             # NOTE: dataはリストで返却\n#             ret, data = self.readDataFromPLCDevice(d_type='bit', addr=addr, timeout=timeout)\n\n#             # NOTE: 通信失敗したらcontinue\n#             if not ret:\n#                 timer_count = int((perf_counter() - start_time) * 1000)\n#                 continue\n\n#             # NOTE: 通信に成功したら値を確認\n#             bit_16 = word2bit(data[0])\n#             s_bit = bit_16[self.IN_BIT_IDX[key]]\n#             if s_bit == val:\n#                 # NOTE: 一致\n#                 success = True\n#                 break\n#             else:\n#                 # NOTE: 不一致\n#                 timer_count = int((perf_counter() - start_time) * 1000)\n#                 continue\n#         return success\n\n#     def checkCommunicationWithPLC(self) -> Tuple[bool, str]:\n#         \"\"\"Ready信号に対する応答\"\"\"\n#         # NOTE: 初回起動時、原点復帰後に実施\n\n#         # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n#         self.setBitInWord('STATUS', 'PC_ONLINE', 0)\n#         self.setBitInWord('STATUS', 'PC_READY', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE: W(x_out).08-11 <Write> プログラム起動時に初期化（検査系）\n#         self.setBitInWord('STATUS', 'INSPECTING', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_OK', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_NG', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_ERR', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE:  W(x_out).00 <Write> PCの電源がONであることをPLCに通達\n#         self.setBitInWord('STATUS', 'PC_ONLINE', 1)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE: W(x_in).01 <Read> Request Readyがオンになっていることを確認\n#         ret = self.checkPLCAcknowledgement('REQ', 'READY', 1, timeout=5000)\n#         if not ret:\n#             logger.debug('Timeout Request Ready [on]')\n#             return False, 'Timeout Request Ready [on]'\n\n#         # NOTE: W(x_out).01 <Write> PLC側のW(2).01を確認したことを通達\n#         self.setBitInWord('STATUS', 'PC_READY', 1)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE: W(x_in).01 <Read> PLC側が通達を確認\n#         ret = self.checkPLCAcknowledgement('REQ', 'READY', 0, timeout=5000)\n#         if not ret:\n#             logger.debug('Timeout Request Ready [off]')\n#             return False, 'Timeout Request Ready [off]'\n\n#         # NOTE: W(x_out).01 <Write> 初期通信確認終了\n#         self.setBitInWord('STATUS', 'PC_READY', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         logger.debug('Ready Sequence Complete')\n#         return True, ''\n\n#     def getInspectionDataFromPLC(self) -> Tuple[bool, List[int]]:\n#         \"\"\"各種検査に関する番号の取得\"\"\"\n#         # NOTE: DM(x_in+1,+2,+3) ワーク機種\n#         # NOTE: int(self.IN_WORD_AD['MODEL_NO']+1)はPOSITION_NOがない場合の配慮\n#         ret, data = self.readDataFromPLCDevice(d_type='word',\n#                                                addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n#                                                addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n#                                                multi=True)\n#         if ret:\n#             return True, data\n#         else:\n#             return False, [-1, -1, -1, -1]\n\n#     def sendCustomDataToPLC(self, data: list) -> bool:\n#         \"\"\"カスタムデータを送信 9x2 = 18\"\"\"\n#         # NOTE: 一応intに変換\n#         data = [int(v) for v in data]\n#         # NOTE: 符号付きの形式に変換\n#         send_data = convert_signed(data)\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'] + 18,\n#                                         addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'] + 35,\n#                                         multi=True,\n#                                         data=send_data)\n#         return ret\n\n#     def sendAlignmentDataToPLC(self, data: list) -> bool:\n#         \"\"\"補正量を送信\"\"\"\n#         # NOTE: 一応intに変換\n#         data = [int(v) for v in data]\n#         # NOTE: 符号付きの形式に変換\n#         send_data = convert_signed(data)\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n#                                         addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n#                                         multi=True,\n#                                         data=send_data)\n#         return ret\n\n#     def sendBasePositionDataToPLC(self, data: list) -> bool:\n#         \"\"\"基準量を送付\"\"\"\n#         # NOTE: 一応intに変換\n#         data = [int(v) for v in data]\n#         # NOTE: 符号付きの形式に変換\n#         send_data = convert_signed(data)\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n#                                         addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n#                                         multi=True,\n#                                         data=send_data)\n#         return ret\n\n#     def sendNumOfWorkPiece(self, num_work: int) -> bool:\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr=self.OUT_WORD_AD['NUM_WORK'],\n#                                         data=[int(num_work)])\n#         return ret\n\n#     def sendInspectionResultToPLC(self,\n#                                   status: int,\n#                                   align_data: list,\n#                                   b_align_data: list = [],\n#                                   ng_code: int = 1,\n#                                   err_code: int = 1,\n#                                   ) -> bool:\n#         \"\"\"結果を送信する\n\n#         Args:\n#             status (int): 判定結果 ok:1 ng:2 err:3\n#             align_data (list): 検出した座標\n#             b_align_data (list, optional): マスター登録した座標\n#             ng_code (int, optional): 画像処理のNGコード\n#             err_code (int, optional): 画像処理のERRORコード\n\n#         Returns:\n#             bool: _description_\n#         \"\"\"\n#         # NOTE: 現在位置書き込み\n#         ret = self.sendAlignmentDataToPLC(align_data)\n#         # NOTE: 基準位置書き込み\n#         if b_align_data:\n#             ret = self.sendBasePositionDataToPLC(b_align_data)\n\n#         # NOTE: 判定がNGの場合NGコードを出力\n#         if status == 2:\n#             ret = self.setInspectionNGCode(ng_code=ng_code)\n#         # NOTE: 判定がERRの場合ERRコードを出力\n#         elif status == 3:\n#             ret = self.setInspectionErrorCode(error_code=err_code)\n\n#         # NOTE: ジャッジリストを更新\n#         judge_list = [0, 0, 0, 0]\n#         judge_list[status] = 1\n\n#         # NOTE: 検査判定を書き込み\n#         self.setBitInWord('STATUS', 'INSPECT_OK', judge_list[1])\n#         self.setBitInWord('STATUS', 'INSPECT_NG', judge_list[2])\n#         self.setBitInWord('STATUS', 'INSPECT_ERR', judge_list[3])\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         # NOTE: 検査終了を伝令\n#         self.sendInspectionInProgressSignalToPLC(in_progress=False)\n\n#         # NOTE: PLC側で検査結果を受けとれたか確認\n#         ret = self.checkPLCAcknowledgement('REQ', 'INSPECT_RCV', 1, timeout=5000)\n#         if not ret:\n#             return False\n\n#         # NOTE: 検査結果を初期化\n#         self.setBitInWord('STATUS', 'INSPECT_OK', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_NG', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_ERR', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         return True\n\n#     def sendPcErrorSignalToPLC(self, error_code: int = 1) -> bool:\n#         \"\"\"エラー出力\"\"\"\n#         # NOTE: エラーコードを出力\n#         ret1 = self.setPcErrorCode(error_code=error_code)\n#         # NOTE: PCエラーステータスをON\n#         ret2 = self.setPcError(bit_on=True)\n\n#         if ret1 and ret2:\n#             return True\n#         return False\n\n#     def sendPcErrorResetSignalToPLC(self) -> bool:\n#         \"\"\"PCエラーをリセット\"\"\"\n#         # NOTE: ステータス初期化\n#         self.initializeStatus()\n#         return True\n\n#     def sendHeartbeatSignalToPLC(self, pre_beat: bool) -> bool:\n#         \"\"\"ラズパイの生存をPLC側に通達\"\"\"\n#         if pre_beat:\n#             self.setPcOnline(bit_on=False)\n#             return False\n#         else:\n#             self.setPcOnline(bit_on=True)\n#             return True\n\n\nif __name__ == \"__main__\":\n    def set_time_from_plc(time_data: dict) -> None:\n        import subprocess\n\n        # NOTE: ERROR_CODEが-1の時, 通信失敗\n        if time_data.get('error_code') == -1:\n            return\n\n        # NOTE: 一応仮でデータが入るようにしておく\n        [year_, month_, day_, hour_, minutes_, second_, micro_second_] \\\n            = time_data.get('exists_data', [2023, 7, 7, 12, 12, 12, 12])\n\n        subprocess.run([\n            \"sudo\",\n            \"date\",\n            \"-s\",\n            \"{:02}/{:02} {:02}:{:02} 20{:02}\".format(\n                month_,\n                day_,\n                hour_,\n                minutes_,\n                year_\n            )\n        ])\n\n    plc = BasePLCCommunication()\n\n    conf = PLCConfiguration(ip='192.168.1.11',\n                            port='9600',\n                            manufacturer='omron',\n                            series='',\n                            plc_protocol='fins',\n                            transport_protocol='udp',\n                            bit='W',\n                            word='DM',\n                            double_word='',)\n\n    plc.loadPLCConfiguration(conf)\n\n    plc.getTimeFromPLC()\n",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\old\\plc\\api": {
        "command_checker.py": "import binascii\nimport os\n\n# NOTE: command\nSA1_INDEX = 14\nSA2_INDEX = 16\n# NOTE: response\nDA1_INDEX = 8\nDA2_INDEX = 10\n# NOTE: identification\nSID_INDEX = 18\nCODE_INDEX = 20\n\n\ndef get_random_sid_str(bytes: int = 1) -> str:\n    \"\"\"SIDをランダムに設定\"\"\"\n    return str(binascii.b2a_hex(os.urandom(bytes)), 'ascii')\n\n\ndef get_random_sid(bytes: int = 1) -> bytes:\n    \"\"\"SIDをランダムに設定\"\"\"\n    return os.urandom(bytes)\n\n\ndef check_command(send_cmd: list, recv_cmd: list) -> bool:\n    \"\"\"送った指令に対する結果であるか、\n    レスポンスの文字列を見て確認する(Omron限定)\n    response\n    0: recv command\n    2: send command [command]\n    3: error command\n\n    Args:\n        response (list): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    # print(send_cmd, recv_cmd)\n\n    # check DA1 == SA1\n    if send_cmd[SA1_INDEX:SA1_INDEX + 2] != recv_cmd[DA1_INDEX:DA1_INDEX + 2]:\n        return False\n\n    # check SA2 == DA2\n    if send_cmd[SA2_INDEX:SA2_INDEX + 2] != recv_cmd[DA2_INDEX:DA2_INDEX + 2]:\n        return False\n\n    # check sid\n    if send_cmd[SID_INDEX:SID_INDEX + 2] != recv_cmd[SID_INDEX:SID_INDEX + 2]:\n        return False\n\n    # check command\n    if send_cmd[CODE_INDEX:CODE_INDEX + 4] != recv_cmd[CODE_INDEX:CODE_INDEX + 4]:\n        return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(get_random_sid(1))\n",
        "convert_format.py": "import sys\nimport re\nimport itertools\nimport more_itertools\ntry:\n    import logger\n    import global_vars\nexcept Exception:\n    from . import logger\n    from . import global_vars\nlogger = logger.get_module_logger(__name__)\n\n\ndef make_crc(orgcommand: bytes) -> bytes:\n    # 最初のCRCレジスタ値をFFFFhに設定\n    crc_registor = 0xFFFF\n    for data_byte in orgcommand:\n        # CRCレジスタとデータバイトのXOR\n        tmp = crc_registor ^ data_byte\n        # シフト回数を記憶\n        shift_num = 0\n        # シフトが 8回になるまで繰り返す\n        while(shift_num < 8):\n            if(tmp & 1 == 1):  # 桁あふれが1なら\n                tmp = tmp >> 1\n                shift_num += 1\n                tmp = 0xA001 ^ tmp\n            else:\n                tmp = tmp >> 1\n                shift_num += 1\n        # 計算結果をcrc_registorにセット\n        crc_registor = tmp\n    # 計算結果をbytes型へ変換\n    return crc_registor.to_bytes(2, 'little')\n\n\ndef convert_integer_to_double_hex(data: list, *, endian: str = 'big') -> list:\n    # Ex)\n    # big endian   : [10, 11, 12, 13] -> [2826, 3340]\n    # little endian: [10, 11, 12, 13] -> [2571, 3085]\n    convert_data = []\n    if endian in [\"big\", \"big_endian\"]:\n        for i in range(0, len(data), 2):\n            try:\n                convert_data.append(\n                    int(format(data[i + 1], '02x') + format(data[i], '02x'), 16))\n            except Exception:\n                convert_data.append(\n                    int(format(0, '02x') + format(data[i], '02x'), 16))\n    else:\n        for i in range(0, len(data), 2):\n            try:\n                convert_data.append(\n                    int(format(data[i], '02x') + format(data[i + 1], '02x'), 16))\n            except Exception:\n                convert_data.append(\n                    int(format(data[i], '02x') + format(0, '02x'), 16))\n\n    logger.debug('{}, {}'.format(sys._getframe().f_code.co_name, convert_data))\n    return convert_data\n\n\ndef convert_double_hex_to_integer(data: list, *, dhex: bool = False, endian: str = 'big') -> list:\n    # Ex)\n    # big endian   : [2571, 3085] -> [11, 10, 13, 12]\n    # little endian: [2571, 3085] -> [10, 11, 12, 13]\n    convert_data = []\n    if endian in [\"big\", \"big_endian\"]:\n        for i in range(len(data)):\n            string_data = format(data[i], '0x').zfill(\n                int(len(format(data[i], '0x')) + len(format(data[i], '0x')) % 2))\n            try:\n                convert_data.extend(\n                    [int(string_data[-2:], 16), int(string_data[-4:-2], 16)])\n            except Exception:\n                if dhex:\n                    convert_data.extend(\n                        [int(string_data[-2:], 16), 0])\n                else:\n                    convert_data.extend([int(string_data[-2:], 16)])\n    else:\n        for i in range(len(data)):\n            string_data = format(data[i], '0x').zfill(\n                int(len(format(data[i], '0x')) + len(format(data[i], '0x')) % 2))\n            try:\n                convert_data.extend(\n                    [int(string_data[-4:-2], 16), int(string_data[-2:], 16)])\n            except Exception:\n                if dhex:\n                    convert_data.extend(\n                        [0, int(string_data[-2:], 16)])\n                else:\n                    convert_data.extend([int(string_data[-2:], 16)])\n\n    logger.debug('{}, {}'.format(sys._getframe().f_code.co_name, convert_data))\n    return convert_data\n\n\ndef check_string_and_convert_dhex(data: list, byte_order: str, option: str) -> list:\n    try:\n        # check: data is \"string\" or \"integer\"\n        string_data = list(itertools.chain.from_iterable(\n            list(map(lambda x: list(x), data))))\n    except Exception:\n        new_data = data\n        option = option\n    else:\n        # case string\n        cmd_data = list(map(lambda x: ord(x), string_data))\n        try:\n            tmp_data = list(more_itertools.chunked(cmd_data, 2))\n        except Exception:\n            tmp_data = [cmd_data[i: i + 2] for i in range(0, len(cmd_data), 2)]\n        finally:\n            new_data = list(itertools.chain.from_iterable(list(\n                map(lambda x: convert_integer_to_double_hex(x, endian=byte_order), tmp_data))))\n            option = global_vars.g_STRING_OPTION[0]\n    finally:\n        return new_data, option\n\n\ndef check_hex_and_convert_integer(data: list, byte_order: str, *, dhex: bool = False, zero_padding: bool = True) -> list:\n    try:\n        tmp_data = [int(x, 16) for x in data]\n        print(tmp_data)\n    except Exception:\n        new_data = data\n    else:\n        if dhex:\n            new_data = convert_double_hex_to_integer(\n                tmp_data, dhex=dhex, endian=byte_order)\n        else:\n            new_data = tmp_data\n    finally:\n        return new_data\n\n\ndef convert_integer_to_another_base_number_as_string(value: int, base: int) -> str:\n    if (int(value / base)):\n        return convert_integer_to_another_base_number_as_string(int(value / base), base) + str(value % base)\n    return str(value % base)\n\n\ndef convert_number_as_string_to_another_base_and_hex_notation(value: str, base: int, *, paddings=0):\n    # 数値(string)を指定した底に変換したあと、16進数で表示する\n    try:\n        conv_hex = '0{}x'.format(paddings)\n        res_value = ''.join([format(int(i, base), conv_hex) for i in re.split(\n            '{}{}{}'.format('(', '.' * base, ')'), value) if i != ''])\n    except Exception:\n        res_value = value\n    return res_value\n\n\ndef convert_negative_integer_to_signed_hex(list_negative: list, *, word_count: int = 2) -> list:\n    # Convert from negative value to signed hexadecimal.\n    list_response = []\n    for x in list_negative:\n        r_list = []\n        value = x\n        for i in range(int(word_count)):\n            value, r = divmod(value, 65536)\n            if int(x) >= 0:\n                r_list.append(int(format(int(r), 'x'), 16))\n            else:\n                r_list.append(int(format(int(r) & 0xffff, 'x'), 16))\n        if int(value) != 0 and int(value) != -1:\n            if int(x) >= 0:\n                hex_value = [int(format(int(int(value)), 'x'), 16)]\n            else:\n                hex_value = [int(format(int(int(value)) & 0xffff, 'x'), 16)]\n        else:\n            hex_value = []\n        r_list.reverse()\n        hex_value.extend(r_list)\n        hex_value.reverse()\n        list_response.extend(hex_value)\n    return list_response\n\n\ndef convert_date_format(plc_protocol, cmd_data, res_element):\n    if cmd_data[\"option\"] in global_vars.g_TIME_OPTION:\n        if plc_protocol[\"manufacture\"] in global_vars.g_MITSUBISHI:\n            if len(res_element) >= 4:\n                exists_data = []\n                for data in res_element:\n                    try:\n                        exists_data.append(int(data, 16))\n                    except Exception:\n                        exists_data.append(int(data))\n                res_element = exists_data\n        elif plc_protocol[\"manufacture\"] in global_vars.g_PANASONIC:\n            if len(res_element) >= 4:\n                if plc_protocol[\"series\"] in [\"fp7\", \"7\"]:\n                    exists_data = []\n                    for data in res_element:\n                        exists_data.append(int(data))\n                    res_element = exists_data\n                else:\n                    exists_data = [\n                        int(res_element[2][:2]),  # year\n                        int(res_element[2][2:]),  # month\n                        int(res_element[1][:2]),  # day\n                        int(res_element[1][2:]),  # hour\n                        int(res_element[0][:2]),  # minute\n                        int(res_element[0][2:]),  # second\n                        int(res_element[3][2:])   # weekday\n                    ]\n                    res_element = exists_data\n        elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n            exists_data = []\n            for data in res_element:\n                exists_data.append(int(data))\n            res_element = exists_data\n        elif plc_protocol[\"manufacture\"] in global_vars.g_OMRON:\n            exists_data = []\n            for data in res_element:\n                exists_data.append(int(data))\n            res_element = exists_data\n    return res_element\n",
        "device_list.py": "import traceback\nimport sys\ntry:\n    import global_vars\n    import logger\nexcept Exception:\n    from . import global_vars\n    from . import logger\n\nlogger = logger.get_module_logger(__name__)\n\n\ndef devicelist(\n        manufacture: str, protocol: str, series: str, *,\n        transport_layer: str = 'tcp', period_index: int = None) -> (dict, int, int, str):\n    # A list of plc devices. (OLD VERSION)\n    # '<device name of PLC>':['decimal system', 'device code', 'data unit', (offset)]\n    try:\n        # ==== Mitsubishi Electric ====\n        if manufacture in global_vars.g_MITSUBISHI:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL1E:\n                transfer_limit = 255\n                prefix_bit = 4\n                dict_devices = {\n                    'D': ['10', (0x44, 0x20), 'w'], 'R': ['10', (0x52, 0x20), 'w'], 'TN': ['10', (0x54, 0x4E), 'w'], 'TS': ['10', (0x54, 0x53), 'b'],\n                    'CN': ['10', (0x43, 0x4E), 'w'], 'CS': ['10', (0x43, 0x53), 'b'], 'X': ['16', (0x58, 0x20), 'b'], 'Y': ['16', (0x59, 0x20), 'b'],\n                    'M': ['10', (0x4D, 0x20), 'b'], 'S': ['10', (0x53, 0x20), 'b']\n                }\n            elif protocol in global_vars.g_MCPROTOCOL3E:\n                if series in global_vars.g_SERIES_IQR:\n                    transfer_limit = 960\n                    prefix_bit = 22\n                    dict_devices = {\n                        'SM': ['10', 0x0091, 'b'], 'SD': ['10', 0x00A9, 'w'], 'X': ['16', 0x009C, 'b'], 'Y': ['16', 0x009D, 'b'],\n                        'M': ['10', 0x0090, 'b'], 'L': ['10', 0x0092, 'b'], 'F': ['10', 0x0093, 'b'], 'V': ['10', 0x0094, 'b'],\n                        'B': ['16', 0x00A0, 'b'], 'D': ['10', 0x00A8, 'w'], 'W': ['16', 0x00B4, 'w'], 'TS': ['10', 0x00C1, 'b'],\n                        'TC': ['10', 0x00C0, 'b'], 'TN': ['10', 0x00C0, 'w'], 'STS': ['10', 0x00C7, 'b'], 'STC': ['10', 0x00C6, 'b'],\n                        'STN': ['10', 0x00C8, 'w'], 'CS': ['10', 0x00C4, 'b'], 'CC': ['10', 0x00C3, 'b'], 'CN': ['10', 0x00C5, 'w'],\n                        'SB': ['16', 0x00A1, 'b'], 'SW': ['16', 0x00B5, 'w'], 'DX': ['16', 0x00A2, 'b'], 'DY': ['16', 0x00A3, 'b'],\n                        'Z': ['10', 0x00CC, 'w'], 'R': ['10', 0x00AF, 'w'], 'ZR': ['16', 0x00B0, 'w'], 'LTS': ['10', 0x0051, 'b'],\n                        'LTC': ['10', 0x0050, 'b'], 'LTN': ['10', 0x0052, 'dw'], 'LSTS': ['10', 0x0059, 'b'], 'LSTC': ['10', 0x0058, 'b'],\n                        'LSTN': ['10', 0x005A, 'dw'], 'LCS': ['10', 0x0055, 'b'], 'LCC': ['10', 0x0054, 'b'], 'LCN': ['10', 0x0056, 'dw'],\n                        'LZ': ['10', 0x00CC, 'dw'], 'RD': ['10', 0x002C, 'w']\n                    }\n                else:\n                    transfer_limit = 960\n                    prefix_bit = 22\n                    dict_devices = {\n                        'SM': ['10', 0x91, 'b'], 'SD': ['10', 0xA9, 'w'], 'X': ['16', 0x9C, 'b'], 'Y': [16, 0x9D, 'b'],\n                        'M': ['10', 0x90, 'b'], 'L': ['10', 0x92, 'b'], 'F': ['10', 0x93, 'b'], 'V': [10, 0x94, 'b'],\n                        'B': ['16', 0xA0, 'b'], 'D': ['10', 0xA8, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': [10, 0xC1, 'b'],\n                        'TC': ['10', 0xC0, 'b'], 'TN': ['10', 0xC0, 'w'], 'STS': ['10', 0xC7, 'b'], 'STC': [10, 0xC6, 'b'],\n                        'STN': ['10', 0xC8, 'w'], 'CS': ['10', 0xC4, 'b'], 'CC': ['10', 0xC3, 'b'], 'CN': [10, 0xC5, 'w'],\n                        'SB': ['16', 0xA1, 'b'], 'SW': ['16', 0xB5, 'w'], 'DX': ['16', 0xA2, 'b'], 'DY': [16, 0xA3, 'b'],\n                        'Z': ['10', 0xCC, 'w'], 'R': ['10', 0xAF, 'w'], 'ZR': ['16', 0xB0, 'w']\n                    }\n            elif protocol in global_vars.g_MCPROTOCOL4E:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            # ikeikeike\n            elif protocol in global_vars.g_COMPUTERLINK:\n                transfer_limit = 99\n                prefix_bit = 5\n                dict_devices = {\n                    'X': ['ascii', b'X', 'b'], 'Y': ['ascii', b'Y', 'b'],\n                    'M': ['ascii', b'M', 'b'], 'L': ['ascii', b'L', 'b'], 'F': ['ascii', b'F', 'b'], 'V': ['ascii', 'V', 'b'],\n                    'B': ['ascii', b'B', 'b'], 'D': ['ascii', b'D', 'w'], 'W': ['ascii', b'W', 'w'],\n                    'Z': ['ascii', b'Z', 'w'], 'R': ['ascii', b'R', 'w']\n                }\n            # ikeikeike\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Keyence\n        elif manufacture in global_vars.g_KEYENCE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                transfer_limit = 960\n                prefix_bit = 22\n                dict_devices = {\n                    'R': ['1010', 0x9c, 'b'], 'B': ['16', 0xA0, 'b'], 'MR': ['1010', 0x90, 'b'], 'LR': ['1010', 0x92, 'b'],\n                    'CR': ['1010', 0x91, 'b'], 'CM': ['10', 0xA9, 'w'], 'DM': ['10', 0xA8, 'w'], 'EM': ['10', 0xA8, 'w'],\n                    'FM': ['10', 0xAF, 'w'], 'ZF': ['16', 0xB0, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': ['10', 0xC1, 'b'],\n                    'TC': ['10', 0xC2, 'b'], 'CC': ['10', 0xC5, 'b'], 'CS': ['10', 0xC4, 'b'], 'D': ['10', 0xA8, 'w'],\n                    'M': ['1010', 0x90, 'b'], 'T': ['10', 0xC1, 'b'], 'C': ['10', 0xC5, 'b'],\n                }\n\n            elif protocol in global_vars.g_HOSTLINK:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Panasonic\n        elif manufacture in global_vars.g_PANASONIC:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                transfer_limit = 960\n                prefix_bit = 22\n                dict_devices = {\n                    'X': ['1016', 0x9C, 'b'], 'Y': ['1016', 0x9D, 'b'], 'L': ['1016', 0xA0, 'b'], 'R': ['1016', 0x90, 'b'],\n                    'R1': ['1016', 0x92, 'b'], 'DT': ['10', 0xA8, 'w'], 'LD': ['10', 0xB4, 'w'], 'EVT': ['10', 0xC2, 'w'],\n                    'T': ['10', 0xC1, 'b'], 'EVC': ['10', 0xC5, 'w'], 'C': ['10', 0xC4, 'b'], 'SR': ['1016', 0x91, 'b', 9000],\n                    'SD': ['10', 0xA9, 'w', 90000], 'SDT': ['10', 0xA9, 'w', 90000], 'D': ['10', 0xA8, 'w'],\n                }\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Omron\n        elif manufacture in global_vars.g_OMRON:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_FINS:\n                transfer_limit = 498\n                if transport_layer in global_vars.g_UDPIP:\n                    prefix_bit = 28\n                elif transport_layer in global_vars.g_TCPIP:\n                    prefix_bit = 76\n                else:\n                    prefix_bit = 76\n                dict_devices = {\n                    'CIO': ['10.10', 0x30, 'b'], 'W': ['10.10', 0x31, 'b'], 'H': ['10.10', 0x32, 'b'], 'A': ['10.10', 0x33, 'b'],\n                    'DM': ['10.10', 0x02, 'b'], 'TK': ['10.10', 0x46, 'b'], 'IR': ['10', 0xDC, 'w'], 'DR': ['10', 0xBC, 'w'],\n                    'EM0': ['10.10', 0xA0, 'b'], 'EM1': ['10.10', 0xA1, 'b'], 'EM2': ['10.10', 0xA2, 'b'], 'EM3': ['10.10', 0xA3, 'b'], 'EM4': ['10.10', 0xA4, 'b'],\n                    'EM5': ['10.10', 0xA5, 'b'], 'EM6': ['10.10', 0xA6, 'b'], 'EM7': ['10.10', 0xA7, 'b'], 'EM8': ['10.10', 0xA8, 'b'], 'EM9': ['10.10', 0xA9, 'b'],\n                    'EMA': ['10.10', 0xAA, 'b'], 'EMB': ['10.10', 0xAB, 'b'], 'EMC': ['10.10', 0xAC, 'b'], 'EMD': ['10.10', 0xAD, 'b'], 'EME': ['10.10', 0xAE, 'b'],\n                    'EMF': ['10.10', 0xAF, 'b'], 'EM10': ['10.10', 0x60, 'b'], 'EM11': ['10.10', 0x61, 'b'], 'EM12': ['10.10', 0x62, 'b'], 'EM13': [10.10, 0x63, 'b'],\n                    'EM14': ['10.10', 0x64, 'b'], 'EM15': ['10.10', 0x65, 'b'], 'EM16': ['10.10', 0x66, 'b'], 'EM17': ['10.10', 0x67, 'b'], 'EM18': ['10.10', 0x68, 'b'],\n                    'EMCB': ['10', 0x98, 'w'],\n                    'TIMS': ['10', 0x09, 'w'], 'CNTS': ['10', 0x09, 'w', 8000], 'TIMN': ['10', 0x89, 'w'], 'CNTN': ['10', 0x89, 'w', 8000],\n                    'D': ['10.10', 0x82, 'b'],\n                }\n                if period_index is None:\n                    dict_update_devices = {\n                        'CIO': ['10', 0xB0, 'w'], 'W': ['10', 0xB1, 'w'], 'H': ['10', 0xB2, 'w'], 'A': ['10', 0xB3, 'w'],\n                        'DM': ['10', 0x82, 'w'], 'TK': ['10', 0x46, 'w'],\n                        'EM0': ['10', 0xA0, 'w'], 'EM1': ['10', 0xA1, 'w'], 'EM2': ['10', 0xA2, 'w'], 'EM3': ['10', 0xA3, 'w'], 'EM4': ['10', 0xA4, 'w'],\n                        'EM5': ['10', 0xA5, 'w'], 'EM6': ['10', 0xA6, 'w'], 'EM7': ['10', 0xA7, 'w'], 'EM8': ['10', 0xA8, 'w'], 'EM9': ['10', 0xA9, 'w'],\n                        'EMA': ['10', 0xAA, 'w'], 'EMB': ['10', 0xAB, 'w'], 'EMC': ['10', 0xAC, 'w'], 'EMD': ['10', 0xAD, 'w'], 'EME': ['10', 0xAE, 'w'],\n                        'EMF': ['10', 0xAF, 'w'], 'EM10': ['10', 0x60, 'w'], 'EM11': ['10', 0x61, 'w'], 'EM12': ['10', 0x62, 'w'], 'EM13': ['10', 0x63, 'w'],\n                        'EM14': ['10', 0x64, 'w'], 'EM15': ['10', 0x65, 'w'], 'EM16': ['10', 0x66, 'w'], 'EM17': ['10', 0x67, 'w'], 'EM18': ['10', 0x68, 'w'],\n                    }\n                    dict_devices.update(dict_update_devices)\n            elif protocol in global_vars.g_CIP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Rockwell\n        elif manufacture in global_vars.g_ROCKWELL:\n            if protocol in global_vars.g_MODBUSTCP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Siemens\n        elif manufacture in global_vars.g_SIEMENS:\n            if protocol in global_vars.g_MODBUSTCP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Schneider electric\n        elif manufacture in global_vars.g_SCHNEIDERELECTRIC:\n            if protocol in global_vars.g_MODBUSTCP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # ikeike-------------------------------------\n        # Xinje\n        elif manufacture in global_vars.g_XINJE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MODBUSRTU:\n                transfer_limit = 24\n                prefix_bit = 5\n                # prefix_bit = 3\n                dict_devices = {\n                    'M': ['10', 0x01, 'b'], 'X': ['10', 0x01, 'b', 4000], 'Y': ['10', 0x01, 'b', 4800],\n                    'D': ['10', 0x04, 'w'],\n                }\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # ikeike-------------------------------------\n        # Other manufacure\n        else:\n            raise ValueError(\n                '{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This manufacture name is wrong OR is Not supported.'\n                )\n            )\n\n        key = ['decimal', 'binary', 'character']\n        devices = {}\n        for k, v in dict_devices.items():\n            devices[k] = dict(zip(key, v))\n\n        return {\n            'device': devices,\n            'transfer_limit': transfer_limit,\n            'prefix_bit': prefix_bit,\n            'byte_order': byte_order,\n            'traceback': '',\n        }\n    except Exception:\n        return {\n            'device': {},\n            'transfer_limit': 0,\n            'prefix_bit': 0,\n            'byte_order': '',\n            'traceback': traceback.format_exc(),\n        }\n\n\ndef convert_to_decimal(n_array: str, device_parameter: dict) -> dict:\n    # Converts the number of digits set by each company to the number of\n    # digits of the communication protocol.\n    try:\n        period_index = device_parameter['min'].index('.')\n    except ValueError:\n        period_index = None\n    # Decimal number.  Ex) '1000' -> 1000(10)\n    if n_array == '10':\n        min_bit = int(device_parameter['min'],)\n        try:\n            max_bit = int(device_parameter['max'])\n        except Exception:\n            max_bit = min_bit\n    # Hexadecimal number.  Ex) '1000' -> 4096(10)\n    elif n_array == '16':\n        min_bit = int(device_parameter['min'], 16)\n        try:\n            max_bit = int(device_parameter['max'], 16)\n        except Exception:\n            max_bit = min_bit\n    # Upper digits are in decimal. The last 2 digit is a decimal number of n_array notation.\n    #  Ex) '511.15' -> 51115(10)\n    elif n_array == '10.10':\n        min_integer = str(device_parameter['min'])[:period_index]\n        if period_index is not None:\n            min_n_array = str(device_parameter['min'])[period_index + 1:]\n            min_bit = int(min_integer) * 16 + int(min_n_array)\n            try:\n                period_index_max = device_parameter['max'].index('.')\n                max_bit = (\n                    int(str(device_parameter['max'])[:period_index_max]) * 16\n                    + int(str(device_parameter['max'])[period_index_max + 1:])\n                )\n            except Exception:\n                max_bit = min_bit\n        else:\n            min_bit = int(min_integer)\n            try:\n                max_bit = int(str(device_parameter['max']))\n            except Exception:\n                max_bit = min_bit\n    # Upper digits are in decimal. The last 2 digit is a Hexadecimal number of decimal notation.\n    #  Ex) 199915 -> 1999*16+15 = 31999(10)\n    elif n_array == '1010':\n        if len(str(device_parameter['min'])) <= 2:\n            min_bit = int(str(device_parameter['min']))\n        else:\n            min_bit = (\n                int(str(device_parameter['min'])[:-2]) * 16\n                + int(str(device_parameter['min'])[-2:])\n            )\n        try:\n            if len(str(device_parameter['max'])) <= 2:\n                max_bit = int(str(device_parameter['max']))\n            else:\n                max_bit = (\n                    int(str(device_parameter['max'])[:-2]) * 16\n                    + int(str(device_parameter['max'])[-2:])\n                )\n        except Exception:\n            max_bit = min_bit\n    # Upper digits are in decimal. The last 1 digit is a Hexadecimal number of Hexadecimal notation.\n    # Ex) 109F -> 109*16+F = 1759(10)\n    elif n_array == '1016':\n        if len(str(device_parameter['min'])) <= 1:\n            min_bit = int(str(device_parameter['min']), 16)\n        else:\n            min_bit = (\n                int(str(device_parameter['min'])[:-1]) * 16\n                + int(str(device_parameter['min'])[-1:], 16)\n            )\n        try:\n            if len(str(device_parameter['max'])) <= 1:\n                max_bit = int(str(device_parameter['max']), 16)\n            else:\n                max_bit = (\n                    int(str(device_parameter['max'])[:-1]) * 16\n                    + int(str(device_parameter['max'])[-1:], 16)\n                )\n        except Exception:\n            max_bit = min_bit\n    elif n_array == 'ascii':\n        min_bit = int(device_parameter['min'])\n        max_bit = int(device_parameter['max'])\n\n    # Confirmation of large and small.\n    if min_bit > max_bit:\n        (temp_min, temp_max) = (min_bit, max_bit)\n        (min_bit, max_bit) = (temp_max, temp_min)\n    lead_number = min_bit\n    # Number of communication data and times.\n    send_length = max_bit - min_bit + 1\n    return {\n        'lead_number': lead_number,\n        'send_length': send_length,\n    }\n\n\ndef convert_to_n_array(\n        n_array: str, lead_number: int,\n        send_length: int) -> (str, str):\n    # Converts the number of digits set by each company to the number of digits of the communication protocol.\n    # Decimal number.  Ex) 1000(10) -> '1000'\n    if n_array == '10':\n        min_bit = lead_number\n        min_bit = str(min_bit)\n        max_bit = str(lead_number + send_length)\n    # Hexadecimal number.  Ex) 4096(10) -> '1000'\n    elif n_array == '16':\n        min_bit = lead_number\n        min_bit = format(min_bit, 'x')\n        max_bit = format(lead_number + send_length - 1, 'x')\n    # Upper digits are in decimal. The last 2 digit is a decimal number of decimal notation.\n    #  Ex) 51115(10) '511.15'\n    elif n_array == '10.10':\n        min_integer, min_n_array = divmod(lead_number, 16)\n        max_integer, max_n_array = divmod(lead_number + send_length, 16)\n        min_bit = str(min_integer) + \".\" + \"{02}\".format(min_n_array)\n        max_bit = str(max_integer) + \".\" + \"{02}\".format(max_n_array)\n    # Upper digits are in decimal. The last 2 digit is a Hexadecimal number of decimal notation.\n    #  Ex) 31999(10) = 1999*16+15 -> 199915\n    elif n_array == '1010':\n        min_integer, min_n_array = divmod(lead_number, 16)\n        max_integer, max_n_array = divmod(lead_number + send_length, 16)\n        min_bit = str(min_integer) + '{02}'.format(min_n_array)\n        max_bit = str(max_integer) + '{02}'.format(max_n_array)\n    # Upper digits are in decimal. The last 1 digit is a Hexadecimal number of Hexadecimal notation.\n    # Ex) 1759(10) = 109*16+F -> 109F\n    elif n_array == '1016':\n        min_integer, min_n_array = divmod(lead_number, 16)\n        max_integer, max_n_array = divmod(lead_number + send_length, 16)\n        min_bit = str(min_integer) + format(min_n_array, '01x')\n        max_bit = str(max_integer) + format(max_n_array, '01x')\n    elif n_array == 'ascii':\n        min_bit = lead_number\n        max_bit = min_bit\n    return {\n        'min_bit': min_bit,\n        'max_bit': max_bit,\n    }\n\n\ndef device_list(manufacture: str, protocol: str, series: str, *,\n                transport_layer: str = 'tcp', period_index: int = None) -> (dict, int, int, str):\n    # A list of plc devices.(LATEST VERSION)\n    # '<device name of PLC>':['decimal system', 'device code', 'data unit', (offset)]\n    try:\n        # Mitsubishi electric\n        if manufacture in global_vars.g_MITSUBISHI:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL1E:\n                dict_devices = {\n                    'D': ['10', (0x44, 0x20), 'w'], 'R': ['10', (0x52, 0x20), 'w'], 'TN': ['10', (0x54, 0x4E), 'w'], 'TS': ['10', (0x54, 0x53), 'b'],\n                    'CN': ['10', (0x43, 0x4E), 'w'], 'CS': ['10', (0x43, 0x53), 'b'], 'X': ['16', (0x58, 0x20), 'b'], 'Y': ['16', (0x59, 0x20), 'b'],\n                    'M': ['10', (0x4D, 0x20), 'b'], 'S': ['10', (0x53, 0x20), 'b']\n                }\n                transfer_limit = 255\n                prefix_bit = 4\n            elif protocol in global_vars.g_MCPROTOCOL3E:\n                if series in global_vars.g_SERIES_IQR:\n                    dict_devices = {\n                        'SM': ['10', 0x0091, 'b'], 'SD': ['10', 0x00A9, 'w'], 'X': ['16', 0x009C, 'b'], 'Y': ['16', 0x009D, 'b'],\n                        'M': ['10', 0x0090, 'b'], 'L': ['10', 0x0092, 'b'], 'F': ['10', 0x0093, 'b'], 'V': ['10', 0x0094, 'b'],\n                        'B': ['16', 0x00A0, 'b'], 'D': ['10', 0x00A8, 'w'], 'W': ['16', 0x00B4, 'w'], 'TS': ['10', 0x00C1, 'b'],\n                        'TC': ['10', 0x00C0, 'b'], 'TN': ['10', 0x00C0, 'w'], 'STS': ['10', 0x00C7, 'b'], 'STC': ['10', 0x00C6, 'b'],\n                        'STN': ['10', 0x00C8, 'w'], 'CS': ['10', 0x00C4, 'b'], 'CC': ['10', 0x00C3, 'b'], 'CN': ['10', 0x00C5, 'w'],\n                        'SB': ['16', 0x00A1, 'b'], 'SW': ['16', 0x00B5, 'w'], 'DX': ['16', 0x00A2, 'b'], 'DY': ['16', 0x00A3, 'b'],\n                        'Z': ['10', 0x00CC, 'w'], 'R': ['10', 0x00AF, 'w'], 'ZR': ['16', 0x00B0, 'w'], 'LTS': ['10', 0x0051, 'b'],\n                        'LTC': ['10', 0x0050, 'b'], 'LTN': ['10', 0x0052, 'dw'], 'LSTS': ['10', 0x0059, 'b'], 'LSTC': ['10', 0x0058, 'b'],\n                        'LSTN': ['10', 0x005A, 'dw'], 'LCS': ['10', 0x0055, 'b'], 'LCC': ['10', 0x0054, 'b'], 'LCN': ['10', 0x0056, 'dw'],\n                        'LZ': ['10', 0x00CC, 'dw'], 'RD': ['10', 0x002C, 'w']\n                    }\n                    transfer_limit = 960\n                    prefix_bit = 22\n                else:\n                    dict_devices = {\n                        'SM': ['10', 0x91, 'b'], 'SD': ['10', 0xA9, 'w'], 'X': ['16', 0x9C, 'b'], 'Y': [16, 0x9D, 'b'],\n                        'M': ['10', 0x90, 'b'], 'L': ['10', 0x92, 'b'], 'F': ['10', 0x93, 'b'], 'V': [10, 0x94, 'b'],\n                        'B': ['16', 0xA0, 'b'], 'D': ['10', 0xA8, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': [10, 0xC1, 'b'],\n                        'TC': ['10', 0xC0, 'b'], 'TN': ['10', 0xC0, 'w'], 'STS': ['10', 0xC7, 'b'], 'STC': [10, 0xC6, 'b'],\n                        'STN': ['10', 0xC8, 'w'], 'CS': ['10', 0xC4, 'b'], 'CC': ['10', 0xC3, 'b'], 'CN': [10, 0xC5, 'w'],\n                        'SB': ['16', 0xA1, 'b'], 'SW': ['16', 0xB5, 'w'], 'DX': ['16', 0xA2, 'b'], 'DY': [16, 0xA3, 'b'],\n                        'Z': ['10', 0xCC, 'w'], 'R': ['10', 0xAF, 'w'], 'ZR': ['16', 0xB0, 'w']\n                    }\n                    transfer_limit = 960\n                    prefix_bit = 22\n            elif protocol in global_vars.g_MCPROTOCOL4E:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            elif protocol in global_vars.g_COMPUTERLINK:\n                transfer_limit = 99\n                prefix_bit = 5\n                dict_devices = {\n                    'X': ['ascii', b'X', 'b'], 'Y': ['ascii', b'Y', 'b'],\n                    'M': ['ascii', b'M', 'b'], 'L': ['ascii', b'L', 'b'], 'F': ['ascii', b'F', 'b'], 'V': ['ascii', 'V', 'b'],\n                    'B': ['ascii', b'B', 'b'], 'D': ['ascii', b'D', 'w'], 'W': ['ascii', b'W', 'w'],\n                    'Z': ['ascii', b'Z', 'w'], 'R': ['ascii', b'R', 'w']\n                }\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Keyence\n        elif manufacture in global_vars.g_KEYENCE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                dict_devices = {\n                    'R': ['1010', 0x9c, 'b'], 'B': ['16', 0xA0, 'b'], 'MR': ['1010', 0x90, 'b'], 'LR': ['1010', 0x92, 'b'],\n                    'CR': ['1010', 0x91, 'b'], 'CM': ['10', 0xA9, 'w'], 'DM': ['10', 0xA8, 'w'], 'EM': ['10', 0xA8, 'w'],\n                    'FM': ['10', 0xAF, 'w'], 'ZF': ['16', 0xB0, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': ['10', 0xC1, 'b'],\n                    'TC': ['10', 0xC2, 'b'], 'CC': ['10', 0xC5, 'b'], 'CS': ['10', 0xC4, 'b'], 'D': ['10', 0xA8, 'w'],\n                    'M': ['1010', 0x90, 'b'], 'T': ['10', 0xC1, 'b'], 'C': ['10', 0xC5, 'b'],\n                }\n\n                transfer_limit = 960\n                prefix_bit = 22\n            elif protocol in global_vars.g_HOSTLINK:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Panasonic\n        elif manufacture in global_vars.g_PANASONIC:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                dict_devices = {\n                    'X': ['1016', 0x9C, 'b'], 'Y': ['1016', 0x9D, 'b'], 'L': ['1016', 0xA0, 'b'], 'R': ['1016', 0x90, 'b'],\n                    'R1': ['1016', 0x92, 'b'], 'DT': ['10', 0xA8, 'w'], 'LD': ['10', 0xB4, 'w'], 'EVT': ['10', 0xC2, 'w'],\n                    'T': ['10', 0xC1, 'b'], 'EVC': ['10', 0xC5, 'w'], 'C': ['10', 0xC4, 'b'], 'SR': ['1016', 0x91, 'b', 9000],\n                    'SD': ['10', 0xA9, 'w', 90000], 'SDT': ['10', 0xA9, 'w', 90000], 'D': ['10', 0xA8, 'w'],\n                }\n                transfer_limit = 960\n                prefix_bit = 22\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Omron\n        elif manufacture in global_vars.g_OMRON:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_FINS:\n                dict_devices = {\n                    'CIO': ['10.10', 0x30, 'b'], 'W': ['10.10', 0x31, 'b'], 'H': ['10.10', 0x32, 'b'], 'A': ['10.10', 0x33, 'b'],\n                    'DM': ['10.10', 0x02, 'b'], 'TK': ['10.10', 0x46, 'b'], 'IR': ['10', 0xDC, 'w'], 'DR': ['10', 0xBC, 'w'],\n                    'EM0': ['10.10', 0xA0, 'b'], 'EM1': ['10.10', 0xA1, 'b'], 'EM2': ['10.10', 0xA2, 'b'], 'EM3': ['10.10', 0xA3, 'b'], 'EM4': ['10.10', 0xA4, 'b'],\n                    'EM5': ['10.10', 0xA5, 'b'], 'EM6': ['10.10', 0xA6, 'b'], 'EM7': ['10.10', 0xA7, 'b'], 'EM8': ['10.10', 0xA8, 'b'], 'EM9': ['10.10', 0xA9, 'b'],\n                    'EMA': ['10.10', 0xAA, 'b'], 'EMB': ['10.10', 0xAB, 'b'], 'EMC': ['10.10', 0xAC, 'b'], 'EMD': ['10.10', 0xAD, 'b'], 'EME': ['10.10', 0xAE, 'b'],\n                    'EMF': ['10.10', 0xAF, 'b'], 'EM10': ['10.10', 0x60, 'b'], 'EM11': ['10.10', 0x61, 'b'], 'EM12': ['10.10', 0x62, 'b'], 'EM13': [10.10, 0x63, 'b'],\n                    'EM14': ['10.10', 0x64, 'b'], 'EM15': ['10.10', 0x65, 'b'], 'EM16': ['10.10', 0x66, 'b'], 'EM17': ['10.10', 0x67, 'b'], 'EM18': ['10.10', 0x68, 'b'],\n                    'EMCB': ['10', 0x98, 'w'],\n                    'TIMS': ['10', 0x09, 'w'], 'CNTS': ['10', 0x09, 'w', 8000], 'TIMN': ['10', 0x89, 'w'], 'CNTN': ['10', 0x89, 'w', 8000]\n                }\n                if period_index is None:\n                    dict_update_devices = {\n                        'CIO': ['10', 0xB0, 'w'], 'W': ['10', 0xB1, 'w'], 'H': ['10', 0xB2, 'w'], 'A': ['10', 0xB3, 'w'],\n                        'DM': ['10', 0x82, 'w'], 'TK': ['10', 0x46, 'w'],\n                        'EM0': ['10', 0xA0, 'w'], 'EM1': ['10', 0xA1, 'w'], 'EM2': ['10', 0xA2, 'w'], 'EM3': ['10', 0xA3, 'w'], 'EM4': ['10', 0xA4, 'w'],\n                        'EM5': ['10', 0xA5, 'w'], 'EM6': ['10', 0xA6, 'w'], 'EM7': ['10', 0xA7, 'w'], 'EM8': ['10', 0xA8, 'w'], 'EM9': ['10', 0xA9, 'w'],\n                        'EMA': ['10', 0xAA, 'w'], 'EMB': ['10', 0xAB, 'w'], 'EMC': ['10', 0xAC, 'w'], 'EMD': ['10', 0xAD, 'w'], 'EME': ['10', 0xAE, 'w'],\n                        'EMF': ['10', 0xAF, 'w'], 'EM10': ['10', 0x60, 'w'], 'EM11': ['10', 0x61, 'w'], 'EM12': ['10', 0x62, 'w'], 'EM13': ['10', 0x63, 'w'],\n                        'EM14': ['10', 0x64, 'w'], 'EM15': ['10', 0x65, 'w'], 'EM16': ['10', 0x66, 'w'], 'EM17': ['10', 0x67, 'w'], 'EM18': ['10', 0x68, 'w'],\n                    }\n                    dict_devices.update(dict_update_devices)\n                transfer_limit = 498\n                if transport_layer in global_vars.g_UDPIP:\n                    prefix_bit = 28\n                elif transport_layer in global_vars.g_TCPIP:\n                    prefix_bit = 76\n                else:\n                    prefix_bit = 76\n            elif protocol in global_vars.g_CIP:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Rockwell\n        elif manufacture in global_vars.g_ROCKWELL:\n            if protocol in global_vars.g_MODBUS:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Siemens\n        elif manufacture in global_vars.g_SIEMENS:\n            if protocol in global_vars.g_MODBUS:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Schneider electric\n        elif manufacture in global_vars.g_SCHNEIDERELECTRIC:\n            if protocol in global_vars.g_MODBUS:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Xinje\n        elif manufacture in global_vars.g_XINJE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MODBUSRTU:\n                transfer_limit = 960\n                prefix_bit = 3\n                dict_devices = {\n                    'M': ['10', 0x01, 'b'], 'X': ['10', 0x01, 'b', 4000], 'Y': ['10', 0x01, 'b', 4800],\n                    'D': ['10', 0x04, 'w'],\n                }\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Other manufacure\n        else:\n            raise ValueError('{},{}'.format(sys._getframe(\n            ).f_code.co_name, 'This manufacture name is wrong OR is Not supported.'))\n        return {\n            'device': dict_devices,\n            'transfer_limit': transfer_limit,\n            'prefix_bit': prefix_bit,\n            'byte_order': byte_order,\n            'traceback': '',\n        }\n    except Exception:\n        return {\n            'device': {},\n            'transfer_limit': 0,\n            'prefix_bit': 0,\n            'byte_order': '',\n            'traceback': traceback.format_exc(),\n        }\n\n\nif __name__ == '__main__':\n    a = []\n    for i in range(2):\n        # a.append(device_list('panasonic', 'mc_3e', 'q', transport_layer='tcp'))\n        # a.append(devicelist('panasonic', 'mc_3e', 'q', transport_layer='tcp'))\n        a.append(list(device_list('mitsubishi', 'slmp', '')['device'].keys()))\n    print(a)\n",
        "global_vars.py": "import os\nimport json\n# from dotenv import load_dotenv\nimport dotenv\ndotenv.load_dotenv()\n\n# Manifacture\ng_MITSUBISHI = [\n    'mitsubishi',\n    'mitubisi',\n    'melco',\n    'melsec'\n]\ng_KEYENCE = [\n    'keyence'\n]\ng_PANASONIC = [\n    'panasonic',\n    'matsushita',\n    'matusita'\n]\ng_OMRON = [\n    'omron'\n]\ng_ROCKWELL = [\n    'rockwell'\n]\ng_SIEMENS = [\n    'siemens'\n]\ng_SCHNEIDERELECTRIC = [\n    'schneiderelectric',\n    'schneider electric',\n    'schneider_electric'\n]\ng_XINJE = [\n    'xinje'\n]  # ikeike\n\n# Protocol.\ng_MCPROTOCOL1E = [\n    'mc_1e',\n    'mc1e',\n    'mcprotocol_1e',\n    'mcprotocol_1e_frame'\n]\ng_MCPROTOCOL2E = [\n    'mc_2e',\n    'mc2e',\n    'mcprotocol_2e',\n    'mcprotocol_2e_frame'\n]\ng_MCPROTOCOL3E = [\n    'mc_3e',\n    'mc3e',\n    'mcprotocol_3e',\n    'mcprotocol_3e_frame',\n    'slmp'\n]\ng_MCPROTOCOL4E = [\n    'mc_4e',\n    'mc4e',\n    'mcprotocol_4e',\n    'mcprotocol_4e_frame'\n]\ng_HOSTLINK = [\n    'hostlink',\n    'upperlink',\n    'host_link',\n    'upper_link'\n]\ng_MEWTOCOL = [\n    'mewtocol'\n]\ng_FINS = [\n    'fins'\n]\ng_CIP = [\n    'cip'\n]\ng_MODBUSTCP = [\n    'modbustcp',\n    'modbus_tcp'\n]\ng_ETHERNETIP = [\n    'ethernetip',\n    'ethernet_ip,'\n]\n\ng_MODBUSRTU = [\n    'modbusrtu',\n    'modbus_rtu'\n]  # ikeike\ng_COMPUTERLINK = [\n    'computerlink',\n    'computer_link',\n    'keisankilink',\n    'keisanki_link'\n]  # ikeikeike\n\n# PLC Series.\ng_SERIES_QR = ['qr', 'q', 'qna']\ng_SERIES_IQR = ['iqr', 'iq']\ng_SERIES_FX = ['fx']  # ikeikeike\n\n# Ethernet Connection.\ng_TCPIP = [\n    'tcp',\n    'tcpip',\n    'tcp_ip',\n    't'\n]\ng_UDPIP = [\n    'udp',\n    'udpip',\n    'udp_ip',\n    'u'\n]\ng_RC232C = [\n    'rc232c',\n    'rc232',\n    '232'\n]\n\n# Commands.\ng_WRITE_COMMAND = [\n    'write',\n    'w'\n]\ng_READ_COMMAND = [\n    'read',\n    'r'\n]\n\n# Command options.\ng_STRING_OPTION = [\n    'string',\n    's'\n]\ng_TIME_OPTION = [\n    'time',\n    't'\n]\n\n\n# Identify device.\ng_IFY_BIT_DEVICE = [\n    'b',\n    'bit',\n    'bits',\n    'byte',\n    'bytes'\n]\ng_IFY_WORD_DEVICE = [\n    'w',\n    'word',\n    'words'\n]\ng_IFY_D_WORD_DEVICE = [\n    'dw',\n    'd_word',\n    'd_words',\n    'double_word',\n    'double_words'\n]\n\nPLC_TIMEOUT_SECONDS = 0.5  # ikeike0.1\n\n# Error Code.\ng_ERROR_CODE = {\n    'SUCCESSFLLY_CODE': 0,\n    'FUNCTIONAL_ERRORCODE': -1,\n    'CONNECTION_ERRORCODE': -10,\n    'SKIP_PROCESS_ERRORCODE': -100,\n    'HARDWARE_ERRORCODE': -150,\n    'PLC_SEQUENCE_ERRORCODE': -200,\n}\ng_SUCCESSFLLY_CODE = 0\ng_FUNCTIONAL_ERRORCODE = -1\ng_CONNECTION_ERRORCODE = -10\ng_SKIP_PROCESS_ERRORCODE = -100\ng_HARDWARE_ERRORCODE = -150\ng_PLC_SEQUENCE_ERRORCODE = -200\n\n# MASTER DATA TYPE\ntry:\n    TYPE_ERRORDATA = json.loads(os.environ['TYPE_ERRORDATA'])\n    TYPE_WARNINGDATA = json.loads(os.environ['TYPE_WARNINGDATA'])\n    TYPE_PRODUCTIONDATA = json.loads(os.environ['TYPE_PRODUCTIONDATA'])\n    TYPE_PROGRESSDATA = json.loads(os.environ['TYPE_PROGRESSDATA'])\n    TYPE_INSPECTIONDATA = json.loads(os.environ['TYPE_INSPECTIONDATA'])\nexcept:\n    TYPE_ERRORDATA = ['error', 'run']\n    TYPE_WARNINGDATA = ['warning', 'lift']\n    TYPE_PRODUCTIONDATA = [\n        'input', 'output', 'plantime',\n        'actualtime', 'standardcycle', 'outputtarget']\n    TYPE_PROGRESSDATA = ['status', 'currentstatus']\n    TYPE_INSPECTIONDATA = ['inspect']\n\n# INTERVAL TIME\nACQUISITION_INTERVAL = {\n    'log': 1,\n    'error': 1,\n    'warning': 1,\n    'production': 10,\n    'progress': 10,\n}\n\nCONNECTION_ERROR_THRESHOLD = 5\nNOT_CONNECTION_PARAMETER = 0\nBEFORE_DATA_COUNT = 5\n\n# Grobal constants.\ng_ENABLE_OPTION = {\n    'ENABLE_MANUFACTURE': {\n        'mitsubishi': {\n            'slmp': {'device': [], 'connection_type': ['tcp', 'udp']},\n            'mcprotocol_1e': {'device': [], 'connection_type': ['tcp', 'udp']},\n            'computer_link': {'device': [], 'connection_type': ['rc232c']}\n        },\n        'keyence': {\n            'slmp': {'device': [], 'connection_type': ['tcp', 'udp']},\n        },\n        'panasonic': {\n            'slmp': {'device': [], 'connection_type': ['tcp', 'udp']},\n        },\n        'omron': {\n            'fins': {'device': [], 'connection_type': ['tcp', 'udp']},\n        },\n        'xinje': {\n            'modbus_rtu': {'device': [], 'connection_type': ['rc232c']},\n        },\n    },\n    'ENABLE_MASTER_TYPE': TYPE_ERRORDATA + TYPE_PRODUCTIONDATA + TYPE_PROGRESSDATA + TYPE_INSPECTIONDATA\n}\n",
        "logger.py": "import os\nimport logging\nimport dotenv\n\n\ndef get_module_logger(modname):\n    logger = logging.getLogger(modname)\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        '%(asctime)s-%(name)s-%(levelname)s-%(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    dotenv.load_dotenv(override=True)\n    LOGGER_LEVEL = os.getenv('LOGGER_LEVEL')\n    if (LOGGER_LEVEL == 'CRITICAL'):\n        logger.setLevel(logging.CRITICAL)\n    elif (LOGGER_LEVEL == 'ERROR'):\n        logger.setLevel(logging.ERROR)\n    elif (LOGGER_LEVEL == 'WARNING'):\n        logger.setLevel(logging.WARNING)\n    elif (LOGGER_LEVEL == 'INFO'):\n        logger.setLevel(logging.INFO)\n    elif (LOGGER_LEVEL == 'DEBUG'):\n        logger.setLevel(logging.DEBUG)\n    else:\n        logger.setLevel(logging.NOTSET)\n    return logger\n",
        "plc_comm.py": "import os\nimport sys\nimport typing\nimport asyncio\nimport traceback\nimport re\nimport math\nimport struct\nimport datetime\nimport socket\n# IF client pc is NOT Windows, need pip install\nimport psutil\ntry:\n    import netifaces as ni\nexcept Exception:\n    pass\n\ntry:\n    # Rev 0.9.4=\n    from pyModbusTCP.client import ModbusClient\nexcept Exception:\n    pass\n# other script\ntry:\n    import logger\n    import global_vars\n    import device_list\n    import convert_format\n    from command_checker import get_random_sid\nexcept Exception:\n    from . import logger\n    from . import global_vars\n    from . import device_list\n    from . import convert_format\n    from .command_checker import get_random_sid\n\n\n# Logger\nlogger = logger.get_module_logger(__name__)\n\n\n# Convert from negative value to signed hexadecimal.\ndef convert_signed(list_negative: list, *, word_count: int = 2) -> list:\n    list_response = []\n    for x in list_negative:\n        len_hex = len('{:x}'.format(x).replace('-', ''))\n        r_list = []\n        value = x\n        for i in range(int(word_count)):\n            value, r = divmod(value, 65536)\n            if int(x) >= 0:\n                r_list.append(int(format(int(r), 'x'), 16))\n            else:\n                r_list.append(int(format(int(r) & 0xffff, 'x'), 16))\n        if int(value) != 0 and int(value) != -1:\n            if int(x) >= 0:\n                hex_value = [int(format(int(int(value)), 'x'), 16)]\n            else:\n                hex_value = [int(format(int(int(value)) & 0xffff, 'x'), 16)]\n        else:\n            hex_value = []\n        r_list.reverse()\n        hex_value.extend(r_list)\n        hex_value.reverse()\n        list_response.extend(hex_value)\n    return list_response\n\n\n# vvv Pre-operation to secure a node for FINS communication vvv\ndef get_class_c_host_ip(ip_address) -> int:\n    # Get the ClassC host of the IP address.\n    # Windows.\n    if os.name == \"nt\":\n        iplist = socket.gethostbyname_ex(socket.gethostname())[2]\n    # Linux or Mac.\n    else:\n        iplist = []\n        address_list = psutil.net_if_addrs()\n        for nic in address_list.keys():\n            ni.ifaddresses(nic)\n            try:\n                ip = ni.ifaddresses(nic)[ni.AF_INET][0]['addr']\n                if ip not in [\"127.0.0.1\"]:\n                    iplist.append(ip)\n            except KeyError as err:\n                logger.debug(err)\n    connection_ip = ip_address\n    same_network_ip = connection_ip.rsplit('.', 1)[0]\n    try:\n        _client_ip = [x for x in iplist if same_network_ip in x]\n        client_ip = _client_ip[0]\n        class_c_host = int(client_ip.rsplit('.', 1)[1])\n    except Exception as e:\n        logger.warning(\n            '{}:{}, {}'.format(\n                sys._getframe().f_code.co_name, e, 'No connection found. Please check your communication settings.'\n            )\n        )\n        # class_c_host = None\n        class_c_host = int(iplist[0].rsplit('.', 1)[1])\n    return class_c_host\n\n\ndef generate_node_telegram(protocol) -> bytes:\n    if protocol in global_vars.g_FINS:\n        header = (\n            struct.pack('B', 0x46)\n            + struct.pack('B', 0x49)\n            + struct.pack('B', 0x4E)\n            + struct.pack('B', 0x53)\n        )  # header(only TCP)\n        data_length = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x0C)\n        )  # data length(only TCP)\n        tcp_cmd = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n        )  # command(only TCP)\n        err_cd = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n        )  # error code(only TCP)\n        client_node_address = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n        )  # client node address(only TCP)\n        telegram_data = (\n            header\n            + data_length\n            + tcp_cmd\n            + err_cd\n            + client_node_address\n        )\n    else:\n        telegram_data = global_vars.g_CONNECTION_ERRORCODE\n    return telegram_data\n# ^^^ Pre-operation to secure a node for FINS communication ^^^\n\n\nclass ConnectToPlc:\n    def __init__(self, plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict) -> None:  # Initialize Configure\n        # Configure parameter.\n        self.host = str(plc_network['ip'])\n        self.port = int(plc_network['port'])\n        self.manufacture = str(plc_protocol['manufacture']).lower()\n        self.protocol = str(plc_protocol['protocol']).lower()\n        self.series = str(plc_protocol['series']).lower()\n        self.cmd = cmd_data['cmd']\n        self.option = cmd_data['option']\n\n        # Check Transport layer.\n        try:\n            self.transport_layer = str(plc_protocol['transport_layer']).lower()\n        except Exception:\n            self.transport_layer = 'tcp'\n\n        # Check float parameter.\n        try:\n            self.period_index = device_parameter['min'].index('.')\n        except ValueError:\n            self.period_index = None\n\n        # PLC register device parameter.\n        device_info = device_list.device_list(\n            self.manufacture, self.protocol, self.series, transport_layer=self.transport_layer, period_index=self.period_index)\n        self.device_list = device_info['device']\n        self.transfer_limit = device_info['transfer_limit']\n        self.prefix_bit = device_info['prefix_bit']\n        self.byte_order = device_info['byte_order']\n\n        self.option = cmd_data['option']\n        if self.option in global_vars.g_TIME_OPTION:\n            self.time_option_configure()\n        else:\n            try:\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n            except Exception:\n                self.device = None\n                self.n_array = None\n                self.device_code = None\n                self.bit_identify = \"bit\"\n\n            if self.cmd in global_vars.g_WRITE_COMMAND:\n                if self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                    self.cmd_data, self.option = convert_format.check_string_and_convert_dhex(\n                        cmd_data[\"data\"], self.byte_order, self.option)\n                    try:\n                        self.cmd_data = convert_format.convert_negative_integer_to_signed_hex(\n                            self.cmd_data, word_count=1)\n                    except Exception:\n                        pass\n                else:\n                    self.cmd_data = cmd_data[\"data\"]\n            else:\n                self.cmd_data = []\n            try:\n                convert_decimal = device_list.convert_to_decimal(\n                    self.n_array, device_parameter)\n                self.lead_number = convert_decimal['lead_number']\n                self.send_length = convert_decimal['send_length']\n                self.transfer_count = math.ceil(\n                    self.send_length / self.transfer_limit)\n                if self.send_length % 2 != 0:\n                    self.bit_odd_flag = True\n                else:\n                    self.bit_odd_flag = False\n            except Exception:\n                self.lead_number = None\n                self.send_length = None\n                self.transfer_count = 1\n                self.bit_odd_flag = None\n\n    # Get/Write timedata to PLC.\n    def time_option_configure(self):\n        device_parameter = {}\n        if self.protocol in global_vars.g_MCPROTOCOL3E:\n            if self.manufacture in global_vars.g_MITSUBISHI:\n                device_parameter[\"device\"] = \"SD\"\n                device_parameter[\"min\"] = \"210\"\n                device_parameter[\"max\"] = \"216\"\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n            elif self.manufacture in global_vars.g_PANASONIC:\n                if self.series in [\"fp7\", \"7\"]:\n                    pass\n                else:\n                    device_parameter[\"device\"] = \"SDT\"\n                    device_parameter[\"min\"] = \"54\"\n                    device_parameter[\"max\"] = \"57\"\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n            elif self.manufacture in global_vars.g_KEYENCE:\n                device_parameter[\"device\"] = \"CM\"\n                device_parameter[\"min\"] = \"700\"\n                device_parameter[\"max\"] = \"706\"\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n        elif self.protocol in global_vars.g_FINS:\n            if self.manufacture in global_vars.g_OMRON:\n                self.device = None\n                self.n_array = None\n                self.device_code = None\n                self.bit_identify = \"bit\"\n        else:\n            self.device = None\n            self.n_array = None\n            self.device_code = None\n\n        if self.cmd in global_vars.g_WRITE_COMMAND:\n            self.cmd_data = cmd_data['data']\n        else:\n            self.cmd_data = []\n        try:\n            convert_decimal = device_list.convert_to_decimal(\n                self.n_array, device_parameter\n            )\n            self.lead_number = convert_decimal['lead_number']\n            self.send_length = convert_decimal['send_length']\n            self.transfer_count = math.ceil(\n                self.send_length / self.transfer_limit)\n            self.bit_odd_flag = False\n        except Exception:\n            self.lead_number = None\n            self.send_length = None\n            self.transfer_count = 1\n            self.bit_odd_flag = None\n\n    # Generate a telegram to be sent.\n    def generate_telegram(self, current_count: int) -> bytes:\n        try:\n            # ======= ETHERNET CONNECTION =======\n            # ======= MC Protocol / 1E Frame =======\n            if self.protocol in global_vars.g_MCPROTOCOL1E:\n                pc_number = struct.pack('B', 0xFF)\n                cpu_speed = (struct.pack('B', 0x10) + struct.pack('B', 0x00))\n                # The device code of a 1E frame consists of 4 bytes.\n                device_code = (\n                    struct.pack('B', self.device_code[1])\n                    + struct.pack('B', self.device_code[0])\n                )\n                # Extract each hexadecimal digit and reconvert for transmission.\n                #  X, Y device need to be converted from octal descriptions to hexadecimal binaries.\n                if self.device == 'X' or self.device == 'Y':\n                    lead_device = (\n                        int(self.lead_number, 8)\n                        + current_count * self.transfer_limit\n                    )\n                else:\n                    lead_device = (\n                        self.lead_number\n                        + current_count * self.transfer_limit\n                    )\n                bits = '{:08x}'.format(lead_device)\n                hex_lead_bit = (\n                    struct.pack('B', int(bits[6] + bits[7], 16))\n                    + struct.pack('B', int(bits[4] + bits[5], 16))\n                    + struct.pack('B', int(bits[2] + bits[3], 16))\n                    + struct.pack('B', int(bits[0] + bits[1], 16))\n                )\n                delimiter = struct.pack('B', 0x00)\n                # For the Read command.\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    remain_length = (\n                        self.send_length\n                        - current_count * self.transfer_limit\n                    )\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        sub_header = struct.pack('B', 0x00)\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        sub_header = struct.pack('B', 0x01)\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n                # For the Write command\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    remain_length = (\n                        self.send_length\n                        - current_count * self.transfer_limit\n                    )\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        sub_header = struct.pack('B', 0x02)\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        sub_header = struct.pack('B', 0x03)\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                        )\n                    )\n                # Check the transmission limit.\n                if remain_length >= self.transfer_limit:\n                    bits_dnum = '{:02x}'.format(self.transfer_limit)\n                else:\n                    bits_dnum = '{:02x}'.format(remain_length)\n                data_count = (\n                    struct.pack('B', int(bits_dnum[0] + bits_dnum[1], 16))\n                )\n                telegram_data = (\n                    sub_header + pc_number + cpu_speed\n                    + hex_lead_bit + device_code + data_count + delimiter\n                )\n\n            # ======= MC Protocol / 3E Frame =======\n            elif self.protocol in global_vars.g_MCPROTOCOL3E:\n                sub_header = (\n                    struct.pack('B', 0x50)\n                    + struct.pack('B', 0x00)\n                )\n                network = struct.pack('B', 0x00)\n                pc_number = struct.pack('B', 0xff)\n                unit_io = (\n                    struct.pack('B', 0xff)\n                    + struct.pack('B', 0x03)\n                )\n                unit_number = struct.pack('B', 0x00)\n                cpu_speed = (\n                    struct.pack('B', 0x10)\n                    + struct.pack('B', 0x00)\n                )\n                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                    sub_cmd = (\n                        struct.pack('B', 0x01)\n                        + struct.pack('B', 0x00)\n                    )\n                elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                    sub_cmd = (\n                        struct.pack('B', 0x00)\n                        + struct.pack('B', 0x00)\n                    )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                        )\n                    )\n                # Extract each hexadecimal digit and reconvert for transmission.\n                lead_bit = (\n                    self.lead_number + current_count * self.transfer_limit\n                )\n                device_code = struct.pack('B', self.device_code)\n                # For the Read command\n                if self.cmd in global_vars.g_READ_COMMAND:\n\n                    # Number of bits acquired\n                    bits = '{:06x}'.format(lead_bit)\n                    hex_lead_bit = (\n                        struct.pack('B', int(bits[4] + bits[5], 16))\n                        + struct.pack('B', int(bits[2] + bits[3], 16))\n                        + struct.pack('B', int(bits[0] + bits[1], 16))\n                    )\n                    remain_length = (\n                        self.send_length - current_count * self.transfer_limit\n                    )\n                    if self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        if remain_length % 2 != 0:\n                            # remain_length += 1\n                            self.odd_flag = True\n                    if remain_length >= self.transfer_limit:\n                        bits_vol = '{:04x}'.format(self.transfer_limit)\n                    else:\n                        bits_vol = '{:04x}'.format(remain_length)\n\n                    data_count = (\n                        struct.pack('B', int(bits_vol[2] + bits_vol[3], 16))\n                        + struct.pack(\n                            'B', int(bits_vol[0] + bits_vol[1], 16))\n                    )\n                    cmd = struct.pack('B', 0x01) + struct.pack('B', 0x04)\n                    data_length = (\n                        struct.pack('B', 0x0c) + struct.pack('B', 0x00))\n                    telegram_data = (\n                        sub_header\n                        + network\n                        + pc_number\n                        + unit_io\n                        + unit_number\n                        + data_length\n                        + cpu_speed\n                        + cmd\n                        + sub_cmd\n                        + hex_lead_bit\n                        + device_code\n                        + data_count\n                    )\n\n                    if self.option == 'comment':\n                        telegram_data = (\n                            sub_header\n                            + network\n                            + pc_number\n                            + unit_io\n                            + unit_number\n                            + data_length\n                            + cpu_speed\n                            + (struct.pack('B', 0xa4) + struct.pack('B', 0x45))\n                            + (struct.pack('B', 0x10) + struct.pack('B', 0x03))\n                            + hex_lead_bit\n                            + device_code\n                            + data_count\n                        )\n\n                # For the Write command\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    if (self.option in global_vars.g_STRING_OPTION and self.bit_identify in global_vars.g_IFY_WORD_DEVICE):\n                        if self.manufacture in global_vars.g_PANASONIC:\n                            bits = '{:06x}'.format(lead_bit + 1)\n                        else:\n                            bits = '{:06x}'.format(lead_bit)\n                    else:\n                        bits = '{:06x}'.format(lead_bit)\n                    hex_lead_bit = (\n                        struct.pack('B', int(bits[4] + bits[5], 16))\n                        + struct.pack('B', int(bits[2] + bits[3], 16))\n                        + struct.pack('B', int(bits[0] + bits[1], 16))\n                    )\n                    cmd = (\n                        struct.pack('B', 0x01)\n                        + struct.pack('B', 0x14)\n                    )\n                    # Write data.\n                    w_data = []\n                    temp_data = []\n                    length = 0\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        if len(self.cmd_data) % 2 != 0:\n                            self.cmd_data.append(0)\n                            self.bit_odd_flag = True\n                        it = iter(self.cmd_data)\n                        for i, j in zip(it, it):\n                            w_data.append([j, i])\n\n                    else:\n                        for i in range(len(self.cmd_data)):\n                            if self.cmd_data[i] >= 0:\n                                _hex_w_data = '{:x}'.format(self.cmd_data[i])\n                            else:\n                                _hex_w_data = format(\n                                    self.cmd_data[i] & 0xffff, 'x'\n                                )\n                            length += len(_hex_w_data) / 2\n                            if self.option in global_vars.g_STRING_OPTION:\n                                for j in range((int(len(_hex_w_data) // 4.01)) + 1):\n                                    if len(_hex_w_data) >= 2:\n                                        if j == 0:\n                                            four_hex = '{:0>4s}'.format(\n                                                _hex_w_data[-4:]\n                                            )\n                                        elif j == len(_hex_w_data) // 4:\n                                            continue\n                                        else:\n                                            four_hex = '{:0>4s}'.format(\n                                                _hex_w_data[\n                                                    (j + 1) * (-4): j * (-4)\n                                                ]\n                                            )\n                                        w_data.append(\n                                            [\n                                                int(four_hex[0]\n                                                    + four_hex[1], 16),\n                                                int(four_hex[2]\n                                                    + four_hex[3], 16)\n                                            ]\n                                        )\n                                    else:\n                                        if len(temp_data) >= 2:\n                                            temp_data = []\n                                        if j == 0:\n                                            if i % 2 == 0:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[-2:]\n                                                    )\n                                                )\n                                                if i == len(self.cmd_data):\n                                                    w_data.append(\n                                                        [int(temp_data[0], 16), 0]\n                                                    )\n                                            else:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[-2:]\n                                                    )\n                                                )\n                                                try:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            int(temp_data[1], 16)\n                                                        ]\n                                                    )\n                                                except Exception:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            0\n                                                        ]\n                                                    )\n\n                                        else:\n                                            if i % 2 == 0:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[\n                                                            (j + 1) * (-2):j * (-2)\n                                                        ]\n                                                    )\n                                                )\n                                                if i == len(self.cmd_data):\n                                                    w_data.append(\n                                                        [int(temp_data[0], 16), 0]\n                                                    )\n                                            else:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[\n                                                            (j + 1) * (-2):j * (-2)\n                                                        ]\n                                                    )\n                                                )\n                                                try:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            int(temp_data[1], 16)\n                                                        ]\n                                                    )\n                                                except Exception:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            0\n                                                        ]\n                                                    )\n\n                                        if i == len(self.cmd_data):\n                                            try:\n                                                w_data.append(\n                                                    [\n                                                        int(temp_data[0], 16),\n                                                        int(temp_data[1], 16)\n                                                    ]\n                                                )\n                                            except Exception:\n                                                w_data.append(\n                                                    [int(temp_data[0], 16)]\n                                                )\n                            else:\n                                for j in range(int((len(_hex_w_data) // 4.01)) + 1):\n                                    if len(_hex_w_data) <= 4:\n                                        four_hex = '{:0>4s}'.format(\n                                            _hex_w_data[-4:]\n                                        )\n                                    else:\n                                        four_hex = '{:0>4s}'.format(\n                                            _hex_w_data[(j + 1)\n                                                        * (-4):j * (-4)]\n                                        )\n                                    w_data.append(\n                                        [\n                                            int(four_hex[0] + four_hex[1], 16),\n                                            int(four_hex[2] + four_hex[3], 16)\n                                        ]\n                                    )\n                    # Number of bits acquired\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        remain_length = (\n                            len(w_data) * 2\n                            - current_count * self.transfer_limit\n                        )\n                        if remain_length >= self.transfer_limit:\n                            if self.bit_odd_flag:\n                                bits_vol = '{:04x}'.format(\n                                    self.transfer_limit - 1)\n                            else:\n                                bits_vol = '{:04x}'.format(self.transfer_limit)\n                        else:\n                            if self.bit_odd_flag:\n                                bits_vol = '{:04x}'.format(remain_length - 1)\n                            else:\n                                bits_vol = '{:04x}'.format(remain_length)\n                    else:\n                        if self.option in global_vars.g_STRING_OPTION:\n                            if self.manufacture in global_vars.g_PANASONIC:\n                                w_data_length = '{:0>4s}'.format(\n                                    str(int(length)))\n                                w_data.insert(\n                                    0, [\n                                        int(w_data_length[:-2], 10),\n                                        int(w_data_length[-2:], 10)\n                                    ]\n                                )\n                            else:\n                                w_data.append([0, 0])\n                        remain_length = (\n                            len(w_data)\n                            - current_count * self.transfer_limit\n                        )\n                        if remain_length >= self.transfer_limit:\n                            bits_vol = '{:04x}'.format(self.transfer_limit)\n                        else:\n                            bits_vol = '{:04x}'.format(remain_length)\n\n                    data_count = (\n                        struct.pack('B', int(bits_vol[2] + bits_vol[3], 16))\n                        + struct.pack('B', int(bits_vol[0] + bits_vol[1], 16))\n                    )\n                    # data_count = struct.pack('B', 2) + struct.pack('B', 0)\n\n                    # Communication data length.\n                    # If the write is bit, add to the command byte length 12, or\n                    # If the writing is a word, add x2 to the command's byte length of 12.\n                    cmd_data = b''\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        characters = 12 + int(remain_length / 2)\n                        temp_dleng = '{:04x}'.format(characters)\n                        data_length = (\n                            struct.pack('B', int(temp_dleng[2] + temp_dleng[3], 16))\n                            + struct.pack(\n                                'B', int(temp_dleng[0] + temp_dleng[1], 16)\n                            )\n                        )\n                        for i, x in enumerate(w_data):\n                            try:\n                                cmd_data += struct.pack('B', x[1] * 16 + x[0])\n                            except Exception:\n                                cmd_data += struct.pack(\"B\", x[0])\n\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        characters = 12 + remain_length * 2\n                        temp_dleng = '{:04x}'.format(characters)\n                        # temp_dleng = \"001a\"\n                        data_length = (\n                            struct.pack('B', int(temp_dleng[2] + temp_dleng[3], 16))\n                            + struct.pack(\n                                'B', int(temp_dleng[0] + temp_dleng[1], 16)\n                            )\n                        )\n                        for i, x in enumerate(w_data):\n                            cmd_data += (\n                                struct.pack('B', x[1])\n                                + struct.pack('B', x[0])\n                            )\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n\n                    telegram_data = (\n                        sub_header\n                        + network\n                        + pc_number\n                        + unit_io\n                        + unit_number\n                        + data_length\n                        + cpu_speed\n                        + cmd\n                        + sub_cmd\n                        + hex_lead_bit\n                        + device_code\n                        + data_count\n                        + cmd_data\n                    )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                        )\n                    )\n\n            # ======= FINS =======\n            elif self.protocol in global_vars.g_FINS:\n                # TCP header\n                header = (\n                    struct.pack('B', 0x46)\n                    + struct.pack('B', 0x49)\n                    + struct.pack('B', 0x4E)\n                    + struct.pack('B', 0x53)\n                )     # TCP header(only TCP)\n                tcp_cmd = (\n                    struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x02)\n                )     # TCP command(only TCP)\n                err_cd = (\n                    struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                )     # TCP error code(only TCP)\n                # FINS header\n                # ICF. Bit7=1:fixed value, Bit6=0:command, Bit0=0:need response\n                icf = struct.pack('B', 0x80)\n                rsv = struct.pack('B', 0x00)                # RSV. fixed value\n                # Number of allowable bridge passes. Basically 0x02, 0x07: When using network crossings up to 8 layers.\n                gct = struct.pack('B', 0x02)\n                # Destination network address. 0x00: Same network, 0x01~0x7F: Destination network\n                dna = struct.pack('B', 0x00)\n                if self.transport_layer in global_vars.g_UDPIP:\n                    client_ip_address = get_class_c_host_ip(self.host)\n                    da1 = struct.pack('B', 0x00)\n                    sa1 = struct.pack('B', client_ip_address)\n                else:\n                    # Destination node address. # 0x00: in own PLC, 0x01~20: ControllerLink, 0x01~FE: Ethernet, 0xFF: Simultaneous broadcast\n                    da1 = struct.pack('B', self.server_node)\n                    # Source node address. # 0x01~FE TCP: Specify No. 5 of the response, UDP: 4th digit of the PC-side IP address.\n                    sa1 = struct.pack('B', self.client_node)\n                # Destination Unit Address. # 0x00: CPU unit, 0xFE: ControllerLink or Ethernet unit, 0x10~1F: CPU Advanced Function Unit, 0xE1: INNER board.\n                da2 = struct.pack('B', 0x00)\n                # Source network address. # 0x00: same network, 0x01~0x7F: source network.\n                sna = struct.pack('B', 0x00)\n                # Source address. # fixed value\n                sa2 = struct.pack('B', 0x00)\n                # Service ID. # 0x00~FF Any, source identifier.\n                # sid = struct.pack('B', 0x19)\n                sid = get_random_sid(1)  # add\n\n                # no parameter format\n                if self.option in global_vars.g_TIME_OPTION:\n                    if self.cmd in global_vars.g_READ_COMMAND:\n                        cmd_code = \"0701\"\n                        cmd = (\n                            struct.pack(\"B\", int(cmd_code[0:2], 16))\n                            + struct.pack(\"B\", int(cmd_code[2:4], 16))\n                        )\n                        # Transmission length.\n                        data_length = (\n                            struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x1A)\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                            )\n                    elif self.cmd in global_vars.g_WRITE_COMMAND:\n                        cmd_code = \"0702\"\n                        cmd = (\n                            struct.pack(\"B\", int(cmd_code[0:2], 16))\n                            + struct.pack(\"B\", int(cmd_code[2:4], 16))\n                        )\n                        if len(self.cmd_data) == 5:\n                            # 秒を00にして曜日算出\n                            year = int(self.cmd_data[0])\n                            month = int(self.cmd_data[1])\n                            day = int(self.cmd_data[2])\n                            if year >= 98:\n                                year += 1900\n                            else:\n                                year += 2000\n                            add_data = [\"00\", format(\n                                datetime.date(year, month, day).weekday() + 1, \"02\")]\n                            self.cmd_data.extend(add_data)\n                        elif len(self.cmd_data) == 6:\n                            # 曜日算出\n                            year = int(self.cmd_data[0])\n                            month = int(self.cmd_data[1])\n                            day = int(self.cmd_data[2])\n                            if year >= 98:\n                                year += 1900\n                            else:\n                                year += 2000\n                            add_data = [\n                                format(datetime.date(year, month, day).weekday() + 1, \"02\")]\n                            self.cmd_data.extend(add_data)\n                        elif len(self.cmd_data) >= 7:\n                            # 7データまでを入力\n                            self.cmd_data = self.cmd_data[:7]\n                        cmd_data = b''\n                        for data in self.cmd_data:\n                            try:\n                                cmd_data += struct.pack(\"B\",\n                                                        int(str(data), 16))\n                            except Exception:\n                                pass\n                        # Data length.\n                        _data_len = '{:08x}'.format(\n                            26 + (len(self.cmd_data) * 2))\n                        data_length = (\n                            struct.pack('B', int(_data_len[0] + _data_len[1], 16))\n                            + struct.pack('B', int(_data_len[2] + _data_len[3], 16))\n                            + struct.pack('B', int(_data_len[4] + _data_len[5], 16))\n                            + struct.pack(\n                                'B', int(_data_len[6] + _data_len[7], 16))\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + cmd_data\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + cmd_data\n                            )\n                elif self.option in [\"warning\"]:\n                    cmd_code = '2102'\n                    cmd = (\n                        struct.pack('B', int(cmd_code[0:2], 16))\n                        + struct.pack('B', int(cmd_code[2:4], 16))\n                    )\n                    read_start = struct.pack(\n                        'B', 0x00) + struct.pack('B', 0x00)\n                    read_count = struct.pack(\n                        'B', 0x01) + struct.pack('B', 0x00)\n\n                    # Transmission length.\n                    data_length = (\n                        struct.pack('B', 0x00)\n                        + struct.pack('B', 0x00)\n                        + struct.pack('B', 0x00)\n                        + struct.pack('B', 0x1A)\n                    )\n                    if self.transport_layer in global_vars.g_UDPIP:\n                        telegram_data = (\n                            icf\n                            + rsv\n                            + gct\n                            + dna\n                            + da1\n                            + da2\n                            + sna\n                            + sa1\n                            + sa2\n                            + sid\n                            + cmd\n                            + read_start\n                            + read_count\n                        )\n                    else:\n                        telegram_data = (\n                            header\n                            + data_length\n                            + tcp_cmd\n                            + err_cd\n                            + icf\n                            + rsv\n                            + gct\n                            + dna\n                            + da1\n                            + da2\n                            + sna\n                            + sa1\n                            + sa2\n                            + sid\n                            + cmd\n                            + read_start\n                            + read_count\n                        )\n                else:\n                    # Devices code\n                    device_code = struct.pack('B', self.device_code)\n\n                    # Extract each hexadecimal digit and reconvert for transmission.\n                    # The first and second bytes are device numbers,\n                    # and the third byte is a bit number within the device. (In the case of word, this is basically '0x00'.)\n                    lead_device = (\n                        self.lead_number\n                        + current_count * self.transfer_limit\n                    )\n                    if self.n_array == '10.10':\n                        q, mod = divmod(lead_device, 16)\n                        bits1 = '{:04x}'.format(q)\n                        bits2 = '{:02x}'.format(mod)\n                        temp1 = int(bits1[0] + bits1[1], 16)\n                        temp2 = int(bits1[2] + bits1[3], 16)\n                        temp3 = int(bits2[0] + bits2[1], 16)\n                    else:\n                        bits = '{:04x}'.format(lead_device)\n                        temp1 = int(bits[0] + bits[1], 16)\n                        temp2 = int(bits[2] + bits[3], 16)\n                        temp3 = 0x00\n                    lead_device_number = (\n                        struct.pack('B', temp1)\n                        + struct.pack('B', temp2)\n                        + struct.pack('B', temp3)\n                    )\n\n                    # Read command telegram.\n                    if self.cmd in global_vars.g_READ_COMMAND:\n                        cmd = (\n                            struct.pack('B', 0x01)\n                            + struct.pack('B', 0x01)\n                        )\n                        # Transmission length.\n                        data_length = (\n                            struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x1A)\n                        )\n                        # Number of bits acquired\n                        if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                            integer_sendlength = (\n                                str(self.send_length)[\n                                    :len(str(self.send_length)) - 2\n                                ]\n                            )\n                            if integer_sendlength == '':\n                                integer_sendlength = 0\n                            few_sendlength = (\n                                str(self.send_length)[\n                                    len(str(self.send_length)) - 2:\n                                ]\n                            )\n                            remain_length = (\n                                int(integer_sendlength) * 16\n                                + int(few_sendlength)\n                                - current_count * self.transfer_limit\n                            )\n                        else:\n                            remain_length = (\n                                self.send_length\n                                - current_count * self.transfer_limit\n                            )\n\n                        # Check the transmission limit.\n                        if remain_length >= self.transfer_limit:\n                            bits_dnum = '{:04x}'.format(self.transfer_limit)\n                        else:\n                            bits_dnum = '{:04x}'.format(remain_length)\n                        device_count = (\n                            struct.pack('B', int(bits_dnum[0] + bits_dnum[1], 16))\n                            + struct.pack(\n                                'B', int(bits_dnum[2] + bits_dnum[3], 16))\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                            )\n                    # Write command telegram.\n                    elif self.cmd in global_vars.g_WRITE_COMMAND:\n                        cmd = (\n                            struct.pack('B', 0x01)\n                            + struct.pack('B', 0x02)\n                        )\n                        # Converts write data into 2 bytes of hexadecimal numbers.\n                        w_data = []\n                        for i in range(len(self.cmd_data)):\n                            if self.cmd_data[i] >= 0:\n                                _hex_w_data = '{:x}'.format(self.cmd_data[i])\n                            else:\n                                _hex_w_data = format(\n                                    self.cmd_data[i] & 0xffff, 'x'\n                                )\n                            for j in range((len(_hex_w_data) // 5) + 1):\n                                if j == 0:\n                                    four_hex = '{:0>4s}'.format(\n                                        _hex_w_data[-4:])\n                                else:\n                                    four_hex = '{:0>4s}'.format(\n                                        _hex_w_data[(j + 1) * (-4):j * (-4)]\n                                    )\n                                w_data.append(\n                                    [\n                                        int(four_hex[0] + four_hex[1], 16),\n                                        int(four_hex[2] + four_hex[3], 16)\n                                    ]\n                                )\n                        # For Big Endian, reverse order acquisition is further reversed to reverse order.\n                        for i in range(len(w_data)):\n                            if i == 0:\n                                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                    cmd_data = struct.pack('B', w_data[i][1])\n                                else:\n                                    cmd_data = (\n                                        struct.pack('B', w_data[i][0])\n                                        + struct.pack('B', w_data[i][1])\n                                    )\n                            else:\n                                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                    cmd_data = (\n                                        cmd_data\n                                        + struct.pack('B', w_data[i][1])\n                                    )\n                                else:\n                                    cmd_data = (\n                                        cmd_data\n                                        + struct.pack('B', w_data[i][0])\n                                        + struct.pack('B', w_data[i][1])\n                                    )\n                        for i in range(len(self.cmd_data)):\n                            for j in range((self.cmd_data[i] // 65535) + 1):\n                                # Number of bits acquired\n                                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                    remain_length = (\n                                        self.send_length * (len(w_data) // 17 + 1)\n                                        - (current_count * self.transfer_limit)\n                                    )\n                                else:\n                                    remain_length = (\n                                        self.send_length\n                                        - current_count * self.transfer_limit\n                                    )\n                                # Check the transmission limit.\n                                if remain_length >= self.transfer_limit:\n                                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                        bits_dnum = '{:04x}'.format(\n                                            self.transfer_limit\n                                        )\n                                    else:\n                                        bits_dnum = '{:04x}'.format(\n                                            self.transfer_limit\n                                        )\n                                elif remain_length < self.transfer_limit:\n                                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                        bits_dnum = '{:04x}'.format(\n                                            remain_length)\n                                    else:\n                                        bits_dnum = '{:04x}'.format(\n                                            remain_length)\n                                device_count = (\n                                    struct.pack('B', int(bits_dnum[0] + bits_dnum[1], 16))\n                                    + struct.pack(\n                                        'B', int(bits_dnum[2] + bits_dnum[3], 16))\n                                )\n                        # Data length.\n                        _data_len = '{:08x}'.format(26 + (len(w_data) * 2))\n                        data_length = (\n                            struct.pack('B', int(_data_len[0] + _data_len[1], 16))\n                            + struct.pack('B', int(_data_len[2] + _data_len[3], 16))\n                            + struct.pack('B', int(_data_len[4] + _data_len[5], 16))\n                            + struct.pack(\n                                'B', int(_data_len[6] + _data_len[7], 16))\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                                + cmd_data\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                                + cmd_data\n                            )\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                            )\n                        )\n\n            # ======= CIP =======\n            elif self.protocol in global_vars.g_CIP:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                    )\n                )\n\n            # ======= HOST LINK (Jp:Joui LINK) =======\n            elif self.protocol in global_vars.g_HOSTLINK:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                    )\n                )\n\n            # ======= EHTERNET IP ========\n            elif self.protocol in global_vars.g_ETHERNETIP:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                    )\n                )\n\n            # ======= CONNECTION THROUGH RASPI-RC232C =======\n            # ======= MODBUS RTU =======\n            elif self.protocol in global_vars.g_MODBUSRTU:\n                rp_header = (\n                    struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                )\n                slave_addr = struct.pack('B', 0x01)\n                rp_footer = (\n                    struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                )\n                # Extract each hexadecimal digit and reconvert for transmission.\n                lead_bit = (\n                    self.lead_number\n                    + current_count * self.transfer_limit\n                )\n                bits = '{:04x}'.format(lead_bit)\n                hex_lead_bit = (\n                    struct.pack('B', int(bits[0] + bits[1], 16))\n                    + struct.pack('B', int(bits[2] + bits[3], 16))\n                )\n                # device_code  = struct.pack('B', self.device_code)\n\n                # For the Read command\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        func_code = struct.pack('B', 0x01)\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        func_code = struct.pack('B', 0x03)\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n\n                    # Number of bits acquired\n                    remain_length = (\n                        self.send_length\n                        - current_count * self.transfer_limit\n                    )\n                    if remain_length >= self.transfer_limit:\n                        bits_vol = '{:04x}'.format(self.transfer_limit)\n                    else:\n                        bits_vol = '{:04x}'.format(remain_length)\n                    data_count = (\n                        struct.pack('B', int(bits_vol[0] + bits_vol[1], 16))\n                        + struct.pack('B', int(bits_vol[2] + bits_vol[3], 16))\n                    )\n                    row_data = (\n                        slave_addr\n                        + func_code\n                        + hex_lead_bit\n                        + data_count\n                    )\n                    telegram_data = (\n                        rp_header\n                        + row_data\n                        + convert_format.make_crc(row_data)\n                        + rp_footer\n                    )\n                # For the Write command\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    pass\n\n            # ======= COMPUTER LINK =======\n            elif self.protocol in global_vars.g_COMPUTERLINK:\n                rp_header = (\n                    struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                )\n                slave_addr = b'\\x0500FF'\n                rp_footer = (\n                    struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                )\n\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        func_code = b'BR'\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        func_code = b'WR'\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n\n                timeout_addr = b'0'\n                # Extract each hexadecimal digit and reconvert for transmission.\n                device_code = struct.pack('B', self.device_code[0])\n                lead_data = (\n                    '{:04d}'.format(\n                        self.lead_number\n                        + current_count * self.transfer_limit\n                    )\n                ).encode()\n                remain_length = (\n                    self.send_length\n                    - current_count * self.transfer_limit\n                )\n                if remain_length >= self.transfer_limit:\n                    data_count = (\n                        '{:02x}'.format(\n                            self.transfer_limit\n                        )\n                    ).encode()\n                else:\n                    data_count = '{:02x}'.format(remain_length).encode()\n                row_data = (\n                    slave_addr\n                    + func_code\n                    + timeout_addr\n                    + device_code\n                    + lead_data\n                    + data_count\n                )\n                telegram_data = (\n                    rp_header\n                    + row_data\n                    + rp_footer\n                )\n\n            return telegram_data\n        except Exception:\n            logger.warning(traceback.format_exc())\n\n    # Telegraphic data transmission.\n    def sent_telegram(self) -> typing.Tuple[str, bytes, int]:\n        loop_count = self.transfer_count\n        res = ''\n        try:\n            # =============================\n            # MODBUS-TCP (Modbus Protocol - TCP)\n            # =============================\n            if self.protocol in global_vars.g_MODBUSTCP:\n                # Coil              Read-Write  1bit    (Discrete Output(DO)    1~9999)\n                # Input Status      Read        1bit    (Discrete Input(DI)     10001~19999)\n                # Input Register    Read        16bit   (Analog Input(AI)       30001~39999)\n                # Holding Register  Read-Write  16bit   (Analog Output(AO)      40001~49999)\n                con = ModbusClient()\n                con.host(self.host)\n                con.port(self.port)\n\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    if self.device in ['COIL', 'DO', 'DISCRETE_OUTPUT']:\n                        res = con.read_coils(self.lead_nuber, self.send_length)\n                    elif self.device in ['INPUT_STATUS', 'DI', 'DISCRETE_INPUT']:\n                        res = con.read_discrete_inputs(\n                            self.lead_nuber, self.send_length)\n                    elif self.device in ['INPUT_REGISTER', 'AI', 'ANALOG_INPUT']:\n                        res = con.read_input_registers(\n                            self.lead_nuber, self.send_length)\n                    elif self.device in ['HOLDING_REGISTER', 'AO', 'ANALOG_OUTPUT']:\n                        res = con.read_holding_register(\n                            self.lead_nuber, self.send_length)\n                    else:\n                        raise ValueError(\n                            '{},Ecode:{}'.format(\n                                sys._getframe().f_code.co_name, 'Device name is wrong.'\n                            )\n                        )\n\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    if self.device in ['DO', 'COIL', 'DISCRETE_OUTPUT']:\n                        con.write_multiple_coils(\n                            self.lead_number, self.cmd_data)\n                    elif self.device in ['HOLDING_REGISTER', 'AO', 'ANALOG_OUTPUT']:\n                        con.write_multiple_registers(\n                            self.lead_number, self.cmd_data)\n                    else:\n                        raise ValueError(\n                            '{},Ecode:{}'.format(\n                                sys._getframe().f_code.co_name, 'Device name is wrong.'\n                            )\n                        )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This command is not supported.'\n                        )\n                    )\n\n            # =============================\n            # Socket Connection\n            # =============================\n            else:\n                # Connection initialize\n                if self.transport_layer in global_vars.g_TCPIP:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                elif self.transport_layer in global_vars.g_UDPIP:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                else:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.settimeout(global_vars.PLC_TIMEOUT_SECONDS)\n                s.connect((self.host, self.port))\n\n                # ===========================\n                # Read Data Command\n                # ===========================\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    for i in range(loop_count):\n                        # =============================\n                        # MC Protocol(MELSEC Communication Protocol)\n                        # =============================\n                        if self.protocol in global_vars.g_MCPROTOCOL1E + global_vars.g_MCPROTOCOL3E:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n\n                            # =============================\n                            # MC protocol/1E Frame\n                            # =============================\n                            # Check error code. '00' is success. other is error.\n                            if self.protocol in global_vars.g_MCPROTOCOL1E:\n                                ecode = recv_data[\n                                    self.prefix_bit - 2: self.prefix_bit\n                                ]\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n\n                            # =============================\n                            # MC protocol/3E Frame, SLMP(Seamless Message Protocol)\n                            # =============================\n                            elif self.protocol in global_vars.g_MCPROTOCOL3E:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                )\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    'Protcol is {}. Not support.'.format(\n                                        self.protocol\n                                    )\n                                )\n\n                            # Successfully completed.\n                            ecode = 0\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                e_bit = self.transfer_limit + self.prefix_bit\n                                res += recv_data[self.prefix_bit: e_bit]\n                            elif i == 0:\n                                res = recv_data\n\n                        # =============================\n                        # FINS(Factory Interface Netwrok Service)\n                        # =============================\n                        elif self.protocol in global_vars.g_FINS:\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                self.client_node = ''\n                                self.server_node = ''\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                # Communication for obtaining node parameters.\n                                send_nodeData = self.generate_node_telegram(\n                                    self.protocol)\n                                s.send(bytes(send_nodeData))\n                                recv_nodeData = s.recv(1024).hex()\n                                node_ecode1 = recv_nodeData[16:24]\n                                node_ecode2 = recv_nodeData[24:32]\n                                # Node error handling\n                                if int(node_ecode1, 16) not in [1, 64, 128]:\n                                    ecode = node_ecode1\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                if int(node_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = node_ecode2\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                self.client_node = int(\n                                    '0x'\n                                    + recv_nodeData[32:40], 16\n                                )\n                                self.server_node = int(\n                                    '0x' + recv_nodeData[40:48], 16\n                                )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n                            # FINS connection Error check\n                            # Check \"Connection\" error code. If command(only TCP) is not \"2\", error code is '00000000' is success. other is error.\n                            # Check error code. '0000' is success. other is error.\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                )\n                                if int(ecode, 16) not in [0, 64, 128]:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                conn_ecode1 = recv_data[16:24]\n                                conn_ecode2 = recv_data[24:32]\n                                ecode = recv_data[\n                                    self.prefix_bit - 4: self.prefix_bit\n                                ]\n                                if int(conn_ecode1, 16) not in [2, 64, 128] and int(conn_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = conn_ecode2 + ',' + ecode\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                elif int(ecode, 16) not in [0, 64, 128]:\n                                    ecode = (\n                                        recv_data[\n                                            self.prefix_bit - 4: self.prefix_bit - 2\n                                        ]\n                                        + recv_data[\n                                            self.prefix_bit - 2: self.prefix_bit\n                                        ]\n                                    )\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n                            # Successfully completed.\n                            ecode = 0\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                e_bit = self.transfer_limit + self.prefix_bit\n                                res += recv_data[self.prefix_bit:e_bit]\n                            elif i == 0:\n                                res = recv_data\n\n                        # =============================\n                        # MODBUS-RTU (Modbus Protocol - Remote Terminal Unit)\n                        # =============================\n                        elif self.protocol in global_vars.g_MODBUSRTU:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data_r = s.recv(1024)  # .hex()\n                            s.close()\n                            # Check CRC. success or error?\n                            if len(recv_data_r) > 6:\n                                row_data_r = recv_data_r[3:len(\n                                    recv_data_r) - 5]\n                                if convert_format.make_crc(row_data_r) != recv_data_r[len(recv_data_r) - 5:len(recv_data_r) - 3]:\n                                    raise ValueError(\n                                        '{}, {}'.format(\n                                            recv_data_r, 'too short recieve data'\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    '{}, {}'.format(\n                                        recv_data_r, 'too short recieve data'\n                                    )\n                                )\n                            recv_data = row_data_r\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                # このあたり不明\n                                res += recv_data\n                            elif i == 0:\n                                # Successfully completed.\n                                ecode = 0\n                                res = recv_data\n\n                        # =============================\n                        # Computer Link (PC Link)\n                        # =============================\n                        elif self.protocol in global_vars.g_COMPUTERLINK:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data_r = s.recv(1024)  # .hex()\n                            s.close()\n                            # Check CRC. success or error?\n                            if len(recv_data_r) > 6:\n                                row_data_r = recv_data_r[3:len(\n                                    recv_data_r) - 3]\n                            else:\n                                raise ValueError(\n                                    '{}, {}'.format(\n                                        recv_data_r, 'too short recieve data'\n                                    )\n                                )\n                            recv_data = row_data_r\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                # このあたり不明\n                                res += recv_data\n                            elif i == 0:\n                                # Successfully completed.\n                                ecode = 0\n                                res = recv_data\n\n                        else:\n                            raise ValueError(\n                                '{}, {}'.format(\n                                    sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                                )\n                            )\n\n                # =============================\n                # Write Data Command\n                # =============================\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    for i in range(loop_count):\n                        # =============================\n                        # MC Protocol(MELSEC Communication Protocol)\n                        # =============================\n                        if self.protocol in global_vars.g_MCPROTOCOL1E + global_vars.g_MCPROTOCOL3E:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n\n                            # =============================\n                            # MC protocol/1E Frame\n                            # =============================\n                            if self.protocol in global_vars.g_MCPROTOCOL1E:\n                                ecode = recv_data[\n                                    self.prefix_bit - 2: self.prefix_bit\n                                ]\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n\n                            # =============================\n                            # MC protocol/3E Frame, SLMP(Seamless Message Protocol)\n                            # =============================\n                            elif self.protocol in global_vars.g_MCPROTOCOL3E:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                )\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            # Successful handling.\n                            # Write command has no received.\n                            ecode = 0\n                            res = recv_data\n\n                        # =============================\n                        # FINS(Factory Interface Netwrok Service)\n                        # =============================\n                        elif self.protocol in global_vars.g_FINS:\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                self.client_node = self.server_node = ''\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                # Communication for obtaining node parameters.\n                                send_nodeData = self.generate_node_telegram(\n                                    self.protocol)\n                                s.send(bytes(send_nodeData))\n                                recv_nodeData = s.recv(1024).hex()\n                                node_ecode1 = recv_nodeData[16:24]\n                                node_ecode2 = recv_nodeData[24:32]\n                                # Node Error handling.\n                                if int(node_ecode1, 16) not in [1, 64, 128]:\n                                    ecode = node_ecode1\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_nodeData, send_nodeData, ecode\n                                        )\n                                    )\n                                if int(node_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = node_ecode2\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_nodeData, send_nodeData, ecode\n                                        )\n                                    )\n                                self.client_node = int(\n                                    '0x'\n                                    + recv_nodeData[32:40], 16\n                                )\n                                self.server_node = int(\n                                    '0x'\n                                    + recv_nodeData[40:48], 16\n                                )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n\n                            # FINS connection Error check\n                            # Check \"Connection\" error code. If command(only TCP) is not \"2\", error code is '00000000' is success. other is error.\n                            # Check error code. '0000' is success. other is error.\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                )\n                                if int(ecode, 16) not in [0, 64, 128]:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                conn_ecode1 = recv_data[16:24]\n                                conn_ecode2 = recv_data[24:32]\n                                ecode = recv_data[\n                                    self.prefix_bit - 4: self.prefix_bit\n                                ]\n\n                                if int(conn_ecode1, 16) not in [2, 64, 128] and int(conn_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = conn_ecode2 + ',' + ecode\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                elif int(ecode, 16) not in [0, 64, 128]:\n                                    ecode = (\n                                        recv_data[\n                                            self.prefix_bit - 4: self.prefix_bit - 2\n                                        ]\n                                        + recv_data[\n                                            self.prefix_bit - 2: self.prefix_bit\n                                        ]\n                                    )\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n                            res = recv_data\n                            ecode = 0\n\n                        # =============================\n                        # MODBUS-RTU (Modbus Protocol - Remote Terminal Unit)\n                        # =============================\n                        elif self.protocol in global_vars.g_MODBUSRTU:\n                            pass\n\n                        else:\n                            raise ValueError(\n                                '{}, {}'.format(\n                                    sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                                )\n                            )\n\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This command is not supported.'\n                        )\n                    )\n        # Error Response Handling.\n        except Exception as err:\n            try:\n                if res == '':\n                    res = recv_data\n                else:\n                    res\n            except NameError:\n                res = str(err)\n            try:\n                senddata.hex()\n            except NameError:\n                senddata = ''\n            try:\n                recv_data\n            except NameError:\n                recv_data = ''\n            try:\n                ecode\n            except NameError:\n                ecode = -1\n            try:\n                s.close()\n            except Exception:\n                logger.warning('Socket can not closed.')\n        finally:\n            try:\n                senddata = senddata.hex()\n            except Exception:\n                pass\n            finally:\n                return res, senddata, ecode\n\n    # Parse the data in bit/word units.\n    # When it's bit, if you are reading an odd number of bits, a 0 is padded after the last bit.\n    # When it's word, it'll consolidate four digits and convert hexadecimal numbers to decimal numbers.\n\n    def extracting_elements(self, data: str, *, use_bcd: bool = False, optional: dict = {}) -> list:\n        # logger.info('string_null:{}'.format(string_option_null_break))\n        res = []\n        message = \"\"\n        try:\n            data_len = int(len(data))\n            # Perse bit unit\n            if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                if self.manufacture in global_vars.g_OMRON:\n                    for j in range(int((data_len - self.prefix_bit) / 2)):\n                        st = self.prefix_bit + j * 2\n                        ed = st + 2\n                        temp_w_recv = data[st:ed]\n                        if self.protocol in global_vars.g_FINS:\n                            w_recv = temp_w_recv\n                        res.append(w_recv)\n                # ikeike\n                elif self.protocol in global_vars.g_MODBUSRTU:\n                    # 長すぎる場合は未対応data[self.prefix_bit - 1]\n                    len_of_data = self.send_length\n                    for j in range(data_len - self.prefix_bit):\n                        val = int(data[j + self.prefix_bit])\n                        for k in range(16):\n                            if k >= len_of_data:\n                                break\n                            res.append(str(int(val % 2)))\n                            val /= 2\n                        len_of_data -= 16\n                # ikeike\n                # ikeikeike\n                elif self.protocol in global_vars.g_COMPUTERLINK:\n                    # 長すぎる場合は未対応data[self.prefix_bit - 1]\n                    for j in range(0, data_len - self.prefix_bit - 1):\n                        res.append(chr(data[j + self.prefix_bit]))\n                # ikeikeike\n                else:\n                    for j in range(data_len - self.prefix_bit):\n                        st = self.prefix_bit + j\n                        ed = st + 1\n                        b_recv = data[st:ed]\n                        res.append(b_recv)\n            # Perse word unit\n            elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                if self.protocol in global_vars.g_MODBUSRTU:\n                    for j in range(0, data_len - self.prefix_bit, 2):\n                        try:\n                            res.append(\n                                format(int(data[j + self.prefix_bit]), '02x')\n                                + format(\n                                    int(data[j + 1 + self.prefix_bit]), '02x')\n                            )\n                        except Exception:\n                            res.append(\n                                format(int(data[j + self.prefix_bit], 16), '02x')\n                                + format(\n                                    int(data[j + 1 + self.prefix_bit], 16), '02x')\n                            )\n                elif self.protocol in global_vars.g_COMPUTERLINK:\n                    for j in range(0, data_len - self.prefix_bit - 1, 4):\n                        res.append(\n                            format(\n                                int((\n                                    chr(data[self.prefix_bit + j])\n                                    + chr(data[self.prefix_bit + j + 1])\n                                    + chr(data[self.prefix_bit + j + 2])\n                                    + chr(data[self.prefix_bit + j + 3])\n                                ).lower(), 16), '04x'\n                            )\n                        )\n                else:\n                    for j in range(int((data_len - self.prefix_bit) / 4)):\n                        st = self.prefix_bit + j * 4\n                        ed = st + 4\n                        temp_w_recv = data[st:ed]\n                        if self.protocol in global_vars.g_FINS:\n                            w_recv = temp_w_recv\n                        elif self.protocol in global_vars.g_MODBUSRTU:\n                            if j < 2 and int(temp_w_recv[2:]) == 0:\n                                w_recv = temp_w_recv[:2]\n                            elif j < 2 and int(temp_w_recv[:2]) == 0:\n                                w_recv = temp_w_recv[2:]\n                            else:\n                                w_recv = temp_w_recv[2:] + temp_w_recv[:2]\n                        else:\n                            w_recv = temp_w_recv[2:] + temp_w_recv[:2]\n                        res.append(w_recv)\n\n                if (self.option in global_vars.g_STRING_OPTION and self.cmd in global_vars.g_READ_COMMAND):\n                    if self.manufacture in global_vars.g_PANASONIC:\n                        _res = convert_format.check_hex_and_convert_integer(\n                            res[2:], self.byte_order, dhex=True)\n                        try:\n                            try:\n                                word_cnt = int(res[1], 16)\n                            except Exception:\n                                word_cnt = int(res[1])\n                        except Exception:\n                            word_cnt = 0\n                        res = _res[:word_cnt]\n                    # elif self.manufacture in global_vars.g_KEYENCE:\n                    #     _res = convert_format.check_hex_and_convert_integer(\n                    #         res, self.byte_order, dhex=True)\n                    #     try:\n                    #         try:\n                    #             word_cnt = int(res[1], 16)\n                    #         except Exception:\n                    #             word_cnt = int(res[1])\n                    #     except Exception:\n                    #         word_cnt = 0\n                    #     res = _res[:word_cnt]\n                    else:\n                        _res = convert_format.check_hex_and_convert_integer(\n                            res, self.byte_order, dhex=True)\n                        try:\n                            string_option_null_break = optional['string_option_null_break']\n                        except Exception:\n                            string_option_null_break = True\n                        if string_option_null_break:\n                            for i, x in enumerate(_res):\n                                if x == 0:\n                                    res = _res[:i]\n                                    break\n                        else:\n                            res = _res\n                        # logger.info(\"Res:{}, null_break:{}\".format(\n                        #    res, string_option_null_break))\n            else:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                    )\n                )\n            try:\n                if use_bcd:\n                    response = res\n                else:\n                    try:\n                        response = [int(x, 16) for x in res]\n                    except Exception:\n                        response = res\n                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                    if self.bit_odd_flag:\n                        try:\n                            if len(response) % 2 == 0:\n                                response.pop()\n                        except Exception:\n                            pass\n            except Exception:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'System error:Response format is incorrect.'\n                    )\n                )\n        except Exception:\n            logger.warning(traceback.format_exc())\n            message = str(traceback.format_exc())\n            response = None\n        finally:\n            # logger.info('Response:{}, {}'.format(response, message))\n            return response, message\n\n\ndef adjust_max_characters_of_case_of_string(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict):\n    # In the case of string reading, the maximum number of characters is read from the PLC first.\n    #  Adjust the maximum number of characters for string reading.\n    try:\n        if (cmd_data[\"option\"] in global_vars.g_STRING_OPTION\n            and cmd_data[\"cmd\"] in global_vars.g_READ_COMMAND\n                and plc_protocol[\"manufacture\"] in global_vars.g_PANASONIC):\n            _device_info = device_list.device_list(\n                plc_protocol[\"manufacture\"], plc_protocol[\"protocol\"], plc_protocol[\n                    \"series\"], transport_layer=plc_protocol[\"transport_layer\"], period_index=plc_protocol[\"period_index\"]\n            )\n            if _device_info[\"device\"][device_parameter[\"device\"]][2] == \"w\":\n                _device_parameter = device_parameter\n                _device_parameter[\"max\"] = _device_parameter[\"min\"]\n                _cmd_data = cmd_data\n                _cmd_data[\"option\"] = \"\"\n                _connect = ConnectToPlc(\n                    plc_network,\n                    plc_protocol,\n                    _device_parameter,\n                    _cmd_data\n                )\n                _res, _send, _err = _connect.sent_telegram()\n\n                if re.fullmatch(\"[0-9a-f]+\", _res, re.I):\n                    # Parse the data in bit/word units.\n                    _res_element, _message_element = _connect.extracting_elements(\n                        _res)\n                    logger.debug('Adjust Res Element:{}'.format(_res_element))\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'Error.'\n                        )\n                    )\n                _cnv_leaddev = device_list.convert_to_decimal(\n                    _device_info[\"device\"][_device_parameter[\"device\"]][0], _device_parameter)\n                _cnv_minmax = device_list.convert_to_n_array(\n                    _device_info[\"device\"][_device_parameter[\"device\"]][0], _cnv_leaddev[\"lead_number\"], _res_element[0] + 2)\n                device_parameter[\"min\"] = _cnv_minmax[\"min_bit\"]\n                device_parameter[\"max\"] = _cnv_minmax[\"max_bit\"]\n                cmd_data[\"option\"] = global_vars.g_STRING_OPTION[0]\n    except Exception:\n        pass\n    finally:\n        return plc_network, plc_protocol, device_parameter, cmd_data\n\n\n# Use asyncio to connect to multiple PLCs in parallel.\nasync def parallel_communication_to_plc(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict, *, optional: dict = {}) -> dict:\n    res = ''\n    send = ''\n    res_element = ''\n    try:\n        # If can read max string length, fixed max device.\n        plc_network, plc_protocol, device_parameter, cmd_data = adjust_max_characters_of_case_of_string(\n            plc_network, plc_protocol, device_parameter, cmd_data)\n\n        # Connection to PLC\n        connect = ConnectToPlc(\n            plc_network,\n            plc_protocol,\n            device_parameter,\n            cmd_data\n        )\n        # Generate telegram and transmission telegram to PLC.\n        res, send, err = connect.sent_telegram()\n\n        # Is data format BCD?\n        use_bcd: bool = False\n        try:\n            if cmd_data[\"option\"] in [\"time\", \"warning\"]:\n                if plc_protocol[\"manufacture\"] in (global_vars.g_MITSUBISHI + global_vars.g_PANASONIC + global_vars.g_OMRON):\n                    use_bcd = True\n                elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n                    use_bcd = False\n        except Exception:\n            use_bcd = False\n\n        if re.fullmatch(\"[0-9a-f]+\", res, re.I):\n            # Parse the data in bit/word units.\n            res_element, message_element = connect.extracting_elements(\n                res, use_bcd=use_bcd, optional=optional)\n            logger.debug(\"Extract:{}\".format(res_element))\n            # convert date format.\n            if cmd_data[\"option\"] in global_vars.g_TIME_OPTION:\n                res_element = convert_format.convert_date_format(\n                    plc_protocol, cmd_data, res_element)\n        else:\n            raise ValueError(\n                '{}, {}'.format(\n                    sys._getframe().f_code.co_name, 'Error.'\n                )\n            )\n\n    except Exception as e:\n        if not res or res == ['']:\n            res = [e]\n            err = e\n        if not send:\n            send = ''\n        if not res_element or res_element == 0:\n            res_element = 0\n    finally:\n        return {\n            'response': res,\n            'exists_data': res_element,\n            'send_binary': send,\n            'error_code': err,\n            'message': err,\n        }\n\n\nasync def parallel_connect(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict, *, optional: dict = {}):\n    # Communicate in parallel\n    if not optional:\n        for k in plc_network:\n            optional[k] = {}\n    all_groups = await asyncio.gather(\n        *[\n            parallel_communication_to_plc(\n                plc_network[i],\n                plc_protocol[i],\n                device_parameter[i],\n                cmd_data[i],\n                optional=optional[i]\n            ) for i in device_parameter.keys()\n        ]\n    )\n    return {[j for j in device_parameter.keys()][i]: x for i, x in enumerate(all_groups)}\n\n\ndef single_communication_to_plc(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict) -> dict:\n    res = send = res_element = ''\n    try:\n        # If can read max string length, fixed max device.\n        plc_network, plc_protocol, device_parameter, cmd_data = adjust_max_characters_of_case_of_string(\n            plc_network, plc_protocol, device_parameter, cmd_data)\n\n        # Connection to PLC\n        connect = ConnectToPlc(\n            plc_network,\n            plc_protocol,\n            device_parameter,\n            cmd_data\n        )\n        # Generate telegram and transmission telegram to PLC.\n        res, send, err = connect.sent_telegram()\n\n        # Is data format BCD?\n        use_bcd: bool = False\n        try:\n            if cmd_data[\"option\"] in [\"time\", \"warning\"]:\n                if plc_protocol[\"manufacture\"] in (global_vars.g_MITSUBISHI + global_vars.g_PANASONIC + global_vars.g_OMRON):\n                    use_bcd = True\n                elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n                    use_bcd = False\n        except Exception:\n            use_bcd = False\n\n        if re.fullmatch(\"[0-9a-f]+\", res, re.I):\n            # Parse the data in bit/word units.\n            res_element, message_element = connect.extracting_elements(\n                res, use_bcd=use_bcd)\n\n            # convert date format.\n            res_element = convert_format.convert_date_format(\n                plc_protocol, cmd_data, res_element)\n        else:\n            raise ValueError(\n                '{}, {}'.format(\n                    sys._getframe().f_code.co_name, 'Error.'\n                )\n            )\n    except Exception as e:\n        if not res or res == ['']:\n            res = [e]\n            err = e\n        if not send:\n            send = ''\n        if not res_element or res_element == 0:\n            res_element = 0\n        # print(traceback.format_exc())\n    finally:\n        return {\n            'response': res,\n            'exists_data': res_element,\n            'send_binary': send,\n            'error_code': err,\n            'message': err,\n        }\n\n\ndef single_connect(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict):\n    key = [i for i in device_parameter.keys()][0]\n    # Communicate in parallel\n    all_groups = single_communication_to_plc(\n        plc_network[key],\n        plc_protocol[key],\n        device_parameter[key],\n        cmd_data[key]\n    )\n    return {key: all_groups}\n\n\ndef communication_to_plc(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict) -> typing.Tuple[str, list, str, int]:\n    res = send = res_element = ''\n    try:\n        # If can read max string length, fixed max device.\n        plc_network, plc_protocol, device_parameter, cmd_data = adjust_max_characters_of_case_of_string(\n            plc_network, plc_protocol, device_parameter, cmd_data)\n\n        # Connection to PLC\n        connect = ConnectToPlc(\n            plc_network,\n            plc_protocol,\n            device_parameter,\n            cmd_data\n        )\n        # Generate telegram and transmission telegram to PLC.\n        res, send, err = connect.sent_telegram()\n\n        # Is data format BCD?\n        use_bcd: bool = False\n        try:\n            if cmd_data[\"option\"] in [\"time\", \"warning\"]:\n                if plc_protocol[\"manufacture\"] in (global_vars.g_MITSUBISHI + global_vars.g_PANASONIC + global_vars.g_OMRON):\n                    use_bcd = True\n                elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n                    use_bcd = False\n        except Exception:\n            use_bcd = False\n\n        if re.fullmatch(\"[0-9a-f]+\", res, re.I):\n            # Parse the data in bit/word units.\n            res_element, message_element = connect.extracting_elements(\n                res, use_bcd=use_bcd)\n\n            # convert date format.\n            res_element = convert_format.convert_date_format(\n                plc_protocol, cmd_data, res_element)\n        else:\n            raise ValueError(\n                '{}, {}'.format(\n                    sys._getframe().f_code.co_name, 'Error.'\n                )\n            )\n\n    except Exception as e:\n        if not res or res == ['']:\n            res = [e]\n            err = e\n        if not send:\n            send = ''\n        if not res_element or res_element == 0:\n            res_element = 0\n        # print(traceback.format_exc())\n    return res, res_element, send, err\n\n\ndef _main(plc_network: list, plc_protocol: list, device_parameter: list, cmd_data: list):\n    # Communicate only.\n    all_groups = communication_to_plc(\n        plc_network[0], plc_protocol[0], device_parameter[0], cmd_data[0])\n    return all_groups\n\n\nif __name__ == '__main__':\n    _plc_network = {\n        \"pqm_address\": {'ip': '10.224.136.114', 'port': '5000'},\n        # \"pqm_model\": {'ip': '10.224.136.114', 'port': '5000'},\n        # \"pqm_runmode\": {'ip': '10.224.136.114', 'port': '5000'},\n        # \"pqm_time\": {'ip': '10.224.136.114', 'port': '5000'},\n    }\n    _plc_protocol = {\n        \"pqm_address\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n        # \"pqm_model\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n        # \"pqm_runmode\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n        # \"pqm_time\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n    }\n    _device_parameter = {\n        \"pqm_address\": {\"device\": \"D\", \"min\": \"200\", \"max\": \"230\"},\n        # \"pqm_model\": {\"device\": \"D\", \"min\": \"400\", \"max\": \"520\"},\n        # \"pqm_runmode\": {\"device\": \"D\", \"min\": \"700\", \"max\": \"720\"},\n        # \"pqm_time\": {\"device\": \"D\", \"min\": \"200\", \"max\": \"201\"},\n    }\n    _cmd_data = {\n        \"pqm_address\": {\"cmd\": \"read\", \"data\": [], \"option\": \"\"},\n        # \"pqm_model\": {\"cmd\": \"read\", \"data\": [], \"option\": \"string\"},\n        # \"pqm_runmode\": {\"cmd\": \"read\", \"data\": [], \"option\": \"string\"},\n        # \"pqm_time\": {\"cmd\": \"read\", \"data\": [], \"option\": \"time\"},\n    }\n    _optional = {\n        # \"pqm_address\": {},\n        # \"pqm_model\": {\"string_option_null_break\": False},\n        # \"pqm_runmode\": {\"string_option_null_break\": False},\n        # \"pqm_time\": {},\n    }\n    loop = asyncio.get_event_loop()\n    result = loop.run_until_complete(parallel_connect(\n        _plc_network, _plc_protocol, _device_parameter, _cmd_data, optional=_optional))\n    logger.info(\n        'result(recv, recv_parameter(n_array), send):{}'.format(result))\n",
        "pymodbus.py": "# from pymodbus3.client.sync import ModbusTcpClient\n\n# import logging\n# UNIT = 0x1\n\n# def run_sync_client():\n#     try:\n#         client = ModbusTcpClient('192.168.0.10', port=502)\n#         # client = ModbusClient('localhost', port=502)\n#         client.connect()\n#         #connected =1\n\n#     except:\n#         print(\"modbus error\")\n#    # \"Read write registeres simulataneously\")\n#     try:\n#         rr = client.read_holding_registers(1, 4, unit=UNIT)\n#         # following will write value 10 or 20 to address 1\n#         rq = client.write_register(4, 20, unit=UNIT)\n#         # close the client\n#         client.close()\n#         print(rr)\n#         print(rr.registers)\n#     except Exception as e:\n#         print(\"Modbus Connection returned Error \", e)\n\n\n# if __name__ == \"__main__\":\n#     run_sync_client()\n\n\n# from pyModbusTCP.client import ModbusClient\n# c = ModbusClient(host=\"127.0.0.1\", auto_open=True, auto_close=True)\n# regs = c.read_holding_registers(0, 2)\n# if regs:\n#     print(regs)\n# else:\n#     print(\"read error\")\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# read_register\n# read 10 registers and print result on stdout\n# you can use the tiny modbus server \"mbserverd\" to test this code\n# mbserverd is here: https://github.com/sourceperl/mbserverd\n# the command line modbus client mbtget can also be useful\n# mbtget is here: https://github.com/sourceperl/mbtget\nfrom pyModbusTCP.client import ModbusClient\nimport time\nSERVER_HOST = \"192.168.0.10\"  # 接続先ホスト\nSERVER_PORT = 502\nc = ModbusClient()\n# uncomment this line to see debug message\n# c.debug(True)\n# define modbus server host, port\nc.host(SERVER_HOST)\nc.port(SERVER_PORT)\nwhile True:\n    # open or reconnect TCP to server\n    if not c.is_open():\n        if not c.open():\n            print(\"unable to connect to \"+SERVER_HOST+\":\"+str(SERVER_PORT))\n    # if open() is ok, read register (modbus function 0x03)\n    if c.is_open():\n\n        # recs = c.read_coils(8192, 10)\n        # print(recs)\n        # if c.write_multiple_registers(10, [44, 55]):\n        #     print(\"write ok\")\n        # else:\n        #     print(\"write error\")\n\n        # read 10 registers at address 0, store result in regs list\n        regs = c.read_holding_registers(0, 125)\n        # if success display registers\n        if regs:\n            print(\"reg ad #0 to 9: \"+str(regs))\n    # sleep 2s before next polling\n    time.sleep(2)\n",
        "README.md": "EthernetでPLCと通信する - python.\n==============\nPLCとPCをイーサネット間で接続し、ソケット通信(TCP)で疎通します。<br>\n指定したPLCのデバイス(ビット群)にアクセスし、内容の読み書きを行います。<br>\n通信する際は通信先PLCと通信元PCのネットワーク設定をよく確認してください。<br>\n\n## 対応PLC\n三菱　　　　：MELSEC-QL /iQ-R /iQ-Fシリーズ (MCプロトコル 1E, 3Eフレーム対応機種)<br>\nキーエンス　：KV-3000 /5000 /7000 /8000シリーズ (MCプロトコル対応機種)<br>\nパナソニック：FP-0 /7シリーズ (MCプロトコル対応機種)<br>\nオムロン　　：CS /CJ /CP /NSJシリーズ (FINS通信対応機種)<br>\n\n## 使い方\n##### ~~~~~~ 辞書型 ~~~~~~\n##### PLCのネットワーク設定\n&nbsp;plc_netwok = {'com0':{'ip':'xxx.xxx.xxx.xxx', 'port':'xxxxx'},}<br>\n##### PLCの機種設定\n&nbsp;plc_protocol = {'com0':{'manufacture':'mitsubishi', 'series':'ql', 'protocol':'mc_3e', 'transport_layer':'tcp'},}<br>\n##### アクセスするPLCのデバイスの設定<br>\n&nbsp;device_parameter = {'com0':{'device':'M', 'min':'0', 'max':10},}<br>\n##### 実行内容\n###### 読出し\n&emsp;cmd_data = {'com0':{'cmd':'read', 'data':[], 'option':''},}<br>\n###### 書込み(数値)\n&emsp;cmd_data = {'com0':{'cmd':'write', 'data':[0,1,2,3,4,5,6,7,8,9,10], 'option':''},}<br>\n###### 書込み(文字列)\n&emsp;moji = ['A','B','C','D']　⇒　ASCII(10)変換 　⇒　moji_ascii = [97,98,99,100]<br>\n&emsp;cmd_data = {'com0':{'cmd':'write', 'data':[len(moji_ascii), moji_ascii[0]+moji_ascii[1]*256+moji_ascii[2]*(256**2)+moji_ascii[3]*(256**3)], 'option':'string'},}<br>\n##### 実行\n&nbsp;loop = asyncio.get_event_loop()<br>\n&nbsp;result = loop.run_until_complete(parallel_connect(plc_network, plc_protocol, device_parameter, cmd_data))<br>\n##### 結果\n&nbsp;result[n]['response']    ⇒ n台目に設定したPLCからの返答電文<br>\n&nbsp;result[n]['exists_data'] ⇒ 返答電文の内容 (書込みの場合は空)<br>\n&nbsp;result[n]['send_binary'] ⇒ PLCに送信した電文<br>\n&nbsp;result[n]['error_code']  ⇒ エラー判定。0の場合通信成功<br>\n",
        "requirements.txt": "pytz             == 2020.4\ntzlocal          == 2.1\n# numpy            == 1.19.4\n# pandas           == 1.1.5\npsycopg2         == 2.8.6\nflask            == 1.1.2\nflask-Cors       == 3.0.10\nflask-Migrate    == 2.7.0\nflask-RESTful    == 0.3.8\nflask-Script     == 2.0.6\nflask_sqlalchemy == 2.5.1\nSQLAlchemy       == 1.3.23\nrequests         == 2.25.1\ngevent           == 20.12.0\ngevent-websocket == 0.10.1\nwerkzeug         == 1.0.1\nxlrd             == 1.2.0\ntqdm             == 4.54.1\nuwsgi            == 2.0.19.1\nnetifaces        == 0.10.9\npsutil           == 5.8.0\nopenpyxl         == 3.0.7\n# numba            == 0.53.1\nuwsgidecorators  == 1.1.0\nicmplib          == 3.0\npython-dotenv    == 0.18.0\npyModbusTCP      == 0.1.10\nmore-itertools   == 8.9.0",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols": {
        "const.py": "# Manufacturer\nMANUFACTURER_MITSUBISHI = [\"mitsubishi\", \"mitubisi\", \"melsec\"]\nMANUFACTURER_KEYENCE = [\"keyence\"]\nMANUFACTURER_PANASONIC = [\"panasonic\", \"matsushita\", \"matusita\"]\nMANUFACTURER_OMRON = [\"omron\"]\n# MANUFACTURER_YASKAWA = [\"yaskawa\", \"yasukawa\"]\n# MANUFACTURER_YOKOGAWA = [\"yokogawa\", \"yokokawa\"]\n# MANUFACTURER_JTEKT = [\"jtekt\"]\n# MANUFACTURER_HITACHI = [\"hitachi\", \"hitati\"]\n# MANUFACTURER_TOSHIBA = [\"toshiba\", \"tosiba\"]\n# MANUFACTURER_SIEMENS = [\"siemens\"]\n# MANUFACTURER_SCHNEIDER = [\n#     \"schneider\", \"schneiderelectric\", \"schneider_electric\", \"schneider electric\"]\n# MANUFACTURER_ROCKWELL = [\"rockwell\"]\nMANUFACTURER_FANUC = [\"fanuc\"]\nMANUFACTURER_BROTHER = [\"brother\"]\n# MANUFACTURER_SHIBAURA = [\"shibaura\"]\n# MANUFACTURER_SUMITOMOHEAVY = [\n#     \"sumitomoheavy\", \"sumitomo_heavy\", \"sumitomo heavy\"]\n\n# Series\nSERIES_MITSUBISHI_IQR = [\"iqr\"]\nSERIES_MITSUBISHI_QL = [\"ql\", \"q61p\"]\n# SERIES_MITSUBISHI_QNA = [\"qna\", \"qa\"]\n# SERIES_MITSUBISHI_A = [\"a\"]\n# SERIES_KEYENCE_KV8XXX = [\"8000\"]\nSERIES_KEYENCE_KV7XXX = [\"7000\", \"7300\", \"7500\"]\nSERIES_KEYENCE_KV5XXX = [\"5000\", \"5500\", \"3000\"]\nSERIES_KEYENCE_KVNANO = [\"nano\"]\nSERIES_PANASONIC_FP0 = [\"fp0\"]\nSERIES_PANASONIC_FP7 = [\"fp7\"]\n\n# Protocol\nPROTOCOL_SLMP = [\"slmp\", \"mcprotocol3e\",\n                 \"mcprotocol_3e\", \"mcprotocol 3e\", \"mcprotocol\", \"3e\"]\nPROTOCOL_MC4E = [\"mcprotocol4e\", \"4e\", \"mcprotocol_4e\", \"mcprotocol 4e\"]\nPROTOCOL_MC1E = [\"mcprotocol1e\", \"1e\", \"mcprotocol_1e\", \"mcprotocol 1e\"]\nPROTOCOL_FINS = [\"fins\"]\n# PROTOCOL_CIP = [\"cip\"]\n# PROTOCOL_HOSTLINK = [\"hostlink\", \"host link\"]\nPROTOCOL_MODBUSTCP = [\"modbus_tcp\", \"modbustcp\", \"modbus tcp\"]\n# PROTOCOL_FOCAS2 = [\"focas2\"]\n# PROTOCOL_MTLINKI = [\"mtlinki\", \"mt_linki\", \"mt linki\"]\n# PROTOCOL_OPCUA = [\"opcua\"]\n# PROTOCOL_MTCONNECT = [\"mtconnect\", \"mt_connect\", \"mt connect\"]\n\n# Device Identify\nBIT_DEVICE = [\"bit\", \"b\"]\nWORD_DEVICE = [\"word\", \"w\"]\nDOUBLE_DEVICE = [\"double\", \"double word\", \"double_word\", \"dw\"]\n\n# Endian\nENDIAN_LITTLE = [\"little\", \"l\"]\nENDIAN_BIG = [\"big\", \"b\"]\n\n# Transport identify\nTRANSPORT_TCP = [\"tcp\", \"tcpip\", \"t\"]\nTRANSPORT_UDP = [\"udp\", \"udpip\", \"u\"]\nTRANSPORT_RS232C = [\"rs232c\", \"232c\"]\nTRANSPORT_RS485 = [\"rs485\", \"485\"]\nTRANSPORT_RS422 = [\"rs422\", \"422\"]\nTRANSPORT_ETHERCAT = [\"ethercat\"]\n\n# Timeout\nTRANSPORT_TIMEOUT = 0.1\n# Retry count\nRETRY_COUNT = 3\n\n# Command\nREAD_COMMAND = [\"read\", \"r\"]\nWRITE_COMMAND = [\"write\", \"w\"]\n\n# Options\nSTRING_DATA = [\"string\", \"str\", \"s\"]\nTIME_DATA = [\"time\"]\nASCII_DATA_CODE = [\"ascii\"]\n",
        "convert.py": "\n\n# アドレス毎に指定された進数表現を元に、入力されたアドレスの文字列を10進数数値に変換\ndef decimal_convert(decimal: str, str_address: str) -> int:\n    \"\"\"\n    # \"10\": \"99999\" => 99999\n    # \"16\": \"FFFF\" => 65535\n    # \"1016\": \"10015\" => 100*16 + 15 = 1615\n    # \"108\": \"1007\" => 100*8 + 7 = 807\n    # \"10F\": \"100F\" => 100*16 + 15 = 1615\n    # \"10.7\": \"100.7\" => 100[7] =  107\n    # \"10.9\": \"100.9\" => 100[9] =  109\n    # \"10.15\": \"100.15\" => 100[15] = 115\n    # \"10.F\": \"100.F\" => 100[15] = 115\n    \"\"\"\n    if decimal == \"10\":\n        int_address = int(float(str_address))\n    elif decimal == \"16\":\n        int_address = int(str_address, 16)\n    elif decimal == \"1016\":\n        # 下2桁だけ分割し、それより上を*16 + 下2桁\n        try:\n            int_address = int(\n                str_address[:-2]) * 16 + int(str_address[-2:])\n        except Exception:\n            int_address = int(str_address[-2:]) * 16\n    elif decimal == \"108\":\n        # 下1桁だけ分割し、それより上を*8*2 + 下1桁\n        try:\n            int_address = int(\n                str_address[:-1]) * 16 + int(str_address[-1:])\n        except Exception:\n            int_address = int(str_address[-1:]) * 16\n    elif decimal == \"10F\":\n        # 下1桁だけ分割し、それより上を*16 + 下1桁を10進数変換\n        try:\n            int_address = int(\n                str_address[:-1]) * 16 + int(str_address[-1:], 16)\n        except Exception:\n            int_address = int(str_address[-1:]) * 16\n    elif (decimal == \"10.7\" or decimal == \"10.8\") or (decimal == \"10.15\" or decimal == \"10.16\"):\n        # 整数と少数に分けて、整数を8*2倍 + 少数\n        # 整数と少数に分けて、整数を16倍 + 少数\n        try:\n            i, d = str_address.split(\".\")\n            int_address = int(i) * 16 + int(d)\n        except Exception:\n            int_address = int(str_address) * 16\n    elif decimal == \"10.9\" or decimal == \"10.10\":\n        # 整数と少数に分けて、整数を10倍 + 少数 = 少数化*100(2桁)\n        int_address = float(str_address) * 100\n    elif decimal == \"10.F\":\n        # 整数と少数に分けて、整数を16倍 + 少数を10進数変換\n        try:\n            i, d = str_address.split(\".\")\n            int_address = int(i) * 16 + int(d, 16)\n        except Exception:\n            int_address = int(str_address) * 16\n    else:\n        int_address = None\n    return int_address\n\n\n# 10進数数値からアドレス毎に指定された進数表現の文字列に変換\ndef each_convert(decimal: str, int_address: int):\n    \"\"\"\n    # \"10\": 99999 => \"99999\"\n    # \"16\": 65535 => \"FFFF\"\n    # \"1016\": 1615 = 100*16 + 15 => \"10015\"\n    # \"108\": 807 = 100*8 + 7 => \"1007\"\n    # \"10F\": 1615 = 100*16 + 15 => \"100F\"\n    # \"10.7\": 107 = 100[7] => \"100.7\"\n    # \"10.9\": 109 = 100[9] => \"100.9\"\n    # \"10.15\": 115 = 100[15] => \"100.15\"\n    # \"10.F\": 115 = 100[15] => \"100.F\"\n    \"\"\"\n    if decimal == \"10\":\n        str_address = format(int_address, \"d\")\n        quotient = str_address\n        remainder = \"00\"\n\n    elif decimal == \"16\":\n        str_address = format(int_address, \"x\")\n        quotient = str_address\n        remainder = \"00\"\n\n    elif decimal == \"1016\":\n        # 16で割り、\"商余(02d)\"\n        x, y = divmod(int_address, 16)\n        str_address = format(x, \"d\") + format(y, \"02d\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"02d\")\n\n    elif decimal == \"108\":\n        # 8で割り、\"商余(01d)\"\n        x, y = divmod(int_address, 8)\n        str_address = format(x, \"d\") + format(y, \"01d\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"01d\")\n\n    elif decimal == \"10F\":\n        # 16で割り、\"商余(01x)\"\n        x, y = divmod(int_address, 8)\n        str_address = format(x, \"d\") + format(y, \"01x\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"01x\")\n\n    elif (decimal == \"10.7\" or decimal == \"10.8\"):\n        # 8で割り、\"商.余(01d)\"\n        x, y = divmod(int_address, 8)\n        str_address = format(x, \"d\") + \".\" + format(y, \"01d\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"01d\")\n\n    elif (decimal == \"10.15\" or decimal == \"10.16\"):\n        # 16で割り、\"商.余(02d)\"\n        x, y = divmod(int_address, 16)\n        str_address = format(x, \"d\") + \".\" + format(y, \"02d\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"02d\")\n\n    elif decimal == \"10.9\" or decimal == \"10.10\":\n        # 10で割り、\"商.余(01d)\"\n        x, y = divmod(int_address, 10)\n        str_address = format(x, \"d\") + \".\" + format(y, \"01d\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"01d\")\n\n    elif decimal == \"10.F\":\n        # 10で割り、\"商.余(01x)\"\n        x, y = divmod(int_address, 10)\n        str_address = format(x, \"d\") + \".\" + format(y, \"01x\")\n        quotient = format(x, \"d\")\n        remainder = format(y, \"01x\")\n\n    else:\n        str_address = None\n        quotient = None\n        remainder = None\n\n    return str_address, quotient, remainder\n\n\nif __name__ == \"__main__\":\n    converted = decimal_convert(\"10.10\", \"100\")\n",
        "logger.py": "import logging\nimport os\nimport dotenv\n\n\ndef get_module_logger(modname, *, level=None):\n    logger = logging.getLogger(modname)\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        'Time:%(asctime)s, %(name)s, Level:%(levelname)s, Func:%(funcName)s, Line:%(lineno)s, %(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    dotenv.load_dotenv(override=True)\n    # try:\n    #     FILE_HANDLER = os.getenv(\"FILE_HANDLER\")\n    #     if FILE_HANDLER is True or FILE_HANDLER == \"True\" or FILE_HANDLER == \"true\" or FILE_HANDLER == \"TRUE\":\n    #         import datetime\n    #         _now = datetime.datetime.now()\n    #         _date = _now.strftime(\"%Y%m&d\")\n    #         try:\n    #             script_dirname = os.path.dirname(__file__)\n    #         except Exception:\n    #             script_dirname = os.getcwd()\n    #         finally:\n    #             os.makedirs(script_dirname + \"/log/\", exist_ok=True)\n    #             filename = _date + \".log\"\n    #             fh = logging.FileHandler(\n    #                 script_dirname + \"/log/\" + filename, 'a+')\n    #             logger.addHandler(fh)\n    # except Exception:\n    #     pass\n\n    if level is None:\n        LOGGER_LEVEL = os.getenv('LOGGER_LEVEL')\n    elif level in [\"CRITICAL\", \"ERROR\", \"WARNING\", \"INFO\", \"DEBUG\"]:\n        LOGGER_LEVEL = level\n    else:\n        LOGGER_LEVEL = \"INFO\"\n\n    if (LOGGER_LEVEL == 'CRITICAL'):\n        logger.setLevel(logging.CRITICAL)\n    elif (LOGGER_LEVEL == 'ERROR'):\n        logger.setLevel(logging.ERROR)\n    elif (LOGGER_LEVEL == 'WARNING'):\n        logger.setLevel(logging.WARNING)\n    elif (LOGGER_LEVEL == 'INFO'):\n        logger.setLevel(logging.INFO)\n    elif (LOGGER_LEVEL == 'DEBUG'):\n        logger.setLevel(logging.DEBUG)\n    else:\n        logger.setLevel(logging.NOTSET)\n    return logger\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\dust": {
        "NPSV_20240417_Output_OEE_Monitoring.sql": "Unsupported file type",
        "OEE Query.sql": "Unsupported file type"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\fins": {
        "devices.py": "try:\n    from .. import const\nexcept Exception:\n    import sys\n    import pathlib\n    parent_dir = str(pathlib.Path(__file__).parent.parent.resolve())\n    sys.path.append(parent_dir)\n    import const\n\n\nclass DeviceList():\n    def __init__(self, *, manufacture=\"omron\", series=\"default\", has_point=False, transport=\"udp\"):\n        self.manufacture = manufacture\n        self.series = series\n        self.has_point = has_point\n        self.transport = transport\n        self.endian = \"\"\n        self.transfer_limit = 0\n        self.perfix_bit = 0\n\n    def plc_omron(self):\n        self.endian = \"big\"\n        self.transfer_limit = 498\n        if self.transport in const.TRANSPORT_UDP:\n            self.prefix_byte = 28\n        else:\n            self.prefix_byte = 60\n\n        if self.series in [\"cvm1\", \"cv\"]:\n            devices = [\n                {\"symbol\": \"CIO\", \"binary\": 0x00, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Chanel I/O\", \"range\": [\"0.0\", \"2555.15\"]},\n                {\"symbol\": \"AR[RO]\", \"binary\": 0x00, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Special auxiliary relay\", \"range\": [\"0.0\", \"447.15\"],\n                    \"offset\": 2816, \"optional\": \"readonly\", },\n                {\"symbol\": \"AR\", \"binary\": 0x00, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Special auxiliary relay\", \"range\": [\"0.0\", \"959.15\"], \"offset\": 2816},\n                # Memory\n                {\"symbol\": \"DM\", \"binary\": 0x82, \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Data memory\", \"range\": [\"0\", \"32767\"]},\n                # Timer\n                {\"symbol\": \"TIM\", \"binary\": 0x01, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Timer up flag\", \"range\": [\"0\", \"2047\"]},\n                {\"symbol\": \"TIM[C]\", \"binary\": 0x81, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Timer current value\", \"range\": [\"0\", \"2047\"]},\n                # Counter\n                {\"symbol\": \"CNT\", \"binary\": 0x01, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Counter up flag\", \"range\": [\"0\", \"2047\"], \"offset\": 8000},\n                {\"symbol\": \"CNT[C]\", \"binary\": 0x81, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Counter current value\", \"range\": [\"0\", \"2047\"], \"offset\": 8000},\n                {\"symbol\": \"EM_0\", \"binary\": 0x90, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 0\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_1\", \"binary\": 0x91, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 1\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_2\", \"binary\": 0x92, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 2\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_3\", \"binary\": 0x93, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 3\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_4\", \"binary\": 0x94, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 4\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_5\", \"binary\": 0x95, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 5\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_6\", \"binary\": 0x96, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 6\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM_7\", \"binary\": 0x97, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory 7\", \"range\": [\"0\", \"32767\"]},\n                {\"symbol\": \"EM[C]\", \"binary\": 0x98, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion memory current bank\", \"range\": [\"0\", \"32767\"]},\n                # Data register\n                {\"symbol\": \"DR\", \"binary\": 0x9C, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register\", \"range\": [\"0\", \"2\"]},\n            ]\n            if self.has_point is not True:\n                update_devices = [\n                    {\"symbol\": \"CIO\", \"binary\": 0x80, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Chanel I/O\", \"range\": [\"0\", \"2555\"]},\n                    {\"symbol\": \"AR[RO]\", \"binary\": 0x80, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Special auxiliary relay\", \"range\": [\"0\", \"447\"],\n                        \"offset\": 2816, \"optional\": \"readonly\", },\n                    {\"symbol\": \"AR\", \"binary\": 0x80, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Special auxiliary relay\", \"range\": [\"0\", \"959\"], \"offset\": 2816},\n                ]\n                devices = [\n                    x if x[\"symbol\"] not in [y[\"symbol\"] for y in update_devices]\n                    else [z for z in update_devices if z[\"symbol\"] == x[\"symbol\"]][0] for x in devices]\n\n        # [\"cs\", \"cj\", \"cp\", \"nsj\"]\n        else:\n            devices = [\n                # Relay\n                {\"symbol\": \"CIO\", \"binary\": 0x30, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Chanel I/O\", \"range\": [\"0.0\", \"6143.15\"]},\n                {\"symbol\": \"WR\", \"binary\": 0x31, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Internal auxiliary relay\", \"range\": [\"0.0\", \"511.15\"]},\n                {\"symbol\": \"HR\", \"binary\": 0x32, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Holding relay\", \"range\": [\"0.0\", \"511.15\"]},\n                {\"symbol\": \"AR[RO]\", \"binary\": 0x33, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Special auxiliary relay\", \"range\": [\"0.0\", \"447.15\"], \"optional\": \"readonly\"},\n                {\"symbol\": \"AR\", \"binary\": 0x33, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Special auxiliary relay\", \"range\": [\"0.0\", \"959.15\"]},\n                # Memory\n                {\"symbol\": \"DM\", \"binary\": 0x02, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Data memory\", \"range\": [\"0.0\", \"32767.15\"]},\n                # Expansion memory\n                {\"symbol\": \"EM_0\", \"binary\": 0x20, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 0\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_1\", \"binary\": 0x21, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 1\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_2\", \"binary\": 0x22, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 2\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_3\", \"binary\": 0x23, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 3\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_4\", \"binary\": 0x24, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 4\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_5\", \"binary\": 0x25, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 5\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_6\", \"binary\": 0x26, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 6\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_7\", \"binary\": 0x27, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 7\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_8\", \"binary\": 0x28, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 8\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_9\", \"binary\": 0x29, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 9\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_A\", \"binary\": 0x2A, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory A\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_B\", \"binary\": 0x2B, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory B\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_C\", \"binary\": 0x2C, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory C\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_D\", \"binary\": 0x2D, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory D\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_E\", \"binary\": 0x2E, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory E\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_F\", \"binary\": 0x2F, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory F\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_10\", \"binary\": 0xE0, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 10\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_11\", \"binary\": 0xE1, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 11\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_12\", \"binary\": 0xE2, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 12\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_13\", \"binary\": 0xE3, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 13\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_14\", \"binary\": 0xE4, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 14\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_15\", \"binary\": 0xE5, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 15\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_16\", \"binary\": 0xE6, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 16\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_17\", \"binary\": 0xE7, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 17\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM_18\", \"binary\": 0xE8, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory 18\", \"range\": [\"0.0\", \"32767.15\"]},\n                {\"symbol\": \"EM[C]\", \"binary\": 0x0A, \"identify\": \"bit\",\n                    \"decimal\": \"10.15\", \"name\": \"Expansion memory current bank\", \"range\": [\"0.0\", \"32767.15\"]},\n                # Task flag\n                {\"symbol\": \"TK\", \"binary\": 0x06, \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Task flag\", \"range\": [\"0\", \"31\"]},\n                # Index register\n                {\"symbol\": \"IR\", \"binary\": 0xDC, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Index register\", \"range\": [\"0\", \"15\"]},\n                # Data register\n                {\"symbol\": \"DR\", \"binary\": 0xBC, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register\", \"range\": [\"0\", \"15\"]},\n                # Timer\n                {\"symbol\": \"TIM\", \"binary\": 0x09, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Timer up flag\", \"range\": [\"0\", \"4095\"]},\n                {\"symbol\": \"TIM[C]\", \"binary\": 0x89, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Timer current value\", \"range\": [\"0\", \"4095\"]},\n                # Counter\n                {\"symbol\": \"CNT\", \"binary\": 0x09, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Counter up flag\", \"range\": [\"0\", \"4095\"], \"offset\": 8000},\n                {\"symbol\": \"CNT[C]\", \"binary\": 0x89, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Counter current value\", \"range\": [\"0\", \"4095\"], \"offset\": 8000},\n            ]\n            if self.has_point is not True:\n                update_devices = [\n                    {\"symbol\": \"CIO\", \"binary\": 0xB0, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Chanel I/O\", \"range\": [\"0\", \"6143\"]},\n                    {\"symbol\": \"WR\", \"binary\": 0xB1, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Internal auxiliary relay\", \"range\": [\"0\", \"511\"]},\n                    {\"symbol\": \"HR\", \"binary\": 0xB2, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Holding relay\", \"range\": [\"0\", \"511\"]},\n                    {\"symbol\": \"AR[RO]\", \"binary\": 0xB3, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Special auxiliary relay\", \"range\": [\"0\", \"447\"], \"optional\": \"readonly\"},\n                    {\"symbol\": \"AR\", \"binary\": 0xB3, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Special auxiliary relay\", \"range\": [\"0\", \"959\"]},\n                    # Memory\n                    {\"symbol\": \"DM\", \"binary\": 0x82, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Data memory\", \"range\": [\"0\", \"32767\"]},\n                    # Expansion memory\n                    {\"symbol\": \"EM_0\", \"binary\": 0xA0, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 0\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_1\", \"binary\": 0xA1, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 1\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_2\", \"binary\": 0xA2, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 2\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_3\", \"binary\": 0xA3, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 3\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_4\", \"binary\": 0xA4, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 4\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_5\", \"binary\": 0xA5, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 5\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_6\", \"binary\": 0xA6, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 6\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_7\", \"binary\": 0xA7, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 7\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_8\", \"binary\": 0xA8, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 8\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_9\", \"binary\": 0xA9, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 9\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_A\", \"binary\": 0xAA, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory A\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_B\", \"binary\": 0xAB, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory B\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_C\", \"binary\": 0xAC, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory C\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_D\", \"binary\": 0xAD, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory D\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_E\", \"binary\": 0xAE, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory E\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_F\", \"binary\": 0xAF, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory F\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_10\", \"binary\": 0x60, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 10\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_11\", \"binary\": 0x61, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 11\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_12\", \"binary\": 0x62, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 12\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_13\", \"binary\": 0x63, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 13\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_14\", \"binary\": 0x64, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 14\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_15\", \"binary\": 0x65, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 15\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_16\", \"binary\": 0x66, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 16\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_17\", \"binary\": 0x67, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 17\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM_18\", \"binary\": 0x68, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory 18\", \"range\": [\"0\", \"32767\"]},\n                    {\"symbol\": \"EM[C]\", \"binary\": 0x90, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Expansion memory current bank\", \"range\": [\"0\", \"32767\"]},\n                    # Task flag\n                    {\"symbol\": \"TK\", \"binary\": 0x46, \"identify\": \"word\",\n                        \"decimal\": \"10\", \"name\": \"Task flag\", \"range\": [\"0\", \"31\"]},\n                ]\n                devices = [\n                    x if x[\"symbol\"] not in [y[\"symbol\"] for y in update_devices]\n                    else [z for z in update_devices if z[\"symbol\"] == x[\"symbol\"]][0] for x in devices]\n\n        return devices\n\n    # Device list\n    def devices(self):\n        if self.manufacture in const.MANUFACTURER_OMRON:\n            devices = self.plc_omron()\n        else:\n            devices = []\n\n        return {\n            \"transfer_limit\": self.transfer_limit,\n            \"prefix_byte\": self.prefix_byte,\n            \"endian\": self.endian,\n            \"devices\": devices\n        }\n\n\ndef device_list(manufacture, *, series=None, has_point=False, transport=\"udp\"):\n    if series is None:\n        # Default series\n        if manufacture in const.MANUFACTURER_OMRON:\n            series = \"\"\n\n    if has_point is None or has_point is False:\n        has_point = False\n    else:\n        has_point = True\n\n    d = DeviceList(\n        manufacture=manufacture,\n        series=series, has_point=has_point,\n        transport=transport\n    )\n    _devices = d.devices()\n    return _devices\n\n\nif __name__ == \"__main__\":\n    manufacture = \"mitsubishi\"\n    series = \"iq\"\n    has_point = False\n    transport = \"udp\"\n\n    devices = device_list(\n        manufacture=manufacture,\n        series=series, has_point=has_point, transport=transport)\n    print(devices)\n",
        "exit_code.json": "Unsupported file type",
        "main.py": "import socket\nimport re\nimport os\nimport sys\nimport struct\nimport binascii\nimport itertools\nimport random\nfrom pydantic import BaseModel\nimport psutil\nfrom typing import Pattern\n\ntry:\n    import devices\nexcept Exception:\n    try:\n        from . import devices\n    except Exception:\n        try:\n            from slmp import devices\n        except Exception:\n            try:\n                from protocols.fins import devices\n            except Exception:\n                try:\n                    from connection.protocols.fins import devices\n                except Exception:\n                    from src.connection.protocols.fins import devices\n\n\nclass Device(BaseModel):\n    symbol: str = \"DM\"\n    name: str = \"Data memory\"\n    notation: str = \"10\"\n    binary: int = 0x82\n    offset: int = 0\n    data_unit: str = \"word\"\n    datarange: list = [\"0\", \"32767\"]\n\n\ndef find_device(symbol: str, *,\n                manufacturer=\"omron\",\n                series=\"NJ\",\n                identify: str = \"word\") -> dict:\n\n    if \"omron\" in manufacturer.lower():\n        manufacturer = \"omron\"\n        if \"cv\" in series.lower():\n            series = \"cv\"\n        if \"cvm1\" in series.lower():\n            series = \"cvm1\"\n\n    device_info = devices.device_list(manufacturer, series=series)\n\n    return next(filter(lambda x: x[\"symbol\"] == symbol, device_info[\"devices\"]), None)\n    # devices = [\n    #     # {\"symbol\": \"DM\", \"binary\": 0x02, \"identify\": \"bit\",\n    #     #     \"decimal\": \"10\", \"name\": \"Data memory\", \"range\": [\"0.0\", \"32767.15\"]},\n    #     # {\"symbol\": \"CIO\", \"binary\": 0x30, \"identify\": \"bit\",\n    #     #     \"decimal\": \"10.16\", \"name\": \"Chanel I/O\", \"range\": [\"0.0\", \"6143.15\"]},\n    #     {\"symbol\": \"CIO\", \"binary\": 0xB0, \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Chanel I/O\", \"range\": [\"0.0\", \"6143.15\"]},\n\n    #     {\"symbol\": \"WR\", \"binary\": 0xB1, \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Internal auxiliary relay\", \"range\": [\"0\", \"511\"]},\n    #     {\"symbol\": \"HR\", \"binary\": 0xB2, \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Holding relay\", \"range\": [\"0\", \"511\"]},\n    #     {\"symbol\": \"AR\", \"binary\": 0xB3, \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Special auxiliary relay\", \"range\": [\"0\", \"447\"]},\n\n    #     {\"symbol\": \"DR\", \"binary\": 0xBC, \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Data register\", \"range\": [\"0\", \"15\"]},\n    #     {\"symbol\": \"DM\", \"binary\": 0x82, \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Data memory\", \"range\": [\"0\", \"32767\"]},\n    # ]\n    # return next(filter(lambda x: x[\"symbol\"].upper() == symbol.upper(), devices), None)\n\n\ndef flatten(data):\n    return [element\n            for item in data\n            for element in (flatten(item) if hasattr(item, '__iter__') and not isinstance(item, str) and not isinstance(item, dict) else (item, ))]\n\n\ndef try_except(data: dict, key: str, *, exception=None):\n    try:\n        return data[key]\n    except Exception:\n        return exception\n\n\ndef try_integer(data: str, *, notation=10, exception=\"default\"):\n    try:\n        return int(data, notation)\n    except Exception:\n        if exception == \"default\":\n            return data\n        else:\n            return exception\n\n\ndef int_to_binary(n: int, bits: int = 16) -> str:\n    \"\"\"intを2進数に変換\"\"\"\n    return ''.join([str(n >> i & 1) for i in reversed(range(0, bits))])\n\n\ndef reverse_bytes(message: bytes):\n    return b\"\".join([int2byte_str(x, byte_len=1) for x in list(reversed([x for x in message]))])\n\n\ndef byte_str2int(message: bytes, *, byteorder=\"little\", signed=False):\n    return int.from_bytes(message, byteorder=byteorder, signed=signed)\n\n\ndef int2byte_str(number: int, *, byte_len: int = None, byteorder=\"little\"):\n    if byte_len is None:\n        byte_len = (number.bit_length() + 7) // 8\n    return number.to_bytes(byte_len, byteorder)\n\n\n# 任意の進数表記のアドレスを10進数数値に変換\ndef convert_decimal_notation_to_integer(address: str, notation: str) -> int:\n    \"\"\"\n        任意の進数表記のアドレスを10進数数値に変換\n    \"\"\"\n    if notation == \"10\":\n        # ex: \"1234\" -> 1234\n        return int(address, 10)\n    elif notation in [\"16\", \"F\"]:\n        # ex: \"1234\"(16) -> 4660\n        return int(address, 16)\n\n    elif notation == \"108\":\n        # ex: \"1234\"(8) -> 668\n        return int(address, 8)\n    elif notation == \"1016\":\n        # ex: \"1210\" -> \"12\"(10)*16 + \"10\"(16) -> 192 + 16 -> 208\n        return int(address[:-2], 10) * 16 + int(address[-2:], 10)\n    elif notation == \"10F\":\n        # ex: \"12A\" -> \"12\"(10)*16 + \"A\"(16) -> 192 + 10 -> 202\n        return int(address[:-1], 10) * 16 + int(address[-1:], 16)\n    elif notation == \"108\":\n        # ex: \"127\"(8) -> \"12\"(10)*8 + \"7\"(8) -> 96 + 7 -> 103\n        return int(address[:-1], 10) * 8 + int(address[-1:], 8)\n    else:\n        raise ValueError(f\"Notation {notation} is not supported\")\n\n\ndef check_error_code(message, *, transport_layer: str = None):\n    # TCP\n    if transport_layer in [\"tcp\"]:\n        tcp_command_code = byte_str2int(message[8:12])\n        tcp_error_code = byte_str2int(message[12:16])\n\n        exit_code = byte_str2int(message[36:38])\n        # tcp_command_code = 0x00000002のときチェック不要\n        if tcp_command_code != 2:\n            if tcp_error_code != 0:\n                response = {\n                    \"code\": tcp_error_code,\n                    \"message\": f\"TCP error code: {tcp_error_code}\"\n                }\n\n        # Bit7, Bit8はPLC本体の異常(バッテリ異常など)のため無視\n        if exit_code not in [0, 64, 128]:\n            response = {\n                \"code\": exit_code\n            }\n        else:\n            response = {\n                \"code\": 0,\n            }\n    # UDP\n    elif transport_layer in [\"udp\"]:\n        exit_code = byte_str2int(message[12:14])    # Bit7, Bit8はPLC本体の異常(バッテリ異常など)のため無視\n        if exit_code not in [0, 64, 128]:\n            response = {\n                \"code\": exit_code,\n            }\n        else:\n            response = {\n                \"code\": 0,\n            }\n\n    return response\n\n\ndef get_host_fourth_octet(ip_address, port):\n    def get_local_ip(ip_address, port):\n        from socket import socket, AF_INET, SOCK_DGRAM\n        s = socket(AF_INET, SOCK_DGRAM)\n        try:\n            s.connect((ip_address, port))\n            ipaddr = s.getsockname()[0]\n        except Exception:\n            ipaddr = '127.0.0.1'\n        finally:\n            s.close()\n        return ipaddr\n\n    # Windows OS\n    if os.name == \"nt\":\n        iplist = socket.gethostbyname_ex(socket.gethostname())[2]\n    # Mac OS or Linux OS\n    else:\n        iplist = []\n        address_list = psutil.net_if_addrs()\n        for _ in address_list.keys():\n            local_ip = get_local_ip(ip_address, port)\n            iplist.append(local_ip)\n\n    same_network = ip_address.rsplit('.', 1)[0]\n    if len(iplist) > 0:\n        try:\n            client_ip = [x for x in iplist if same_network in x]\n            fourth_octet = int(client_ip[0].rsplit('.', 1)[1])\n        except Exception as e:\n            print(\n                '{}:{}, {}, {}'.format(\n                    sys._getframe().f_code.co_name, e, same_network, 'No connection found. Please check your communication settings.'))\n            fourth_octet = int(iplist[0].rsplit('.', 1)[1])\n    else:\n        fourth_octet = None\n    return fourth_octet\n\n\nclass Configure(BaseModel):\n    ip_address: str = \"127.0.0.1\"\n    port: int = 0\n    type: str = \"PLC\"\n    manufacturer: str = \"Omron\"\n    series: str = \"NJ\"\n    protocol: str = \"FINS/UDP\"\n    attributes: dict = {}\n    read_data: dict = {\n        \"word\": [],\n        \"doubleword\": [],\n        \"bulk\": [],\n    }\n    write_data: dict = {\n        \"bit\": [],\n        \"word\": [],\n        \"doubleword\": [],\n        \"string\": [],\n        \"bulk\": []\n    }\n\n\nclass Regexes(BaseModel):\n    bit: Pattern = re.compile(r\"(bit|boolean)\")\n    word: Pattern = re.compile(r\"(word|short)\")\n    dword: Pattern = re.compile(r\"(dword|doubleword|integer)\")\n    string: Pattern = re.compile(r\"string\")\n    fraction: Pattern = re.compile(r\"\\.\")\n    signed: Pattern = re.compile(r\"(\\-|\\±|s_|signed_)\")\n    tcp: Pattern = re.compile(r\"tcp\", flags=re.IGNORECASE)\n    udp: Pattern = re.compile(r\"udp\", flags=re.IGNORECASE)\n\n\nclass Communication():\n    def __init__(self, configure: dict):\n        \"\"\"\n            Parameters\n            ----------\n            configure: dict\n                network: dict\n                    ip_address: str\n                        IPアドレス\n                    port: int\n                        ポート番号\n                controller: dict\n                    type: str\n                        コントローラ種別\n                    manufacturer: str\n                        コントローラのメーカ名\n                    series: str\n                        コントローラのシリーズ\n                    protocol: str\n                        使用プロトコル名\n                    attribute: dict\n                        その他オプション\n                data: list in dict\n                    データ毎の設定\n        \"\"\"\n        self.regexes = Regexes()\n        self.base_param = {\n            \"tcp_header\": [0x46, 0x49, 0x4E, 0x53],     # 固定値 \"FINS\"\n            \"tcp_node_command\": [0x00, 0x00, 0x00, 0x00],\n            \"tcp_command\": [0x00, 0x00, 0x00, 0x02],\n            \"tcp_error_code\": [0x00, 0x00, 0x00, 0x00],\n            \"tcp_client_node\": [0x00, 0x00, 0x00, 0x00],\n\n            \"icf\": [0x80],\n            \"rsv\": [0x00],\n            \"gct\": [0x02],      # 許容ブリッジ通過数 基本的に0x02\n            \"dna\": [0x00],      # 相手先ネットワークアドレス 0x00: 同一ネットワーク, 0x01-7F: 他相手先ネットワーク\n            \"da1\": [0x00],      # 相手先ノードアドレス 0x00: 自PLC, 0x01-20: Controller Link, 0x01-FE: Ethernet, 0xFF: 一斉同報\n            \"da2\": [0x00],      # 0x00: CPUユニット,\n            \"sna\": [0x00],      # 発信元ネットワークアドレス 0x00: 同一ネットワーク, 0x01-7F: 他ネットワーク\n\n            \"sa2\": [0x00],      # 発信元号機アドレス 0x00: CPU固定値\n        }\n        network = try_except(configure, \"network\")\n        controller = try_except(configure, \"controller\")\n        self.conf = Configure(**network, **controller)\n        self.data = try_except(configure, \"data\")\n\n        self.request_messages = []\n\n    def identification_unit(self):\n        for data in self.data:\n            if data[\"data_unit\"]:\n                # doubleword random read\n                if ((self.regexes.dword.search(data[\"data_unit\"]))):\n                    self.conf.read_data[\"doubleword\"].append(data)\n                # word random read\n                elif ((self.regexes.bit.search(data[\"data_unit\"])) or (self.regexes.word.search(data[\"data_unit\"]))):\n                    self.conf.read_data[\"word\"].append(data)\n                # bulk read\n                else:\n                    self.conf.read_data[\"bulk\"].append(data)\n        return self.conf.read_data\n\n    def set_request_node_address(self):\n        tcp_data_length = [0x00, 0x00, 0x00, 0x0C]\n        _message = [\n            self.base_param[\"tcp_header\"],\n            tcp_data_length,\n            self.base_param[\"tcp_node_command\"],\n            self.base_param[\"tcp_error_code\"],\n            self.base_param[\"tcp_client_node\"],\n        ]\n        self.node_telegram = b\"\"\n        for x in flatten(_message):\n            self.node_telegram = self.node_telegram + struct.pack(\"B\", x)\n        return self.node_telegram\n\n    def divided_response_node(self, *, message):\n        self.client_node = int(\"0x\" + message[32:40], 16)\n        self.server_node = int(\"0x\" + message[40:48], 16)\n        return {\n            \"client_node\": self.client_node,\n            \"server_node\": self.server_node\n        }\n\n    def device_code_address_encode(self, device: str, address, *, random_doubleword: bool = False) -> bytearray:\n        \"\"\"\n            Return\n                bytearray: [device_code(1byte), decimal part address(2byte), fractional part \"0x00\"(1byte)]\n        \"\"\"\n        found_device = find_device(symbol=device, series=self.conf.series)\n        decimal_notation = try_except(found_device, \"decimal\")\n        device_code = try_except(found_device, \"binary\")\n        if isinstance(address, str):\n            address_integer = convert_decimal_notation_to_integer(address, decimal_notation)\n        else:\n            address_integer = address\n\n        if random_doubleword:\n            address = [int(x, 16) for x in re.findall(\"..\", f\"{address_integer:04x}\")]\n            d_address_integer = address_integer + 1\n            d_address = [int(x, 16) for x in re.findall(\"..\", f\"{d_address_integer:04x}\")]\n            return bytearray(flatten([device_code, address, 0x00, device_code, d_address, 0x00]))\n        else:\n            address = [int(x, 16) for x in re.findall(\"..\", f\"{address_integer:04x}\")]\n            return bytearray(flatten([device_code, address, 0x00]))\n\n    # Bulk read\n    def set_request_message_bulk_read(self, *, node_data=None):\n        # TODO TCP\n        if self.regexes.tcp.search(self.conf.protocol):\n            tcp_header = self.base_param[\"tcp_header\"]\n            tcp_command = self.base_param[\"tcp_command\"]\n            tcp_error_code = self.base_param[\"tcp_error_code\"]\n            if node_data:\n                da1 = node_data[\"server_node\"]\n                sa1 = node_data[\"client_node\"]\n            else:\n                da1 = self.server_node\n                sa1 = self.client_node\n\n            _base_request_message = [\n                self.base_param[\"tcp_header\"],\n                # data length\n                self.base_param[\"tcp_command\"],\n                self.base_param[\"tcp_error_code\"],\n                # client node address\n                self.base_param[\"icf\"],\n                self.base_param[\"rsv\"],\n                self.base_param[\"gct\"],\n                self.base_param[\"dna\"],\n                da1,\n                self.base_param[\"da2\"],\n                self.base_param[\"sna\"],\n                sa1,\n                self.base_param[\"sa2\"],\n            ]\n\n        elif self.regexes.udp.search(self.conf.protocol):\n            da1 = [0x00]\n            sa1 = get_host_fourth_octet(self.conf.ip_address, self.conf.port)\n            _base_request_message = [\n                self.base_param[\"icf\"],\n                self.base_param[\"rsv\"],\n                self.base_param[\"gct\"],\n                self.base_param[\"dna\"],\n                da1,\n                self.base_param[\"da2\"],\n                self.base_param[\"sna\"],\n                sa1,\n                self.base_param[\"sa2\"],\n            ]\n\n        command = [0x01, 0x01]\n        max_access_count = 498\n\n        bulk_datas = self.conf.read_data[\"bulk\"]\n        each_device_data = {}\n        for _data in bulk_datas:\n            try:\n                each_device_data[_data[\"device\"]].append(_data)\n            except Exception:\n                each_device_data[_data[\"device\"]] = [_data]\n\n        for key, values in each_device_data.items():\n            found_device = find_device(symbol=key, series=self.conf.series)\n            decimal_notation = try_except(found_device, \"decimal\")\n\n            min_value = min(\n                [convert_decimal_notation_to_integer(x[\"address\"].split(\".\")[0], decimal_notation) for x in values])\n\n            max_value = max(\n                [convert_decimal_notation_to_integer(x[\"address\"].split(\".\")[0], decimal_notation) + int(try_except(x, key=\"data_length\", exception=\"256\")) for x in values])\n            _request = {\n                \"min\": min_value,\n                \"max\": max_value\n            }\n\n            for i in range(((max_value - min_value) // max_access_count) + 1):\n                _min_value = min_value + (max_access_count * i)\n                _max_value = min_value + (max_access_count * (i + 1))\n                if _max_value < max_value:\n                    _request.update(split_min=_min_value, split_max=_max_value)\n                else:\n                    _request.update(split_min=_min_value, split_max=max_value)\n                _request.update(device=key, count=_request[\"split_max\"] - _request[\"split_min\"])\n\n                device_first_address = self.device_code_address_encode(key, _request['split_min'])\n\n                address_count = bytearray(flatten(\n                    [int(x, 16) for x in re.findall(\"..\", f\"{_request['count']:04x}\")]))\n                sid = random.randrange(0, 255, 1)\n\n                message = bytearray([x for x in flatten(_base_request_message + [sid, command])]) + device_first_address + address_count\n                self.request_messages.append({**_request, \"message\": message, \"command\": \"bulk_read\", \"sid\": sid})\n\n        return self.request_messages\n\n    # Random read\n    def set_request_message_randam_read(self, *, node_data=None):\n        # TODO TCP\n        if self.regexes.tcp.search(self.conf.protocol):\n            tcp_header = self.base_param[\"tcp_header\"]\n            tcp_command = self.base_param[\"tcp_command\"]\n            tcp_error_code = self.base_param[\"tcp_error_code\"]\n            if node_data:\n                da1 = node_data[\"server_node\"]\n                sa1 = node_data[\"client_node\"]\n            else:\n                da1 = self.server_node\n                sa1 = self.client_node\n\n            _base_request_message = [\n                self.base_param[\"tcp_header\"],\n                # data length\n                self.base_param[\"tcp_command\"],\n                self.base_param[\"tcp_error_code\"],\n                # client node address\n                self.base_param[\"icf\"],\n                self.base_param[\"rsv\"],\n                self.base_param[\"gct\"],\n                self.base_param[\"dna\"],\n                da1,\n                self.base_param[\"da2\"],\n                self.base_param[\"sna\"],\n                sa1,\n                self.base_param[\"sa2\"],\n            ]\n\n        elif self.regexes.udp.search(self.conf.protocol):\n            da1 = [0x00]\n            sa1 = get_host_fourth_octet(self.conf.ip_address, self.conf.port)\n            _base_request_message = [\n                self.base_param[\"icf\"],\n                self.base_param[\"rsv\"],\n                self.base_param[\"gct\"],\n                self.base_param[\"dna\"],\n                da1,\n                self.base_param[\"da2\"],\n                self.base_param[\"sna\"],\n                sa1,\n                self.base_param[\"sa2\"],\n            ]\n\n        command = [0x01, 0x04]\n\n        max_access_count = 165\n\n        request_datas = []\n        _message = b\"\"\n        word_datas = self.conf.read_data[\"word\"]\n        doubleword_datas = self.conf.read_data[\"doubleword\"]\n        word_data_count = 0\n        doubleword_data_count = 0\n        for data in word_datas:\n            # over max_access_count more than data_count(word_datas)\n            if word_data_count >= max_access_count:\n                request_datas.append({\n                    \"message\": _message,\n                    \"word_count\": word_data_count,\n                    \"doubleword_count\": doubleword_data_count,\n                })\n                word_data_count = 0\n                _message = b\"\"\n\n            word_data_count = word_data_count + 1\n            device = data[\"device\"]\n            address = data[\"address\"].split(\".\")[0]\n            _message = _message + self.device_code_address_encode(device, address)\n\n        for data in doubleword_datas:\n            # over max_access_count more than data_count(remain word_datas + double_datas)\n            if (word_data_count + doubleword_data_count * 2) - 1 >= max_access_count:\n                request_datas.append({\n                    \"message\": _message,\n                    \"word_count\": word_data_count,\n                    \"double_count\": doubleword_data_count,\n                })\n                _message = b\"\"\n                word_data_count = 0\n                doubleword_data_count = 0\n\n            doubleword_data_count = doubleword_data_count + 1\n            device = data[\"device\"]\n            address = data[\"address\"].split(\".\")[0]\n            _message = _message + self.device_code_address_encode(device, address, random_doubleword=True)\n\n        if _message:\n            request_datas.append({\n                \"message\": _message,\n                \"word_count\": word_data_count,\n                \"double_count\": doubleword_data_count,\n            })\n\n        for data in request_datas:\n            sid = random.randrange(0, 255, 1)\n            message = bytearray([x for x in flatten(_base_request_message + [sid, command])]) + data[\"message\"]\n            self.request_messages.append({\n                **data,\n                \"message\": message,\n                \"command\": \"random_read\",\n                \"sid\": sid,\n            })\n\n        return self.request_messages\n\n    def set_connection(self, *, transport_layer: str = None, timeout=10):\n        if transport_layer is None:\n            if self.regexes.tcp.search(self.conf.protocol):\n                transport_layer = \"tcp\"\n            elif self.regexes.udp.search(self.conf.protocol):\n                transport_layer = \"udp\"\n            else:\n                raise ValueError(f\"This protocol: {self.conf.protocol} is unsupported.\")\n\n        if transport_layer in [\"tcp\"]:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.transport_layer = \"tcp\"\n        elif transport_layer in [\"udp\"]:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.transport_layer = \"udp\"\n        else:\n            raise ValueError(f\"This protocol: {self.conf.protocol} is unsupported.\")\n        self.sock.settimeout(timeout)\n\n    def open(self, *, ip_address: str = None, port: int = None):\n        if ip_address is None:\n            ip_address = self.conf.ip_address\n        if port is None:\n            port = self.conf.port\n        print(f\"ip_address: {ip_address}, port: {port}\")\n        self.sock.connect((ip_address, port))\n\n    def connection(self, *, request_messages: list = None) -> dict:\n        def retry_recieve(send_sid, *, retry_count: int = 0, max_retry_count: int = 2):\n            recieve_message = self.sock.recv(1024)\n\n            # check sid match\n            recv_sid = recieve_message[10:12]\n            if send_sid != recv_sid:\n                if retry_count < max_retry_count:\n                    recieve_message = retry_recieve(send_sid, retry_count=retry_count + 1, max_retry_count=max_retry_count)\n                else:\n                    raise ConnectionError(\"Sid mismatch\")\n            return recieve_message\n\n        if request_messages is None:\n            request_messages = self.request_messages\n\n        self.responses = []\n        connection_check = True\n        for request in request_messages:\n            response = {\"request\": request}\n            if connection_check is False:\n                response.update(connection={\n                    \"recieve_message\": None,\n                    \"code\": 10060,\n                    \"message\": \"Connection Error (skip)\"\n                })\n            else:\n                if isinstance(request, dict):\n                    request_message = try_except(request, key=\"message\", exception=request)\n                else:\n                    request_message = request\n                send_sid = request_message[10:12]\n\n                self.sock.send(request_message)\n                # print(f\"request_message: {request_message}\")\n                try:\n                    recieve_message = retry_recieve(send_sid)\n                    # print(recieve_message.hex())\n\n                    response.update(connection={\n                        \"request_message\": request_message.hex(),\n                        \"recieve_message\": recieve_message,\n                        \"code\": 0,\n                        \"message\": \"success\"\n                    })\n                except Exception as e:\n                    print(f\"Error: {e}\")\n                    connection_check = False\n\n                    response.update(connection={\n                        \"request_message\": request_message.hex(),\n                        \"recieve_message\": None,\n                        \"code\": 10060,\n                        \"message\": str(e)\n                    })\n\n            self.responses.append(response)\n        return self.responses\n\n    def close(self):\n        try:\n            self.sock.close()\n        except Exception:\n            print(\"Already closed\")\n\n    def divided_response_common(self, metainfo: dict) -> dict:\n        \"\"\"\n            Argument:\n                metainfo: dict\n            Keyargument:\n                ascii_mode: bool -> flag of ascii or binary, default is None = binary mode.\n            Return:\n                code: str -> error code\n                judge: str -> result\n                message: str -> error details\n                response: str -> extraction data part from response message\n        \"\"\"\n        message = metainfo[\"connection\"][\"recieve_message\"]\n\n        # error check and extact data part\n        if self.regexes.tcp.search(self.conf.protocol):\n            check_result = check_error_code(message, transport_layer=\"tcp\")\n            message_data_index = 38\n        elif self.regexes.udp.search(self.conf.protocol):\n            check_result = check_error_code(message, transport_layer=\"udp\")\n            message_data_index = 14\n        else:\n            raise ValueError(f\"Not supported protocol: {self.conf.protocol}\")\n\n        finish_code = try_integer(check_result[\"code\"], notation=16)\n        if finish_code == 0:\n            response_data = message[message_data_index:]\n            check_result.update(response=response_data)\n        else:\n            check_result.update(response=None)\n\n        metainfo.update(judge=check_result)\n        return metainfo\n\n    def divided_response_random_read(self):\n        checked_response = [self.divided_response_common(metainfo=x)\n                        for x in self.responses\n                        if x[\"request\"][\"command\"] in [\"random_read\"] and x[\"connection\"][\"code\"] == 0]\n        try:\n            join_response = b\"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n        except Exception:\n            try:\n                join_response = \"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n            except Exception:\n                print(f'Random read has error_code: {[x[\"judge\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) != 0]}')\n                join_response = None\n\n        if join_response:\n            data_length = 0\n            # word data convert\n            for i, data in enumerate(self.conf.read_data[\"word\"]):\n                _data = join_response[i * 3:(i + 1) * 3]\n                if _data:\n                    data_length = (i + 1) * 3\n\n                    # bit data\n                    if (self.regexes.bit.search(data[\"data_unit\"])) or self.regexes.fraction.search(data[\"address\"]):\n                        _binary = list(reversed(list(int_to_binary(byte_str2int(reverse_bytes(_data[1:3]), signed=False)))))\n                        try:\n                            # 0~15 or 0~F なので10~15分だけ識別すれば良い\n                            if data[\"address\"].split(\".\")[1].isdecimal():\n                                fraction_index = int(data[\"address\"].split(\".\")[1], 10)\n                            else:\n                                fraction_index = int(data[\"address\"].split(\".\")[1], 16)\n                        except Exception:\n                            fraction_index = 0\n                        res = _binary[fraction_index]\n\n                    # word data\n                    else:\n                        if (self.regexes.signed.search(data[\"data_unit\"])):\n                            res = byte_str2int(reverse_bytes(_data[1:3]), signed=True)\n                        else:\n                            res = byte_str2int(reverse_bytes(_data[1:3]), signed=False)\n                    data.update({\"value\": res})\n\n            # doubleword word data convert\n            # TODO double wordで取得設定、かつBitデータ設定\n            for i, data in enumerate(self.conf.read_data[\"doubleword\"]):\n                _data = join_response[data_length + (i * 6):data_length + ((i + 1) * 6)]\n                if _data:\n                    if (self.regexes.signed.search(data[\"data_unit\"])):\n                        res = byte_str2int(b\"\" + reverse_bytes(_data[1:3]) + reverse_bytes(_data[4:6]), signed=True)\n                    else:\n                        res = byte_str2int(b\"\" + reverse_bytes(_data[1:3]) + reverse_bytes(_data[4:6]))\n                    data.update({\"value\": res})\n        return {\n            \"metainfo\": checked_response,\n            \"data\": self.conf.read_data\n        }\n\n    def divided_response_bulk_read(self):\n        # デバイス名と開始アドレスで集約\n        multi_responses = [list(res) for _, res in itertools.groupby(\n            [x for x in self.responses if x[\"request\"][\"command\"] in [\"bulk_read\"] and x[\"connection\"][\"code\"] == 0], lambda x: (x[\"request\"][\"device\"] and x[\"request\"][\"min\"]))]\n\n        for res in multi_responses:\n            checked_response = [self.divided_response_common(metainfo=x) for x in res]\n            try:\n                join_response = b\"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n            except Exception:\n                try:\n                    join_response = \"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n                except Exception:\n                    print(f'Bulk read has error_code: {[x[\"judge\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) != 0]}')\n                    join_response = None\n\n            if join_response:\n                response_min = res[0][\"request\"][\"min\"]\n                response_max = res[0][\"request\"][\"max\"]\n\n                for data in self.conf.read_data[\"bulk\"]:\n                    if res[0][\"request\"][\"device\"] == data[\"device\"]:\n\n                        device = find_device(symbol=data[\"device\"], series=self.conf.series)\n                        decimal_notation = device[\"decimal\"]\n                        address_integer = convert_decimal_notation_to_integer(data[\"address\"].split(\".\")[0], decimal_notation)\n                        address_min = address_integer - response_min\n\n                        # string data\n                        if (self.regexes.string.search(data[\"data_unit\"])):\n                            length = try_except(data, key=\"data_length\", exception=256)\n                            address_max = address_min + length if address_min + length <= response_max else response_max\n\n                            extraction_response = join_response[address_min: address_max]\n                            if len(extraction_response) % 2:\n                                extraction_response + b\"\\x00\"\n\n                            _data = \"\"\n                            for i in range(0, len(extraction_response), 2):\n                                upper = extraction_response[i]\n                                lower = extraction_response[i + 1]\n                                # Little Endian\n                                if lower != 0:\n                                    _data = _data + chr(lower)\n                                else:\n                                    break\n                                if upper != 0:\n                                    _data = _data + chr(upper)\n                                else:\n                                    break\n                                # TODO Big Endian\n                                if upper != 0:\n                                    _data = _data + chr(upper)\n                                else:\n                                    break\n                                if lower != 0:\n                                    _data = _data + chr(lower)\n                                else:\n                                    break\n\n                            if _data:\n                                data.update({\"value\": _data})\n\n                        # double word data\n                        elif (self.regexes.dword.search(data[\"data_unit\"])):\n                            length = 4\n                            address_max = address_min + length if address_min + length <= response_max else response_max\n\n                            extraction_response = join_response[address_min: address_max]\n                            if len(extraction_response) % 2:\n                                extraction_response + b\"\\x00\"\n\n                            if (self.regexes.signed.search(data[\"data_unit\"])):\n                                res = byte_str2int(b\"\" + reverse_bytes(extraction_response[1:3]) + reverse_bytes(extraction_response[4:6]), signed=True)\n                            else:\n                                res = byte_str2int(b\"\" + reverse_bytes(extraction_response[1:3]) + reverse_bytes(extraction_response[4:6]))\n                            data.update({\"value\": res})\n\n                        # bit data\n                        elif (self.regexes.bit.search(data[\"data_unit\"])) or self.regexes.fraction.search(data[\"address\"]):\n                            length = 2\n                            address_max = address_min + length if address_min + length <= response_max else response_max\n\n                            extraction_response = join_response[address_min: address_max]\n                            if len(extraction_response) % 2:\n                                extraction_response + b\"\\x00\"\n\n                            _binary = list(reversed(list(int_to_binary(byte_str2int(extraction_response[1:3], signed=False)))))\n                            try:\n                                if data[\"address\"].split(\".\")[1].isdecimal():\n                                    fraction_index = int(data[\"address\"].split(\".\")[1], 10)\n                                else:\n                                    fraction_index = int(data[\"address\"].split(\".\")[1], 16)\n                            except Exception:\n                                fraction_index = 0\n                            res = _binary[fraction_index]\n                            data.update({\"value\": res})\n\n                        # word data\n                        elif self.regexes.word.search(data[\"data_unit\"]):\n                            length = 2\n                            address_max = address_min + length if address_min + length <= response_max else response_max\n\n                            extraction_response = join_response[address_min: address_max]\n                            if len(extraction_response) % 2:\n                                extraction_response + b\"\\x00\"\n\n                            _binary = list(reversed(list(int_to_binary(byte_str2int(extraction_response[1:3], signed=False)))))\n                            if (self.regexes.signed.search(data[\"data_unit\"])):\n                                res = byte_str2int(reverse_bytes(extraction_response[1:3]), signed=True)\n                            else:\n                                res = byte_str2int(reverse_bytes(extraction_response[1:3]), signed=False)\n                            data.update({\"value\": res})\n\n                        # return Array\n                        else:\n                            extraction_response = join_response[address_min: response_max]\n                            if len(extraction_response) % 2:\n                                extraction_response + b\"\\x00\"\n\n                            _data = []\n                            for i in range(0, len(extraction_response), 2):\n                                _data.append(byte_str2int(extraction_response[i:i + 2]))\n\n                            if _data:\n                                data.update({\"value\": _data})\n\n        return {\n            \"metainfo\": multi_responses,\n            \"data\": self.conf.read_data\n        }\n\n    def divided_read(self):\n        return (\n            self.conf.read_data[\"word\"] + self.conf.read_data[\"doubleword\"] + self.conf.read_data[\"bulk\"]\n        )\n\n    def extract_error_connection(self, data_list: list):\n        def metalist(data_list: list):\n            return flatten([try_except(x, \"metainfo\", exception=[]) for x in data_list])\n\n        meta = metalist(data_list)\n        return [x[\"judge\"] for x in meta\n                if try_integer(try_except(try_except(x, \"connection\"), \"code\"), notation=16) != 0 or try_integer(try_except(try_except(x, \"judge\"), \"code\"), notation=16) != 0]\n\n\nif __name__ == \"__main__\":\n    configure = {\n        \"network\": {\n            \"ip_address\": \"192.168.0.1\",\n            # \"ip_address\": \"192.168.250.1\",\n            \"port\": 9600\n        },\n        \"controller\": {\n            \"type\": \"PLC\",\n            \"manufacturer\": \"Omron\",\n            \"series\": \"CJ\",\n            # \"series\": \"NJ101\",\n            \"protocol\": \"FINS/UDP\",\n            \"attributes\": {\n            }\n        },\n        \"data\": [\n            # # TODO Float\n            # {\n            #     \"execute\": \"read\",\n            #     \"machine_id\": 1,\n            #     # \"group\": \"count\",\n            #     # \"datatype\": \"input\",\n            #     # \"trigger_value\": None,\n            #     # \"item_value\": None,\n            #     \"device\": \"DM\",\n            #     \"address\": \"1004\",\n            #     # \"data_length\": 2,\n            #     # \"data_unit\": \"+integer\",\n            #     \"data_unit\": \"float\",\n            # },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                # \"group\": \"count\",\n                # \"datatype\": \"input\",\n                # \"trigger_value\": None,\n                # \"item_value\": None,\n                \"device\": \"DM\",\n                \"address\": \"100\",\n                # \"data_length\": 2,\n                # \"data_unit\": \"+integer\",\n                \"data_unit\": \"integer\",\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                # \"group\": \"count\",\n                # \"datatype\": \"input\",\n                # \"trigger_value\": None,\n                # \"item_value\": None,\n                \"device\": \"DM\",\n                \"address\": \"100.5\",\n                # \"data_length\": 2,\n                # \"data_unit\": \"+integer\",\n                \"data_unit\": \"integer\",\n            },\n            # {\n            #     \"execute\": \"read\",\n            #     \"machine_id\": 1,\n            #     # \"group\": \"count\",\n            #     # \"datatype\": \"input\",\n            #     # \"trigger_value\": None,\n            #     # \"item_value\": None,\n            #     \"device\": \"DM\",\n            #     \"address\": \"1000\",\n            #     # \"data_length\": 2,\n            #     # \"data_unit\": \"+integer\",\n            #     \"data_unit\": \"s_short\",\n            # },\n            # {\n            #     \"execute\": \"read\",\n            #     \"machine_id\": 1,\n            #     # \"group\": \"count\",\n            #     # \"datatype\": \"input\",\n            #     # \"trigger_value\": None,\n            #     # \"item_value\": None,\n            #     \"device\": \"DM\",\n            #     \"address\": \"1001\",\n            #     # \"data_length\": 2,\n            #     # \"data_unit\": \"+integer\",\n            #     \"data_unit\": \"s_short\",\n            # },\n            # {\n            #     \"execute\": \"read\",\n            #     \"machine_id\": 1,\n            #     # \"group\": \"count\",\n            #     # \"datatype\": \"input\",\n            #     # \"trigger_value\": None,\n            #     # \"item_value\": None,\n            #     \"device\": \"DM\",\n            #     \"address\": \"1000\",\n            #     # \"data_length\": 2,\n            #     # \"data_unit\": \"+integer\",\n            #     \"data_unit\": \"s_integer\",\n            # },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                # \"group\": \"count\",\n                # \"datatype\": \"input\",\n                # \"trigger_value\": None,\n                # \"item_value\": None,\n                \"device\": \"DM\",\n                \"address\": \"100\",\n                # \"data_length\": 2,\n                # \"data_unit\": \"+integer\",\n                \"data_unit\": \"-short\",\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                # \"group\": \"count\",\n                # \"datatype\": \"input\",\n                # \"trigger_value\": None,\n                # \"item_value\": None,\n                \"device\": \"DM\",\n                \"address\": \"100\",\n                # \"data_length\": 256,\n                \"data_unit\": \"string\"\n            },\n        ]\n    }\n    # configure[\"data\"].extend(\n    #     [\n    #         {\n    #             \"execute\": \"read\",\n    #             \"machine_id\": 1,\n    #             # \"group\": \"count\",\n    #             # \"datatype\": \"input\",\n    #             # \"trigger_value\": None,\n    #             # \"item_value\": None,\n    #             \"device\": \"DM\",\n    #             \"address\": \"1000\",\n    #             # \"data_length\": 2,\n    #             \"data_unit\": \"+integer\",\n    #             # \"data_unit\": \"bulk\"\n    #         },\n    #     ] * 165\n    # )\n\n    con = Communication(configure=configure)\n    con.identification_unit()\n    con.set_request_message_randam_read()\n    con.set_request_message_bulk_read()\n    con.set_connection()\n    con.open()\n    result = con.connection()\n    con.close()\n\n    con.divided_response_random_read()\n    con.divided_response_bulk_read()\n    response = con.divided_read()\n    # node = con.set_request_node_address()\n    # node_result = con.connection(request_messages=[node])\n    # con.divided_response_node(message=node_result)\n\n    print(response)\n\n",
        "_main.py": "import os\nimport re\nimport psutil\nimport socket\nimport random\nimport itertools\nimport struct\nimport traceback\nimport inspect\n\ntry:\n    from .. import const\n    from .. import convert\n    from .. import logger\nexcept Exception:\n    import sys\n    import pathlib\n    parent_dir = str(pathlib.Path(__file__).parent.parent.resolve())\n    sys.path.append(parent_dir)\n    import const\n    import convert\n    import logger\n\ntry:\n    from . import devices\nexcept Exception:\n    import src.connection.protocols.fins.devices as devices\n\nlogger = logger.get_module_logger(__name__, level=\"DEBUG\")\n\n\nclass Base():\n    def try_except_object(obj: dict, *, key: str = None, except_key: str = None, exception=\"\"):\n        if key is None:\n            try:\n                result = obj\n            except Exception:\n                result = exception\n        else:\n            try:\n                result = obj[key]\n            except Exception:\n                if except_key is not None:\n                    try:\n                        result = obj[except_key]\n                    except Exception:\n                        result = exception\n                else:\n                    result = exception\n        return result\n\n    def try_except_int(val, *, base_number=10, exception=None):\n        try:\n            return int(val, base_number)\n        except Exception:\n            if exception is None:\n                return val\n            else:\n                return exception\n\n    def try_except_str(val, *, exception=None):\n        try:\n            return str(val)\n        except Exception:\n            if exception is None:\n                return val\n            else:\n                return exception\n\n\nclass Connect():\n    # 通信設定をセット\n    def __init__(self, network: dict, protocol: dict, device: dict, cmd: dict, *, optional: dict = None):\n        self.network = network\n        self.protocol = protocol\n        self.device = device\n        self.cmd = cmd\n        self.optional = optional\n\n        self.ip_address = self.network[\"ip\"]\n        self.port = Base.try_except_int(network[\"port\"])\n\n        self.cmd_cmd = self.cmd[\"cmd\"]\n        self.cmd_data = self.cmd[\"data\"]\n        self.transport_layer_protocol = self.protocol[\"transport_layer\"]\n        self.manufacture = self.protocol[\"manufacture\"]\n        self.series = self.protocol[\"series\"]\n\n        self.str_min_address = Base.try_except_object(\n            self.device, key=\"min\", except_key=\"minimum\", exception=None)\n        self.str_max_address = Base.try_except_object(\n            self.device, key=\"max\", except_key=\"maximum\", exception=None)\n\n        self.skip_address_index = []\n\n    # Optionのチェック\n    def check_optional(self):\n        try:\n            self.telegram_data = []\n            self.segment_length = []\n            self.cmd_option = Base.try_except_object(self.cmd, key=\"option\")\n\n            self.optional_data_type = Base.try_except_object(\n                self.optional, key=\"data_type\")\n\n            # STRING OPTINONのチェック。Dataの型がstrの場合、PLCに読み書きするデータを強制的にSTRINGデータとして扱う\n            self.string_option = False\n            if self.cmd_cmd in const.WRITE_COMMAND and (self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA):\n                self.string_option = True\n                if isinstance(self.cmd_data, list) and all(isinstance(s, str) for s in self.cmd_data):\n                    self.cmd_data = \"\".join(self.cmd_data)\n\n            # TIME OPTIONのチェック\n            self.time_option = False\n            if (self.cmd_option in const.TIME_DATA or self.optional_data_type in const.TIME_DATA):\n                self.time_option = True\n\n        except Exception as e:\n            logger.warning(traceback.format_exc())\n            return {\n                \"error_code\": 20003,\n                \"message\": \"The option parameter setting is incorrect. \",\n                \"traceback\": str(e)\n            }\n        else:\n            return {\n                \"error_code\": 0,\n                \"message\": f\"Success: {inspect.getframeinfo(inspect.currentframe()).function}\"\n            }\n\n    # Min, MaxのAddressに小数点が含まれているかのチェック\n    def check_decimalpoint(self):\n        try:\n            self.point_index = self.str_min_address.index('.')\n        except ValueError:\n            try:\n                self.point_index = self.str_max_address.index('.')\n            except ValueError:\n                self.point_index = False\n        finally:\n            return {\n                \"error_code\": 0,\n                \"message\": f\"Success: {inspect.getframeinfo(inspect.currentframe()).function}\"\n            }\n\n    # SKIP OPTIONの確認 listに含まれているアドレスが必要なためスキップしない＝含まれない場合スキップ\n    def check_withoutskip(self):\n        try:\n            optional_without_skip = Base.try_except_object(\n                self.optional, key=\"without_skip\", except_key=\"only_use_address\", exception=[])\n            self.without_skip_address = []\n            if self.cmd_cmd in const.READ_COMMAND and len(optional_without_skip) > 0:\n                for without_skip_address in optional_without_skip:\n                    without_address = convert.decimal_convert(\n                        decimal=self.decimal, str_address=without_skip_address)\n                    self.without_skip_address.append(\n                        without_address - self.int_min_address\n                    )\n        except Exception as e:\n            logger.warning(traceback.format_exc())\n            return {\n                \"error_code\": 20005,\n                \"message\": \"Setting without_skip optional has error.\",\n                \"traceback\": str(e)\n            }\n        else:\n            return {\n                \"error_code\": 0,\n                \"message\": f\"Success: {inspect.getframeinfo(inspect.currentframe()).function}\"\n            }\n\n    # PLCのデバイス値などの固定値をdevice_list.pyから取得し変換\n    def set_device_parameter(self):\n        try:\n            has_point = Base.try_except_object(\n                self.protocol, key=\"point_index\", exception=None)\n\n            device_list = devices.device_list(\n                manufacture=self.manufacture, series=self.series,\n                transport=self.transport_layer_protocol,\n                has_point=(has_point or self.point_index)\n            )\n            self.max_communicate_address_length = device_list[\"transfer_limit\"]\n            self.prefix_byte = device_list[\"prefix_byte\"]\n            self.endian = device_list[\"endian\"]\n\n            device_list_data = [x for x in device_list[\"devices\"]\n                                if x[\"symbol\"] == self.device[\"device\"]][0]\n            self.device_code = [device_list_data[\"binary\"]]\n            self.bit_identify = device_list_data[\"identify\"]\n            self.decimal = device_list_data[\"decimal\"]\n\n            self.int_min_address = convert.decimal_convert(\n                decimal=self.decimal, str_address=self.str_min_address)\n            self.int_max_address = convert.decimal_convert(\n                decimal=self.decimal, str_address=self.str_max_address)\n\n            self.communicate_address_length = (\n                self.int_max_address - self.int_min_address + 1)\n\n        except Exception as e:\n            logger.warning(traceback.format_exc())\n            return {\n                \"error_code\": 20002,\n                \"message\": \"Parameter setting is incorrect.\",\n                \"traceback\": str(e)\n            }\n        else:\n            return {\n                \"error_code\": 0,\n                \"message\": f\"Success: {inspect.getframeinfo(inspect.currentframe()).function}\"\n            }\n\n    def set_parameter(self):\n        result_check_optional = self.check_optional()\n        if result_check_optional[\"error_code\"] == 0:\n            result_check_withoutskip = self.check_withoutskip()\n            if result_check_withoutskip[\"error_code\"] == 0:\n                result_check_decimalpoint = self.check_decimalpoint()\n                if result_check_decimalpoint[\"error_code\"] == 0:\n                    result_set_device_parameter = self.set_device_parameter()\n                    if result_check_decimalpoint[\"error_code\"] == 0:\n                        return {\n                            \"error_code\": 0,\n                            \"error_message\": \"SUCCESS\",\n                        }\n                    else:\n                        return result_set_device_parameter\n                else:\n                    return result_check_decimalpoint\n            else:\n                return result_check_withoutskip\n        else:\n            return result_check_optional\n\n    # =================================================================\n    # ネットワークの第4オクテットを取得(FINS通信設定に必要)\n    def get_host_fourth_octet(self, ip_address, port):\n        def get_local_ip(ip_address, port):\n            from socket import socket, AF_INET, SOCK_DGRAM\n            s = socket(AF_INET, SOCK_DGRAM)\n            try:\n                s.connect((ip_address, port))\n                ipaddr = s.getsockname()[0]\n            except Exception:\n                ipaddr = '127.0.0.1'\n            finally:\n                s.close()\n            return ipaddr\n\n        # Windows OS\n        if os.name == \"nt\":\n            iplist = socket.gethostbyname_ex(socket.gethostname())[2]\n        # Mac OS or Linux OS\n        else:\n            iplist = []\n            address_list = psutil.net_if_addrs()\n            for _ in address_list.keys():\n                local_ip = get_local_ip(ip_address, port)\n                iplist.append(local_ip)\n\n        same_network = ip_address.rsplit('.', 1)[0]\n        if len(iplist) > 0:\n            try:\n                client_ip = [x for x in iplist if same_network in x]\n                fourth_octet = int(client_ip[0].rsplit('.', 1)[1])\n            except Exception as e:\n                logger.warning(\n                    '{}:{}, {}'.format(\n                        sys._getframe().f_code.co_name, e, 'No connection found. Please check your communication settings.'))\n                fourth_octet = int(iplist[0].rsplit('.', 1)[1])\n        else:\n            fourth_octet = None\n        return fourth_octet\n\n    # 連続読出しコマンド生成\n    def sequence_read(self):\n        cmd_data = []\n        access_data_length = []\n        first_address = []\n\n        _segment = [x for x in range(0, self.communicate_address_length, self.max_communicate_address_length)]\n        _segment.append(self.communicate_address_length)\n        for i_segment in range(len(_segment)):\n            try:\n                min_segment = _segment[i_segment]\n                max_segment = _segment[i_segment + 1]\n            except Exception:\n                break\n            else:\n                _segment_cmd_data = list(range(min_segment, max_segment))\n\n                # Skip addressのチェック(without skipが存在し、かつsegmentと重複していないものをSkip扱いとする)\n                if len(self.without_skip_address) > 0 and not (set(_segment_cmd_data) & set(self.without_skip_address)):\n                    self.skip_address_index.append(i_segment)\n\n                self.segment_length.append(len(_segment_cmd_data))\n\n                _access_data_length = format(len(_segment_cmd_data), \"04x\")\n                # アドレスが整数指定の場合\n                if self.point_index is None:\n                    _min_ad = format(self.int_min_address + min_segment, \"04x\")\n\n                    # エンディアンの調整\n                    if self.endian in const.ENDIAN_BIG:\n                        access_data_length.append([int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                        _first_address = [int(x, 16) for x in list(re.findall(\"..\", _min_ad))]\n                    else:\n                        access_data_length.append([int(x, 16) for x in list(reversed(list(re.findall(\"..\", _access_data_length))))])\n                        _first_address = [int(x, 16) for x in list(reversed(list(re.findall(\"..\", _min_ad))))]\n                    _first_address.append(0)\n\n                # アドレスが小数指定の場合\n                else:\n                    _, quotient, remainder = convert.each_convert(self.decimal, self.int_min_address + min_segment)\n                    padded_quotient = quotient.rjust(4, \"0\")\n                    padded_remainder = remainder.rjust(2, \"0\")\n                    padded = list(re.findall(\"..\", padded_quotient)) + [padded_remainder]\n\n                    # エンディアンの調整\n                    if self.endian in const.ENDIAN_BIG:\n                        access_data_length.append([int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                        _first_address = [int(x, 16) for x in padded]\n                    else:\n                        access_data_length.append([int(x, 16) for x in list(reversed(list(re.findall(\"..\", _access_data_length))))])\n                        _first_address = [int(x, 16) for x in list(reversed(padded))]\n\n                first_address.append(_first_address)\n\n        return {\n            \"cmd_data\": cmd_data,\n            \"access_data_length\": access_data_length,\n            \"first_address\": first_address,\n        }\n\n    # 文字列書き込みコマンド生成\n    def convert_write_string(self, data):\n        cmd_data = []\n\n        if isinstance(data, list) is True:\n            _data = \"\".join(data)\n        else:\n            _data = data\n\n        _data_list = [format(ord(x), \"02x\") for x in list(_data)]\n\n        it = iter(_data_list)\n        for _a, _b in itertools.zip_longest(it, it, fillvalue=\"00\"):\n            cmd_data.append([int(_b, 16), int(_a, 16)])\n\n        length, _mod = divmod(len(_data), 2)\n        length += _mod\n        return cmd_data, length\n\n    # WORD書き込みコマンド生成\n    def convert_write_word(self, data: list):\n        cmd_data = []\n        for i in range(len(data)):\n            # positive/negative judgment\n            if data[i] >= 0:\n                _data = format(data[i], \"04x\")\n            else:\n                _data = format(\n                    data[i] & 0xffff, '04x')\n\n            it = iter(_data)\n            for _a, _b, _c, _d in zip(it, it, it, it):\n                if self.endian in const.ENDIAN_BIG:\n                    cmd_data.append(\n                        [int(_a + _b, 16), int(_c + _d, 16)])\n                else:\n                    cmd_data.append(\n                        [int(_c + _d, 16), int(_a + _b, 16)])\n        length = len(cmd_data)\n        return cmd_data, length\n\n    # BIT書き込みコマンド生成\n    def convert_write_bit(self, data: list):\n        cmd_data = []\n        if self.point_index is None:\n            _data = [format(x, \"01x\") for x in data]\n            it = iter(_data)\n            for _a, _b in itertools.zip_longest(it, it, fillvalue=\"0\"):\n                cmd_data.append(\n                    [int(_a + _b, 16)])\n            length = len(cmd_data) * 2\n        else:\n            cmd_data.append(data)\n            length = len(data)\n        return cmd_data, length\n\n    # 連続書き込みコマンド生成\n    def sequence_write(self):\n        # Ex: W1.00 ~ W1.05 [1,1,0,0,1,0]\n        # a = b\"\\x46\\x49\\x4E\\x53\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x80\\x00\\x02\\x00\\x01\\x00\\x00\\xef\\x00\\x19\\x01\\x02\\x31\\x00\\x00\\x01\\x00\\x06\\x01\\x01\\x00\\x00\\x01\\x00\"\n        # Ex: W1 ~ W5 [1,1,0,0,1,0]\n        # a = b\"\\x46\\x49\\x4e\\x53\\x00\\x00\\x00\\x26\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x80\\x00\\x02\\x00\\x01\\x00\\x00\\xef\\x00\\x19\\x01\\x02\\xb1\\x00\\x01\\x00\\x00\\x06\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\"\n\n        cmd_data = []\n        access_data_length = []\n        first_address = []\n\n        _segment = [\n            x for x in range(0, self.communicate_address_length, self.max_communicate_address_length)]\n        _segment.append(self.communicate_address_length)\n        for i_segment in range(len(_segment)):\n            try:\n                min_segment = _segment[i_segment]\n                max_segment = _segment[i_segment + 1]\n            except Exception:\n                break\n            else:\n                _length = 0\n                _segment_cmd_data = self.cmd_data[min_segment: max_segment]\n                _cmd_data = []\n\n                # 書き込みコマンドの変換\n                # Word devices\n                if self.bit_identify in const.WORD_DEVICE:\n                    # Writing of character strings.\n                    if self.string_option is True:\n                        _cmd_data, _length = self.convert_write_string(\n                            _segment_cmd_data)\n                    # Writing of integer or boolean.\n                    else:\n                        _cmd_data, _length = self.convert_write_word(_segment_cmd_data)\n                # TODO double device\n                elif self.bit_identify in const.DOUBLE_DEVICE:\n                    pass\n                # Bit devices\n                else:\n                    _cmd_data, _length = self.convert_write_bit(_segment_cmd_data)\n\n                if _length > 0:\n                    cmd_data.append(_cmd_data)\n                    _access_data_length = format(_length, \"04x\")\n                    if self.point_index is None:\n                        _min_ad = format(\n                            self.int_min_address + min_segment, \"04x\")\n                        if self.endian in const.ENDIAN_BIG:\n                            access_data_length.append(\n                                [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                            _first_address = [int(x, 16) for x in list(\n                                re.findall(\"..\", _min_ad))]\n                        else:\n                            access_data_length.append([int(x, 16) for x in list(\n                                reversed(list(re.findall(\"..\", _access_data_length))))])\n                            _first_address = [int(x, 16) for x in list(\n                                reversed(list(re.findall(\"..\", _min_ad))))]\n                        _first_address.append(0)\n                    # TODO\n                    else:\n                        _, quotient, remainder = convert.each_convert(\n                            self.decimal, self.int_min_address + min_segment)\n                        padded_quotient = quotient.rjust(4, \"0\")\n                        padded_remainder = remainder.rjust(2, \"0\")\n                        padded = list(re.findall(\n                            \"..\", padded_quotient)) + [padded_remainder]\n\n                        if self.endian in const.ENDIAN_BIG:\n                            access_data_length.append(\n                                [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                            _first_address = [\n                                int(x, 16) for x in padded]\n                        else:\n                            access_data_length.append([int(x, 16) for x in list(\n                                reversed(list(re.findall(\"..\", _access_data_length))))])\n                            _first_address = [\n                                int(x, 16) for x in list(reversed(padded))]\n\n                    first_address.append(_first_address)\n\n        return {\n            \"cmd_data\": cmd_data,\n            \"access_data_length\": access_data_length,\n            \"first_address\": first_address,\n        }\n\n    # ノード通信電文生成\n    def generate_node_telegram(self):\n        if self.transport_layer_protocol in const.TRANSPORT_TCP:\n            header = [0x46, 0x49, 0x4E, 0x53]\n            length = [0x00, 0x00, 0x00, 0x0C]\n            tcp_command = [0x00, 0x00, 0x00, 0x00]\n            error_code = [0x00, 0x00, 0x00, 0x00]\n            client_node = [0x00, 0x00, 0x00, 0x00]\n            node_telegram = (\n                header + length + tcp_command + error_code + client_node\n            )\n            binary = b\"\"\n            for x in node_telegram:\n                binary += struct.pack(\"B\", x)\n            self.node_telegram = binary\n            return self.node_telegram\n\n    # 通信電文生成\n    def generate_telegram(self, *, node_data=None):\n        # self.skip_address_index = []\n\n        if self.transport_layer_protocol in const.TRANSPORT_TCP:\n            header = [0x46, 0x49, 0x4E, 0x53]\n            tcp_command = [0x00, 0x00, 0x00, 0x02]\n            error_code = [0x00, 0x00, 0x00, 0x00]\n            if node_data is not None and node_data[\"error_code\"] == 0:\n                da1 = [node_data[\"server_node\"]]\n                sa1 = [node_data[\"client_node\"]]\n            else:\n                return node_data\n\n        elif self.transport_layer_protocol in const.TRANSPORT_UDP:\n            header = []\n            tcp_command = []\n            error_code = []\n            client_ip = self.get_host_fourth_octet(self.ip_address, self.port)\n            client_ip = 52\n            da1 = [0x00]\n            sa1 = [client_ip]\n\n        # Bit7=1:fixed value, Bit6=0:command, Bit0=0:need response\n        # icf = [0x00]\n        icf = [0x80]\n        rsv = [0x00]\n        # Number of allowable bridge passes.\n        # Basically 0x02, 0x07: When using network crossings up to 8 layers.\n        gct = [0x02]\n        # Destination network address.\n        # 0x00: Same network, 0x01~0x7F: Destination network\n        dna = [0x00]\n        da2 = [0x00]\n        sna = [0x00]\n        sa2 = [0x00]\n        self.sid = random.randrange(0, 255, 1)\n        sid = [self.sid]\n\n        device_code = self.device_code\n\n        # Readコマンド\n        if self.cmd_cmd in const.READ_COMMAND:\n            command = [0x01, 0x01]\n            command_data = self.sequence_read()\n            arr_cmd_data = command_data[\"cmd_data\"]\n            arr_access_data_length = command_data[\"access_data_length\"]\n            arr_first_address = command_data[\"first_address\"]\n        # Writeコマンド\n        else:\n            command = [0x01, 0x02]\n            command_data = self.sequence_write()\n            arr_cmd_data = command_data[\"cmd_data\"]\n            arr_access_data_length = command_data[\"access_data_length\"]\n            arr_first_address = command_data[\"first_address\"]\n\n        for i in range(len(arr_access_data_length)):\n            try:\n                cmd_data = list(\n                    (itertools.chain.from_iterable(arr_cmd_data[i])))\n            except Exception:\n                cmd_data = []\n            access_data_length = arr_access_data_length[i]\n            first_address = arr_first_address[i]\n\n            if self.transport_layer_protocol in const.TRANSPORT_TCP:\n                length_count = len(\n                    tcp_command + error_code + icf + rsv + gct + dna + da1 + da2 + sna + sa1 + sa2 + sid + command + device_code + first_address + access_data_length + cmd_data\n                )\n\n                _length = [int(x, 16) for x in list(\n                    re.findall(\"..\", format(length_count, \"08x\")))]\n            else:\n                _length = []\n\n            if self.endian in const.ENDIAN_BIG:\n                length = _length\n            else:\n                length = list(reversed(_length))\n\n        _data = (\n            header + length + tcp_command + error_code + icf + rsv + gct + dna + da1 + da2 + sna + sa1 + sa2 + sid + command + device_code + first_address + access_data_length + cmd_data\n        )\n\n        _binary = b\"\"\n        for x in _data:\n            _binary += struct.pack(\"B\", x)\n        self.telegram_data.append(_binary)\n        self.access_data_length = access_data_length\n        return {\n            \"error_code\": 0,\n            \"message\": \"SUCCESS\",\n            \"data\": self.telegram_data,\n            \"check\": self.sid\n        }\n\n    # =================================================================\n    # Socketの定義\n    def set_connection(self):\n        try:\n            # Socket定義\n            if self.transport_layer_protocol in const.TRANSPORT_TCP:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            else:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.sock.settimeout(const.TRANSPORT_TIMEOUT)\n        except Exception as e:\n            logger.warning(traceback.format_exc())\n            return {\n                \"error_code\": 20010,\n                \"message\": \"Socket communication could not be established.\",\n                \"traceback\": str(e)\n            }\n        else:\n            return {\n                \"error_code\": 0,\n                \"message\": f\"Success: {inspect.getframeinfo(inspect.currentframe()).function}\"\n            }\n\n    # 送受信電文のIDチェック\n    def check_sid(self, recv):\n        try:\n            recv_sid = int(recv[self.prefix_byte - 10: self.prefix_byte - 8], 16)\n            if recv_sid == self.sid:\n                error_message = \"SUCCESS\"\n                err_code = 0\n            else:\n                err_code = 221 if err_code in [0, 9999] else err_code\n                error_message = \"SID for sending and receiving are different.\"\n        except Exception as e:\n            err_code = 222 if err_code in [0, 9999] else err_code\n            error_message = str(e)\n        finally:\n            return {\n                \"error_code\": err_code,\n                \"error_message\": error_message\n            }\n\n    # エラーコードの判定\n    def check_error_code(self, recv):\n        if self.transport_layer_protocol in const.TRANSPORT_UDP:\n            ecode = (recv[self.prefix_byte - 4: self.prefix_byte - 2] + recv[self.prefix_byte - 2: self.prefix_byte])\n            # Bit7, Bit8はPLC本体の異常(バッテリ異常など)のため無視\n            if int(ecode, 16) not in [0, 64, 128]:\n                err_code = ecode\n                error_message = f\"ErrorCode: {err_code}\"\n            else:\n                err_code = 0\n                error_message = \"SUCCESS\"\n        elif self.transport_layer_protocol in const.TRANSPORT_TCP:\n            conn_ecode1 = recv[16:24]\n            conn_ecode2 = recv[24:32]\n            ecode = recv[self.prefix_byte - 4: self.prefix_byte]\n\n            # Bit7, Bit8はPLC本体の異常(バッテリ異常など)のため無視\n            if int(conn_ecode1, 16) not in [2, 64, 128] and int(conn_ecode2, 16) not in [0, 64, 128]:\n                ecode = conn_ecode2 + ',' + conn_ecode2\n                err_code = ecode if err_code in [0, 9999] else err_code\n                error_message = f\"ErrorCode: {err_code}\"\n            elif int(ecode, 16) not in [0, 64, 128]:\n                ecode = (\n                    recv[self.prefix_byte - 4: self.prefix_byte - 2] + recv[self.prefix_byte - 2: self.prefix_byte]\n                )\n                err_code = ecode if err_code in [0, 9999] else err_code\n                error_message = f\"ErrorCode: {err_code}\"\n            else:\n                err_code = 0\n                error_message = \"SUCCESS\"\n\n        return {\n            \"error_code\": err_code,\n            \"error_message\": error_message\n        }\n\n    # TCP通信の場合、通信前に必要なノード通信を実施\n    def send_node_telegram(self):\n        self.client_node = None\n        self.server_node = None\n        self.generate_node_telegram()\n        try:\n            self.sock.connect((self.ip_address, self.port))\n            self.sock.send(bytes(self.node_telegram))\n            recv_node = self.sock.recv(1024).hex()\n        except socket.error as e:\n            logger.warning(e)\n            self.node_ecode = 10060\n            self.node_error_message = str(e)\n        else:\n            node_ecode1 = recv_node[16:24]\n            node_ecode2 = recv_node[24:32]\n\n            # Node error handling.\n            if int(node_ecode1, 16) not in [1, 64, 128]:\n                self.node_ecode = 30098\n                self.node_error_message = \"node ecode1: {}\".format(\n                    node_ecode1)\n            elif int(node_ecode2, 16) not in [0, 64, 128]:\n                self.node_ecode = 30099\n                self.node_error_message = \"node ecode2: {}\".format(\n                    node_ecode2)\n            else:\n                self.client_node = int(\"0x\" + recv_node[32:40], 16)\n                self.server_node = int(\"0x\" + recv_node[40:48], 16)\n                self.node_ecode = 0\n                self.node_error_message = \"node success\"\n\n        return {\n            \"error_code\": self.node_ecode,\n            \"message\": self.node_error_message,\n            \"client_node\": self.client_node,\n            \"server_node\": self.server_node,\n        }\n\n    # 通信\n    def send_telegram(self, *, telegram_data=None, skip_address_index=None) -> dict:\n        some_send_data = []\n        some_recv_data = []\n        some_err_code = []\n        some_err_message = []\n        recv_data = \"\"\n\n        # スキップのチェック\n        if skip_address_index is None:\n            try:\n                skip_address_index = self.skip_address_index\n            except Exception:\n                skip_address_index = []\n        else:\n            skip_address_index = []\n\n        # Connection\n        try:\n            self.set_connection()\n            # TCPの場合、ノード通信を実行\n            if self.transport_layer_protocol in const.TRANSPORT_TCP:\n                node_data = self.send_node_telegram()\n            else:\n                node_data = None\n                self.sock.connect((self.ip_address, self.port))\n\n            # 送信電文を生成\n            if telegram_data is None:\n                telegram_obj = self.generate_telegram(node_data=node_data)\n                telegram_data = telegram_obj[\"data\"]\n            elif isinstance(telegram_data, str):\n                telegram_data = [telegram_data]\n        except socket.error as e:\n            if e.errno is None:\n                some_err_code.append(10060)\n            else:\n                some_err_code.append(e.errno)\n            some_err_message.append(str(e))\n        else:\n            # 小分けした電文毎に通信・成功判定\n            for index, telegram in enumerate(telegram_data):\n                recv = None\n                # スキップインデックスの場合処理をスキップ\n                if len(skip_address_index) > 0 and index in skip_address_index:\n                    recv = \"skip\"\n                    error_code = 0\n                    error_message = \"SKIP\"\n                    recv_data += \"0000\" * self.segment_length[index]\n                else:\n                    error_code = 9999\n                    error_message = \"\"\n                    for i in range(const.RETRY_COUNT):\n                        logger.debug(f\"send telegram: {telegram}\")\n\n                        # 電文送信, 失敗した場合Retry countの回数分再送\n                        self.sock.send(bytes(telegram))\n\n                        # Recieved data.\n                        try:\n                            recv = self.sock.recv(1024).hex()\n                            logger.debug(\"recv: {}\".format(recv))\n                        # WSAETIMEDOUT\n                        except socket.timeout as e:\n                            error_code = 10060\n                            error_message = str(e)\n                        # WSAECONNREFUSED\n                        except socket.herror as e:\n                            error_code = 10061\n                            error_message = str(e)\n                        except socket.gaierror as e:\n                            error_code = 11001\n                            error_message = str(e)\n                        except socket.error as e:\n                            error_code = 10065\n                            error_message = str(e)\n                        else:\n                            try:\n                                # エラーコードのチェック\n                                checked_error_code = self.check_error_code(recv)\n                                # SIDのチェック\n                                checked_sid = self.check_sid(recv)\n\n                                if checked_error_code[\"error_code\"] == 0 and checked_sid[\"error_code\"] == 0:\n                                    error_code = checked_error_code[\"error_code\"]\n                                    error_message = checked_error_code[\"error_message\"]\n                                    break\n                                else:\n                                    error_code = checked_error_code[\"error_code\"] if checked_error_code[\"error_code\"] in [0, 9999] else checked_sid[\"error_code\"]\n                                    error_message = checked_error_code[\"error_message\"] if checked_error_code[\"error_message\"] in [\"\", \"success\", \"SUCCESS\"] else checked_sid[\"error_message\"]\n\n                            except Exception as e:\n                                error_code = 9999 if error_code in [0, 9999] else error_code\n                                error_message = str(e) if error_message == \"\" else error_message\n\n                    else:\n                        logger.debug(f\"Retry count: {i+1}, Errcd: {error_code}, Message: {error_message}\")\n                        some_err_code.append(error_code)\n                        some_err_message.append(error_message)\n                        break\n\n                    recv_data += recv[self.prefix_byte:]\n\n                some_send_data.append(telegram)\n                some_recv_data.append(recv)\n                some_err_code.append(error_code)\n                some_err_message.append(error_message)\n\n        # 電文返答をデコード\n        try:\n            some_send_data = [x.hex() for x in some_send_data]\n        except Exception:\n            pass\n\n        self.recv_data = recv_data\n        error_code = max(some_err_code) if len(some_err_code) > 0 else None\n        return {\n            \"recv_data\": recv_data,\n            \"error_code\": max(some_err_code),\n            \"some_send\": some_send_data,\n            \"some_recv\": some_recv_data,\n            \"some_err_code\": some_err_code,\n            \"some_err_message\": some_err_message,\n        }\n\n    # 文字列に変換\n    @staticmethod\n    def convert_ascii_string(data: str, *, endian=\"\") -> str:\n        _string_data = []\n\n        if len(data) <= 2:\n            # Asciiは0x00~0x1Fは制御文字のため文字列としてはNullと扱う\n            _1st_str = chr(int(data[:2], 16)) if int(\n                data[:2], 16) >= 20 else \"\"\n            _string_data.append(_1st_str)\n        else:\n            # Asciiは0x00~0x1Fは制御文字のため文字列としてはNullと扱う\n            if endian in const.ENDIAN_BIG:\n                _1st_str = chr(int(data[2:], 16)) if int(\n                    data[2:], 16) >= 20 else \"\"\n                _2nd_str = chr(int(data[:2], 16)) if int(\n                    data[:2], 16) >= 20 else \"\"\n            else:\n                _1st_str = chr(int(data[:2], 16)) if int(\n                    data[:2], 16) >= 20 else \"\"\n                _2nd_str = chr(int(data[2:], 16)) if int(\n                    data[2:], 16) >= 20 else \"\"\n            _string_data.append(_1st_str)\n            _string_data.append(_2nd_str)\n\n        return \"\".join(_string_data)\n\n    # 取得データをWord/Bit単位に分割\n    def devide_received(self, *, recv_data=None):\n        if self.cmd_cmd in const.WRITE_COMMAND:\n            return []\n        else:\n            if recv_data is None:\n                _devide_data = self.recv_data\n            else:\n                _devide_data = recv_data\n            _devide = []\n            _word = 4\n            _byte = 2\n            _bit = 1\n\n            _count = 0\n            if self.bit_identify in const.BIT_DEVICE:\n                for i in range(0, len(_devide_data), _byte):\n                    if len(_devide_data[i: i + _byte]) < _byte:\n                        _data = _devide_data[i: i + _byte] + (\"0\" * _byte)\n                    else:\n                        _data = _devide_data[i: i + _byte]\n\n                    if self.endian in const.ENDIAN_LITTLE:\n                        _data = _data[_bit:] + _data[:_bit]\n\n                    _devide.append(int(_data, 16))\n\n            elif self.bit_identify in const.WORD_DEVICE:\n                for i in range(0, len(_devide_data), _word):\n                    if len(_devide_data[i: i + _word]) < _word:\n                        _data = _devide_data[i: i + _word] + (\"0\" * _word)\n                    else:\n                        _data = _devide_data[i: i + _word]\n\n                    if self.endian in const.ENDIAN_LITTLE:\n                        _data = _data[_byte:] + _data[:_byte]\n\n                    # 文字列として返答\n                    if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                        # [0x00, 0x00]で区切り文字。それ以降はバッファが含まれる可能性があるので無視する\n                        if _data == \"0000\":\n                            break\n                        else:\n                            _string_data = self.convert_ascii_string(\n                                _data, endian=self.endian)\n                            _devide.append(_string_data)\n\n                    # wordデバイスをbitとして使用している場合の返答\n                    elif self.bit_identify in const.WORD_DEVICE and self.point_index is not None:\n                        _bit_data = list(\n                            reversed([int(x, 16) for x in list(format(int(_data, 16), \"016b\"))]))\n                        if _count == 0 and self.communicate_address_length - 1 == 0:\n                            _min_bit = int(\n                                self.str_min_address.rsplit(\".\", 1)[-1], 16)\n                            _max_bit = int(\n                                self.str_max_address.rsplit(\".\", 1)[-1], 16)\n                            _devide.extend(_bit_data[_min_bit:_max_bit])\n                        elif _count == 0:\n                            _min_bit = int(\n                                self.str_min_address.rsplit(\".\", 1)[-1], 16)\n                            _devide.extend(_bit_data[_min_bit:])\n                        elif _count == self.communicate_address_length - 1:\n                            _max_bit = int(\n                                self.str_max_address.rsplit(\".\", 1)[-1], 16)\n                            _devide.extend(_bit_data[:_max_bit])\n                        else:\n                            _devide.extend(_bit_data)\n\n                    else:\n                        _devide.append(int(_data, 16))\n                    _count += 1\n\n            # 文字列の場合、結合してtextで返答\n            if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                _devide = \"\".join(_devide)\n\n            return _devide\n\n\ndef main(network: dict, protocol: dict, device: dict, cmd: dict, *, optional=None):\n    try:\n        connect = Connect(network, protocol, device, cmd, optional=optional)\n    except Exception:\n        result = {\n            \"error_code\": 20001,\n            \"message\": \"There are some missing parts in the settings.\"\n        }\n    else:\n        result_set_parameter = connect.set_parameter()\n        logger.info(result_set_parameter)\n        if result_set_parameter[\"error_code\"] != 0:\n            result = {\n                \"extract\": [],\n                \"send\": \"\",\n                \"receive\": \"\",\n                \"error_code\": result_set_parameter[\"error_code\"],\n                \"message\": Base.try_except_object(result_set_parameter, key=\"message\", except_key=\"error_message\", exception=\"\")\n            }\n        else:\n            result_send_telegram = connect.send_telegram()\n\n            logger.info(result_send_telegram)\n            if not (result_send_telegram[\"error_code\"] == 0 and result_send_telegram[\"recv_data\"] != []):\n                result = {\n                    \"extract\": [],\n                    \"send\": result_send_telegram[\"some_send\"],\n                    \"receive\": result_send_telegram[\"some_recv\"],\n                    \"error_code\": result_send_telegram[\"error_code\"],\n                    \"message\": Base.try_except_object(result_send_telegram, key=\"some_err_message\", except_key=\"error_message\", exception=\"\")\n                }\n            else:\n                result_devide_received = connect.devide_received(recv_data=result_send_telegram[\"recv_data\"])\n                logger.info(result_devide_received)\n\n                result = {\n                    \"extract\": result_devide_received,\n                    \"send\": result_send_telegram[\"some_send\"],\n                    \"receive\": result_send_telegram[\"some_recv\"],\n                    \"error_code\": result_send_telegram[\"error_code\"],\n                    \"message\": Base.try_except_object(result_send_telegram, key=\"some_err_message\", except_key=\"error_message\", exception=\"\")\n                }\n    finally:\n        try:\n            del connect\n        except Exception as e:\n            logger.debug(str(e))\n        finally:\n            logger.debug(result)\n            return result\n\n\nclass Connection():\n    def __init__(self):\n        pass\n\n    def __del__(self):\n        try:\n            self.sock.close()\n        except socket.error as e:\n            logger.warning(str(e))\n        except Exception as e:\n            logger.warning(str(e))\n\n    # Optionの確認\n    def check_optional(self):\n        self.telegram_data = []\n        self.segment_length = []\n        self.cmd_option = Base.try_except_object(self.cmd, key=\"option\")\n\n        self.optional_data_type = Base.try_except_object(\n            self.optional, key=\"data_type\")\n\n        # STRING OPTINONの確認。Dataの型がstrの場合、強制的にSTRINGと扱う\n        self.string_option = False\n        if self.cmd_cmd in const.WRITE_COMMAND and (self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA):\n            self.string_option = True\n            if isinstance(self.cmd_data, list) and all(isinstance(s, str) for s in self.cmd_data):\n                self.cmd_data = \"\".join(self.cmd_data)\n\n        # TIME OPTIONの確認\n        self.time_option = False\n        if (self.cmd_option in const.TIME_DATA or self.optional_data_type in const.TIME_DATA):\n            self.time_option = True\n\n    def check_decimal_point(self):\n        try:\n            self.point_index = self.str_min_address.index('.')\n        except ValueError:\n            try:\n                self.point_index = self.str_max_address.index('.')\n            except ValueError:\n                self.point_index = None\n\n    # デバイス/アドレス情報の定義\n    def define_device_parameter(self):\n        has_point = Base.try_except_object(\n            self.protocol, key=\"point_index\", exception=None)\n\n        device_list = devices.device_list(\n            manufacture=self.manufacture, series=self.series,\n            transport=self.transport_layer_protocol,\n            has_point=(has_point or self.point_index)\n        )\n        self.max_communicate_address_length = device_list[\"transfer_limit\"]\n        self.prefix_byte = device_list[\"prefix_byte\"]\n        self.endian = device_list[\"endian\"]\n\n        device_list_data = [x for x in device_list[\"devices\"]\n                            if x[\"symbol\"] == self.device[\"device\"]][0]\n        self.device_code = [device_list_data[\"binary\"]]\n        self.bit_identify = device_list_data[\"identify\"]\n        self.decimal = device_list_data[\"decimal\"]\n\n        self.int_min_address = convert.decimal_convert(\n            decimal=self.decimal, str_address=self.str_min_address)\n        self.int_max_address = convert.decimal_convert(\n            decimal=self.decimal, str_address=self.str_max_address)\n\n        self.communicate_address_length = (\n            self.int_max_address - self.int_min_address + 1)\n\n    def check_withoutskip_optional(self):\n        # SKIP OPTIONの確認 listに含まれているアドレスが必要なためスキップしない＝含まれない場合スキップ\n        optional_without_skip = Base.try_except_object(\n            self.optional, key=\"without_skip\", except_key=\"only_use_address\", exception=[])\n        self.without_skip_address = []\n        if self.cmd_cmd in const.READ_COMMAND and len(optional_without_skip) > 0:\n            for without_skip_address in optional_without_skip:\n                without_address = convert.decimal_convert(\n                    decimal=self.decimal, str_address=without_skip_address)\n                self.without_skip_address.append(\n                    without_address - self.int_min_address\n                )\n\n    def define_parameter(self, network: dict, protocol: dict, device: dict, cmd: dict, *, optional: dict = None):\n        try:\n            self.network = network\n            self.protocol = protocol\n            self.device = device\n            self.cmd = cmd\n            self.optional = optional\n\n            self.ip_address = self.network[\"ip\"]\n            try:\n                self.port = int(network[\"port\"])\n            except ValueError:\n                self.port = network[\"port\"]\n            self.cmd_cmd = self.cmd[\"cmd\"]\n            self.cmd_data = self.cmd[\"data\"]\n            self.transport_layer_protocol = self.protocol[\"transport_layer\"]\n            self.manufacture = self.protocol[\"manufacture\"]\n            self.series = self.protocol[\"series\"]\n\n            self.str_min_address = Base.try_except_object(\n                self.device, key=\"min\", except_key=\"minimum\", exception=None)\n            self.str_max_address = Base.try_except_object(\n                self.device, key=\"max\", except_key=\"maximum\", exception=None)\n        except Exception:\n            return {\n                \"error_code\": 20001,\n                \"message\": \"There are some missing parts in the settings.\"\n            }\n\n        # Optionalの確認, 応じてself.cmd_dataを変更する\n        try:\n            self.check_optional()\n        except Exception:\n            return {\n                \"error_code\": 20003,\n                \"message\": \"The option parameter setting is incorrect. \"\n            }\n        # 小数点の指定(bitの指定)があるかどうか\n        self.check_decimal_point()\n\n        # device parameterの定義\n        try:\n            self.define_device_parameter()\n        except Exception:\n            return {\n                \"error_code\": 20002,\n                \"message\": \"Parameter setting is incorrect.\"\n            }\n\n        # 指定したアドレスを含む通信以外を無視する設定の確認\n        # 要デバイスパラメータ定義\n        try:\n            self.check_withoutskip_optional()\n        except Exception:\n            return {\n                \"error_code\": 20005,\n                \"message\": \"Setting without_skip optional has error\"\n            }\n\n        try:\n            # Socket定義\n            if self.transport_layer_protocol in const.TRANSPORT_TCP:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            else:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.sock.settimeout(const.TRANSPORT_TIMEOUT)\n        except Exception:\n            return {\n                \"error_code\": 20010,\n                \"message\": \"Socket communication could not be established.\"\n            }\n\n        return {\n            \"error_code\": 0,\n            \"message\": \"success\"\n        }\n\n    def get_host_fourth_octet(self, ip_address, port):\n        def get_local_ip(ip_address, port):\n            from socket import socket, AF_INET, SOCK_DGRAM\n            s = socket(AF_INET, SOCK_DGRAM)\n            try:\n                s.connect((ip_address, port))\n                ipaddr = s.getsockname()[0]\n            except Exception:\n                ipaddr = '127.0.0.1'\n            finally:\n                s.close()\n            return ipaddr\n\n        # Windows OS\n        if os.name == \"nt\":\n            iplist = socket.gethostbyname_ex(socket.gethostname())[2]\n        # Mac OS or Linux OS\n        else:\n            iplist = []\n            address_list = psutil.net_if_addrs()\n            for _ in address_list.keys():\n                local_ip = get_local_ip(ip_address, port)\n                iplist.append(local_ip)\n\n        # logger.info(iplist)\n        same_network = ip_address.rsplit('.', 1)[0]\n        if len(iplist) > 0:\n            try:\n                client_ip = [x for x in iplist if same_network in x]\n                fourth_octet = int(client_ip[0].rsplit('.', 1)[1])\n            except Exception as e:\n                logger.debug(\n                    '{}:{}, {}'.format(\n                        sys._getframe().f_code.co_name, e, 'No connection found. Please check your communication settings.'))\n                fourth_octet = int(iplist[0].rsplit('.', 1)[1])\n        else:\n            fourth_octet = None\n        return fourth_octet\n\n    def generate_node_telegram(self):\n        if self.transport_layer_protocol in const.TRANSPORT_TCP:\n            header = [0x46, 0x49, 0x4E, 0x53]\n            length = [0x00, 0x00, 0x00, 0x0C]\n            tcp_command = [0x00, 0x00, 0x00, 0x00]\n            error_code = [0x00, 0x00, 0x00, 0x00]\n            client_node = [0x00, 0x00, 0x00, 0x00]\n            node_telegram = (\n                header + length + tcp_command + error_code + client_node\n            )\n            binary = b\"\"\n            for x in node_telegram:\n                binary += struct.pack(\"B\", x)\n            self.node_telegram = binary\n\n    def send_node_telegram(self):\n        self.client_node = None\n        self.server_node = None\n        self.generate_node_telegram()\n        try:\n            self.sock.connect((self.ip_address, self.port))\n            self.sock.send(bytes(self.node_telegram))\n            recv_node = self.sock.recv(1024).hex()\n        except socket.error as e:\n            logger.warning(e)\n            self.node_ecode = 10060\n            self.node_error_message = str(e)\n        else:\n            node_ecode1 = recv_node[16:24]\n            node_ecode2 = recv_node[24:32]\n\n            # Node error handling.\n            if int(node_ecode1, 16) not in [1, 64, 128]:\n                self.node_ecode = 30098\n                self.node_error_message = \"node ecode1: {}\".format(\n                    node_ecode1)\n            elif int(node_ecode2, 16) not in [0, 64, 128]:\n                self.node_ecode = 30099\n                self.node_error_message = \"node ecode2: {}\".format(\n                    node_ecode2)\n            else:\n                self.client_node = int(\"0x\" + recv_node[32:40], 16)\n                self.server_node = int(\"0x\" + recv_node[40:48], 16)\n                self.node_ecode = 0\n                self.node_error_message = \"node success\"\n\n        return {\n            \"error_code\": self.node_ecode,\n            \"message\": self.node_error_message,\n            \"client_node\": self.client_node,\n            \"server_node\": self.server_node,\n        }\n\n    def read_command(self):\n        cmd_data = []\n        access_data_length = []\n        first_address = []\n\n        _segment = [\n            x for x in range(0, self.communicate_address_length, self.max_communicate_address_length)]\n        _segment.append(self.communicate_address_length)\n        for i_segment in range(len(_segment)):\n            try:\n                min_segment = _segment[i_segment]\n                max_segment = _segment[i_segment + 1]\n            except Exception:\n                break\n            else:\n                _segment_cmd_data = list(range(min_segment, max_segment))\n                # Skip addressのチェック(without skipが存在し、かつsegmentと重複していないものをSkip扱いとする)\n                if len(self.without_skip_address) > 0 and not (set(_segment_cmd_data) & set(self.without_skip_address)):\n                    self.skip_address_index.append(i_segment)\n\n                self.segment_length.append(len(_segment_cmd_data))\n\n                _access_data_length = format(len(_segment_cmd_data), \"04x\")\n                if self.point_index is None:\n                    _min_ad = format(self.int_min_address + min_segment, \"04x\")\n                    if self.endian in const.ENDIAN_BIG:\n                        access_data_length.append(\n                            [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                        _first_address = [int(x, 16) for x in list(\n                            re.findall(\"..\", _min_ad))]\n                    else:\n                        access_data_length.append([int(x, 16) for x in list(\n                            reversed(list(re.findall(\"..\", _access_data_length))))])\n                        _first_address = [int(x, 16) for x in list(\n                            reversed(list(re.findall(\"..\", _min_ad))))]\n                    _first_address.append(0)\n                # TODO\n                else:\n                    _, quotient, remainder = convert.each_convert(\n                        self.decimal, self.int_min_address + min_segment)\n                    padded_quotient = quotient.rjust(4, \"0\")\n                    padded_remainder = remainder.rjust(2, \"0\")\n                    padded = list(re.findall(\"..\", padded_quotient)\n                                  ) + [padded_remainder]\n\n                    if self.endian in const.ENDIAN_BIG:\n                        access_data_length.append(\n                            [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                        _first_address = [\n                            int(x, 16) for x in padded]\n                    else:\n                        access_data_length.append([int(x, 16) for x in list(\n                            reversed(list(re.findall(\"..\", _access_data_length))))])\n                        _first_address = [\n                            int(x, 16) for x in list(reversed(padded))]\n\n                first_address.append(_first_address)\n\n        return {\n            \"cmd_data\": cmd_data,\n            \"access_data_length\": access_data_length,\n            \"first_address\": first_address,\n        }\n\n    def write_string(self, data):\n        _cmd_data = []\n\n        if isinstance(data, list) is True:\n            _data = \"\".join(data)\n        else:\n            _data = data\n\n        _data_list = [format(ord(x), \"02x\") for x in list(_data)]\n\n        it = iter(_data_list)\n        for _a, _b in itertools.zip_longest(it, it, fillvalue=\"00\"):\n            _cmd_data.append([int(_b, 16), int(_a, 16)])\n\n        _length, _mod = divmod(len(_data), 2)\n        _length += _mod\n        return _cmd_data, _length\n\n    def write_word(self, data: list):\n        _cmd_data = []\n        for i in range(len(data)):\n            # positive/negative judgment\n            if data[i] >= 0:\n                _data = format(data[i], \"04x\")\n            else:\n                _data = format(\n                    data[i] & 0xffff, '04x')\n\n            it = iter(_data)\n            for _a, _b, _c, _d in zip(it, it, it, it):\n                if self.endian in const.ENDIAN_BIG:\n                    _cmd_data.append(\n                        [int(_a + _b, 16), int(_c + _d, 16)])\n                else:\n                    _cmd_data.append(\n                        [int(_c + _d, 16), int(_a + _b, 16)])\n        _length = len(_cmd_data)\n        return _cmd_data, _length\n\n    def write_bit(self, data: list):\n        _cmd_data = []\n        if self.point_index is None:\n            _data = [format(x, \"01x\") for x in data]\n            it = iter(_data)\n            for _a, _b in itertools.zip_longest(it, it, fillvalue=\"0\"):\n                _cmd_data.append(\n                    [int(_a + _b, 16)])\n            _length = len(_cmd_data) * 2\n        else:\n            _cmd_data.append(data)\n            _length = len(data)\n        return _cmd_data, _length\n\n    # TODO\n    def write_command(self):\n        # Ex: W1.00 ~ W1.05 [1,1,0,0,1,0]\n        # a = b\"\\x46\\x49\\x4E\\x53\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x80\\x00\\x02\\x00\\x01\\x00\\x00\\xef\\x00\\x19\\x01\\x02\\x31\\x00\\x00\\x01\\x00\\x06\\x01\\x01\\x00\\x00\\x01\\x00\"\n        # Ex: W1 ~ W5 [1,1,0,0,1,0]\n        # a = b\"\\x46\\x49\\x4e\\x53\\x00\\x00\\x00\\x26\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x80\\x00\\x02\\x00\\x01\\x00\\x00\\xef\\x00\\x19\\x01\\x02\\xb1\\x00\\x01\\x00\\x00\\x06\\x00\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\"\n\n        cmd_data = []\n        access_data_length = []\n        first_address = []\n\n        _segment = [\n            x for x in range(0, self.communicate_address_length, self.max_communicate_address_length)]\n        _segment.append(self.communicate_address_length)\n        for i_segment in range(len(_segment)):\n            try:\n                min_segment = _segment[i_segment]\n                max_segment = _segment[i_segment + 1]\n            except Exception:\n                break\n            else:\n                _length = 0\n                _segment_cmd_data = self.cmd_data[min_segment: max_segment]\n                _cmd_data = []\n                # Word devices\n                if self.bit_identify in const.WORD_DEVICE:\n                    # Writing of character strings.\n                    if self.string_option is True:\n                        _cmd_data, _length = self.write_string(\n                            _segment_cmd_data)\n                    # Writing of integer or boolean.\n                    else:\n                        _cmd_data, _length = self.write_word(_segment_cmd_data)\n                # TODO double device\n                elif self.bit_identify in const.DOUBLE_DEVICE:\n                    pass\n                # Bit devices\n                else:\n                    _cmd_data, _length = self.write_bit(_segment_cmd_data)\n\n                if _length > 0:\n                    cmd_data.append(_cmd_data)\n                    # _access_data_length = format(_length, \"04x\")\n                    # _min_ad = format(\n                    #     self.int_min_address + min_segment, \"04x\")\n\n                    # if self.endian in const.ENDIAN_BIG:\n                    #     access_data_length.append(\n                    #         [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                    #     _first_address = [int(x, 16) for x in list(\n                    #         re.findall(\"..\", _min_ad))]\n                    # else:\n                    #     access_data_length.append([int(x, 16) for x in list(\n                    #         reversed(list(re.findall(\"..\", _access_data_length))))])\n\n                    #     _first_address = [int(x, 16) for x in list(\n                    #         reversed(list(re.findall(\"..\", _min_ad))))]\n                    # first_address.append(_first_address)\n\n                    _access_data_length = format(_length, \"04x\")\n                    if self.point_index is None:\n                        _min_ad = format(\n                            self.int_min_address + min_segment, \"04x\")\n                        if self.endian in const.ENDIAN_BIG:\n                            access_data_length.append(\n                                [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                            _first_address = [int(x, 16) for x in list(\n                                re.findall(\"..\", _min_ad))]\n                        else:\n                            access_data_length.append([int(x, 16) for x in list(\n                                reversed(list(re.findall(\"..\", _access_data_length))))])\n                            _first_address = [int(x, 16) for x in list(\n                                reversed(list(re.findall(\"..\", _min_ad))))]\n                        _first_address.append(0)\n                    # TODO\n                    else:\n                        _, quotient, remainder = convert.each_convert(\n                            self.decimal, self.int_min_address + min_segment)\n                        padded_quotient = quotient.rjust(4, \"0\")\n                        padded_remainder = remainder.rjust(2, \"0\")\n                        padded = list(re.findall(\n                            \"..\", padded_quotient)) + [padded_remainder]\n\n                        if self.endian in const.ENDIAN_BIG:\n                            access_data_length.append(\n                                [int(x, 16) for x in list(re.findall(\"..\", _access_data_length))])\n                            _first_address = [\n                                int(x, 16) for x in padded]\n                        else:\n                            access_data_length.append([int(x, 16) for x in list(\n                                reversed(list(re.findall(\"..\", _access_data_length))))])\n                            _first_address = [\n                                int(x, 16) for x in list(reversed(padded))]\n\n                    first_address.append(_first_address)\n\n        return {\n            \"cmd_data\": cmd_data,\n            \"access_data_length\": access_data_length,\n            \"first_address\": first_address,\n        }\n\n    def generate_telegram(self) -> list:\n        self.skip_address_index = []\n\n        if self.transport_layer_protocol in const.TRANSPORT_TCP:\n            header = [0x46, 0x49, 0x4E, 0x53]\n            tcp_command = [0x00, 0x00, 0x00, 0x02]\n            error_code = [0x00, 0x00, 0x00, 0x00]\n            node_data = self.send_node_telegram()\n            if node_data[\"error_code\"] == 0:\n                da1 = [node_data[\"server_node\"]]\n                sa1 = [node_data[\"client_node\"]]\n            else:\n                return node_data\n        elif self.transport_layer_protocol in const.TRANSPORT_UDP:\n            header = []\n            tcp_command = []\n            error_code = []\n            client_ip = self.get_host_fourth_octet(self.ip_address, self.port)\n            # client_ip = 52\n            da1 = [0x00]\n            sa1 = [client_ip]\n\n        # Bit7=1:fixed value, Bit6=0:command, Bit0=0:need response\n        # icf = [0x00]\n        icf = [0x80]\n        rsv = [0x00]\n        # Number of allowable bridge passes.\n        # Basically 0x02, 0x07: When using network crossings up to 8 layers.\n        gct = [0x02]\n        # Destination network address.\n        # 0x00: Same network, 0x01~0x7F: Destination network\n        dna = [0x00]\n        da2 = [0x00]\n        sna = [0x00]\n        sa2 = [0x00]\n        self.sid = random.randrange(0, 255, 1)\n        sid = [self.sid]\n\n        device_code = self.device_code\n\n        if self.cmd_cmd in const.READ_COMMAND:\n            command = [0x01, 0x01]\n            command_data = self.read_command()\n        else:\n            # TODO\n            command = [0x01, 0x02]\n            command_data = self.write_command()\n\n        arr_cmd_data = command_data[\"cmd_data\"]\n        arr_access_data_length = command_data[\"access_data_length\"]\n        arr_first_address = command_data[\"first_address\"]\n        for i in range(len(arr_access_data_length)):\n            try:\n                cmd_data = list(\n                    (itertools.chain.from_iterable(arr_cmd_data[i])))\n            except Exception:\n                cmd_data = []\n            access_data_length = arr_access_data_length[i]\n            first_address = arr_first_address[i]\n\n            if self.transport_layer_protocol in const.TRANSPORT_TCP:\n                length_count = len(tcp_command + error_code + icf + rsv + gct + dna + da1 + da2 + sna + sa1 +\n                                   sa2 + sid + command + device_code + first_address + access_data_length + cmd_data)\n\n                _length = [int(x, 16) for x in list(\n                    re.findall(\"..\", format(length_count, \"08x\")))]\n            else:\n                _length = []\n\n            if self.endian in const.ENDIAN_BIG:\n                length = _length\n            else:\n                length = list(reversed(_length))\n\n        _data = (\n            header + length + tcp_command + error_code +\n            icf + rsv + gct + dna + da1 + da2 + sna + sa1 + sa2 + sid +\n            command + device_code + first_address + access_data_length + cmd_data\n        )\n\n        _binary = b\"\"\n        for x in _data:\n            _binary += struct.pack(\"B\", x)\n        self.telegram_data.append(_binary)\n        self.access_data_length = access_data_length\n        return {\n            \"error_code\": 0,\n            \"message\": \"SUCCESS\",\n            \"data\": self.telegram_data,\n            \"check\": self.sid\n        }\n\n    def send_telegram(self, *, telegram_data=None, skip_address_index=None) -> dict:\n        some_send_data = []\n        some_recv_data = []\n        some_err_code = []\n        some_err_message = []\n        recv_data = \"\"\n        if telegram_data is None:\n            telegram_data = self.telegram_data\n        elif isinstance(telegram_data, str):\n            telegram_data = [telegram_data]\n\n        if skip_address_index is None:\n            try:\n                skip_address_index = self.skip_address_index\n            except Exception:\n                skip_address_index = []\n        else:\n            skip_address_index = []\n\n        # Connection\n        try:\n            if self.transport_layer_protocol in const.TRANSPORT_UDP:\n                self.sock.connect((self.ip_address, self.port))\n            # else:\n            #     self.sock.connect((self.ip_address, self.port))\n        except socket.error as e:\n            if e.errno is None:\n                some_err_code.append(10060)\n            else:\n                some_err_code.append(e.errno)\n            some_err_message.append(str(e))\n        else:\n            for index, telegram in enumerate(telegram_data):\n                _recv = None\n                if len(skip_address_index) > 0 and index in skip_address_index:\n                    _recv = \"skip\"\n                    _err_code = 0\n                    _err_message = \"SKIP\"\n                    recv_data += \"0000\" * self.segment_length[index]\n                else:\n                    _err_code = 9999\n                    _err_message = \"\"\n                    # 再送処理\n                    for i in range(const.RETRY_COUNT):\n                        logger.debug(\"send: {}\".format(telegram))\n\n                        # Send data\n                        self.sock.send(bytes(telegram))\n                        try:\n                            # Recieved data.\n                            _recv = self.sock.recv(1024).hex()\n                            logger.debug(\"recv: {}\".format(_recv))\n                        except socket.timeout as e:\n                            # WSAETIMEDOUT\n                            _err_code = 10060\n                            _err_message = str(e)\n                        except socket.herror as e:\n                            # WSAECONNREFUSED\n                            _err_code = 10061\n                            _err_message = str(e)\n                        except socket.gaierror as e:\n                            _err_code = 11001\n                            _err_message = str(e)\n                        except socket.error as e:\n                            _err_code = 10065\n                            _err_message = str(e)\n                        else:\n                            # エラーコードを取得\n                            try:\n                                if self.transport_layer_protocol in const.TRANSPORT_UDP:\n                                    ecode = (\n                                        _recv[\n                                            self.prefix_byte - 4: self.prefix_byte - 2\n                                        ] +\n                                        _recv[\n                                            self.prefix_byte - 2: self.prefix_byte\n                                        ]\n                                    )\n                                    # Bit7, Bit8はPLC本体の異常(バッテリ異常など)のため無視\n                                    if int(ecode, 16) not in [0, 64, 128]:\n                                        _err_code = ecode\n                                    else:\n                                        _err_code = 0\n                                elif self.transport_layer_protocol in const.TRANSPORT_TCP:\n                                    conn_ecode1 = _recv[16:24]\n                                    conn_ecode2 = _recv[24:32]\n                                    ecode = _recv[\n                                        self.prefix_byte - 4: self.prefix_byte\n                                    ]\n                                    if int(conn_ecode1, 16) not in [2, 64, 128] and int(conn_ecode2, 16) not in [0, 64, 128]:\n                                        ecode = conn_ecode2 + ',' + conn_ecode2\n                                        _err_code = ecode if _err_code in [\n                                            0, 9999] else _err_code\n                                    elif int(ecode, 16) not in [0, 64, 128]:\n                                        ecode = (\n                                            _recv[\n                                                self.prefix_byte - 4: self.prefix_byte - 2\n                                            ] +\n                                            _recv[\n                                                self.prefix_byte - 2: self.prefix_byte\n                                            ]\n                                        )\n                                        _err_code = ecode if _err_code in [\n                                            0, 9999] else _err_code\n                                    else:\n                                        _err_code = 0\n\n                                logger.debug(\"Error Code:{}\".format(ecode))\n\n                                # エラーコードのチェック\n                                # error code 0x00 is Success. others is Error.\n                                if _err_code == 0:\n                                    # 送受信のidチェック\n                                    try:\n                                        recv_sid = int(\n                                            _recv[self.prefix_byte - 10: self.prefix_byte - 8], 16)\n                                        if recv_sid == self.sid:\n                                            _error_message = \"SUCCESS\"\n                                            _err_code = 0\n                                            break\n                                        else:\n                                            _err_code = 221 if _err_code in [\n                                                0, 9999] else _err_code\n                                            _error_message = \"SID for sending and receiving are different.\" if _err_message == \"\" else _err_message\n                                    except Exception as e:\n                                        _err_code = 222 if _err_code in [\n                                            0, 9999] else _err_code\n                                        _error_message = str(\n                                            e) if _err_message == \"\" else _err_message\n                            except Exception as e:\n                                _err_code = 9999 if _err_code in [\n                                    0, 9999] else _err_code\n                                _err_message = str(\n                                    e) if _err_message == \"\" else _err_message\n                    else:\n                        logger.debug(\"Retry count: {}\".format(i + 1))\n                        some_err_code.append(_err_code)\n                        some_err_message.append(_err_message)\n                        break\n\n                    recv_data += _recv[self.prefix_byte:]\n\n                some_send_data.append(telegram)\n                some_recv_data.append(_recv)\n                some_err_code.append(_err_code)\n                some_err_message.append(_err_message)\n\n        try:\n            some_send_data = [x.hex() for x in some_send_data]\n        except Exception:\n            pass\n\n        self.recv_data = recv_data\n        return {\n            \"recv_data\": recv_data,\n            \"error_code\": max(some_err_code),\n            \"some_send\": some_send_data,\n            \"some_recv\": some_recv_data,\n            \"some_err_code\": some_err_code,\n            \"some_err_message\": some_err_message,\n        }\n\n    # 文字列に変換\n    @staticmethod\n    def convert_ascii_string(data: str, *, endian=\"\") -> str:\n        _string_data = []\n\n        if len(data) <= 2:\n            # Asciiは0x00~0x1Fは制御文字のため文字列としてはNullと扱う\n            _1st_str = chr(int(data[:2], 16)) if int(\n                data[:2], 16) >= 20 else \"\"\n            _string_data.append(_1st_str)\n        else:\n            # Asciiは0x00~0x1Fは制御文字のため文字列としてはNullと扱う\n            if endian in const.ENDIAN_BIG:\n                _1st_str = chr(int(data[2:], 16)) if int(\n                    data[2:], 16) >= 20 else \"\"\n                _2nd_str = chr(int(data[:2], 16)) if int(\n                    data[:2], 16) >= 20 else \"\"\n            else:\n                _1st_str = chr(int(data[:2], 16)) if int(\n                    data[:2], 16) >= 20 else \"\"\n                _2nd_str = chr(int(data[2:], 16)) if int(\n                    data[2:], 16) >= 20 else \"\"\n            _string_data.append(_1st_str)\n            _string_data.append(_2nd_str)\n\n        return \"\".join(_string_data)\n\n    def devide_received(self, *, recv_data=None):\n        if self.cmd_cmd in const.WRITE_COMMAND:\n            return []\n        else:\n            if recv_data is None:\n                _devide_data = self.recv_data\n            else:\n                _devide_data = recv_data\n            _devide = []\n            _word = 4\n            _byte = 2\n            _bit = 1\n\n            _count = 0\n            if self.bit_identify in const.BIT_DEVICE:\n                for i in range(0, len(_devide_data), _byte):\n                    if len(_devide_data[i: i + _byte]) < _byte:\n                        _data = _devide_data[i: i + _byte] + (\"0\" * _byte)\n                    else:\n                        _data = _devide_data[i: i + _byte]\n\n                    if self.endian in const.ENDIAN_LITTLE:\n                        _data = _data[_bit:] + _data[:_bit]\n\n                    _devide.append(int(_data, 16))\n\n            elif self.bit_identify in const.WORD_DEVICE:\n                for i in range(0, len(_devide_data), _word):\n                    if len(_devide_data[i: i + _word]) < _word:\n                        _data = _devide_data[i: i + _word] + (\"0\" * _word)\n                    else:\n                        _data = _devide_data[i: i + _word]\n\n                    if self.endian in const.ENDIAN_LITTLE:\n                        _data = _data[_byte:] + _data[:_byte]\n\n                    # 文字列として返答\n                    if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                        # [0x00, 0x00]で区切り文字。それ以降はバッファが含まれる可能性があるので無視する\n                        if _data == \"0000\":\n                            break\n                        else:\n                            _string_data = self.convert_ascii_string(\n                                _data, endian=self.endian)\n                            _devide.append(_string_data)\n\n                    # wordデバイスをbitとして使用している場合の返答\n                    elif self.bit_identify in const.WORD_DEVICE and self.point_index is not None:\n                        _bit_data = list(\n                            reversed([int(x, 16) for x in list(format(int(_data, 16), \"016b\"))]))\n                        if _count == 0 and self.communicate_address_length - 1 == 0:\n                            _min_bit = int(\n                                self.str_min_address.rsplit(\".\", 1)[-1], 16)\n                            _max_bit = int(\n                                self.str_max_address.rsplit(\".\", 1)[-1], 16)\n                            _devide.extend(_bit_data[_min_bit:_max_bit])\n                        elif _count == 0:\n                            _min_bit = int(\n                                self.str_min_address.rsplit(\".\", 1)[-1], 16)\n                            _devide.extend(_bit_data[_min_bit:])\n                        elif _count == self.communicate_address_length - 1:\n                            _max_bit = int(\n                                self.str_max_address.rsplit(\".\", 1)[-1], 16)\n                            _devide.extend(_bit_data[:_max_bit])\n                        else:\n                            _devide.extend(_bit_data)\n\n                    else:\n                        _devide.append(int(_data, 16))\n                    _count += 1\n\n            # 文字列の場合、結合してtextで返答\n            if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                _devide = \"\".join(_devide)\n\n            return _devide\n\n\ndef _main(network: dict, protocol: dict, device: dict, cmd: dict, *, optional=None):\n    connection = Connection()\n    defines = connection.define_parameter(\n        network, protocol, device, cmd, optional=optional)\n\n    if defines[\"error_code\"] != 0:\n        logger.warning(defines)\n        result = {\n            \"extract\": \"\",\n            \"send\": \"\",\n            \"receive\": \"\",\n            \"error_code\": defines[\"error_code\"],\n            \"message\": defines[\"message\"]\n        }\n    else:\n        send_data = connection.generate_telegram()\n        logger.debug(\"send_data: {}\".format(send_data))\n        if send_data[\"error_code\"] != 0:\n            return {\n                \"extract\": [],\n                \"send\": [],\n                \"receive\": [],\n                \"error_code\": send_data[\"error_code\"]\n            }\n        else:\n            receive_data = connection.send_telegram()\n            logger.debug(\"receive: {}\".format(receive_data))\n\n            devided_data = connection.devide_received()\n            logger.debug(\"devide: {}\".format(devided_data))\n            error_code = receive_data[\"error_code\"]\n            result = {\n                \"extract\": devided_data,\n                \"send\": receive_data[\"some_send\"],\n                \"receive\": receive_data[\"recv_data\"],\n                \"error_code\": error_code,\n                \"some_receive\": receive_data[\"some_recv\"],\n                \"some_error_code\": receive_data[\"some_err_code\"],\n                \"some_error_message\": receive_data[\"some_err_message\"],\n            }\n    try:\n        del connection\n    except Exception:\n        pass\n    return result\n\n\nif __name__ == \"__main__\":\n    # オムロン\n    network = {\"ip\": \"192.168.250.1\", \"port\": 9600}\n    protocol = {\"manufacture\": \"omron\", \"series\": \"nj\",\n                \"protocol\": \"fins\", \"transport_layer\": \"udp\", \"point_index\": None, }\n    # device = {\"device\": \"WR\", \"min\": \"1\", \"max\": \"5\"}\n    # device = {\"device\": \"WR\", \"min\": \"1\", \"max\": \"1.10\"}\n    # device = {\"device\": \"DM\", \"min\": \"5850\", \"max\": \"5860\"}\n    # device = {\"device\": \"DM\", \"min\": \"5854\", \"max\": \"5857\"}\n    device = {\"device\": \"DM\", \"min\": \"2000\", \"max\": \"2010\"}\n    cmd = {\"cmd\": \"read\", \"data\": [], \"option\": \"\"}\n    # cmd = {\"cmd\": \"write\", \"data\": [1, 1, 1, 1, 1, 1], \"option\": \"\"}\n    # cmd = {\"cmd\": \"write\", \"data\": [222, 333, 444, 555], \"option\": \"\"}\n    # cmd = {\"cmd\": \"write\", \"data\": [\"abcde\"], \"option\": \"\"}\n    optional = {\n        # \"without_skip\": [\"503\", \"1001\"],\n        \"data_type\": \"string\",\n\n        # TODO\n        # \"data_type\": \"time\",  # read: 0701, write: 0702\n        # \"data_type\": \"cycletime\",  # read: 0620(min, max, average)\n        # \"data_type\": \"unit_status\",  # read: 0601\n        # \"data_type\": \"alert\",  # read: 2102\n        # \"data_type\": \"parameter_area\",  # read: 0201, write: 0202\n        # \"data_type\": \"program_area\",  # read: 0306, write: 0307\n        # \"data_type\": \"filename\",  # read: 2201, rename: 2208\n        # \"data_type\": \"file_area\",  # read: 2202, write: 2203, delete: 2205, copy: 2207\n    }\n\n    result = _main(\n        network=network,\n        protocol=protocol,\n        device=device,\n        cmd=cmd,\n        optional=optional\n    )\n    logger.info(result)\n    logger.info(\"=================================\")\n    # device = {\"device\": \"DM\", \"min\": \"5854.00\", \"max\": \"5860.00\"}\n    # cmd = {\"cmd\": \"read\", \"data\": [], \"option\": \"\"}\n\n    # result = _main(\n    #     network=network,\n    #     protocol=protocol,\n    #     device=device,\n    #     cmd=cmd,\n    #     optional=optional\n    # )\n    # logger.info(result)",
        "__devices.py": "\nfrom pydantic import BaseModel\nimport psutil\n\n\nclass Device(BaseModel):\n    symbol: str = \"DM\"\n    name: str = \"Data memory\"\n    notation: str = \"10\"\n    binary: int = 0x82\n    offset: int = 0\n    unit: str = \"word\"\n\n\ndevices = [\n    # CHANNEL(WORD) data type\n    {\n        \"symbol\": \"CIO\",\n        \"name\": \"Channel I/O\",\n        \"binary\": 0xB0\n    },\n    {\n        \"symbol\": \"WR\",\n        \"name\": \"Internal auxiliary relay\",\n        \"binary\": 0xB1\n    },\n    {\n        \"symbol\": \"HR\",\n        \"name\": \"Holding relay\",\n        \"binary\": 0xB2\n    },\n    {\n        \"symbol\": \"AR\",\n        \"name\": \"Special auxiliary relay\",\n        \"binary\": 0xB3\n    },\n    {\n        \"symbol\": \"TIM\",\n        \"name\": \"Special auxiliary relay\",\n        \"binary\": 0xB3\n    },\n    {\n        \"symbol\": \"CNT\",\n        \"name\": \"Special auxiliary relay\",\n        \"binary\": 0xB3,\n        \"offset\": 32768\n    },\n    {\n        \"symbol\": \"AR\",\n        \"name\": \"Special auxiliary relay\",\n        \"binary\": 0xB3\n    },\n    {\n        \"symbol\": \"AR\",\n        \"name\": \"Special auxiliary relay\",\n        \"binary\": 0xB3\n    },\n\n\n]\n\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\localfile": {
        "main.py": "\nimport re\nimport io\nimport os\nimport glob\nimport pathlib\nfrom pydantic import BaseModel\nfrom typing import Pattern\nfrom itertools import groupby\nfrom operator import itemgetter\nimport platform\nimport polars\nimport datetime\n\n\nconst_share_name = \"\"\nconst_path_name = \"/vast/seasv2/data\"\n\n\ndef try_except(data: dict, key: str, *, exception=None):\n    try:\n        return data[key]\n    except Exception:\n        return exception\n\n\ndef get_filename_objects(*, path_name=\"/\", pattern=\".*\\\\.(csv|CSV)\"):\n    _path = pathlib.Path(path_name)\n    filelist = [p for p in _path.glob('**/*') if re.search(pattern, str(p))]\n\n    fileobjects = []\n    for _filename in filelist:\n        last_write_time = os.path.getmtime(_filename)\n        filename = str(_filename).replace(\"\\\\\", \"/\").split(\"/\")[-1]\n        fileobjects.append({\n            \"filename\": filename,\n            \"last_write_time\": last_write_time\n        })\n    return fileobjects\n\n\ndef get_csv_data(agg_data: dict, *, strage: list = [], mode: str = \"diff\", path_change: bool = False):\n    flg_getdata = False\n\n    if path_change is True:\n        share_name = try_except(agg_data, key=\"share_name\", exception=None)\n        path_name = try_except(agg_data, key=\"path\", exception=\"/\")\n    else:\n        share_name = const_share_name\n        path_name = const_path_name\n    reg_filename = try_except(agg_data, key=\"regex_filename\", exception=\".*.csv\")\n    group_name = share_name + path_name + reg_filename\n\n    _fileobjs = get_filename_objects(path_name=path_name)\n    fileobjs = [x for x in _fileobjs if re.findall(reg_filename, x[\"filename\"]) != []]\n\n    if fileobjs != []:\n        latest_fileobj = max(fileobjs, key=lambda x: x[\"last_write_time\"])\n        filename = latest_fileobj[\"filename\"]\n\n        strage_fileobj = next((item for item in strage if item[\"group\"] == group_name), None)\n        if strage_fileobj is None:\n            strage.append({\"group\": group_name, \"filename\": filename})\n\n        print(f\"========== MODE: {mode}, Strage: {strage}\")\n        if mode == \"diff\":\n            # ファイル名かファイルサイズが異なる場合データ取得\n            pre_filename = try_except(strage_fileobj, key=\"filename\")\n            print(f\"===== {pre_filename}, {filename}\")\n            if pre_filename != filename:\n                flg_getdata = True\n                strage = [{**item, \"filename\": filename} if item[\"group\"] == group_name else item for item in strage]\n            else:\n                pass\n        else:\n            flg_getdata = True\n            strage = [{**item, \"filename\": filename} if item[\"group\"] == group_name else item for item in strage]\n\n        print(f\"FLAG: {flg_getdata}\")\n        if flg_getdata is True:\n            # カンマ区切りとタブ区切りの両対応\n            # タブ区切りで読み取った時にColumnsが1以下の場合にカンマ区切りで再読出し\n            csv_data = polars.read_csv(path_name + \"/\" + latest_fileobj[\"filename\"], encoding=\"utf8\", has_header=True, separator=\"\\t\")\n            if len(csv_data.columns) <= 1:\n                csv_data = polars.read_csv(path_name + \"/\" + latest_fileobj[\"filename\"], encoding=\"utf8\", has_header=True, separator=\",\")\n\n            err = 0\n            message = \"success\"\n        else:\n            csv_data = None\n            err = 9999\n            message = \"skip\"\n    else:\n        csv_data = None\n        err = 10000\n        message = \"no file\"\n\n    result = {\n        \"data\": csv_data,\n        \"strage\": strage,\n        \"error\": err,\n        \"message\": message\n    }\n    print(f\"====== RESULT: {result}\")\n    return result\n\n\ndef main(configure: dict, *, strage: list = []):\n    conf_data = try_except(configure, key=\"data\")\n\n    # Sort data by the keys we want to group by\n    sorted_data = sorted(conf_data, key=itemgetter('share_name', 'path', 'regex_filename'))\n\n    # Group by 'share_name', 'path', 'regex_filename'\n    grouped_data = [\n        list(group) for _, group in groupby(sorted_data, key=itemgetter('share_name', 'path', 'regex_filename'))\n    ]\n\n    for datas in grouped_data:\n        result = get_csv_data(datas[0], strage=strage, mode=\"diff\")\n        result_data = try_except(result, key=\"data\")\n\n        # エラーコードが0 = SUCCESS or 9999 = SKIP以外の時、エラーコードを出力\n        if result[\"error\"] in [0, 9999] and result_data is not None:\n            error_info = None\n\n            if result[\"error\"] == 0:\n                for data in datas:\n                    column_name = try_except(data, key=\"column_name\")\n                    if column_name:\n                        column = next((col for col in result_data.columns if col.lower().replace(\" \", \"\") == column_name.lower().replace(\" \", \"\")), None)\n                        if column:\n                            last_row = result_data.filter(result_data[column].is_not_null()).tail(1)\n\n                            # datetimeの値を取得\n                            datetime_value = last_row[\"datetime\"][0] if \"datetime\" in last_row.columns else None\n\n                            # dateとtimeの値を取得し結合\n                            date_value = last_row[\"date\"][0] if \"date\" in last_row.columns else \"\"\n                            time_value = last_row[\"time\"][0] if \"time\" in last_row.columns else \"\"\n                            combined_date_time = f\"{date_value} {time_value}\".strip()\n\n                            # yyyy/mm/ddとhh:mm:ssの値を取得し結合\n                            date_str_ymd_slash = last_row[\"yyyy/mm/dd\"][0] if \"yyyy/mm/dd\" in last_row.columns else \"\"\n                            date_str_ymd_hyphen = last_row[\"yyyy-mm-dd\"][0] if \"yyyy-mm-dd\" in last_row.columns else \"\"\n                            date_str_mdy_slash = last_row[\"mm/dd/yyyy\"][0] if \"mm/dd/yyyy\" in last_row.columns else \"\"\n                            date_str_mdy_hyphen = last_row[\"mm-dd-yyyy\"][0] if \"mm-dd-yyyy\" in last_row.columns else \"\"\n                            date_str_dmy_slash = last_row[\"dd/mm/yyyy\"][0] if \"dd/mm/yyyy\" in last_row.columns else \"\"\n                            date_str_dmy_hyphen = last_row[\"dd-mm-yyyy\"][0] if \"dd-mm-yyyy\" in last_row.columns else \"\"\n                            time_str = last_row[\"hh:mm:ss\"][0] if \"hh:mm:ss\" in last_row.columns else \"\"\n                            date_str = date_str_ymd_slash or date_str_ymd_hyphen or date_str_mdy_slash or date_str_mdy_hyphen or date_str_dmy_slash or date_str_dmy_hyphen\n                            combined_date_time_str = f\"{date_str} {time_str}\".strip()\n\n                            # 値が存在する方のみ返す\n                            timestamp = ((\n                                datetime_value or combined_date_time or combined_date_time_str\n                            ).replace(\"/\", \"-\") or datetime.datetime.now().replace(microsecond=0))\n\n                            data[\"response\"] = last_row[column][0]\n                            data[\"response_datetime\"] = timestamp\n\n        else:\n            error_info = [{\n                \"code\": result[\"error\"],\n                \"message\": \"Not find file\"\n            }]\n\n    data_list = [item for sublist in grouped_data for item in sublist]\n    return {\n        \"data_list\": data_list,\n        \"error\": error_info,\n        \"strage\": strage\n    }\n\n\nif __name__ == \"__main__\":\n\n    configure = {\n        'network': {'ip_address': \"localhost\", 'port': None},\n        'controller': {\n            'type': 'PC', 'manufacturer': 'Microsoft', 'series': 'Windows10', 'protocol': 'LocalFolder',\n            'attributes': {\"Connection_waittime\": 20}\n        },\n        'data': [\n            {\n                'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 5,\n                'datatype': 'Input', 'record_table': 't_record_count', 'method': 'datafile',\n                'path': '/vast/seasv2/data',\n                # 'path': 'C:/Develop/DockerImage/VAST/VAST-DB/app/vast/seasv2/data',\n                'share_name': 'share', 'column_name': 'input', 'regex_filename': '20.*_SUS_1.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            # {\n            #     'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 6,\n            #     'datatype': 'Output', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n            #     'share_name': 'share', 'column_name': 'output', 'regex_filename': '20.*_SUS_1.csv',\n            #     'trigger': None, 'item': None, 'is_valid': True\n            # },\n            # {\n            #     'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 7,\n            #     'datatype': 'Cycle time', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n            #     'share_name': 'share', 'column_name': 'cycletime', 'regex_filename': '20.*_SUS_1.csv',\n            #     'trigger': None, 'item': None, 'is_valid': True\n            # },\n            # {\n            #     'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 8,\n            #     'datatype': 'Product Model', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n            #     'share_name': 'share', 'column_name': 'Model', 'regex_filename': '20.*_SUS_1.csv',\n            #     'trigger': None, 'item': None, 'is_valid': True\n            # },\n            {\n                'machine_id': 5, 'machine_no': 'ddd', 'controller_connection_id': 5, 'data_location_id': 9,\n                'datatype': 'Input', 'record_table': 't_record_count', 'method': 'datafile',\n                'path': '/vast/seasv2/data',\n                # 'path': 'C:/Develop/DockerImage/VAST/VAST-DB/app/vast/seasv2/data',\n                'share_name': 'share', 'column_name': 'input', 'regex_filename': '20.*_SUS_2.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            # {\n            #     'machine_id': 5, 'machine_no': 'ddd', 'controller_connection_id': 5, 'data_location_id': 10,\n            #     'datatype': 'Output', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n            #     'share_name': 'share', 'column_name': 'output', 'regex_filename': '20.*_SUS_2.csv',\n            #     'trigger': None, 'item': None, 'is_valid': True\n            # },\n        ]\n    }\n\n    strage = []\n\n    result = main(configure=configure, strage=strage)\n    print(result)\n\n\n\n\n\n\n\n\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\modbus": {
        "main.py": "from pymodbus.client.sync import ModbusTcpClient\n# try:\n#     from . import logger\n# except Exception:\n#     import logger\n\n# logger = logger.get_module_logger(__name__)\n\n\ndef lower_check(str):\n    try:\n        return str.lower()\n    except Exception:\n        return str\n\n\ndef try_int(numeric_str):\n    try:\n        return int(numeric_str)\n    except Exception:\n        return int(numeric_str, 16)\n\n\ndef datasize_length(device, cmd):\n    if not cmd[\"data\"]:\n        datalength = try_int(device[\"max\"]) - try_int(device[\"min\"])\n    else:\n        datalength = len(cmd[\"data\"])\n    return datalength\n\n\ndef main(network: dict, protocol: dict, device: dict, cmd: dict, *, optional={}):\n    datalength = datasize_length(device=device, cmd=cmd)\n    min = try_int(device[\"min\"])\n    response = {}\n    try:\n        unit = network[\"unit\"]\n    except Exception:\n        unit = 0\n    # connection\n    try:\n        client = ModbusTcpClient(network[\"ip\"], port=network[\"port\"])\n        client.connect()\n    except Exception as e:\n        print(\"Connect Error: {}\".format(str(e)))\n    else:\n        # Read Command Process\n        if lower_check(cmd[\"cmd\"]) in [\"read\", \"r\"]:\n            return_array = []\n            try:\n                # Read Coil\n                if lower_check(device[\"device\"]) in [\"coils\", \"coil\", \"c\", \"do\", \"01\", \"1\"]:\n                    rr_do = client.read_coils(min, datalength, unit=unit)\n                    return_array = rr_do.bits\n                # Read Input Status\n                elif lower_check(device[\"device\"]) in [\"discreteinput\", \"discrete_input\", \"discrete input\", \"input\", \"status\", \"is\", \"di\", \"02\", \"2\"]:\n                    rr_di = client.read_discrete_inputs(\n                        min, datalength, unit=unit)\n                    return_array = rr_di.bits\n                # Read Holding Register\n                elif lower_check(device[\"device\"]) in [\"holdingregisters\", \"holding_registers\", \"holding registers\", \"holdingregister\", \"holding_register\", \"holding register\", \"hr\", \"ai\", \"03\", \"3\"]:\n                    rr_ai = client.read_holding_registers(\n                        min, datalength, unit=unit)\n                    return_array = rr_ai.registers\n                # Read Input Register\n                elif lower_check(device[\"device\"]) in [\"inputregisters\", \"input_registers\", \"input registers\", \"inputregister\", \"input_register\", \"input register\", \"ir\", \"ao\", \"04\", \"4\"]:\n                    rr_ao = client.read_input_registers(\n                        min, datalength, unit=unit)\n                    return_array = rr_ao.registers\n\n                # # Diagnostics\n                # elif lower_check(device[\"device\"]) in [\"diagnostics\", \"08\", \"8\"]:\n                #     pass\n                # # Read Event Counter\n                # elif lower_check(device[\"device\"]) in [\"event_counter\", \"11\", \"b\"]:\n                #     pass\n                # # Read Event Log\n                # elif lower_check(device[\"device\"]) in [\"event_counter\", \"12\", \"c\"]:\n                #     pass\n\n                else:\n                    raise Exception(\n                        \"The specified parameter is incorrect. Please check the setting.\")\n            except Exception as e:\n                # logger.warning(\"Modbus error: {}\".format(str(e)))\n                return_array = []\n                error_code = 10000\n                message = str(e)\n            else:\n                error_code = 0\n                message = \"success\"\n            finally:\n                client.close()\n                response = {\n                    \"send_binaly\": \"\",\n                    \"response\": \"\",\n                    \"exists_data\": return_array,\n                    \"error_code\": error_code,\n                    \"message\": message\n                }\n\n        # Write Command Process\n        elif cmd[\"cmd\"] in [\"write\", \"WRITE\", \"Write\", \"w\", \"W\"]:\n            try:\n                # Write Coil\n                if lower_check(device[\"device\"]) in [\"coils\", \"coil\", \"c\", \"do\", \"05\", \"5\"]:\n                    if len(cmd[\"data\"]) == 1:\n                        rq_do = client.write_coil(min, cmd[\"data\"][0])\n                    else:\n                        rq_do = client.write_coil(min, cmd[\"data\"])\n                    return_array = rq_do\n                # Write Holding Register\n                elif lower_check(device[\"device\"]) in [\"holdingregisters\", \"holding_registers\", \"holding registers\", \"holdingregister\", \"holding_register\", \"holding register\", \"ai\", \"06\", \"6\"]:\n                    if len(cmd[\"data\"]) == 1:\n                        rq_ai = client.write_registers(min, cmd[\"data\"][0])\n                    else:\n                        rq_ai = client.write_registers(min, cmd[\"data\"])\n                    return_array = rq_ai\n                else:\n                    raise Exception(\n                        \"The specified parameter is incorrect. Please check the setting.\")\n            except Exception as e:\n                # logger.warning(\"Modbus error: {}\".format(str(e)))\n                return_array = []\n                error_code = 10000\n                message = str(e)\n            else:\n                error_code = 0\n                message = \"success\"\n            finally:\n                client.close()\n                response = {\n                    \"send_binaly\": \"\",\n                    \"response\": \"\",\n                    \"exists_data\": return_array,\n                    \"error_code\": error_code,\n                    \"message\": message\n                }\n    finally:\n        # print(response)\n        return response\n\n\ndef _main(configure):\n    ip_address = configure[\"network\"][\"ip_address\"]\n    port = configure[\"network\"][\"\"]\n    # connection\n    try:\n        client = ModbusTcpClient(ip_address, port=port)\n        client.connect()\n    except Exception as e:\n        print(\"Connect Error: {}\".format(str(e)))\n    else:\n        # TODO Readのみ\n\n        # UNITは基本的に0\n        unit = 0\n\n        datas = configure[\"data\"]\n        for data in datas:\n            data_unit = data[\"data_unit\"]\n            if data_unit in [\"integer\"]:\n                data_length = 4\n\n\n        return_array = []\n        # Read Coil\n        # if lower_check(device[\"device\"]) in [\"coils\", \"coil\", \"c\", \"do\", \"01\", \"1\"]:\n        #     rr_do = client.read_coils(min, datalength, unit=unit)\n        #     return_array = rr_do.bits\n        # # Read Input Status\n        # elif lower_check(device[\"device\"]) in [\"discreteinput\", \"discrete_input\", \"discrete input\", \"input\", \"status\", \"is\", \"di\", \"02\", \"2\"]:\n        #     rr_di = client.read_discrete_inputs(\n        #         min, datalength, unit=unit)\n        #     return_array = rr_di.bits\n        # Read Holding Register\n        # elif lower_check(device[\"device\"]) in [\"holdingregisters\", \"holding_registers\", \"holding registers\", \"holdingregister\", \"holding_register\", \"holding register\", \"hr\", \"ai\", \"03\", \"3\"]:\n            rr_ai = client.read_holding_registers(\n                min, datalength, unit=unit)\n            return_array = rr_ai.registers\n        # # Read Input Register\n        # elif lower_check(device[\"device\"]) in [\"inputregisters\", \"input_registers\", \"input registers\", \"inputregister\", \"input_register\", \"input register\", \"ir\", \"ao\", \"04\", \"4\"]:\n        #     rr_ao = client.read_input_registers(\n        #         min, datalength, unit=unit)\n        #     return_array = rr_ao.registers\n\n\n\nif __name__ == \"__main__\":\n    network = {\"ip\": \"192.168.16.112\", \"port\": 502, \"unit\": 0}\n    # network = {\"ip\": \"192.168.16.73\", \"port\": 502}\n    protocol = {\"manufacture\": \"fanuc\", \"series\": \"nj\",\n                \"protocol\": \"modbus\", \"transport_layer\": \"tcp\", \"period_index\": None, }\n    device = {\"device\": \"HOLDING_REGISTERS\", \"min\": \"0\", \"max\": \"10\"}\n    cmd = {\"cmd\": \"read\", \"data\": [], \"option\": \"\"}\n    optional = {}\n    response = main(\n        network=network,\n        protocol=protocol,\n        device=device,\n        cmd=cmd,\n        optional=optional\n    )\n\n    print(response)\n\n    configure = {\n        'network': {'ip_address': '192.168.250.39', 'port': 9600},\n        'controller': {'type': 'PLC', 'manufacturer': 'Mitsubishi Electric', 'series': 'MELSEC iQ-R', 'protocol': 'SLMP/TCP', 'attributes': {}},\n        'data': [\n            {\n                'execute': 'read',\n                'machine_id': 1,\n                'datatype': 'Input',\n                'device': 'HOLDING_REGISTERS', 'address': 0,\n                'data_unit': 'integer',\n                'trigger': None, 'item': None\n            },\n            {\n                'execute': 'read',\n                'machine_id': 1,\n                'datatype': 'Input',\n                'device': 'HOLDING_REGISTERS', 'address': 10,\n                'data_unit': 'integer',\n                'trigger': None, 'item': None\n            },\n        ]\n    }\n\n\n    \"\"\"\n        HOLDING_REGISTERS: ['10', 0x00, 'w'],\n        # INPUT_REGISTERS: ['10', 0x00, 'w'],\n        # DISCRETE_INPUT: ['10', 0x00, 'b'],\n        # COILS: ['10', 0x00, 'b'],\n\n    \"\"\"\n\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\mtlinki": {
        "CommandResult.txt": "[\"__Collector_Setting\",\n\"svFiles.files\",\n\"L1_Setting\",\n\"LdapWork\",\n\"Tag_Setting\",\n\"FileUploadSchedule\",\n\"MacroVariableHistory\",\n\"TotalExternalDevicePowerConsumption_Hour\",\n\"System_Setting\",\n\"Process_Exclusion\",\n\"Asset_OnlineInfoWebName\",\n\"sessions\",\n\"ReportSchedule\",\n\"__IntegrationServer_Setting\",\n\"Collector_Setting\",\n\"FileTransfer_FTPClientSharedData\",\n\"IPCHistory\",\n\"Program_History\",\n\"Layout_Setting\",\n\"Log_Login\",\n\"Auth_Setting\",\n\"__Layout_Setting\",\n\"Current_TailCursor_ID\",\n\"IntegrationServer_Setting\",\n\"TimeSeriesCsvSchedule\",\n\"Alarm_History\",\n\"TotalExternalDevicePowerConsumption_Month\",\n\"Maintenance_History\",\n\"LdapServer_Setting\",\n\"DBDataDelete\",\n\"__PowerConsumptionSetting\",\n\"SystemDiagnosis_PC\",\n\"Asset_System_Cooperation\",\n\"Tag_Pool\",\n\"__SignalMailSetting\",\n\"__L0Asset_Setting\",\n\"Asset_OnlineInfo\",\n\"L1_Pool\",\n\"__Asset_OnlineInfoWebName\",\n\"L0_Setting\",\n\"PowerConsumption_Month\",\n\"L1_Setting_Deleted\",\n\"AxisConfiguration\",\n\"__DBDataDelete\",\n\"__Tag_Setting\",\n\"system.js\",\n\"__E_MailServer_Setting\",\n\"PowerConsumption_Setting\",\n\"Operation_History\",\n\"Variable_History_CNC\",\n\"MaintenanceDataAggregationHistory\",\n\"__TimeSeriesCsvManual\",\n\"SystemDiagnosis_Machine\",\n\"L1_Pool_Opened\",\n\"L1Signal_Pool\",\n\"fs.files\",\n\"L1Signal_Pool_Active\",\n\"Operator_History\",\n\"ExporterWork\",\n\"License\",\n\"fs.chunks\",\n\"Operator_History_Active\",\n\"__FileUploadSchedule\",\n\"__LDAP\",\n\"__Role\",\n\"__System\",\n\"Tag_Pool_Active\",\n\"__ReportSchedule\",\n\"__User\",\n\"WorkContents_History\",\n\"__TimeSeriesCsvSchedule\",\n\"User_Setting\",\n\"svFiles.chunks\",\n\"ProductPlan_History\",\n\"ErrorInfo_Capped\",\n\"__AlarmMailSetting\",\n\"PowerConsumption_Hour\",\n\"ProductResult_History\",\n\"L1Signal_Pool_Capped\",\n\"ProductResult_History_Active\"]\n\n\n\n\n{\nProductResult_History_Active: [\n(\"_id\": ObjectId(\"660b6314cc6b3e2988772b8c\"),\n\"L1Name\": \"MNC-779\",\n\"productname\": \"D01_CF1,2_CP_EMW01 23001\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 51, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"productresult\": 0,\n\"productresult_accumulate\": 80,\n\"resultflag\": True,\n\"productserialnumber\": None}\n]\n,\nOperator_History_Active:\n[{\"_id\": ObjectId(\"660b62cacc6b3e2988771ff8\"),\n\"L1Name\": \"MNC-782\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"OperatorID\",\n\"value\": None,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}]\n\nL1_Pool_Opened:\n[{\"_id\": ObjectId(\"660b6329cc6b3e2988772ede\"),\n\"L1Name\": \"MNC-785\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None\n},\n{\"_id\": ObjectId(\"660b6329cc6b3e2988772edf\"),\n\"L1Name\": \"MNC-786\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None},\n{\"_id\": ObjectId(\"660b6329cc6b3e2988772ee0\"),\n\"L1Name\": \"MNC-787\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"660b6329cc6b3e2988772ee1\"),\n\"L1Name\": \"MNC-779\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"660b6329cc6b3e2988772ee2\"),\n\"L1Name\": \"MNC-780\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"660b6329cc6b3e2988772ee3\"),\n\"L1Name\": \"MNC-781\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"660b6329cc6b3e2988772ee4\"),\n\"L1Name\": \"MNC-782\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"660b6329cc6b3e2988772ee5\"),\n\"L1Name\": \"MNC-783\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"660b6329cc6b3e2988772ee6\"),\n\"L1Name\": \"MNC-784\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"condition\",\n\"value\": \"DISCONNECT\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}]\n\nL1Signal_Pool\n[{\"_id\": ObjectId(\"661f99dacc6b3e32d851d52c\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 43),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43, 53, 500000),\n\"timespan\": 53.5,\n\"signalname\": \"ServoTemp_2_path1_MNC-827\",\n\"value\": 59.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f99dacc6b3e32d851d50a\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 42),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43, 53, 500000),\n\"timespan\": 113.5,\n\"signalname\": \"ServoTemp_0_path1_MNC-827\",\n\"value\": 33.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f99dacc6b3e32d851d52d\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 42),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43, 53, 500000),\n\"timespan\": 113.5,\n\"signalname\": \"PulseCoderTemp_2_path1_MNC-827\",\n\"value\": 60.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f99a4cc6b3e32d851cd20\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 40),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43),\n\"timespan\": 180.0,\n\"signalname\": \"ServoTemp_2_path1_MNC-827\",\n\"value\": 60.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f98f0cc6b3e32d851ca68\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 38),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 40),\n\"timespan\": 120.0,\n\"signalname\": \"ServoTemp_2_path1_MNC-827\",\n\"value\": 61.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f9968cc6b3e32d851cc48\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 38),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 42),\n\"timespan\": 240.0,\n\"signalname\": \"ServoTemp_0_path1_MNC-827\",\n\"value\": 34.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f9968cc6b3e32d851cc49\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 38),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 42),\n\"timespan\": 240.0,\n\"signalname\": \"PulseCoderTemp_2_path1_MNC-827\",\n\"value\": 61.0,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f99dacc6b3e32d851d500\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 38),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43, 53, 500000),\n\"timespan\": 353.5,\n\"signalname\": \"CncFan1Status_path1_MNC-827\",\n\"value\": \"NORMAL\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f99dacc6b3e32d851d501\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 38),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43, 53, 500000),\n\"timespan\": 353.5,\n\"signalname\": \"CncFan2Status_path1_MNC-827\",\n\"value\": \"NORMAL\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}, {\"_id\": ObjectId(\"661f99dacc6b3e32d851d502\"),\n\"L1Name\": \"MNC-827\",\n\"updatedate\": datetime.datetime(2024, 4, 17, 9, 38),\n\"enddate\": datetime.datetime(2024, 4, 17, 9, 43, 53, 500000),\n\"timespan\": 353.5,\n\"signalname\": \"CncFan3Status_path1_MNC-827\",\n\"value\": \"NON\",\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}]\n\nL1Signal_Pool_Active\n{\"_id\": ObjectId(\"660b6329cc6b3e2988772edc\"),\n\"L1Name\": \"MNC-784\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"RadFan2SpindleAmpStatus_0_path1_MNC-784\",\n\"value\": None,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None},\n{\"_id\": ObjectId(\"660b6329cc6b3e2988772edd\"),\n\"L1Name\": \"MNC-784\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"Disconnect_MNC-784\",\n\"value\": True,\n\"filter\": None,\n\"TypeID\": None,\n\"Judge\": None,\n\"Error\": None,\n\"Warning\": None}]\n\nL1Signal_Pool_Active => signalname list\n[\"MANUAL\",\n\"WARMUP\",\n\"ProductSerialNumber\",\n\"OperatorID\",\n\"OPERATE\",\n\"DISCONNECT\",\n\"ALARM\",\n\"EMERGENCY\",\n\"SUSPEND\",\n\"STOP\",\n\"WARNING\",\n\"ProductName\",\n\"ProductResultNumber\",\n\"Mode_path1_MNC-784\",\n\"MainProgram_path1_MNC-784\",\n\"ActProgram_path1_MNC-784\",\n\"MainComment_path1_MNC-784\",\n\"ActComment_path1_MNC-784\",\n\"PartsNum_path1_MNC-784\",\n\"SigCUT_path1_MNC-784\",\n\"SigSBK_path1_MNC-784\",\n\"SigDM00_path1_MNC-784\",\n\"SigDM01_path1_MNC-784\",\n\"SigMDRN_path1_MNC-784\",\n\"CncState_path1_MNC-784\",\n\"CncWarning_path1_MNC-784\",\n\"CncFan1Status_path1_MNC-784\",\n\"CncFan2Status_path1_MNC-784\",\n\"CncFan3Status_path1_MNC-784\",\n\"CncFan4Status_path1_MNC-784\",\n\"CncBatLow_0_path1_MNC-784\",\n\"ApcBatZero_0_path1_MNC-784\",\n\"ApcBatLow_0_path1_MNC-784\",\n\"IndBatZero_0_path1_MNC-784\",\n\"SpdBatZero_0_path1_MNC-784\",\n\"SSpdBatZero_0_path1_MNC-784\",\n\"ServoTemp_0_path1_MNC-784\",\n\"PulseCoderTemp_0_path1_MNC-784\",\n\"ServoLeakResistData_0_path1_MNC-784\",\n\"InFan1SrvAmpStatus_0_path1_MNC-784\",\n\"InFan2SrvAmpStatus_0_path1_MNC-784\",\n\"RadFan1SrvAmpStatus_0_path1_MNC-784\",\n\"RadFan2SrvAmpStatus_0_path1_MNC-784\",\n\"InFan1SrvComPwStatus_0_path1_MNC-784\",\n\"InFan2SrvComPwStatus_0_path1_MNC-784\",\n\"RadFan1SrvComPwStatus_0_path1_MNC-784\",\n\"RadFan2SrvComPwStatus_0_path1_MNC-784\",\n\"CncBatLow_1_path1_MNC-784\",\n\"ApcBatZero_1_path1_MNC-784\",\n\"ApcBatLow_1_path1_MNC-784\",\n\"IndBatZero_1_path1_MNC-784\",\n\"SpdBatZero_1_path1_MNC-784\",\n\"SSpdBatZero_1_path1_MNC-784\",\n\"ServoTemp_1_path1_MNC-784\",\n\"PulseCoderTemp_1_path1_MNC-784\",\n\"ServoLeakResistData_1_path1_MNC-784\",\n\"InFan1SrvAmpStatus_1_path1_MNC-784\",\n\"InFan2SrvAmpStatus_1_path1_MNC-784\",\n\"RadFan1SrvAmpStatus_1_path1_MNC-784\",\n\"RadFan2SrvAmpStatus_1_path1_MNC-784\",\n\"InFan1SrvComPwStatus_1_path1_MNC-784\",\n\"InFan2SrvComPwStatus_1_path1_MNC-784\",\n\"RadFan1SrvComPwStatus_1_path1_MNC-784\",\n\"RadFan2SrvComPwStatus_1_path1_MNC-784\",\n\"CncBatLow_2_path1_MNC-784\",\n\"ApcBatZero_2_path1_MNC-784\",\n\"ApcBatLow_2_path1_MNC-784\",\n\"IndBatZero_2_path1_MNC-784\",\n\"SpdBatZero_2_path1_MNC-784\",\n\"SSpdBatZero_2_path1_MNC-784\",\n\"ServoTemp_2_path1_MNC-784\",\n\"PulseCoderTemp_2_path1_MNC-784\",\n\"ServoLeakResistData_2_path1_MNC-784\",\n\"InFan1SrvAmpStatus_2_path1_MNC-784\",\n\"InFan2SrvAmpStatus_2_path1_MNC-784\",\n\"RadFan1SrvAmpStatus_2_path1_MNC-784\",\n\"RadFan2SrvAmpStatus_2_path1_MNC-784\",\n\"InFan1SrvComPwStatus_2_path1_MNC-784\",\n\"InFan2SrvComPwStatus_2_path1_MNC-784\",\n\"RadFan1SrvComPwStatus_2_path1_MNC-784\",\n\"RadFan2SrvComPwStatus_2_path1_MNC-784\",\n\"SpindleTemp_0_path1_MNC-784\",\n\"SpindleLeakResistData_0_path1_MNC-784\",\n\"SpindleTotalRev1_0_path1_MNC-784\",\n\"SpindleTotalRev2_0_path1_MNC-784\",\n\"InFan1SpdlComPwStatus_0_path1_MNC-784\",\n\"InFan2SpdlComPwStatus_0_path1_MNC-784\",\n\"RadFan1SpdlComPwStatus_0_path1_MNC-784\",\n\"RadFan2SpdlComPwStatus_0_path1_MNC-784\",\n\"InFan1SpindleAmpStatus_0_path1_MNC-784\",\n\"InFan2SpindleAmpStatus_0_path1_MNC-784\",\n\"RadFan1SpindleAmpStatus_0_path1_MNC-784\",\n\"RadFan2SpindleAmpStatus_0_path1_MNC-784\",\n\"Disconnect_MNC-784\"]\n\nTag_Pool_Active\n[{\"_id\": ObjectId(\"660b62cacc6b3e2988771ffb\"),\n\"TagName\": \"CF1\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"In\",\n\"value\": None},\n{\"_id\": ObjectId(\"660b62cacc6b3e2988771ffc\"),\n\"TagName\": \"CF1\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"Out\",\n\"value\": None},\n{\"_id\": ObjectId(\"660b62cacc6b3e2988771ffd\"),\n\"TagName\": \"CF2\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"In\",\n\"value\": None},\n{\"_id\": ObjectId(\"660b62cacc6b3e2988771ffe\"),\n\"TagName\": \"CF2\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"Out\",\n\"value\": None},\n{\"_id\": ObjectId(\"660b62cacc6b3e2988771fff\"),\n\"TagName\": \"CF2_COVER\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"In\",\n\"value\": None},\n{\"_id\": ObjectId(\"660b62cacc6b3e2988772000\"),\n\"TagName\": \"CF2_COVER\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 43, 38),\n\"enddate\": None,\n\"timespan\": 0.0,\n\"signalname\": \"Out\",\n\"value\": None}]\n\nAlarm_History\n{\"_id\": ObjectId(\"660b62e7cc6b3e2988772aef\"),\n\"L1Name\": \"MNC-780\",\n\"L0Name\": \"MNC-780\",\n\"number\": \"1003\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 7),\n\"message\": \"EMERGENCY STOP.\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"level\": 4,\n\"type\": \"EX\",\n\"timespan\": 65.5},\n{\"_id\": ObjectId(\"660b62e7cc6b3e2988772af0\"),\n\"L1Name\": \"MNC-780\",\n\"L0Name\": \"MNC-780\",\n\"number\": \"1028\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 7),\n\"message\": \"OIL LEVEL IS LOWER THAN LIMIT.\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"level\": 4,\n\"type\": \"EX\",\n\"timespan\": 65.5},\n{\"_id\": ObjectId(\"660b62e7cc6b3e2988772af1\"),\n\"L1Name\": \"MNC-780\",\n\"L0Name\": \"MNC-780\",\n\"number\": \"2037\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 7),\n\"message\": \"PERIODICAL MAINTENANCE TIME.\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"level\": 1,\n\"type\": \"OPR\",\n\"timespan\": 65.5},\n{\"_id\": ObjectId(\"660b62e7cc6b3e2988772af2\"),\n\"L1Name\": \"MNC-780\",\n\"L0Name\": \"MNC-780\",\n\"number\": \"2010\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 7),\n\"message\": \"OIL LEVEL IS LOWER THAN LIMIT.\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"level\": 1,\n\"type\": \"OPR\",\n\"timespan\": 65.5},\n{\"_id\": ObjectId(\"660b6306cc6b3e2988772b39\"),\n\"L1Name\": \"MNC-785\",\n\"L0Name\": \"MNC-785\",\n\"number\": \"2001\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 38),\n\"message\": \"THE DOOR OF THE SPLASH GUARD IS OPEN\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"level\": 1,\n\"type\": \"OPR\",\n\"timespan\": 34.5},\n{\"_id\": ObjectId(\"660b6314cc6b3e2988772b8b\"),\n\"L1Name\": \"MNC-779\",\n\"L0Name\": \"MNC-779\",\n\"number\": \"2001\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 51, 500000),\n\"message\": \"THE DOOR OF THE SPLASH GUARD IS OPEN\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"level\": 1,\n\"type\": \"OPR\",\n\"timespan\": 21.0}]\n\nProgram_History\n[{\"_id\": ObjectId(\"660b62e7cc6b3e2988772ad0\"),\n\"L1Name\": \"MNC-779\",\n\"L0Name\": \"MNC-779\",\n\"path\": \"path1\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 7),\n\"mainprogflg\": False,\n\"mainprog\": \"//CNC_MEM/USER/PATH1/O5000\",\n\"runningprog\": \"//CNC_MEM/USER/PATH1/O5000\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 44, 51, 500000),\n\"timespan\": 44.5},\n{\"_id\": ObjectId(\"660b630bcc6b3e2988772b5a\"),\n\"L1Name\": \"MNC-784\",\n\"L0Name\": \"MNC-784\",\n\"path\": \"path1\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 43),\n\"mainprogflg\": True,\n\"mainprog\": \"//CNC_MEM/USER/PATH1/O4121\",\n\"runningprog\": \"//CNC_MEM/USER/PATH1/O4121\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"timespan\": 29.5},\n{\"_id\": ObjectId(\"660b630bcc6b3e2988772b5b\"),\n\"L1Name\": \"MNC-784\",\n\"L0Name\": \"MNC-784\",\n\"path\": \"path1\",\n\"updatedate\": datetime.datetime(2024, 4, 2, 1, 44, 43),\n\"mainprogflg\": False,\n\"mainprog\": \"//CNC_MEM/USER/PATH1/O4121\",\n\"runningprog\": \"//CNC_MEM/USER/PATH1/O4121\",\n\"enddate\": datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n\"timespan\": 29.5}]\n\n\nSystemDiagnosis_PC\n[{\"_id\": ObjectId(\"660cc96dcc6b3e29887773e4\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"PCType\": \"Receiver\",\n\"CPU\": 0,\n\"Memory\": 13,\n\"QueueStatus\": 1,\n\"CycleStatus\": 0,\n\"DiskStatus\": 1,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 13, 49, 14000),\n\"CacheUsedRate\": 0,\n\"CacheStatus\": 1,\n\"CacheUpdateTime\": \"2024/04/02 08:45:12.500\",\n\"ChangePoint\": None,\n\"DataINC\": 0,\n\"DBDataSize\": \"0.00\",\n\"DiskFree\": \"419.16\",\n\"DiskFreeStatus\": 1}, {\"_id\": ObjectId(\"660cc96dcc6b3e29887773e5\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"PCType\": \"Collector\",\n\"CPU\": 0,\n\"Memory\": 13,\n\"QueueStatus\": 1,\n\"CycleStatus\": 0,\n\"DiskStatus\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 13, 49, 14000),\n\"CacheUsedRate\": None,\n\"CacheStatus\": 0,\n\"CacheUpdateTime\": None,\n\"ChangePoint\": None,\n\"DataINC\": None,\n\"DBDataSize\": \"\",\n\"DiskFree\": \"\",\n\"DiskFreeStatus\": 0}]\n\n\nSystemDiagnosis_Machine\n[{\"_id\": ObjectId(\"660cc931cc6b3e29887773db\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-779\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773dc\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-780\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773dd\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-781\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773de\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-782\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773df\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-783\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773e0\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-784\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773e1\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-785\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773e2\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-786\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}, {\"_id\": ObjectId(\"660cc931cc6b3e29887773e3\"),\n\"PCName\": \"VN01-MTLINK01\",\n\"MachineName\": \"MNC-787\",\n\"Status\": 0,\n\"CycleTime\": 500,\n\"ExecuteTime\": 0,\n\"UpdateTime\": datetime.datetime(2024, 4, 3, 3, 12, 49, 12000)}]\n\nAsset_OnlineInfo\n[{\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0bbc\"),\n\"L0Name\": \"MNC-787\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"4\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0bc9\"),\n\"L0Name\": \"MNC-780\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 711000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0bd8\"),\n\"L0Name\": \"MNC-784\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0be5\"),\n\"L0Name\": \"MNC-785\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0bf2\"),\n\"L0Name\": \"MNC-779\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0bff\"),\n\"L0Name\": \"MNC-786\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893ecc6b3e11c4cf0c10\"),\n\"L0Name\": \"MNC-781\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"6601893fcc6b3e11c4cf10d7\"),\n\"L0Name\": \"MNC-782\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"3\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}, {\"_id\": ObjectId(\"66018940cc6b3e11c4cf11a1\"),\n\"L0Name\": \"MNC-783\",\n\"UpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 6, 815000),\n\"CncInfo\": [{\"name\": \"Cnc_Model\",\n\"Value\": \"Series31iB\"}, {\"name\": \"Series\",\n\"Value\": \"G404\"}, {\"name\": \"Version\",\n\"Value\": \"39.0\"}, {\"name\": \"Max_axis\",\n\"Value\": \"32\"}, {\"name\": \"Maxpath_no\",\n\"Value\": \"1\"}, {\"name\": \"Eth_type\",\n\"Value\": \"Windows CE Ethernet Server\"}, {\"name\": \"Eth_device\",\n\"Value\": \"\"}],\n\"Path\": [{\"PathInfo\": [{\"name\": \"mt_type\",\n\"Value\": \"M\"}, {\"name\": \"axes\",\n\"Value\": \"4\"}, {\"name\": \"spdl\",\n\"Value\": \"1\"}]}],\n\"CollectorUpdateDate\": datetime.datetime(2024, 4, 2, 1, 44, 5)}]\n\nMaintenanceDataAggregationHistory:\n[{\"_id\": ObjectId(\"6602771ecc6b3e38e43ab080\"),\n\"L0Name\": \"MNC-782\",\n\"receptionDate\": datetime.datetime(2024, 3, 26, 7, 19, 57, 767000),\n\"createDate\": datetime.datetime(2024, 3, 26, 7, 31, 24, 245000),\n\"option\": \"machine\",\n\"result\": 1,\n\"username\": \"kietlt\",\n\"path\": \"maintenanceData/MNC-782_20240326_141957(20240326T071957Z).zip\",\n\"status\": 2,\n\"error\": None,\n\"contents\": [{\"category\": \"alarm\",\n\"selectedData\": [{\"name\": \"alarmHistory\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"systemAlarm\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": \"\",\n\"strStat\": \"226 transfer complete\\r\\n\"}]}, {\"category\": \"asset\",\n\"selectedData\": [{\"name\": \"baseInfo\",\n\"result\": 2,\n\"errorCode\": \"2004\",\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"maintenanceInfo\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"onlineInfo\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}]}, {\"category\": \"machineData\",\n\"selectedData\": [{\"name\": \"CNCDATA_operationHistoryData\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"CNCDATA_parameter\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"CNCDATA_workpieceCoordinateSystemData\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"CNCDATA_customMacroCommonVariable\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"CNCDATA_pitchErrorCompensationData\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"CNCDATA_offsetData\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"CNCPROG\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"PMCDATA\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"SRAM\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}, {\"name\": \"FROM\",\n\"result\": 1,\n\"errorCode\": None,\n\"strErr\": None,\n\"strStat\": None}]}],\n\"pid\": 14564}]\n\n\n\n}\n\n",
        "CommandResult2.txt": "{'_id': ObjectId('661fd233cc6b3e2898af8548'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 43),\n'enddate': datetime.datetime(2024, 4, 17, 13, 44, 19, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd241cc6b3e2898af8555'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 44, 19, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 44, 32, 500000),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd290cc6b3e2898af85ac'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 44, 32, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 45, 52),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd2bacc6b3e2898af85ce'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 45, 52),\n'enddate': datetime.datetime(2024, 4, 17, 13, 46, 34, 500000),\n'timespan': 42.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd30acc6b3e2898af8622'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 46, 34, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 47, 54),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd31bcc6b3e2898af862a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 47, 54),\n'enddate': datetime.datetime(2024, 4, 17, 13, 48, 11, 500000),\n'timespan': 17.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd36bcc6b3e2898af869e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 48, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 49, 31),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd372cc6b3e2898af86ab'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 49, 31),\n'enddate': datetime.datetime(2024, 4, 17, 13, 49, 38),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd3c2cc6b3e2898af8706'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 49, 38),\n'enddate': datetime.datetime(2024, 4, 17, 13, 50, 57, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd3c9cc6b3e2898af8713'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 50, 57, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 51, 4, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd417cc6b3e2898af8781'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 51, 4, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 52, 23),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd424cc6b3e2898af878e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 52, 23),\n'enddate': datetime.datetime(2024, 4, 17, 13, 52, 36),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd474cc6b3e2898af87e3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 52, 36),\n'enddate': datetime.datetime(2024, 4, 17, 13, 53, 55, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd47bcc6b3e2898af87f0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 53, 55, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 54, 3),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd4cacc6b3e2898af885a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 54, 3),\n'enddate': datetime.datetime(2024, 4, 17, 13, 55, 22),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd4d1cc6b3e2898af8867'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 55, 22),\n'enddate': datetime.datetime(2024, 4, 17, 13, 55, 28, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd520cc6b3e2898af88be'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 55, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 56, 48),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd52ecc6b3e2898af88cb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 56, 48),\n'enddate': datetime.datetime(2024, 4, 17, 13, 57, 2, 500000),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd57dcc6b3e2898af8931'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 57, 2, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 58, 21, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd585cc6b3e2898af893e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 58, 21, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 13, 58, 29),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd5d4cc6b3e2898af899d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 58, 29),\n'enddate': datetime.datetime(2024, 4, 17, 13, 59, 48),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd5dccc6b3e2898af89aa'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 59, 48),\n'enddate': datetime.datetime(2024, 4, 17, 13, 59, 56),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd62bcc6b3e2898af8a10'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 13, 59, 56),\n'enddate': datetime.datetime(2024, 4, 17, 14, 1, 15),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd636cc6b3e2898af8a21'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 1, 15),\n'enddate': datetime.datetime(2024, 4, 17, 14, 1, 26, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd686cc6b3e2898af8a78'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 1, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 2, 45, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd68ecc6b3e2898af8a85'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 2, 45, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 2, 54),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd6ddcc6b3e2898af8ad6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 2, 54),\n'enddate': datetime.datetime(2024, 4, 17, 14, 4, 13),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd6e6cc6b3e2898af8af2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 4, 13),\n'enddate': datetime.datetime(2024, 4, 17, 14, 4, 21, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd735cc6b3e2898af8b4c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 4, 21, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 5, 41),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd749cc6b3e2898af8b54'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 5, 41),\n'enddate': datetime.datetime(2024, 4, 17, 14, 6, 1, 500000),\n'timespan': 20.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd798cc6b3e2898af8bb8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 6, 1, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 7, 20),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd7a0cc6b3e2898af8bc1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 7, 20),\n'enddate': datetime.datetime(2024, 4, 17, 14, 7, 28, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd7efcc6b3e2898af8c18'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 7, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 8, 47, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd7f8cc6b3e2898af8c21'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 8, 47, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 8, 56),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd846cc6b3e2898af8c78'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 8, 56),\n'enddate': datetime.datetime(2024, 4, 17, 14, 10, 14, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd847cc6b3e2898af8c90'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 10, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 10, 15),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd852cc6b3e2898af8c9e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 10, 15),\n'enddate': datetime.datetime(2024, 4, 17, 14, 10, 26, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd8a1cc6b3e2898af8cf3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 10, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 11, 45, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd8accc6b3e2898af8d00'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 11, 45, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 11, 56),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd8fbcc6b3e2898af8d62'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 11, 56),\n'enddate': datetime.datetime(2024, 4, 17, 14, 13, 15, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd903cc6b3e2898af8d71'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 13, 15, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 13, 22, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd952cc6b3e2898af8dc9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 13, 22, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 14, 41, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd95acc6b3e2898af8dd1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 14, 41, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 14, 49, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd9a9cc6b3e2898af8e28'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 14, 49, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 16, 9),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fd9b2cc6b3e2898af8e46'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 16, 9),\n'enddate': datetime.datetime(2024, 4, 17, 14, 16, 18),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fda01cc6b3e2898af8ea3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 16, 18),\n'enddate': datetime.datetime(2024, 4, 17, 14, 17, 37, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fda08cc6b3e2898af8eb0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 17, 37, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 17, 44),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fda57cc6b3e2898af8f05'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 17, 44),\n'enddate': datetime.datetime(2024, 4, 17, 14, 19, 3),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fda5fcc6b3e2898af8f12'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 19, 3),\n'enddate': datetime.datetime(2024, 4, 17, 14, 19, 11, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdaafcc6b3e2898af8f7c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 19, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 20, 31),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdabacc6b3e2898af8f89'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 20, 31),\n'enddate': datetime.datetime(2024, 4, 17, 14, 20, 42),\n'timespan': 11.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdb08cc6b3e2898af8fe6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 20, 42),\n'enddate': datetime.datetime(2024, 4, 17, 14, 22, 0, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdb10cc6b3e2898af8ff3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 22, 0, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 22, 8),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdb5fcc6b3e2898af9053'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 22, 8),\n'enddate': datetime.datetime(2024, 4, 17, 14, 23, 27),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdb6bcc6b3e2898af9060'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 23, 27),\n'enddate': datetime.datetime(2024, 4, 17, 14, 23, 38, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdbb9cc6b3e2898af90b4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 23, 38, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 24, 57, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdbc4cc6b3e2898af90bc'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 24, 57, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 25, 8),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdc13cc6b3e2898af9126'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 25, 8),\n'enddate': datetime.datetime(2024, 4, 17, 14, 26, 27),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdc1bcc6b3e2898af9133'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 26, 27),\n'enddate': datetime.datetime(2024, 4, 17, 14, 26, 35),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdc6acc6b3e2898af9184'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 26, 35),\n'enddate': datetime.datetime(2024, 4, 17, 14, 27, 54),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdc72cc6b3e2898af9191'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 27, 54),\n'enddate': datetime.datetime(2024, 4, 17, 14, 28, 2),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdcc2cc6b3e2898af91f3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 28, 2),\n'enddate': datetime.datetime(2024, 4, 17, 14, 29, 21, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdcd0cc6b3e2898af9200'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 29, 21, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 29, 36, 500000),\n'timespan': 15.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdd1fcc6b3e2898af9255'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 29, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 30, 55, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdd21cc6b3e2898af9262'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 30, 55, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 30, 56, 500000),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdd42cc6b3e2898af9279'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 30, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 31, 30),\n'timespan': 33.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdd91cc6b3e2898af92ce'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 31, 30),\n'enddate': datetime.datetime(2024, 4, 17, 14, 32, 49),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdda0cc6b3e2898af92db'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 32, 49),\n'enddate': datetime.datetime(2024, 4, 17, 14, 33, 4, 500000),\n'timespan': 15.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fddefcc6b3e2898af9341'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 33, 4, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 34, 23),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fddfacc6b3e2898af934e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 34, 23),\n'enddate': datetime.datetime(2024, 4, 17, 14, 34, 34, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fde4acc6b3e2898af939e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 34, 34, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 35, 54),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fde59cc6b3e2898af93a6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 35, 54),\n'enddate': datetime.datetime(2024, 4, 17, 14, 36, 9),\n'timespan': 15.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdea8cc6b3e2898af9404'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 36, 9),\n'enddate': datetime.datetime(2024, 4, 17, 14, 37, 28),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdeb2cc6b3e2898af9411'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 37, 28),\n'enddate': datetime.datetime(2024, 4, 17, 14, 37, 38, 500000),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdf01cc6b3e2898af946e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 37, 38, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 38, 57, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdf0bcc6b3e2898af947b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 38, 57, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 39, 7),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdf5bcc6b3e2898af94df'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 39, 7),\n'enddate': datetime.datetime(2024, 4, 17, 14, 40, 27),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdf6fcc6b3e2898af94ec'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 40, 27),\n'enddate': datetime.datetime(2024, 4, 17, 14, 40, 47, 500000),\n'timespan': 20.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdfbecc6b3e2898af9545'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 40, 47, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 42, 6, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fdfcacc6b3e2898af955d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 42, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 42, 18),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe019cc6b3e2898af95ac'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 42, 18),\n'enddate': datetime.datetime(2024, 4, 17, 14, 43, 37),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe026cc6b3e2898af95b9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 43, 37),\n'enddate': datetime.datetime(2024, 4, 17, 14, 43, 50),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe076cc6b3e2898af9611'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 43, 50),\n'enddate': datetime.datetime(2024, 4, 17, 14, 45, 10),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe07fcc6b3e2898af9626'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 45, 10),\n'enddate': datetime.datetime(2024, 4, 17, 14, 45, 18, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe0cdcc6b3e2898af967f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 45, 18, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 46, 37, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe0d7cc6b3e2898af968c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 46, 37, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 46, 47),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe126cc6b3e2898af96e0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 46, 47),\n'enddate': datetime.datetime(2024, 4, 17, 14, 48, 6),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe131cc6b3e2898af96f5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 48, 6),\n'enddate': datetime.datetime(2024, 4, 17, 14, 48, 17, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe180cc6b3e2898af9748'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 48, 17, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 49, 36),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe18bcc6b3e2898af9755'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 49, 36),\n'enddate': datetime.datetime(2024, 4, 17, 14, 49, 46, 500000),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe1dacc6b3e2898af97aa'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 49, 46, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 51, 5, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe1e2cc6b3e2898af97b7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 51, 5, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 51, 14),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe231cc6b3e2898af981f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 51, 14),\n'enddate': datetime.datetime(2024, 4, 17, 14, 52, 33),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe247cc6b3e2898af982c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 52, 33),\n'enddate': datetime.datetime(2024, 4, 17, 14, 52, 55),\n'timespan': 22.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe296cc6b3e2898af9883'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 52, 55),\n'enddate': datetime.datetime(2024, 4, 17, 14, 54, 14),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe2a8cc6b3e2898af98a1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 54, 14),\n'enddate': datetime.datetime(2024, 4, 17, 14, 54, 32, 500000),\n'timespan': 18.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe2f8cc6b3e2898af98fb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 54, 32, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 55, 52),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe2fecc6b3e2898af9903'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 55, 52),\n'enddate': datetime.datetime(2024, 4, 17, 14, 55, 58),\n'timespan': 6.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe34ecc6b3e2898af996b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 55, 58),\n'enddate': datetime.datetime(2024, 4, 17, 14, 57, 18),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe34ecc6b3e2898af9978'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 57, 18),\n'enddate': datetime.datetime(2024, 4, 17, 14, 57, 18, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe35ccc6b3e2898af9980'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 57, 18, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 14, 57, 32),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe3abcc6b3e2898af99db'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 57, 32),\n'enddate': datetime.datetime(2024, 4, 17, 14, 58, 51),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe6bbcc6b3e2898af9af1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 14, 58, 51),\n'enddate': datetime.datetime(2024, 4, 17, 15, 11, 55),\n'timespan': 784.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe70acc6b3e2898af9b3e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 11, 55),\n'enddate': datetime.datetime(2024, 4, 17, 15, 13, 14, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe70bcc6b3e2898af9b56'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 13, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 13, 15),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe71acc6b3e2898af9b64'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 13, 15),\n'enddate': datetime.datetime(2024, 4, 17, 15, 13, 30, 500000),\n'timespan': 15.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe769cc6b3e2898af9bc5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 13, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 14, 49),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe773cc6b3e2898af9bd2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 14, 49),\n'enddate': datetime.datetime(2024, 4, 17, 15, 14, 59, 500000),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe7c3cc6b3e2898af9c41'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 14, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 16, 19),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe7cccc6b3e2898af9c49'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 16, 19),\n'enddate': datetime.datetime(2024, 4, 17, 15, 16, 28),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe81bcc6b3e2898af9ca4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 16, 28),\n'enddate': datetime.datetime(2024, 4, 17, 15, 17, 47),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe824cc6b3e2898af9cad'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 17, 47),\n'enddate': datetime.datetime(2024, 4, 17, 15, 17, 56),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe872cc6b3e2898af9cfc'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 17, 56),\n'enddate': datetime.datetime(2024, 4, 17, 15, 19, 14, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe873cc6b3e2898af9d14'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 19, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 19, 15),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe87fcc6b3e2898af9d24'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 19, 15),\n'enddate': datetime.datetime(2024, 4, 17, 15, 19, 27, 500000),\n'timespan': 12.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe8cecc6b3e2898af9d78'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 19, 27, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 20, 46, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe8d7cc6b3e2898af9d80'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 20, 46, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 20, 55),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe926cc6b3e2898af9ddf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 20, 55),\n'enddate': datetime.datetime(2024, 4, 17, 15, 22, 14),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe92dcc6b3e2898af9e03'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 22, 14),\n'enddate': datetime.datetime(2024, 4, 17, 15, 22, 21),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe97dcc6b3e2898af9e51'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 22, 21),\n'enddate': datetime.datetime(2024, 4, 17, 15, 23, 40, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe986cc6b3e2898af9e59'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 23, 40, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 23, 50),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe9d5cc6b3e2898af9eb6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 23, 50),\n'enddate': datetime.datetime(2024, 4, 17, 15, 25, 9),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fe9dbcc6b3e2898af9eca'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 25, 9),\n'enddate': datetime.datetime(2024, 4, 17, 15, 25, 15, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fea2acc6b3e2898af9f21'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 25, 15, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 26, 34, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fea2bcc6b3e2898af9f2e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 26, 34, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 26, 35),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fea32cc6b3e2898af9f36'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 26, 35),\n'enddate': datetime.datetime(2024, 4, 17, 15, 26, 42, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fea81cc6b3e2898af9f91'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 26, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 28, 1),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fea8ccc6b3e2898af9f9e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 28, 1),\n'enddate': datetime.datetime(2024, 4, 17, 15, 28, 12, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feadbcc6b3e2898afa007'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 28, 12, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 29, 31, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feae5cc6b3e2898afa00f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 29, 31, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 29, 41),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feb34cc6b3e2898afa05c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 29, 41),\n'enddate': datetime.datetime(2024, 4, 17, 15, 31),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feb3dcc6b3e2898afa069'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 31),\n'enddate': datetime.datetime(2024, 4, 17, 15, 31, 9, 500000),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feb8ccc6b3e2898afa0d7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 31, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 32, 28, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feb8dcc6b3e2898afa0e4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 32, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 32, 29),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feb9acc6b3e2898afa0ec'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 32, 29),\n'enddate': datetime.datetime(2024, 4, 17, 15, 32, 42, 500000),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661febe9cc6b3e2898afa14f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 32, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 34, 1, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661febf3cc6b3e2898afa15c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 34, 1, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 34, 11, 500000),\n'timespan': 10.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fec42cc6b3e2898afa1c7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 34, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 35, 30, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fec4bcc6b3e2898afa1cf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 35, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 35, 39),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fec99cc6b3e2898afa21e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 35, 39),\n'enddate': datetime.datetime(2024, 4, 17, 15, 36, 57),\n'timespan': 78.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fec9acc6b3e2898afa22b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 36, 57),\n'enddate': datetime.datetime(2024, 4, 17, 15, 36, 58),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feca3cc6b3e2898afa233'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 36, 58),\n'enddate': datetime.datetime(2024, 4, 17, 15, 37, 6, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fecf1cc6b3e2898afa2a5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 37, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 38, 25),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fecf8cc6b3e2898afa2b2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 38, 25),\n'enddate': datetime.datetime(2024, 4, 17, 15, 38, 32),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fed47cc6b3e2898afa315'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 38, 32),\n'enddate': datetime.datetime(2024, 4, 17, 15, 39, 51),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fed4ecc6b3e2898afa322'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 39, 51),\n'enddate': datetime.datetime(2024, 4, 17, 15, 39, 58),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fed9ecc6b3e2898afa38f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 39, 58),\n'enddate': datetime.datetime(2024, 4, 17, 15, 41, 18),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feda8cc6b3e2898afa39d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 41, 18),\n'enddate': datetime.datetime(2024, 4, 17, 15, 41, 28),\n'timespan': 10.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fedf6cc6b3e2898afa3ec'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 41, 28),\n'enddate': datetime.datetime(2024, 4, 17, 15, 42, 46, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fedfecc6b3e2898afa3f9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 42, 46, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 42, 54),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fee4dcc6b3e2898afa44b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 42, 54),\n'enddate': datetime.datetime(2024, 4, 17, 15, 44, 13),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fee54cc6b3e2898afa468'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 44, 13),\n'enddate': datetime.datetime(2024, 4, 17, 15, 44, 19, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feea2cc6b3e2898afa4bf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 44, 19, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 45, 38),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feeafcc6b3e2898afa4cc'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 45, 38),\n'enddate': datetime.datetime(2024, 4, 17, 15, 45, 51),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661feefecc6b3e2898afa527'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 45, 51),\n'enddate': datetime.datetime(2024, 4, 17, 15, 47, 10),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fef06cc6b3e2898afa545'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 47, 10),\n'enddate': datetime.datetime(2024, 4, 17, 15, 47, 18),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fef54cc6b3e2898afa59f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 47, 18),\n'enddate': datetime.datetime(2024, 4, 17, 15, 48, 36),\n'timespan': 78.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fef5bcc6b3e2898afa5a7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 48, 36),\n'enddate': datetime.datetime(2024, 4, 17, 15, 48, 43),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fefaacc6b3e2898afa5fd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 48, 43),\n'enddate': datetime.datetime(2024, 4, 17, 15, 50, 2),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fefb7cc6b3e2898afa610'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 50, 2),\n'enddate': datetime.datetime(2024, 4, 17, 15, 50, 15, 500000),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff006cc6b3e2898afa66d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 50, 15, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 51, 34, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff00fcc6b3e2898afa67a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 51, 34, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 51, 42, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff05dcc6b3e2898afa6d5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 51, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 53, 1, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff064cc6b3e2898afa6e2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 53, 1, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 53, 8, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff0b3cc6b3e2898afa750'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 53, 8, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 54, 27, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff0c1cc6b3e2898afa75d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 54, 27, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 54, 41, 500000),\n'timespan': 14.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff111cc6b3e2898afa7b8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 54, 41, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 56, 0, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff118cc6b3e2898afa7c1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 56, 0, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 56, 7, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff166cc6b3e2898afa827'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 56, 7, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 57, 26, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff16fcc6b3e2898afa834'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 57, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 57, 34, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff1bdcc6b3e2898afa88f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 57, 34, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 58, 53, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff1cdcc6b3e2898afa89c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 58, 53, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 15, 59, 9, 500000),\n'timespan': 16.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff21ccc6b3e2898afa910'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 15, 59, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 0, 28, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff223cc6b3e2898afa91d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 0, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 0, 35),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff272cc6b3e2898afa974'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 0, 35),\n'enddate': datetime.datetime(2024, 4, 17, 16, 1, 54),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff273cc6b3e2898afa981'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 1, 54),\n'enddate': datetime.datetime(2024, 4, 17, 16, 1, 55),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff27bcc6b3e2898afa989'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 1, 55),\n'enddate': datetime.datetime(2024, 4, 17, 16, 2, 3),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff2cacc6b3e2898afa9ed'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 2, 3),\n'enddate': datetime.datetime(2024, 4, 17, 16, 3, 22, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff2cbcc6b3e2898afa9fa'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 3, 22, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 3, 23),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff2dacc6b3e2898afaa02'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 3, 23),\n'enddate': datetime.datetime(2024, 4, 17, 16, 3, 38),\n'timespan': 15.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff328cc6b3e2898afaa53'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 3, 38),\n'enddate': datetime.datetime(2024, 4, 17, 16, 4, 56, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff329cc6b3e2898afaa60'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 4, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 4, 57),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff330cc6b3e2898afaa68'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 4, 57),\n'enddate': datetime.datetime(2024, 4, 17, 16, 5, 4),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff37fcc6b3e2898afaad0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 5, 4),\n'enddate': datetime.datetime(2024, 4, 17, 16, 6, 23),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff387cc6b3e2898afaadd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 6, 23),\n'enddate': datetime.datetime(2024, 4, 17, 16, 6, 30, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff3d5cc6b3e2898afab36'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 6, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 7, 49, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff3e8cc6b3e2898afab43'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 7, 49, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 8, 7, 500000),\n'timespan': 18.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff436cc6b3e2898afabab'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 8, 7, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 9, 26, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff445cc6b3e2898afabb8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 9, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 9, 41),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff494cc6b3e2898afac09'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 9, 41),\n'enddate': datetime.datetime(2024, 4, 17, 16, 11),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff49ecc6b3e2898afac12'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 11),\n'enddate': datetime.datetime(2024, 4, 17, 16, 11, 10),\n'timespan': 10.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff4edcc6b3e2898afac80'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 11, 10),\n'enddate': datetime.datetime(2024, 4, 17, 16, 12, 28, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff4f9cc6b3e2898afac8d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 12, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 12, 41),\n'timespan': 12.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff548cc6b3e2898aface5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 12, 41),\n'enddate': datetime.datetime(2024, 4, 17, 16, 14, 0, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff551cc6b3e2898afaced'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 14, 0, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 14, 9, 500000),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff5a0cc6b3e2898afad5b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 14, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 15, 28, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff5bbcc6b3e2898afad68'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 15, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 15, 54, 500000),\n'timespan': 26.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff609cc6b3e2898afadbf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 15, 54, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 17, 13, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff616cc6b3e2898afadd9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 17, 13, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 17, 26, 500000),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff665cc6b3e2898afae39'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 17, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 18, 45),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff75ecc6b3e2898afae9b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 18, 45),\n'enddate': datetime.datetime(2024, 4, 17, 16, 22, 54),\n'timespan': 249.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff7aecc6b3e2898afaeff'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 22, 54),\n'enddate': datetime.datetime(2024, 4, 17, 16, 24, 13, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff7b7cc6b3e2898afaf1e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 24, 13, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 24, 22, 500000),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff806cc6b3e2898afaf76'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 24, 22, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 25, 42),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff810cc6b3e2898afaf7e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 25, 42),\n'enddate': datetime.datetime(2024, 4, 17, 16, 25, 52),\n'timespan': 10.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff85fcc6b3e2898afafdf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 25, 52),\n'enddate': datetime.datetime(2024, 4, 17, 16, 27, 11),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff86bcc6b3e2898afaffb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 27, 11),\n'enddate': datetime.datetime(2024, 4, 17, 16, 27, 23),\n'timespan': 12.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff8bacc6b3e2898afb058'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 27, 23),\n'enddate': datetime.datetime(2024, 4, 17, 16, 28, 42),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff8c1cc6b3e2898afb065'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 28, 42),\n'enddate': datetime.datetime(2024, 4, 17, 16, 28, 49, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff910cc6b3e2898afb0c2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 28, 49, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 30, 8, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff937cc6b3e2898afb0e4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 30, 8, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 30, 47),\n'timespan': 38.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff986cc6b3e2898afb143'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 30, 47),\n'enddate': datetime.datetime(2024, 4, 17, 16, 32, 6),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff986cc6b3e2898afb150'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 32, 6),\n'enddate': datetime.datetime(2024, 4, 17, 16, 32, 6, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff992cc6b3e2898afb16b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 32, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 32, 18),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff9e1cc6b3e2898afb1c6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 32, 18),\n'enddate': datetime.datetime(2024, 4, 17, 16, 33, 37),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ff9e8cc6b3e2898afb1d3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 33, 37),\n'enddate': datetime.datetime(2024, 4, 17, 16, 33, 44, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffa37cc6b3e2898afb230'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 33, 44, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 35, 3),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffa40cc6b3e2898afb239'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 35, 3),\n'enddate': datetime.datetime(2024, 4, 17, 16, 35, 12),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffa8fcc6b3e2898afb29f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 35, 12),\n'enddate': datetime.datetime(2024, 4, 17, 16, 36, 30, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffa98cc6b3e2898afb2ac'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 36, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 36, 40),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffae7cc6b3e2898afb305'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 36, 40),\n'enddate': datetime.datetime(2024, 4, 17, 16, 37, 59, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffae8cc6b3e2898afb312'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 37, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 38),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffaf2cc6b3e2898afb31a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 38),\n'enddate': datetime.datetime(2024, 4, 17, 16, 38, 10, 500000),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffb41cc6b3e2898afb37c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 38, 10, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 39, 29, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffb49cc6b3e2898afb385'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 39, 29, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 39, 37, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffb99cc6b3e2898afb3da'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 39, 37, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 40, 57),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffba7cc6b3e2898afb3e7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 40, 57),\n'enddate': datetime.datetime(2024, 4, 17, 16, 41, 11),\n'timespan': 14.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffbf5cc6b3e2898afb445'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 41, 11),\n'enddate': datetime.datetime(2024, 4, 17, 16, 42, 29),\n'timespan': 78.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffbf6cc6b3e2898afb452'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 42, 29),\n'enddate': datetime.datetime(2024, 4, 17, 16, 42, 30),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffccdcc6b3e2898afb493'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 42, 30),\n'enddate': datetime.datetime(2024, 4, 17, 16, 46, 5),\n'timespan': 215.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffd1ccc6b3e2898afb507'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 46, 5),\n'enddate': datetime.datetime(2024, 4, 17, 16, 47, 24),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffd33cc6b3e2898afb514'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 47, 24),\n'enddate': datetime.datetime(2024, 4, 17, 16, 47, 47),\n'timespan': 23.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffd82cc6b3e2898afb575'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 47, 47),\n'enddate': datetime.datetime(2024, 4, 17, 16, 49, 6),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffd8fcc6b3e2898afb595'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 49, 6),\n'enddate': datetime.datetime(2024, 4, 17, 16, 49, 19, 500000),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffddfcc6b3e2898afb5ed'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 49, 19, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 50, 39),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffde8cc6b3e2898afb5f5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 50, 39),\n'enddate': datetime.datetime(2024, 4, 17, 16, 50, 48),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffe37cc6b3e2898afb648'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 50, 48),\n'enddate': datetime.datetime(2024, 4, 17, 16, 52, 7),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffe3fcc6b3e2898afb660'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 52, 7),\n'enddate': datetime.datetime(2024, 4, 17, 16, 52, 15),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffe8ecc6b3e2898afb6c7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 52, 15),\n'enddate': datetime.datetime(2024, 4, 17, 16, 53, 34),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffe9ccc6b3e2898afb6d4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 53, 34),\n'enddate': datetime.datetime(2024, 4, 17, 16, 53, 48),\n'timespan': 14.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffeebcc6b3e2898afb733'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 53, 48),\n'enddate': datetime.datetime(2024, 4, 17, 16, 55, 7, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffef2cc6b3e2898afb740'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 55, 7, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 55, 14, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fff42cc6b3e2898afb7a8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 55, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 56, 33, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fff48cc6b3e2898afb7b5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 56, 33, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 56, 40),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fff97cc6b3e2898afb812'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 56, 40),\n'enddate': datetime.datetime(2024, 4, 17, 16, 57, 59, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fff98cc6b3e2898afb81f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 57, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 58),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661fffa3cc6b3e2898afb828'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 58),\n'enddate': datetime.datetime(2024, 4, 17, 16, 58, 11, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffff3cc6b3e2898afb897'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 58, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 16, 59, 31),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('661ffffbcc6b3e2898afb89f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 59, 31),\n'enddate': datetime.datetime(2024, 4, 17, 16, 59, 39, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620004acc6b3e2898afb8fc'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 16, 59, 39, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 0, 58),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200050cc6b3e2898afb909'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 0, 58),\n'enddate': datetime.datetime(2024, 4, 17, 17, 1, 4, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620009fcc6b3e2898afb96d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 1, 4, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 2, 23, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662000a0cc6b3e2898afb97a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 2, 23, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 2, 24, 500000),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662000a6cc6b3e2898afb982'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 2, 24, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 2, 30, 500000),\n'timespan': 6.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662000f6cc6b3e2898afb9dd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 2, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 3, 49, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200ba2cc6b3e2898afbd86'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 3, 49, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 49, 22),\n'timespan': 2732.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200bf1cc6b3e2898afbde3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 49, 22),\n'enddate': datetime.datetime(2024, 4, 17, 17, 50, 41),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200c55cc6b3e2898afbe1a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 50, 41),\n'enddate': datetime.datetime(2024, 4, 17, 17, 52, 21),\n'timespan': 100.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200ca4cc6b3e2898afbe7a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 52, 21),\n'enddate': datetime.datetime(2024, 4, 17, 17, 53, 40),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200cafcc6b3e2898afbe82'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 53, 40),\n'enddate': datetime.datetime(2024, 4, 17, 17, 53, 51),\n'timespan': 11.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200cfecc6b3e2898afbedd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 53, 51),\n'enddate': datetime.datetime(2024, 4, 17, 17, 55, 10),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200d59cc6b3e2898afbf12'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 55, 10),\n'enddate': datetime.datetime(2024, 4, 17, 17, 56, 41),\n'timespan': 91.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200da8cc6b3e2898afbf69'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 56, 41),\n'enddate': datetime.datetime(2024, 4, 17, 17, 58, 0, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200da9cc6b3e2898afbf76'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 58, 0, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 17, 58, 1),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200dbccc6b3e2898afbf95'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 58, 1),\n'enddate': datetime.datetime(2024, 4, 17, 17, 58, 20),\n'timespan': 19.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200e0bcc6b3e2898afbff7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 58, 20),\n'enddate': datetime.datetime(2024, 4, 17, 17, 59, 39, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200e81cc6b3e2898afc02b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 17, 59, 39, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 1, 37),\n'timespan': 117.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200ed0cc6b3e2898afc08a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 1, 37),\n'enddate': datetime.datetime(2024, 4, 17, 18, 2, 56),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200ed1cc6b3e2898afc097'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 2, 56),\n'enddate': datetime.datetime(2024, 4, 17, 18, 2, 56, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200ee6cc6b3e2898afc0b6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 2, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 3, 18, 500000),\n'timespan': 22.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200f35cc6b3e2898afc11a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 3, 18, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 4, 36, 500000),\n'timespan': 78.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200f88cc6b3e2898afc13b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 4, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 6),\n'timespan': 83.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200fd7cc6b3e2898afc1ab'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 6),\n'enddate': datetime.datetime(2024, 4, 17, 18, 7, 19),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66200ffacc6b3e2898afc1b8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 7, 19),\n'enddate': datetime.datetime(2024, 4, 17, 18, 7, 54, 500000),\n'timespan': 35.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620104acc6b3e2898afc212'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 7, 54, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 9, 13, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620109ccc6b3e2898afc238'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 9, 13, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 10, 36, 500000),\n'timespan': 83.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662010eccc6b3e2898afc293'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 10, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 11, 56),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662010eccc6b3e2898afc2a0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 11, 56),\n'enddate': datetime.datetime(2024, 4, 17, 18, 11, 56, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201132cc6b3e2898afc2bb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 11, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 13, 6, 500000),\n'timespan': 70.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201182cc6b3e2898afc325'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 13, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 14, 26),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620119acc6b3e2898afc32e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 14, 26),\n'enddate': datetime.datetime(2024, 4, 17, 18, 14, 50),\n'timespan': 24.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662011e9cc6b3e2898afc389'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 14, 50),\n'enddate': datetime.datetime(2024, 4, 17, 18, 16, 9),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620120dcc6b3e2898afc3a9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 16, 9),\n'enddate': datetime.datetime(2024, 4, 17, 18, 16, 45, 500000),\n'timespan': 36.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620125ecc6b3e2898afc403'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 16, 45, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 18, 5, 500000),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201271cc6b3e2898afc422'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 18, 5, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 18, 25),\n'timespan': 19.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662012c1cc6b3e2898afc477'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 18, 25),\n'enddate': datetime.datetime(2024, 4, 17, 18, 19, 44, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201341cc6b3e2898afc4a2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 19, 44, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 21, 53),\n'timespan': 128.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201390cc6b3e2898afc503'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 21, 53),\n'enddate': datetime.datetime(2024, 4, 17, 18, 23, 11, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620139ecc6b3e2898afc521'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 23, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 23, 26),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662013eccc6b3e2898afc57c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 23, 26),\n'enddate': datetime.datetime(2024, 4, 17, 18, 24, 44, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620144acc6b3e2898afc5a7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 24, 44, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 26, 18, 500000),\n'timespan': 94.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201499cc6b3e2898afc5fe'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 26, 18, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 27, 36, 500000),\n'timespan': 78.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620149acc6b3e2898afc60b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 27, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 27, 37, 500000),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662014a3cc6b3e2898afc613'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 27, 37, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 27, 46, 500000),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662014f3cc6b3e2898afc66f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 27, 46, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 29, 7),\n'timespan': 80.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662014fbcc6b3e2898afc682'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 29, 7),\n'enddate': datetime.datetime(2024, 4, 17, 18, 29, 15, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620154bcc6b3e2898afc6e9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 29, 15, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 30, 35),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620154bcc6b3e2898afc6f6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 30, 35),\n'enddate': datetime.datetime(2024, 4, 17, 18, 30, 35, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201585cc6b3e2898afc70f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 30, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 31, 33),\n'timespan': 57.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662015d4cc6b3e2898afc769'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 31, 33),\n'enddate': datetime.datetime(2024, 4, 17, 18, 32, 52),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662015ddcc6b3e2898afc771'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 32, 52),\n'enddate': datetime.datetime(2024, 4, 17, 18, 33, 1, 500000),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620162ccc6b3e2898afc7dd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 33, 1, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 34, 20, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201691cc6b3e2898afc7fb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 34, 20, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 36, 0, 500000),\n'timespan': 100.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662016dfcc6b3e2898afc85d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 36, 0, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 37, 19, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662016e0cc6b3e2898afc86a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 37, 19, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 37, 20),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662016f3cc6b3e2898afc872'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 37, 20),\n'enddate': datetime.datetime(2024, 4, 17, 18, 37, 38, 500000),\n'timespan': 18.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201741cc6b3e2898afc8ce'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 37, 38, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 38, 57),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662017b2cc6b3e2898afc8f4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 38, 57),\n'enddate': datetime.datetime(2024, 4, 17, 18, 40, 49, 500000),\n'timespan': 112.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201801cc6b3e2898afc94d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 40, 49, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 42, 9),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201801cc6b3e2898afc95a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 42, 9),\n'enddate': datetime.datetime(2024, 4, 17, 18, 42, 9, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201970cc6b3e2898afc9e1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 42, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 48, 16),\n'timespan': 366.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662019c0cc6b3e2898afca41'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 48, 16),\n'enddate': datetime.datetime(2024, 4, 17, 18, 49, 35, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662019d0cc6b3e2898afca49'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 49, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 49, 52, 500000),\n'timespan': 17.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201a20cc6b3e2898afcaa2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 49, 52, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 51, 11, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201a71cc6b3e2898afcacf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 51, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 52, 33, 500000),\n'timespan': 82.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201ac0cc6b3e2898afcb25'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 52, 33, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 53, 52, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201ad7cc6b3e2898afcb38'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 53, 52, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 54, 15),\n'timespan': 22.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201b26cc6b3e2898afcb93'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 54, 15),\n'enddate': datetime.datetime(2024, 4, 17, 18, 55, 33, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201b2ecc6b3e2898afcba0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 55, 33, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 55, 42, 500000),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201b7dcc6b3e2898afcbfb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 55, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 57, 1),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201b85cc6b3e2898afcc08'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 57, 1),\n'enddate': datetime.datetime(2024, 4, 17, 18, 57, 9, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201bd4cc6b3e2898afcc6c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 57, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 18, 58, 28),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201be3cc6b3e2898afcc79'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 58, 28),\n'enddate': datetime.datetime(2024, 4, 17, 18, 58, 43, 500000),\n'timespan': 15.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201c33cc6b3e2898afccd4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 18, 58, 43, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 0, 2, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201c33cc6b3e2898afcce1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 0, 2, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 0, 3),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201c39cc6b3e2898afcce9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 0, 3),\n'enddate': datetime.datetime(2024, 4, 17, 19, 0, 9),\n'timespan': 6.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201c88cc6b3e2898afcd55'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 0, 9),\n'enddate': datetime.datetime(2024, 4, 17, 19, 1, 28),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201c92cc6b3e2898afcd62'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 1, 28),\n'enddate': datetime.datetime(2024, 4, 17, 19, 1, 38),\n'timespan': 10.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201ce1cc6b3e2898afcdbf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 1, 38),\n'enddate': datetime.datetime(2024, 4, 17, 19, 2, 57),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201ceccc6b3e2898afcdcc'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 2, 57),\n'enddate': datetime.datetime(2024, 4, 17, 19, 3, 7, 500000),\n'timespan': 10.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201d3bcc6b3e2898afce36'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 3, 7, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 4, 26, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201d48cc6b3e2898afce43'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 4, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 4, 40, 500000),\n'timespan': 14.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201d97cc6b3e2898afce9e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 4, 40, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 5, 59, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201da0cc6b3e2898afceab'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 5, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 6, 7, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201defcc6b3e2898afcf13'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 6, 7, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 7, 27),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201defcc6b3e2898afcf20'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 7, 27),\n'enddate': datetime.datetime(2024, 4, 17, 19, 7, 27, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201e00cc6b3e2898afcf28'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 7, 27, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 7, 43, 500000),\n'timespan': 16.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201e4fcc6b3e2898afcf83'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 7, 43, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 9, 3),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201e56cc6b3e2898afcf90'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 9, 3),\n'enddate': datetime.datetime(2024, 4, 17, 19, 9, 10),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201ea5cc6b3e2898afcffa'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 9, 10),\n'enddate': datetime.datetime(2024, 4, 17, 19, 10, 29, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201eb1cc6b3e2898afd007'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 10, 29, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 10, 40, 500000),\n'timespan': 11.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201f00cc6b3e2898afd05a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 10, 40, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 11, 59, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201f16cc6b3e2898afd078'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 11, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 12, 22),\n'timespan': 22.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201f65cc6b3e2898afd0d3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 12, 22),\n'enddate': datetime.datetime(2024, 4, 17, 19, 13, 40, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201f6ccc6b3e2898afd0dc'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 13, 40, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 13, 48, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201fbbcc6b3e2898afd13d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 13, 48, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 15, 7),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66201fc4cc6b3e2898afd155'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 15, 7),\n'enddate': datetime.datetime(2024, 4, 17, 19, 15, 16),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202014cc6b3e2898afd1b8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 15, 16),\n'enddate': datetime.datetime(2024, 4, 17, 19, 16, 35, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620201fcc6b3e2898afd1c5'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 16, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 16, 47),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620206ecc6b3e2898afd214'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 16, 47),\n'enddate': datetime.datetime(2024, 4, 17, 19, 18, 6, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202075cc6b3e2898afd221'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 18, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 18, 13, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662020c4cc6b3e2898afd281'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 18, 13, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 19, 32, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662020c5cc6b3e2898afd28e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 19, 32, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 19, 33),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662020cccc6b3e2898afd296'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 19, 33),\n'enddate': datetime.datetime(2024, 4, 17, 19, 19, 39, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620211ccc6b3e2898afd2f0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 19, 39, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 20, 59, 500000),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620212acc6b3e2898afd2f8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 20, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 21, 14),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202178cc6b3e2898afd35e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 21, 14),\n'enddate': datetime.datetime(2024, 4, 17, 19, 22, 32, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202184cc6b3e2898afd36b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 22, 32, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 22, 44),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662021d3cc6b3e2898afd3c0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 22, 44),\n'enddate': datetime.datetime(2024, 4, 17, 19, 24, 3),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662021d9cc6b3e2898afd3cd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 24, 3),\n'enddate': datetime.datetime(2024, 4, 17, 19, 24, 9),\n'timespan': 6.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202228cc6b3e2898afd435'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 24, 9),\n'enddate': datetime.datetime(2024, 4, 17, 19, 25, 28, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202229cc6b3e2898afd442'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 25, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 25, 29),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620223acc6b3e2898afd44a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 25, 29),\n'enddate': datetime.datetime(2024, 4, 17, 19, 25, 46, 500000),\n'timespan': 17.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202289cc6b3e2898afd4a3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 25, 46, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 27, 5, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202290cc6b3e2898afd4ac'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 27, 5, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 27, 12),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662022dfcc6b3e2898afd518'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 27, 12),\n'enddate': datetime.datetime(2024, 4, 17, 19, 28, 31),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662022e6cc6b3e2898afd525'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 28, 31),\n'enddate': datetime.datetime(2024, 4, 17, 19, 28, 38),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202335cc6b3e2898afd582'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 28, 38),\n'enddate': datetime.datetime(2024, 4, 17, 19, 29, 57),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202343cc6b3e2898afd58f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 29, 57),\n'enddate': datetime.datetime(2024, 4, 17, 19, 30, 11, 500000),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202392cc6b3e2898afd5fb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 30, 11, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 31, 30, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620239bcc6b3e2898afd604'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 31, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 31, 39),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662023eacc6b3e2898afd661'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 31, 39),\n'enddate': datetime.datetime(2024, 4, 17, 19, 32, 58, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662023f1cc6b3e2898afd66e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 32, 58, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 33, 5, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202440cc6b3e2898afd6de'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 33, 5, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 34, 24, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620244dcc6b3e2898afd6eb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 34, 24, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 34, 37),\n'timespan': 12.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620249ccc6b3e2898afd73e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 34, 37),\n'enddate': datetime.datetime(2024, 4, 17, 19, 35, 56),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662024a4cc6b3e2898afd74b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 35, 56),\n'enddate': datetime.datetime(2024, 4, 17, 19, 36, 3, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662024f3cc6b3e2898afd7b1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 36, 3, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 37, 23),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662024facc6b3e2898afd7be'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 37, 23),\n'enddate': datetime.datetime(2024, 4, 17, 19, 37, 30, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620254acc6b3e2898afd818'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 37, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 38, 50, 500000),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202563cc6b3e2898afd82b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 38, 50, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 39, 15, 500000),\n'timespan': 25.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662025b2cc6b3e2898afd882'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 39, 15, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 40, 34),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662025bacc6b3e2898afd88b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 40, 34),\n'enddate': datetime.datetime(2024, 4, 17, 19, 40, 42, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202609cc6b3e2898afd8e1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 40, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 42, 1, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202611cc6b3e2898afd8e9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 42, 1, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 42, 8, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620265fcc6b3e2898afd950'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 42, 8, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 43, 27),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202671cc6b3e2898afd958'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 43, 27),\n'enddate': datetime.datetime(2024, 4, 17, 19, 43, 45),\n'timespan': 18.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662026c0cc6b3e2898afd9ad'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 43, 45),\n'enddate': datetime.datetime(2024, 4, 17, 19, 45, 4),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202713cc6b3e2898afd9d4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 45, 4),\n'enddate': datetime.datetime(2024, 4, 17, 19, 46, 26, 500000),\n'timespan': 82.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202762cc6b3e2898afda2d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 46, 26, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 47, 46),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202779cc6b3e2898afda3a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 47, 46),\n'enddate': datetime.datetime(2024, 4, 17, 19, 48, 8, 500000),\n'timespan': 22.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662027c7cc6b3e2898afdaa4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 48, 8, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 49, 27, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662027d0cc6b3e2898afdab1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 49, 27, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 49, 36),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620281fcc6b3e2898afdb07'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 49, 36),\n'enddate': datetime.datetime(2024, 4, 17, 19, 50, 55, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202826cc6b3e2898afdb0f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 50, 55, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 51, 2, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202875cc6b3e2898afdb81'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 51, 2, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 52, 21),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202884cc6b3e2898afdb8e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 52, 21),\n'enddate': datetime.datetime(2024, 4, 17, 19, 52, 36, 500000),\n'timespan': 15.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662028d3cc6b3e2898afdbeb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 52, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 53, 55),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662028dbcc6b3e2898afdbf8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 53, 55),\n'enddate': datetime.datetime(2024, 4, 17, 19, 54, 3),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620292acc6b3e2898afdc65'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 54, 3),\n'enddate': datetime.datetime(2024, 4, 17, 19, 55, 22, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202931cc6b3e2898afdc6d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 55, 22, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 55, 29),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202981cc6b3e2898afdcca'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 55, 29),\n'enddate': datetime.datetime(2024, 4, 17, 19, 56, 48, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202990cc6b3e2898afdcd7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 56, 48, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 57, 4, 500000),\n'timespan': 16.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662029dfcc6b3e2898afdd3b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 57, 4, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 58, 23, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662029e0cc6b3e2898afdd48'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 58, 23, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 58, 24),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662029e6cc6b3e2898afdd50'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 58, 24),\n'enddate': datetime.datetime(2024, 4, 17, 19, 58, 30, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202a36cc6b3e2898afdda9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 58, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 59, 49, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202a3dcc6b3e2898afddb6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 59, 49, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 19, 59, 56, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202a8bcc6b3e2898afde1c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 19, 59, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 1, 15),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202a99cc6b3e2898afde29'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 1, 15),\n'enddate': datetime.datetime(2024, 4, 17, 20, 1, 29, 500000),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202ae9cc6b3e2898afde82'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 1, 29, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 2, 49),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202af0cc6b3e2898afde8f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 2, 49),\n'enddate': datetime.datetime(2024, 4, 17, 20, 2, 56),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202b3ecc6b3e2898afdeee'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 2, 56),\n'enddate': datetime.datetime(2024, 4, 17, 20, 4, 14, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202b47cc6b3e2898afdf08'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 4, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 4, 23),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202b96cc6b3e2898afdf5e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 4, 23),\n'enddate': datetime.datetime(2024, 4, 17, 20, 5, 42),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202ba3cc6b3e2898afdf66'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 5, 42),\n'enddate': datetime.datetime(2024, 4, 17, 20, 5, 55, 500000),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202bf3cc6b3e2898afdfc6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 5, 55, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 7, 15),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202bf3cc6b3e2898afdfd3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 7, 15),\n'enddate': datetime.datetime(2024, 4, 17, 20, 7, 15, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202bfbcc6b3e2898afdfdd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 7, 15, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 7, 23),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202c4acc6b3e2898afe034'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 7, 23),\n'enddate': datetime.datetime(2024, 4, 17, 20, 8, 41, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202c51cc6b3e2898afe041'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 8, 41, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 8, 48, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202ca0cc6b3e2898afe0a0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 8, 48, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 10, 8),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202caecc6b3e2898afe0ba'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 10, 8),\n'enddate': datetime.datetime(2024, 4, 17, 20, 10, 21, 500000),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202cfdcc6b3e2898afe111'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 10, 21, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 11, 40, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202cfdcc6b3e2898afe11e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 11, 40, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 11, 41),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202d03cc6b3e2898afe126'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 11, 41),\n'enddate': datetime.datetime(2024, 4, 17, 20, 11, 47),\n'timespan': 6.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202d53cc6b3e2898afe17d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 11, 47),\n'enddate': datetime.datetime(2024, 4, 17, 20, 13, 6, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202d5acc6b3e2898afe18a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 13, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 13, 14),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202da9cc6b3e2898afe202'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 13, 14),\n'enddate': datetime.datetime(2024, 4, 17, 20, 14, 33),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202dbacc6b3e2898afe20f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 14, 33),\n'enddate': datetime.datetime(2024, 4, 17, 20, 14, 50),\n'timespan': 17.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202e09cc6b3e2898afe26e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 14, 50),\n'enddate': datetime.datetime(2024, 4, 17, 20, 16, 9),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202e12cc6b3e2898afe287'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 16, 9),\n'enddate': datetime.datetime(2024, 4, 17, 20, 16, 18, 500000),\n'timespan': 9.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202e61cc6b3e2898afe2dd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 16, 18, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 17, 36, 500000),\n'timespan': 78.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202e67cc6b3e2898afe2ea'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 17, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 17, 43),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202eb7cc6b3e2898afe344'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 17, 43),\n'enddate': datetime.datetime(2024, 4, 17, 20, 19, 3),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202ed8cc6b3e2898afe35b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 19, 3),\n'enddate': datetime.datetime(2024, 4, 17, 20, 19, 35, 500000),\n'timespan': 32.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202f26cc6b3e2898afe3b0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 19, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 20, 54, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202f2fcc6b3e2898afe3bd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 20, 54, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 21, 3),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202f7ecc6b3e2898afe42b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 21, 3),\n'enddate': datetime.datetime(2024, 4, 17, 20, 22, 22),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202f84cc6b3e2898afe438'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 22, 22),\n'enddate': datetime.datetime(2024, 4, 17, 20, 22, 28, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202fd4cc6b3e2898afe495'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 22, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 23, 47, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66202fe9cc6b3e2898afe4a2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 23, 47, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 24, 9),\n'timespan': 21.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203038cc6b3e2898afe50d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 24, 9),\n'enddate': datetime.datetime(2024, 4, 17, 20, 25, 28),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203040cc6b3e2898afe515'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 25, 28),\n'enddate': datetime.datetime(2024, 4, 17, 20, 25, 36),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620308fcc6b3e2898afe562'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 25, 36),\n'enddate': datetime.datetime(2024, 4, 17, 20, 26, 55),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203090cc6b3e2898afe56f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 26, 55),\n'enddate': datetime.datetime(2024, 4, 17, 20, 26, 55, 500000),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203096cc6b3e2898afe577'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 26, 55, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 27, 2, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662030e6cc6b3e2898afe5db'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 27, 2, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 28, 22),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662030e7cc6b3e2898afe5e8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 28, 22),\n'enddate': datetime.datetime(2024, 4, 17, 20, 28, 23),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662030f4cc6b3e2898afe5f0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 28, 23),\n'enddate': datetime.datetime(2024, 4, 17, 20, 28, 35, 500000),\n'timespan': 12.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203142cc6b3e2898afe649'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 28, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 29, 54),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620314acc6b3e2898afe656'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 29, 54),\n'enddate': datetime.datetime(2024, 4, 17, 20, 30, 1, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203198cc6b3e2898afe6c3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 30, 1, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 31, 20, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662031a0cc6b3e2898afe6cb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 31, 20, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 31, 28, 500000),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662031efcc6b3e2898afe72c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 31, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 32, 47),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662031ffcc6b3e2898afe739'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 32, 47),\n'enddate': datetime.datetime(2024, 4, 17, 20, 33, 3),\n'timespan': 16.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620324ecc6b3e2898afe79f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 33, 3),\n'enddate': datetime.datetime(2024, 4, 17, 20, 34, 22),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203255cc6b3e2898afe7ac'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 34, 22),\n'enddate': datetime.datetime(2024, 4, 17, 20, 34, 29),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662032a4cc6b3e2898afe7fd'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 34, 29),\n'enddate': datetime.datetime(2024, 4, 17, 20, 35, 48, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203318cc6b3e2898afe82a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 35, 48, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 37, 44),\n'timespan': 115.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203367cc6b3e2898afe883'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 37, 44),\n'enddate': datetime.datetime(2024, 4, 17, 20, 39, 3),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203376cc6b3e2898afe89d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 39, 3),\n'enddate': datetime.datetime(2024, 4, 17, 20, 39, 18),\n'timespan': 15.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662033c4cc6b3e2898afe8f2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 39, 18),\n'enddate': datetime.datetime(2024, 4, 17, 20, 40, 36, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662033c5cc6b3e2898afe8ff'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 40, 36, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 40, 37),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662033cecc6b3e2898afe907'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 40, 37),\n'enddate': datetime.datetime(2024, 4, 17, 20, 40, 45, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620341dcc6b3e2898afe95a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 40, 45, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 42, 5),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203424cc6b3e2898afe967'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 42, 5),\n'enddate': datetime.datetime(2024, 4, 17, 20, 42, 12),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203472cc6b3e2898afe9d1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 42, 12),\n'enddate': datetime.datetime(2024, 4, 17, 20, 43, 30, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203481cc6b3e2898afe9de'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 43, 30, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 20, 43, 45),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662034d0cc6b3e2898afea31'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 43, 45),\n'enddate': datetime.datetime(2024, 4, 17, 20, 45, 4),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620387bcc6b3e2898afeb44'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 20, 45, 4),\n'enddate': datetime.datetime(2024, 4, 17, 21, 0, 43),\n'timespan': 939.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662038cacc6b3e2898afeb9b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 0, 43),\n'enddate': datetime.datetime(2024, 4, 17, 21, 2, 2, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662038cbcc6b3e2898afeba8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 2, 2, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 2, 3),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662038d1cc6b3e2898afebb0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 2, 3),\n'enddate': datetime.datetime(2024, 4, 17, 21, 2, 9, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203921cc6b3e2898afec10'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 2, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 3, 28, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620392fcc6b3e2898afec1d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 3, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 3, 43),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620397ecc6b3e2898afec78'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 3, 43),\n'enddate': datetime.datetime(2024, 4, 17, 21, 5, 2),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203987cc6b3e2898afec81'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 5, 2),\n'enddate': datetime.datetime(2024, 4, 17, 21, 5, 11),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662039d6cc6b3e2898afecea'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 5, 11),\n'enddate': datetime.datetime(2024, 4, 17, 21, 6, 30),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662039ddcc6b3e2898afecf2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 6, 30),\n'enddate': datetime.datetime(2024, 4, 17, 21, 6, 37, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203a2ccc6b3e2898afed45'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 6, 37, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 7, 56, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203a3acc6b3e2898afed53'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 7, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 8, 9, 500000),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203a89cc6b3e2898afedb9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 8, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 9, 29),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203a91cc6b3e2898afedc2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 9, 29),\n'enddate': datetime.datetime(2024, 4, 17, 21, 9, 37),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203ae0cc6b3e2898afee23'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 9, 37),\n'enddate': datetime.datetime(2024, 4, 17, 21, 10, 56),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203ae9cc6b3e2898afee30'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 10, 56),\n'enddate': datetime.datetime(2024, 4, 17, 21, 11, 5),\n'timespan': 9.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203b38cc6b3e2898afee88'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 11, 5),\n'enddate': datetime.datetime(2024, 4, 17, 21, 12, 24, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203b39cc6b3e2898afee95'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 12, 24, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 12, 25),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203b42cc6b3e2898afee9d'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 12, 25),\n'enddate': datetime.datetime(2024, 4, 17, 21, 12, 33, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203b91cc6b3e2898afeef4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 12, 33, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 13, 53),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203b99cc6b3e2898afef01'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 13, 53),\n'enddate': datetime.datetime(2024, 4, 17, 21, 14, 1),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203be8cc6b3e2898afef65'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 14, 1),\n'enddate': datetime.datetime(2024, 4, 17, 21, 15, 20),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203befcc6b3e2898afef72'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 15, 20),\n'enddate': datetime.datetime(2024, 4, 17, 21, 15, 27),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203c3ecc6b3e2898afefc7'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 15, 27),\n'enddate': datetime.datetime(2024, 4, 17, 21, 16, 46),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203c4bcc6b3e2898afefd4'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 16, 46),\n'enddate': datetime.datetime(2024, 4, 17, 21, 16, 59, 500000),\n'timespan': 13.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203c9bcc6b3e2898aff035'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 16, 59, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 18, 19),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203ca1cc6b3e2898aff041'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 18, 19),\n'enddate': datetime.datetime(2024, 4, 17, 21, 18, 25, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203cf1cc6b3e2898aff0a0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 18, 25, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 19, 45),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203cfacc6b3e2898aff0ad'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 19, 45),\n'enddate': datetime.datetime(2024, 4, 17, 21, 19, 53, 500000),\n'timespan': 8.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203d48cc6b3e2898aff108'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 19, 53, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 21, 12, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203d52cc6b3e2898aff122'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 21, 12, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 21, 22, 500000),\n'timespan': 10.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203da1cc6b3e2898aff172'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 21, 22, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 22, 41, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203da8cc6b3e2898aff17a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 22, 41, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 22, 48),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203df7cc6b3e2898aff1d9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 22, 48),\n'enddate': datetime.datetime(2024, 4, 17, 21, 24, 7),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203dfecc6b3e2898aff1e6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 24, 7),\n'enddate': datetime.datetime(2024, 4, 17, 21, 24, 14, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203e4ecc6b3e2898aff23f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 24, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 25, 34),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203e5acc6b3e2898aff247'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 25, 34),\n'enddate': datetime.datetime(2024, 4, 17, 21, 25, 45, 500000),\n'timespan': 11.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203ea8cc6b3e2898aff28e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 25, 45, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 27, 4, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203ea9cc6b3e2898aff29b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 27, 4, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 27, 5),\n'timespan': 0.5,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203eb0cc6b3e2898aff2a3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 27, 5),\n'enddate': datetime.datetime(2024, 4, 17, 21, 27, 12),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203effcc6b3e2898aff309'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 27, 12),\n'enddate': datetime.datetime(2024, 4, 17, 21, 28, 31),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203f05cc6b3e2898aff316'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 28, 31),\n'enddate': datetime.datetime(2024, 4, 17, 21, 28, 37, 500000),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203f54cc6b3e2898aff373'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 28, 37, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 29, 56, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203f61cc6b3e2898aff37c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 29, 56, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 30, 9, 500000),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203fb0cc6b3e2898aff3e2'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 30, 9, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 31, 28, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66203fb7cc6b3e2898aff3ef'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 31, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 31, 35, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204007cc6b3e2898aff43b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 31, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 32, 55),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620400ecc6b3e2898aff443'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 32, 55),\n'enddate': datetime.datetime(2024, 4, 17, 21, 33, 2),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620405dcc6b3e2898aff4b1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 33, 2),\n'enddate': datetime.datetime(2024, 4, 17, 21, 34, 21),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204069cc6b3e2898aff4be'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 34, 21),\n'enddate': datetime.datetime(2024, 4, 17, 21, 34, 33, 500000),\n'timespan': 12.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662040b8cc6b3e2898aff51b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 34, 33, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 35, 52, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662040c0cc6b3e2898aff528'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 35, 52, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 36),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620410fcc6b3e2898aff58c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 36),\n'enddate': datetime.datetime(2024, 4, 17, 21, 37, 19),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204116cc6b3e2898aff599'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 37, 19),\n'enddate': datetime.datetime(2024, 4, 17, 21, 37, 26),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204165cc6b3e2898aff5e9'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 37, 26),\n'enddate': datetime.datetime(2024, 4, 17, 21, 38, 45, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204172cc6b3e2898aff5f1'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 38, 45, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 38, 57, 500000),\n'timespan': 12.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662041c1cc6b3e2898aff650'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 38, 57, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 40, 17),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662041c8cc6b3e2898aff65c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 40, 17),\n'enddate': datetime.datetime(2024, 4, 17, 21, 40, 24),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204216cc6b3e2898aff6b6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 40, 24),\n'enddate': datetime.datetime(2024, 4, 17, 21, 41, 42, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620421dcc6b3e2898aff6bf'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 41, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 41, 49),\n'timespan': 6.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620426ccc6b3e2898aff716'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 41, 49),\n'enddate': datetime.datetime(2024, 4, 17, 21, 43, 8, 500000),\n'timespan': 79.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620427acc6b3e2898aff730'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 43, 8, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 43, 22, 500000),\n'timespan': 14.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662042c9cc6b3e2898aff78b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 43, 22, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 44, 41, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662042d1cc6b3e2898aff794'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 44, 41, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 44, 49),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204320cc6b3e2898aff7ed'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 44, 49),\n'enddate': datetime.datetime(2024, 4, 17, 21, 46, 7, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204326cc6b3e2898aff7fa'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 46, 7, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 46, 14, 500000),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204375cc6b3e2898aff864'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 46, 14, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 47, 33, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204382cc6b3e2898aff871'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 47, 33, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 47, 46, 500000),\n'timespan': 13.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662043d2cc6b3e2898aff8c3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 47, 46, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 49, 6, 500000),\n'timespan': 80.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662043dacc6b3e2898aff8cb'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 49, 6, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 49, 14),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204429cc6b3e2898aff92f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 49, 14),\n'enddate': datetime.datetime(2024, 4, 17, 21, 50, 33),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204430cc6b3e2898aff93c'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 50, 33),\n'enddate': datetime.datetime(2024, 4, 17, 21, 50, 40, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620447fcc6b3e2898aff989'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 50, 40, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 51, 59),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620448ecc6b3e2898aff996'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 51, 59),\n'enddate': datetime.datetime(2024, 4, 17, 21, 52, 14),\n'timespan': 15.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662044ddcc6b3e2898aff9fe'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 52, 14),\n'enddate': datetime.datetime(2024, 4, 17, 21, 53, 33),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662044e4cc6b3e2898affa0b'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 53, 33),\n'enddate': datetime.datetime(2024, 4, 17, 21, 53, 40),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204533cc6b3e2898affa62'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 53, 40),\n'enddate': datetime.datetime(2024, 4, 17, 21, 54, 59),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620453acc6b3e2898affa6f'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 54, 59),\n'enddate': datetime.datetime(2024, 4, 17, 21, 55, 6),\n'timespan': 7.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204589cc6b3e2898affad3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 55, 6),\n'enddate': datetime.datetime(2024, 4, 17, 21, 56, 25),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620458acc6b3e2898affae0'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 56, 25),\n'enddate': datetime.datetime(2024, 4, 17, 21, 56, 26),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('6620459acc6b3e2898affae8'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 56, 26),\n'enddate': datetime.datetime(2024, 4, 17, 21, 56, 42, 500000),\n'timespan': 16.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662045e9cc6b3e2898affb41'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 56, 42, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 21, 58, 1),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662045f1cc6b3e2898affb4e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 58, 1),\n'enddate': datetime.datetime(2024, 4, 17, 21, 58, 9),\n'timespan': 8.0,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204640cc6b3e2898affbb6'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 58, 9),\n'enddate': datetime.datetime(2024, 4, 17, 21, 59, 28),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204648cc6b3e2898affbc3'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 59, 28),\n'enddate': datetime.datetime(2024, 4, 17, 21, 59, 35, 500000),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('66204696cc6b3e2898affc1a'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 21, 59, 35, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 22, 0, 54, 500000),\n'timespan': 79.0,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662046a5cc6b3e2898affc27'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 22, 0, 54, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 22, 1, 9),\n'timespan': 14.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662046f3cc6b3e2898affc89'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 22, 1, 9),\n'enddate': datetime.datetime(2024, 4, 17, 22, 2, 27, 500000),\n'timespan': 78.5,\n'signalname': 'condition',\n'value': 'OPERATE',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662046f4cc6b3e2898affc96'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 22, 2, 27, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 22, 2, 28, 500000),\n'timespan': 1.0,\n'signalname': 'condition',\n'value': 'SUSPEND',\n'filter': None,\n'TypeID': None,\n'Judge': None,\n'Error': None,\n'Warning': None},\n{'_id': ObjectId('662046fccc6b3e2898affc9e'),\n'L1Name': 'MNC-779',\n'updatedate': datetime.datetime(2024, 4, 17, 22, 2, 28, 500000),\n'enddate': datetime.datetime(2024, 4, 17, 22, 2, 36),\n'timespan': 7.5,\n'signalname': 'condition',\n'value': 'STOP',\n'filter': None,\n'TypeID'",
        "main.py": "\"\"\"\n\n\n\n\"\"\"\nimport pymongo\nimport time\nimport datetime\n\n\ndef try_except(data: dict, key: str, *, exception=None):\n    try:\n        return data[key]\n    except Exception:\n        return exception\n\n\n# class MtlinkiConnection():\n#     def __init__(self):\n#         self.command = \"ProductResult_History_Active\"\n#         self.field = \"productresult_accumulate\"\n#         self.machine_no = \"MNC-779\"\n\n#     def connection(self):\n#         self.client = pymongo.MongoClient(\"mongodb://mtlinki:mtlinki@127.0.0.1:27017/?authMechanism=DEFAULT&authSource=MTLINKi\")\n#         # self.client = pymongo.MongoClient(\"mongodb://mtlinki:mtlinki@192.168.0.2:27017/?authMechanism=DEFAULT&authSource=MTLINKi\")\n\n#     \"\"\"\n#         # 最新データが先頭になるソート -> L1Nameでグルーピング -> 最初のデータ(=最新データ)を取得\n#         pipeline = [{\"$sort\": {\"_id\": -1}}, {\"$group\": {\"_id\": \"$L1Name\", \"latest_data\": {\"$first\": \"$$ROOT\"}} }]\n#         [x for x in col.aggregate(pipeline)]\n#     \"\"\"\n\n#     def find_data(self):\n#         \"\"\"\n#             input: ProductResult_History_Active, L1Name, productname, updatedate, productresult_accumulate\n#             output: ProductResult_History_Active, L1Name, productname, updatedate, productresult_accumulate\n#             # product serial: ProductResult_History_Active, L1Name, productname, updatedate, productserialnumber\n#             plan time: L1Signal_Pool_Active, PowOnTime(default false)\n#             actual time: L1Signal_Pool_Active, RunTime(default false)\n#             # actual time: L1Signal_Pool_Active, CutTime(default false)\n\n#             cycle time: ProductResult_History L1Name, productname, timespan\n#             standard ct: manual?\n#             target output: ProductPlan_History L1Name, productname, productplan, updatedate\n#             target ct: manual?\n#             ng count: manual?\n#             product model: ProductResult_History_Active, productname\n#             product model: L1Signal_Pool_Active, ProductName\n\n#             run trigger: L1_Pool_Opened L1Name, updatedate, signalname='condition', value = START\n#             error trigger: Alarm_History L1Name, number, message, updatedate/enddate, level=4\n#             error item: Alarm_History L1Name, number, message, updatedate/enddate, level=4\n#             # emergency trigger: Alarm_History L1Name, number, message, updatedate/enddate, level=4\n#             # emergency item: Alarm_History L1Name, number, message, updatedate/enddate, level=4\n#             warning trigger: Alarm_History L1Name, number, message, updatedate/enddate, level=2\n#             warning item: Alarm_History L1Name, number, message, updatedate/enddate, level=2\n\n#             status: L1_Pool_Opened L1Name, updatedate, signalname='condition', value(機械切断(通信切断?), collector停止時はnull)\n#             # status: L1Signal_Pool_Active, signalname -> OPERATE, STOP, WARNING, ALARM, EMERGENCY, SUSPEND, MANUAL, WARMUP, DISCONNECT\n\n#             manual work ct: manual\n#             manual work output: manual\n#         \"\"\"\n\n#         # 生産履歴 アクティブ\n#         if self.command == \"ProductResult_History_Active\":\n#             \"\"\"\n#                 EX:\n#                     ('_id': ObjectId('660b6314cc6b3e2988772b8c'),\n#                     'L1Name': 'MNC-779',\n#                     'productname': 'D01_CF1,2_CP_EMW01 23001',\n#                     'updatedate': datetime.datetime(2024, 4, 2, 1, 44, 51, 500000),\n#                     'productresult': 0,\n#                     'productresult_accumulate': 80,\n#                     'enddate': None,\n#                     'timespan': 0.0,\n#                     'resultflag': True,\n#                     'productserialnumber': None\n#             \"\"\"\n#             results = [\n#                 x for x in self.client.MTLINKi.ProductResult_History_Active.find_one(\n#                     filter={\"L1Name\": self.machine_no},\n#                     sort=[(\"updatedate\", pymongo.DESCENDING)]\n#                 ).limit(1)\n#             ]\n#             for result in results:\n#                 return result[self.field]\n\n#         # アラーム履歴 アクティブ\n#         if self.command == \"Alarm_History\":\n#             \"\"\"\n#                 アラーム履歴情報を管理します。\n#                 発生期間、時間、各種情報を保持します。\n#                 発生中の場合は終了時刻・発生時間がありません\n#                 EX:\n#                     ('_id': ObjectId('660b6314cc6b3e2988772b8c'),\n#                     'L1Name': 'MNC-780',\n#                     'L0Name': 'MNC-780',\n#                     'number': '1003',\n#                     'updatedate': datetime.datetime(2024, 4, 2, 1, 44, 7),\n#                     'message': 'EMERGENCY STOP.',\n#                     'enddate': datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n#                     'level': 4,\n#                     'type': 'EX',\n#                     'timespan': 65.5,\n#             \"\"\"\n#             results = [\n#                 x for x in self.client.MTLINKi.Alarm_History.find_one(\n#                     filter={\"L1Name\": self.machine_no},\n#                     sort=[(\"updatedate\", pymongo.DESCENDING)]\n#                 ).limit(1)\n#             ]\n\n#             for result in results:\n#                 start_time = result[\"updatedate\"]\n#                 message = result[\"message\"]\n\n#                 if not result[\"enddate\"]:\n#                     end_time = datetime.datetime.now()\n#                     timespan = end_time - start_time\n#                 else:\n#                     end_time = result[\"endtime\"]\n#                     timespan = result[\"timespan\"]   # unit: second\n\n#         if self.command == \"Program_History\":\n#             results = [\n#                 x for x in self.client.MTLINKi.Program_History.find_one(\n#                     filter={\"L1Name\": self.machine_no},\n#                     sort=[(\"updatedate\", pymongo.DESCENDING)]\n#                 ).limit(1)\n#             ]\n#             # TODO 発生中->enddate, timespan = None\n#             \"\"\"\n#                 '_id': ObjectId('660b62e7cc6b3e2988772ad0'),\n#                 'L1Name': 'MNC-779',\n#                 'L0Name': 'MNC-779',\n#                 'path': 'path1',\n#                 'updatedate': datetime.datetime(2024, 4, 2, 1, 44, 7),\n#                 'mainprogflg': False,\n#                 'mainprog': '//CNC_MEM/USER/PATH1/O5000',\n#                 'runningprog': '//CNC_MEM/USER/PATH1/O5000',\n#                 'enddate': datetime.datetime(2024, 4, 2, 1, 44, 51, 500000),\n#                 'timespan': 44.5\n#             \"\"\"\n\n#         if self.command == \"L1Signal_Pool_Active\":\n#             results = [\n#                 x for x in self.client.MTLINKi.L1Signal_Pool_Active.find_one(\n#                     filter={\"L1Name\": self.machine_no},\n#                     sort=[(\"updatedate\", pymongo.DESCENDING)]\n#                 ).limit(1)\n#             ]\n\n#             \"\"\"\n#                 L1Signal_Pool_Active\n#                 {'_id': ObjectId('660b6329cc6b3e2988772edc'),\n#                 'L1Name': 'MNC-784',\n#                 'updatedate': datetime.datetime(2024, 4, 2, 1, 45, 12, 500000),\n#                 'enddate': None,\n#                 'timespan': 0.0,\n#                 'signalname': 'RadFan2SpindleAmpStatus_0_path1_MNC-784',\n#                 # => signalname\n#                         => \"RunTime_path1_MNC-784\" -> value = 運転時間の積算値(float)\n#                         => \"SigOP_path1_MNC-784\" -> value = 自動運転中信号(boolean)\n\n\n#                 'value': None,\n#                 'filter': None,\n#                 'TypeID': None,\n#                 'Judge': None,\n#                 'Error': None,\n#                 'Warning': None},\n#             \"\"\"\ndef extract_arguments(data):\n    keys = {}\n    for entry in data:\n        if entry.get(\"arguments\"):\n            for key, value in entry[\"arguments\"].items():\n                if key not in keys:\n                    keys[key] = f\"${key}\"\n    return keys\n\n\ndef create_pipeline(argument_keys):\n    group_id = {key: value for key, value in argument_keys.items()}\n    group_id[\"L1Name\"] = \"$L1Name\"  # L1Nameを必ず追加\n    pipeline = [\n        {\"$sort\": {\"_id\": -1}},\n        {\n            \"$group\": {\n                \"_id\": group_id,\n                \"latest_data\": {\"$first\": \"$$ROOT\"}\n            }\n        }\n    ]\n    return pipeline\n\n\ndef main(connection):\n    from collections import defaultdict\n    # コマンド毎にデータを再リスト化\n    command_datalist = defaultdict(list)\n    for data in connection[\"data\"]:\n        command_datalist[data[\"command\"]].append(data)\n    print(command_datalist)\n\n    username = try_except(connection[\"controller\"][\"attributes\"], key=\"username\", exception=\"\")\n    password = try_except(connection[\"controller\"][\"attributes\"], key=\"password\", exception=\"\")\n    hostname = try_except(connection[\"network\"], key=\"ip_address\", exception=\"\")\n    port = try_except(connection[\"network\"], key=\"port\", exception=\"\")\n    _auth_mechanism = try_except(connection[\"controller\"][\"attributes\"], key=\"auth_mechanism\", exception=\"\")\n    if _auth_mechanism != \"\":\n        auth_mechanism = f\"authMechanism={_auth_mechanism}\"\n    else:\n        auth_mechanism = \"\"\n    _auth_source = try_except(connection[\"controller\"][\"attributes\"], key=\"auth_source\", exception=\"\")\n    if _auth_source != \"\":\n        if _auth_mechanism == \"\":\n            auth_source = f\"authSource={_auth_source}\"\n        else:\n            auth_source = f\"&authSource={_auth_source}\"\n    else:\n        auth_source = \"\"\n\n    print(f\"Connection: mongodb://{username}:{password}@{hostname}:{port}/?{auth_mechanism}{auth_source}\")\n    # client = pymongo.MongoClient(f\"mongodb://{username}:{password}@{hostname}:{port}/?authMechanism=DEFAULT&authSource=MTLINKi\")\n    client = pymongo.MongoClient(f\"mongodb://{username}:{password}@{hostname}:{port}/?{auth_mechanism}{auth_source}\")\n    db = client.MTLINKi\n    print(db)\n\n    # TODO signalnameがあるとき、latest_dataはsignalnameの値が指定の値になっている最終データを取得する必要がある\n    # pipeline = [{\"$sort\": {\"_id\": -1}}, {\"$group\": {\"_id\": \"$L1Name\", \"latest_data\": {\"$first\": \"$$ROOT\"}}}]\n\n    result = []\n    with pymongo.timeout(5):\n        try:\n            print(f\"PIPE: {command_datalist}\")\n            if len(command_datalist) == 0:\n                client.admin.command('ping')\n\n            for cmd_k, data_list in command_datalist.items():\n                # argumentsのキーと$付きのキーを抽出\n                argument_keys = extract_arguments(data_list)\n\n                # パイプラインの生成\n                pipeline = create_pipeline(argument_keys)\n\n                agg_result = None\n                if cmd_k == \"ProductResult_History_Active\":\n                    agg_result = [x for x in db.ProductResult_History_Active.aggregate(pipeline)]\n\n                elif cmd_k == \"ProductResult_History\":\n                    agg_result = [x for x in db.ProductResult_History.aggregate(pipeline)]\n\n                elif cmd_k == \"L1Signal_Pool_Active\":\n                    agg_result = [x for x in db.L1Signal_Pool_Active.aggregate(pipeline)]\n\n                elif cmd_k == \"L1_Pool_Opened\":\n                    agg_result = [x for x in db.L1_Pool_Opened.aggregate(pipeline)]\n\n                elif cmd_k == \"Alarm_History\":\n                    agg_result = [x for x in db.Alarm_History.aggregate(pipeline)]\n\n                # argumentsがあれば合致チェック\n                if agg_result is None:\n                    result.extend(data_list)\n                else:\n                    for item in data_list:\n                        arguments = item.get(\"arguments\", {})\n\n                        for res in agg_result:\n                            if res[\"_id\"][\"L1Name\"] == item.get(\"machine_no\"):\n                                if arguments is None:\n                                    field_key = item.get(\"field\")\n                                    item[\"response\"] = res[\"latest_data\"].get(field_key)\n                                    print(f\"arguments: {arguments}, ITEM {item}\")\n                                    result.append(item)\n                                    break\n                                else:\n                                    if all(arguments.get(key) in res[\"_id\"][key] for key in arguments):\n                                        field_key = item.get(\"field\")\n                                        item[\"response\"] = res[\"latest_data\"].get(field_key)\n                                        print(f\"arguments: {arguments}, ITEM {item}\")\n                                        result.append(item)\n                                        break\n                        else:\n                            result.append(item)\n\n        except Exception as e:\n            print(e)\n            return {\n                \"data_list\": result,\n                \"error\": str(e)\n            }\n        else:\n            print(result)\n            return {\n                \"data_list\": result,\n                \"error\": None\n            }\n\n\nif __name__ == \"__main__\":\n    connection = {\n        \"network\": {\n            # \"ip_address\": \"192.168.100.1\",\n            \"ip_address\": \"localhost\",\n            # \"ip_address\": \"mongodb\",\n            \"port\": 27017,\n        },\n        \"controller\": {\n            \"controller_type\": \"PC\",\n            \"manufacturer\": \"FANUC\",\n            \"series\": \"30i\",\n            \"protocol\": \"MT-LINKi\",\n            \"attributes\": {\n                # \"auth_source\": \"MTLINKi\",\n                \"auth_source\": \"\",\n                \"username\": \"mtlinki\",\n                \"password\": \"mtlinki\"\n            }\n        },\n        \"data\": [\n            {\n                \"machine_id\": 1,\n                \"machine_no\": \"MNC-827\",\n                \"group\": \"count\",\n                \"datatype\": \"Product Model\",\n                \"command\": \"ProductResult_History_Active\",\n                \"field\": \"productname\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"arguments\": None\n            },\n            {\n                \"machine_id\": 1,\n                \"machine_no\": \"MNC-827\",\n                \"group\": \"count\",\n                'datatype': \"Actial Time\",\n                \"command\": \"L1Signal_Pool_Active\",\n                \"field\": \"value\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"arguments\": {\n                    \"signalname\": \"RunTime\"\n                }\n            },\n            {\n                \"machine_id\": 1,\n                \"machine_no\": \"MNC-827\",\n                \"group\": \"count\",\n                'datatype': \"Plan Time\",\n                \"command\": \"L1Signal_Pool_Active\",\n                \"field\": \"value\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"arguments\": {\n                    \"signalname\": \"PowOnTime\"\n                }\n            },\n            {\n                \"machine_id\": 1,\n                \"machine_no\": \"MNC-828\",\n                \"group\": \"count\",\n                'datatype': \"Actial Time\",\n                \"command\": \"L1Signal_Pool_Active\",\n                \"field\": \"value\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"arguments\": {\n                    \"signalname\": \"RunTime\"\n                }\n            },\n            {\n                \"machine_id\": 1,\n                \"machine_no\": \"MNC-8285\",\n                \"group\": \"count\",\n                'datatype': \"Actial Time\",\n                \"command\": \"L1Signal_Pool_Active\",\n                \"field\": \"value\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"arguments\": {\n                    \"signalname\": \"AAAA\"\n                }\n            },\n            {\n                \"machine_id\": 1,\n                \"machine_no\": \"MNC-835\",\n                \"group\": \"count\",\n                'datatype': \"Actial Time\",\n                \"command\": \"L1Signal_Pool_Active\",\n                \"field\": \"value\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"arguments\": {\n                    \"signalname\": \"RunTime\"\n                }\n            },\n            # {\n                # \"machine_id\": 1,\n                # \"machine_no\": \"MNC-801\",\n                # \"group\": \"count\",\n                # \"datatype\": \"output\",\n                # \"command\": \"ProductResult_History_Active\",\n                # \"field\": \"productresult_accumulate\",\n                # \"trigger_value\": None,\n                # \"item_value\": None,\n                # \"attributes\": {\n                #     # \"number\": 2\n                # }\n            # },\n                # }, {\n                #     \"machine_id\": 2,\n                #     \"machine_no\": \"MNC-800\",\n                #     \"group\": \"count\",\n                #     \"datatype\": \"input\",\n                #     \"command\": \"ProductResult_History_Active\",\n                #     \"field\": \"productresult_accumulate\",\n                #     \"trigger_value\": None,\n                #     \"item_value\": None,\n                #     \"attributes\": {\n                #         \"number\": 3\n                #     }\n                # }, {\n                #     \"machine_id\": 2,\n                #     \"machine_no\": \"MNC-800\",\n                #     \"group\": \"count\",\n                #     \"datatype\": \"output\",\n                #     \"command\": \"ProductResult_History_Active\",\n                #     \"field\": \"productresult_accumulate\",\n                #     \"trigger_value\": None,\n                #     \"item_value\": None,\n                #     \"attributes\": {\n                #         \"number\": 4\n                #     }\n        ]\n    }\n\n    # {\n    #     \"network\": {\n    #         \"ip_address\": \"0.0.0.1\",\n    #         \"port\": 27017,\n    #     },\n    #     \"controller\": {\n    #         \"controller_type\": \"PC\",\n    #         \"manufacturer\": \"FANUC\",\n    #         \"series\": \"30i\",\n    #         \"protocol\": \"MT-LINKi\",\n    #         \"attributes\": {\n    #             \"auth_source\": \"MTLINKi\",\n    #             \"username\": \"mtlinki\",\n    #             \"password\": \"password\"\n    #         }\n    #     },\n    #     \"data\": [\n    #         {\n    #             \"machine_id\": 11,\n    #             \"group\": \"count\",\n    #             \"datatype\": \"input\",\n    #             \"command\": \"ProductResult_History_Active\",\n    #             \"field\": \"productresult_accumulate\",\n    #             \"trigger_value\": None,\n    #             \"item_value\": None,\n    #             \"attributes\": {\n    #                 \"number\": 1\n    #             }\n    #         }, {\n    #             \"machine_id\": 11,\n    #             \"group\": \"count\",\n    #             \"datatype\": \"output\",\n    #             \"command\": \"ProductResult_History_Active\",\n    #             \"field\": \"productresult_accumulate\",\n    #             \"trigger_value\": None,\n    #             \"item_value\": None,\n    #             \"attributes\": {\n    #                 \"number\": 2\n    #             }\n    #         }, {\n    #             \"machine_id\": 12,\n    #             \"group\": \"count\",\n    #             \"datatype\": \"input\",\n    #             \"command\": \"ProductResult_History_Active\",\n    #             \"field\": \"productresult_accumulate\",\n    #             \"trigger_value\": None,\n    #             \"item_value\": None,\n    #             \"attributes\": {\n    #                 \"number\": 3\n    #             }\n    #         }, {\n    #             \"machine_id\": 12,\n    #             \"group\": \"count\",\n    #             \"datatype\": \"output\",\n    #             \"command\": \"ProductResult_History_Active\",\n    #             \"field\": \"productresult_accumulate\",\n    #             \"trigger_value\": None,\n    #             \"item_value\": None,\n    #             \"attributes\": {\n    #                 \"number\": 4\n    #             }\n    #         },\n    #     ]\n    # },\n\n    datalist = main(connection)\n    print(datalist)\n\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\nc_protocol2": {
        "ncunit_protocol2.py": "import struct\nimport socket\n\n\nclass Connect():\n    def __init__(self, ip_address, port):\n        self.ip_address = ip_address\n        self.port = port\n\n    def header_adjustment(self, il, c, f, s, r):\n        \"\"\"\n        ヘッダーの作成\n        \"\"\"\n        il = (il + \" \" * 1)[:1]\n        c = (c + \" \" * 3)[:3]\n        f = (f + \" \" * 4)[:4]\n        s = (s + \" \" * 8)[:8]\n        r = (r + \" \" * 2)[:2]\n        header = il + c + f + s + r\n\n        return header\n\n    def cal_check_sum(self, header, data):\n        \"\"\"\n        チェックサムの作成\n        \"\"\"\n        # チェックサムの作成\n        check_sum = \"\"\n        d = 0\n        for i in header:\n            d = d + ord(i)\n        if data != \"\":\n            # brotherの場合のLFはASCIIでCR(13)+LF(10)\n            d = d + 23\n            for i in data:\n                d = d + ord(i)\n        _check_sum = str(d % 16)\n        check_sum = (\" \" * 2 + _check_sum)[-2:]\n\n        return check_sum\n\n    def generate_telegram(self, il, c, f, s, r):\n        \"\"\"\n        電文生成\n\n        Header = % il c1 c2 c3 f1 f2 f3 f4 s1 s2 s3 s4 s5 s6 s7 s8 r1 r2\n                %:  開始マーク\n                il: 識別子 1byte\n                    C:  コマンド\n                    R:  レスポンス\n                c1: コマンド種別 3byte\n                f1: 機能 4byte\n                s1: 伝文 8byte\n                r1: 完了コード 2byte\n                    00: 正常終了\n                    以外: 以上終了\n                ※コマンドヘッダ表内の空白はスペースを意味する\n            Data\n                LFで始まり, FotterのLFまでの間\n            Footer = LF ss %\n                ss: チェックサム, 10進数2桁の数字\n                    1. Headerの%以降～FooterのLFの前の文字までをすべて10進数表現で加算\n                    2. 1.を10進数16で除算したときの余りがss\n            ※%はISO/ASCII:%、EIA:ER\n            ※LFはISO: LF、EIA: EOB、ASCII: CR+LF\n        \"\"\"\n        # 電文生成\n        error_code = 0\n        telegram = \"\"\n\n        try:\n            header = self.header_adjustment(il, c, f, s, r)\n\n            data = \"\"\n            check_sum = self.cal_check_sum(header, data)\n            footer = str(check_sum)\n\n            if data == \"\":\n                _telegram = (\n                    \"%\" + header + \"\\r\\n\" + footer + \"%\"\n                )\n            else:\n                _telegram = (\n                    \"%\" + header + \"\\r\\n\" + data + \"\\r\\n\" + footer + \"%\"\n                )\n            telegram = b\"\".join([struct.pack(\"B\", ord(x)) for x in _telegram])\n\n        except Exception:\n            error_code = 10000\n\n        return telegram, error_code\n\n    def define_socket(self):\n        \"\"\"\n        socket定義\n        \"\"\"\n        error_code = 0\n        try:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.sock.settimeout(0.1)\n        except Exception:\n            error_code = 10001  # エラー発生\n        finally:\n            return error_code\n\n    def send_telegram(self, telegram):\n        \"\"\"\n        電文送受信\n\n        [in]\n        telegram: 送信電文\n\n        [out]\n        recv: 受信電文\n        error_code: 0以外の場合はエラー発生\n        \"\"\"\n        error_code = 0\n        recv = \"\"\n        try:\n            self.sock.connect((self.ip_address, self.port))\n        except Exception:\n            error_code = 10002\n            return recv, error_code\n\n        try:\n            self.sock.send(bytes(telegram))\n            recv = self.sock.recv(1024)\n            self.sock.close()\n        except Exception:\n            error_code = 10003\n        else:\n            error_code = int(recv[17:19])\n\n        return recv, error_code\n\n    def divide_received(self, recv, res_structure):\n        \"\"\"\n        受信電文の分割\n\n        [in]\n        recv: 受信電文\n        res_structure: 抽出するシンボル部の項目リスト\n\n        [out]\n        divided_data: 分割後のデータ <- {シンボル部(str): 項目部(dic)}\n        error_code: 0以外の場合はエラー発生\n        \"\"\"\n        # b'%RREDPRGN        00\\r\\n72337233              \\r\\n06%'\n        recv_data = {}\n        error_code = 0\n\n        # 取得データを辞書型にする <- {シンボル部(str): 項目部(str)}\n        recv_list = recv.split(b'\\r\\n')\n        recv_list.pop(0)  # レスポンスデータのヘッダ部分を削除\n        for _sym_data in recv_list:\n            if b',' in _sym_data:\n                sym_data = _sym_data.split(b',', 1)\n                recv_symbol = sym_data[0]  # シンボル部\n                recv_symdata = sym_data[1]  # 項目部\n                recv_data[recv_symbol.decode(\"utf8\")] = recv_symdata.decode(\"utf8\")\n\n        # res_structureに従い取得データからデータ抽出\n        divided_data = {}\n        for symbol, list in res_structure.items():  # 各シンボルごとの処理\n            _data = {}\n            if symbol in recv_data:\n                _recv_symdata = recv_data[symbol]\n                _recv_symdatalist = _recv_symdata.split(\",\")\n                for key, value in zip(list, _recv_symdatalist):\n                    _data[key] = value\n            divided_data[symbol] = _data\n\n        return divided_data, error_code\n\n    def read_plcd(self, device_name, device_num):\n        \"\"\"\n        PLC信号データを取得する\n\n        [in]\n        device_name: 信号種類\n        device_num: 番号\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"RED\"\n        f = \"PLCD\"\n\n        k = (device_name + \" \" * 4)[:4]\n        n = (str(device_num) + \" \" * 4)[:4]\n        s = k + n\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n\n        # 受信電文の分割\n        try:\n            recv_list = recv.split(b'\\r\\n')\n            divided_data = recv_list[1].decode(\"utf8\")\n            result[\"data\"] = divided_data\n        except Exception:\n            error_code = 104\n\n        result[\"result\"] = error_code\n        return result\n\n    def load_toln(self, unit, num):\n        \"\"\"\n        TOLNun: 工具データ（タイプ1）\n\n        [in]\n        unit: 単位系（M: メトリック, I: インチ）\n        num: データバンク番号（0~9: 10は0を使用）\n\n        [data]\n        <T01>\n        lenoffset: 工具長オフセット\n        lenwearcomp: 工具長摩耗補正\n        diacomp: 工具径補正\n        diawewarcomp: 工具径摩耗補正\n        lifeunit: 寿命単位\n        initlife: 初期寿命/終了寿命\n        noticelife: 予告寿命\n        life: 寿命\n        name: 工具名\n        speed: 周速\n        rfeed: 回転送り\n        scommand: S指令値\n        fcommand: F指令値\n        maxrspeed: 最高回転数\n        clean: ツール洗浄\n        cts: CTS\n        typenum: 工具種類番号\n        posoffsetx: 工具位置オフセット(X)\n        poswearcompx: 工具位置摩耗補正(X)\n        posoffsety: 工具位置オフセット(Y)\n        poswearcompy: 工具位置摩耗補正(Y)\n        virtcutedgedirection: 仮想刃先方向\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"LOD\"\n        s = f\"TOLN{unit}{num}\"\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n        # recv = b\"%RLOD    TOLNM2  00\\r\\nT01,120.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT02,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT03,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT04,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT05,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT06,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT07,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT08,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT09,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT10,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT11,0.000,0.000,0.000,0.000,,0,0,0,'              ',,,,,,0,0,,0.000,0.000,0.000,0.000,\\r\\nT12,0.000,0.000,0.000,0.000,,0,0,\"\n\n        # 受信電文の分割設定\n        res_structure = {\n            \"T01\": [\n                \"lenoffset\", \"lenwearcomp\", \"diacomp\", \"diawewarcomp\", \"lifeunit\",\n                \"initlife\", \"noticelife\", \"life\", \"name\", \"speed\",\n                \"rfeed\", \"scommand\", \"fcommand\", \"maxrspeed\", \"clean\",\n                \"cts\", \"typenum\", \"posoffsetx\", \"poswearcompx\", \"posoffsety\",\n                \"poswearcompy\", \"virtcutedgedirection\"\n            ]\n        }\n        # 受信電文の分割\n        divided_data, error_code = self.divide_received(recv, res_structure)\n\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        result.update(divided_data)\n        result[\"result\"] = error_code\n        return result\n\n    def load_prd3(self):\n        \"\"\"\n        PRD3: 生産データ3（状態履歴）\n\n        [data]\n        <C01>\n        currtime: 現在（開始日時）\n        currstatus: 現在（状態）\n        currlang: 現在状態（言語）\n        currstatinfo: 現在状態（プログラム番号/エラー番号）\n        currfolder: 現在状態（フォルダ名）\n        memstatus: メモリ運転種別\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"LOD\"\n        s = \"PRD3\"\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n        # recv = b\"%RLOD    PRD3    00\\r\\nA01,2148,2148,2\\r\\nC01,20230731104231,5,0,050518,'        ',0\\r\\nB0001,20230731104231,2,0,007233,'/       ',0\\r\\nB0002,20230728191907,1,0,007233,'/       ',0\\r\\nB0003,20230728163042,2,0,007233,'/       ',0\\r\\nB0004,20230728162925,3,0,007233,'/       ',0\\r\\nB0005,20230728162735,2,0,007233,'/       ',0\\r\\nB0006,20230728162617,3,0,007233,'/       ',0\\r\\nB0007,20230728162023,2,0,007233,'/       ',0\\r\\nB0008,20230728161905,3,0,007233,'/       ',0\\r\\nB0009,20230728161722,2,0,007233,'/       ',0\\r\\nB0010,20230728161604,3,0,007233,'/       ',0\\r\\nB0011,20230728160637,2,0,007233,'/       ',0\\r\\nB0012,20230728160519,3,0,007233,'/       ',0\\r\\nB0013,20230728160442,2,0,007233,'/       ',0\\r\\nB0014,20230728160326,3,0,007233,'/       ',0\\r\\nB0015,20230728160303,4,0,007233,'/       ',0\\r\\nB0016,20230728160303,3,0,007233,'/       ',0\\r\\nB0017,20230728160301,4,0,007233,'/       ',0\\r\\nB0018,20230728160300,3,0,007233,'/       ',0\\r\\nB0019,20230728160251,4,0,007233,'/       ',0\\r\\nB0020,20230728160250,3,0,007233,'/       ',0\\r\\nB0021,20230728160250,4\"\n\n        # 受信電文の分割設定\n        res_structure = {\n            \"C01\": [\n                \"currtime\", \"currstatus\", \"currlang\", \"currstatinfo\", \"currfolder\", \"memstatus\"\n            ]\n        }\n        # 受信電文の分割\n        divided_data, error_code = self.divide_received(recv, res_structure)\n\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        result.update(divided_data)\n        result[\"result\"] = error_code\n        return result\n\n    def load_prdc2(self, flag):\n        \"\"\"\n        PRDC2: 生産データ2（時間表示）\n\n        [in]\n        flag: Trueのとき、N01~N20シンボルデータは最新の日付データのみ分割後データとして追加（N00シンボル）\n\n        [data]\n        <L01>\n        cycletime1: サイクルタイム(1) （時間/分/0.1秒）\n        cuttingtime1: 切削時間(1) （時間/分/0.1秒）\n        cycletime2: サイクルタイム(2) （時間/分/0.1秒）\n        cuttingtime2: 切削時間(2) （時間/分/0.1秒）\n        prg1: プログラム番号(1)\n        prg2: プログラム番号(2)\n        prgfolder1: プログラムフォルダ(1)\n        prgfolder2: プログラムフォルダ(2)\n        memstatus1: メモリ運転種別(1)\n        memstatus2: メモリ運転種別(2)\n\n        <N01>\n        date1: 稼働時間記録1 (年月日)\n        time1: 稼働時間記録1 (時分秒)\n        count1: 稼働時間記録1 (運転回数)\n        energization1: 稼働時間記録1 (通電時間)\n\n        <N02-20>\n        N01と同一構造\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"LOD\"\n        s = \"PRDC2\"\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n        # recv = b\"%RLOD    PRDC2   00\\r\\nL01,000000256,000000173,000000000,000000000,5000,0000,'/       ','        ',0,0\\r\\nM01,2,16\\r\\nN01,20230630,000000,    0,  1513\\r\\nN02,20230703,000000,    0,  3313\\r\\nN03,20230704,000000,    0,  2714\\r\\nN04,20230705,002655,   18, 71559\\r\\nN05,20230706,010035,   40, 44320\\r\\nN06,20230707,004249,   42, 40517\\r\\nN07,20230711,060503,   18,131854\\r\\nN08,20230712,031142,    3,230309\\r\\nN09,20230713,012627,   17, 50030\\r\\nN10,20230714,003732,    6, 23544\\r\\nN11,20230718,020959,    2, 95834\\r\\nN12,20230719,014247,    1, 14514\\r\\nN13,20230725,001218,    6,  4836\\r\\nN14,20230726,000000,    0, 71531\\r\\nN15,20230727,002032,   10, 85750\\r\\nN16,20230728,004538,   34,103857\\r\\nN17,20230731,000107,    2, 65849\\r\\nN18,20230627,082920,    4,240000\\r\\nN19,20230628,083058,    4,240001\\r\\nN20,20230629,000000,    0,101521\\r\\nO01,0,0,1,0\\r\\nP01,   35.4807,   16.5640,  -45.0600,    0.0000,    0.0000,    0.0000,    0.0000,    0.0000,        0,        0,        0,        0\\r\\n\\r\\n03%\"\n\n        # 受信電文の分割設定\n        res_structure = {\n            \"L01\": [\"cycletime1\", \"cuttingtime1\", \"cycletime2\", \"cuttingtime2\", \"prg1\", \"prg2\", \"prgfolder1\", \"prgfolder2\", \"memstaus1\", \"memstaus2\"],\n            \"N01\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N02\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N03\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N04\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N05\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N06\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N07\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N08\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N09\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N10\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N11\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N12\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N13\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N14\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N15\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N16\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N17\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N18\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N19\": [\"date\", \"time\", \"count\", \"energization\"],\n            \"N20\": [\"date\", \"time\", \"count\", \"energization\"]\n        }\n        # 受信電文の分割\n        divided_data, error_code = self.divide_received(recv, res_structure)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        if flag:  # flag==Trueのとき、N01~N20シンボルデータは最新の日付データのみ分割後データとして追加（N00シンボル）\n            try:\n                latest_divided_data = {}\n                _latest_date = 0\n                _latest_symbol = \"\"\n                for symbol, dic in divided_data.items():\n                    if \"N\" in symbol:\n                        for key in dic:\n                            if key.startswith(\"date\"):\n                                _date = int(dic[key])\n                                _latest_symnum = key.replace(\"date\", \"\")\n                                if _date > _latest_date:\n                                    _latest_date = _date\n                                    _latest_symbol = symbol\n                    else:\n                        latest_divided_data[symbol] = dic\n                # N00シンボル項目部のkeyは数字なしで作成[\"date\", \"time\", \"count\", \"energization\"]\n                latest_symbol_data = {}\n                for key in divided_data[_latest_symbol]:\n                    latest_symbol_data[key.replace(_latest_symnum, \"\")] = divided_data[_latest_symbol][key]\n                latest_divided_data[\"N00\"] = latest_symbol_data\n                result.update(latest_divided_data)\n            except Exception:\n                error_code = 10004\n        else:\n            result.update(divided_data)\n\n        result[\"result\"] = error_code\n        return result\n\n    def load_prdd3(self):\n        \"\"\"\n        PRDD3: 生産データ3（状態履歴）\n\n        [data]\n        <C01>\n        currtime: 現在（開始日時）\n        currstatus: 現在（状態）\n        currlang: 現在状態（言語）\n        currstatinfo: 現在状態（プログラム番号/エラー番号）\n        currfolder: 現在状態（フォルダ名）\n        memstatus: メモリ運転種別\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"LOD\"\n        s = \"PRDD3\"\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n\n        # 受信電文の分割設定\n        res_structure = {\n                         \"C01\": [\"currtime\", \"currstatus\", \"currlang\", \"currstatinfo\", \"currfolder\", \"memstatus\"]\n                         }\n        # 受信電文の分割\n        divided_data, error_code = self.divide_received(recv, res_structure)\n\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        result.update(divided_data)\n        result[\"result\"] = error_code\n        return result\n\n    def load_prdd2(self):\n        \"\"\"\n        PRDD2: 生産データ2（時間表示）\n\n        [data]\n        <L01>\n        cycletime1: サイクルタイム(1) （時間/分/0.1秒）\n        cuttingtime1: 切削時間(1) （時間/分/0.1秒）\n        othertime1: その他(1) （0.1秒）\n        cycletime2: サイクルタイム(2) （時間/分/0.1秒）\n        cuttingtime2: 切削時間(2) （時間/分/0.1秒）\n        othertime2: その他(2) （0.1秒）\n        prg1: プログラム(1)\n        prg2: プログラム(2)\n        prgfolder1: プログラムフォルダ(1)\n        prgfolder2: プログラムフォルダ(2)\n        prgstatus1: プログラム再開/途中終了フラグ(1)\n        prgstatus2: プログラム再開/途中終了フラグ(2)\n        memstatus1: メモリ運転種別(1)\n        memstatus2: メモリ運転種別(2)\n        count: 運転終了カウンタ\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"LOD\"\n        s = \"PRDD2\"\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n\n        # 受信電文の分割設定\n        res_structure = {\n                         \"L01\": [\"cycletime1\", \"cuttingtime1\", \"othertime1\", \"cycletime2\", \"cuttingtime2\", \"othertime2\", \"prg1\", \"prg2\", \"prgfolder1\", \"prgfolder2\", \"prgstatus1\", \"prgstatus2\", \"memstatus1\", \"memstatus2\", \"count\"]\n                         }\n        # 受信電文の分割\n        divided_data, error_code = self.divide_received(recv, res_structure)\n\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        result.update(divided_data)\n        result[\"result\"] = error_code\n        return result\n\n    def load_montr(self):\n        \"\"\"\n        MONTR: 機械モニタ用データ（生産データ4）\n\n        [data]\n        <T01>\n        actualtime: 運転時間\n        energization: 通電時間\n        operating: 稼働時間\n        \"\"\"\n\n        result = {}\n\n        # 設定\n        c = f = s = r = \"\"\n        il = \"C\"\n        c = \"LOD\"\n        s = \"MONTR\"\n\n        # 電文生成\n        telegram, error_code = self.generate_telegram(il, c, f, s, r)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(telegram)\n\n        # Socket定義\n        error_code = self.define_socket()\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        # 電文送受信\n        recv, error_code = self.send_telegram(telegram)\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n        print(recv)\n\n        # 受信電文の分割設定\n        res_structure = {\n                         \"T01\": [\"actualtime\", \"energization\", \"operating\"]\n                         }\n        # 受信電文の分割\n        divided_data, error_code = self.divide_received(recv, res_structure)\n\n        if error_code != 0:\n            result[\"result\"] = error_code\n            return result\n\n        result.update(divided_data)\n        result[\"result\"] = error_code\n        return result\n\n\nif __name__ == \"__main__\":\n    ip_address = \"\"\n    port = \"\"\n    connect = Connect(ip_address, port)\n\n    result = connect.load_prdc2(flag=True)\n    # result = connect.load_prd3()\n    # result = connect.load_toln(unit=\"M\", num=2)\n    # result = connect.read_plcd(device_name=\"DL\", device_num=40)\n\n    # res_structure: レスポンスデータ中で必要なシンボル名称とシンボル別のデータ長を順に作成\n    # シンボル部は必要なもののみ記載でOK、各シンボルの項目部は過不足なく順番通りに記載すること\n    print(result)\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\slmp": {
        "devices.py": "try:\n    from .. import const\nexcept Exception:\n    import sys\n    import pathlib\n    parent_dir = str(pathlib.Path(__file__).parent.parent.resolve())\n    sys.path.append(parent_dir)\n    import const\n\n\nclass DeviceList():\n    def __init__(self, *, manufacture=\"mitsubishi\", series=\"default\", has_point=False, transport=\"udp\"):\n        self.manufacture = manufacture\n        self.series = series\n        self.has_point = has_point\n        self.transport = transport\n        self.endian = \"\"\n        self.transfer_limit = 0\n        self.prefix_byte = 0\n        self.word_length = 16\n\n    def plc_mitsubishi(self):\n        self.endian = \"little\"\n        if self.series in const.SERIES_MITSUBISHI_IQR:\n            self.transfer_limit = 960\n            self.prefix_byte = 22\n            devices = [\n                # Relay devices\n                {\"symbol\": \"X\", \"binary\": 0x009C, \"ascii\": \"X***\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Input\"},\n                {\"symbol\": \"Y\", \"binary\": 0x009D, \"ascii\": \"Y***\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Output\"},\n                {\"symbol\": \"M\", \"binary\": 0x0090, \"ascii\": \"M***\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Internal relay\"},\n                {\"symbol\": \"L\", \"binary\": 0x0092, \"ascii\": \"L***\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Latching relay\"},\n                {\"symbol\": \"F\", \"binary\": 0x0093, \"ascii\": \"F***\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Annunciator\"},\n                {\"symbol\": \"V\", \"binary\": 0x0094, \"ascii\": \"V***\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Edge relay\"},\n                {\"symbol\": \"B\", \"binary\": 0x00A0, \"ascii\": \"B***\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Link relay\"},\n                # Register devices\n                {\"symbol\": \"D\", \"binary\": 0x00A8, \"ascii\": \"D***\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register\"},\n                {\"symbol\": \"W\", \"binary\": 0x00B4, \"ascii\": \"W***\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Link register\"},\n                # Timer devices\n                {\"symbol\": \"TS\", \"binary\": 0x00C1, \"ascii\": \"TS**\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact timer\"},\n                {\"symbol\": \"TC\", \"binary\": 0x00C0, \"ascii\": \"TC**\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Coil timer\"},\n                {\"symbol\": \"TN\", \"binary\": 0x00C2, \"ascii\": \"TN**\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current timer\"},\n                {\"symbol\": \"LTS\", \"binary\": 0x0051, \"ascii\": \"LTS*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Long contact timer\"},\n                {\"symbol\": \"LTC\", \"binary\": 0x0050, \"ascii\": \"LTC*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Long coil timer\"},\n                {\"symbol\": \"LTN\", \"binary\": 0x0052, \"ascii\": \"LTN*\", \"identify\": \"double\",\n                    \"decimal\": \"10\", \"name\": \"Long current timer\"},\n                # Retentive timer devices\n                {\"symbol\": \"STS\", \"binary\": 0x00C7, \"ascii\": \"STS*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact retentive timer\"},\n                {\"symbol\": \"STC\", \"binary\": 0x00C6, \"ascii\": \"STC*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Coil retentive timer\"},\n                {\"symbol\": \"STN\", \"binary\": 0x00C8, \"ascii\": \"STN*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current retentive timer\"},\n                {\"symbol\": \"LSTS\", \"binary\": 0x0059, \"ascii\": \"LSTS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Long contact retentive timer\"},\n                {\"symbol\": \"LSTC\", \"binary\": 0x0058, \"ascii\": \"LSTC\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Long coil retentive timer\"},\n                {\"symbol\": \"LSTN\", \"binary\": 0x005A, \"ascii\": \"LSTN\", \"identify\": \"double\",\n                    \"decimal\": \"10\", \"name\": \"Long current retentive timer\"},\n                # Counter devices\n                {\"symbol\": \"CS\", \"binary\": 0x00C4, \"ascii\": \"CS**\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact counter\"},\n                {\"symbol\": \"CC\", \"binary\": 0x00C3, \"ascii\": \"CC**\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Coil counter\"},\n                {\"symbol\": \"CN\", \"binary\": 0x00C5, \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current counter\"},\n                {\"symbol\": \"LCS\", \"binary\": 0x00C4, \"ascii\": \"LCS*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Long contact counter\"},\n                {\"symbol\": \"LCC\", \"binary\": 0x00C3, \"ascii\": \"LCC*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Long coil counter\"},\n                {\"symbol\": \"LCN\", \"binary\": 0x00C5, \"ascii\": \"LCN*\", \"identify\": \"double\",\n                    \"decimal\": \"10\", \"name\": \"Long current counter\"},\n                # Special devices\n                {\"symbol\": \"SM\", \"binary\": 0x0091, \"ascii\": \"SM**\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Special relay\"},\n                {\"symbol\": \"SD\", \"binary\": 0x00A9, \"ascii\": \"SD**\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Special register\"},\n                {\"symbol\": \"SB\", \"binary\": 0x00A1, \"ascii\": \"SB**\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Link special relay\"},\n                {\"symbol\": \"SW\", \"binary\": 0x00B5, \"ascii\": \"SW**\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Link special register\"},\n                # Direct access devices\n                {\"symbol\": \"DX\", \"binary\": 0x00A2, \"ascii\": \"DX**\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Direct access input\"},\n                {\"symbol\": \"DY\", \"binary\": 0x00A3, \"ascii\": \"DY**\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Direct access output\"},\n                # Index register\n                {\"symbol\": \"LZ\", \"binary\": 0x0062, \"ascii\": \"LZ**\", \"identify\": \"double\",\n                    \"decimal\": \"10\", \"name\": \"Long Index register\"},\n                # File register\n                {\"symbol\": \"R\", \"binary\": 0x00AF, \"ascii\": \"R***\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Switching file register\"},\n                {\"symbol\": \"ZR\", \"binary\": 0x00B0, \"ascii\": \"ZR**\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Sequential file register\"},\n                # Refresh register\n                {\"symbol\": \"RD\", \"binary\": 0x002C, \"ascii\": \"RD**\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Refresh data register\"},\n                # Unit access devices\n                {\"symbol\": \"U_G\", \"binary\": 0x00AB, \"ascii\": \"G***\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Unit access device\"},\n                # CPU buffer memory access devices\n                {\"symbol\": \"U3E_G\", \"binary\": 0x00AB, \"ascii\": \"G*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"CPU buffer memory access devices\"},\n                {\"symbol\": \"U3E_HG\", \"binary\": 0x002E, \"ascii\": \"HG**\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"CPU buffer memory access devices\"},\n            ]\n        # Default iQ\n        else:\n            # if self.series in const.SERIES_MITSUBISHI_QNA:\n            #     self.transfer_limit = 480\n            # elif self.series in const.SERIES_MITSUBISHI_A:\n            #     self.transfer_limit = 64\n            # else:\n            self.transfer_limit = 960\n            self.prefix_byte = 22\n            devices = [\n                # Relay devices\n                {\"symbol\": \"X\", \"binary\": 0x9C, \"ascii\": \"X*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Input\"},\n                {\"symbol\": \"Y\", \"binary\": 0x9D, \"ascii\": \"Y*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Output\"},\n                {\"symbol\": \"M\", \"binary\": 0x90, \"ascii\": \"M*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Internal relay\"},\n                {\"symbol\": \"L\", \"binary\": 0x92, \"ascii\": \"L*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Latching relay\"},\n                {\"symbol\": \"F\", \"binary\": 0x93, \"ascii\": \"F*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Annunciator\"},\n                {\"symbol\": \"V\", \"binary\": 0x94, \"ascii\": \"V*\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Edge relay\"},\n                {\"symbol\": \"B\", \"binary\": 0xA0, \"ascii\": \"B*\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Link relay\"},\n                # Register devices\n                {\"symbol\": \"D\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register\"},\n                {\"symbol\": \"W\", \"binary\": 0xB4, \"ascii\": \"W*\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Link register\"},\n                # Timer devices\n                {\"symbol\": \"TS\", \"binary\": 0xC1, \"ascii\": \"TS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact timer\"},\n                {\"symbol\": \"TC\", \"binary\": 0xC0, \"ascii\": \"TC\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Coil timer\"},\n                {\"symbol\": \"TN\", \"binary\": 0xC2, \"ascii\": \"TN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current timer\"},\n                # Retentive timer devices\n                {\"symbol\": \"STS\", \"binary\": 0xC7, \"ascii\": \"SS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact retentive timer\"},\n                {\"symbol\": \"STC\", \"binary\": 0xC6, \"ascii\": \"SC\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Coil retentive timer\"},\n                {\"symbol\": \"STN\", \"binary\": 0xC8, \"ascii\": \"SN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current retentive timer\"},\n                # Counter devices\n                {\"symbol\": \"CS\", \"binary\": 0xC4, \"ascii\": \"CS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact counter\"},\n                {\"symbol\": \"CC\", \"binary\": 0xC3, \"ascii\": \"CC\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Coil counter\"},\n                {\"symbol\": \"CN\", \"binary\": 0xC5, \"ascii\": \"CN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current counter\"},\n                # Special devices\n                {\"symbol\": \"SM\", \"binary\": 0x91, \"ascii\": \"SM\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Special relay\"},\n                {\"symbol\": \"SD\", \"binary\": 0xA9, \"ascii\": \"SD\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Special register\"},\n                {\"symbol\": \"SB\", \"binary\": 0xA1, \"ascii\": \"SB\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Link special relay\"},\n                {\"symbol\": \"SW\", \"binary\": 0xB5, \"ascii\": \"SW\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Link special register\"},\n                # Direct access devices\n                {\"symbol\": \"DX\", \"binary\": 0xA2, \"ascii\": \"DX\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Direct access input\"},\n                {\"symbol\": \"DY\", \"binary\": 0xA3, \"ascii\": \"DY\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Direct access output\"},\n                # Index register\n                {\"symbol\": \"Z\", \"binary\": 0xCC, \"ascii\": \"Z*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Index register\"},\n                # File register\n                {\"symbol\": \"R\", \"binary\": 0xAF, \"ascii\": \"R*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Switching file register\"},\n                {\"symbol\": \"ZR\", \"binary\": 0xB0, \"ascii\": \"ZR\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Sequential file register\"},\n                # Expansion register\n                {\"symbol\": \"D_EX\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Expansion data register\"},\n                {\"symbol\": \"W_EX\", \"binary\": 0xB4, \"ascii\": \"W*\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Expansion link register\"},\n                # Unit access devices\n                {\"symbol\": \"U_G\", \"binary\": 0xAB, \"ascii\": \"G\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Unit access device\"},\n            ]\n        return devices\n\n    def plc_keyence(self):\n        self.endian = \"little\"\n        if self.series in const.SERIES_KEYENCE_KVNANO:\n            self.transfer_limit = 960\n            self.prefix_byte = 22\n            devices = [\n                # Relay\n                {\"symbol\": \"R_X\", \"binary\": 0x9C, \"ascii\": \"X*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Input\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"R_Y\", \"binary\": 0x9D, \"ascii\": \"Y*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Output\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"R(X)\", \"binary\": 0x9C, \"ascii\": \"X*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Input\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"R(Y)\", \"binary\": 0x9D, \"ascii\": \"Y*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Output\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"B\", \"binary\": 0xA0, \"ascii\": \"B*\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Link relay\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"MR\", \"binary\": 0x90, \"ascii\": \"M*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Internal relay\"},\n                {\"symbol\": \"M\", \"binary\": 0x90, \"ascii\": \"M*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Internal relay((MC Compatible))\"},\n                {\"symbol\": \"LR\", \"binary\": 0x92, \"ascii\": \"L*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Latching relay\"},\n                # Control\n                {\"symbol\": \"CR\", \"binary\": 0x91, \"ascii\": \"SM\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Control relay\"},\n                {\"symbol\": \"CM\", \"binary\": 0xA9, \"ascii\": \"SD\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Control register\"},\n                # Register\n                {\"symbol\": \"DM\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register\"},\n                {\"symbol\": \"D\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register(MC Compatible)\"},\n                # Link register\n                {\"symbol\": \"W\", \"binary\": 0xB4, \"ascii\": \"W*\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Link register\", \"decimal_to_ascii\": \"16\"},\n                # Timer\n                {\"symbol\": \"T_TN\", \"binary\": 0xC2, \"ascii\": \"TN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current timer\"},\n                {\"symbol\": \"T_TS\", \"binary\": 0xC1, \"ascii\": \"TS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact timer\"},\n                # Counter\n                {\"symbol\": \"C_CN\", \"binary\": 0xC5, \"ascii\": \"CN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current timer\"},\n                {\"symbol\": \"C_CS\", \"binary\": 0xC4, \"ascii\": \"CS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact counter\"},\n            ]\n        # Default KV7XXX & KV5XXX\n        else:\n            self.transfer_limit = 960\n            self.prefix_byte = 22\n            devices = [\n                # Relay\n                {\"symbol\": \"R_X\", \"binary\": 0x9C, \"ascii\": \"X*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Input\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"R_Y\", \"binary\": 0x9D, \"ascii\": \"Y*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Output\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"R(X)\", \"binary\": 0x9C, \"ascii\": \"X*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Input\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"R(Y)\", \"binary\": 0x9D, \"ascii\": \"Y*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Output\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"B\", \"binary\": 0xA0, \"ascii\": \"B*\", \"identify\": \"bit\",\n                    \"decimal\": \"16\", \"name\": \"Link relay\", \"decimal_to_ascii\": \"16\"},\n                {\"symbol\": \"MR\", \"binary\": 0x90, \"ascii\": \"M*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Internal relay\"},\n                {\"symbol\": \"M\", \"binary\": 0x90, \"ascii\": \"M*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Internal relay(MC Compatible)\"},\n                {\"symbol\": \"LR\", \"binary\": 0x92, \"ascii\": \"L*\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Latching relay\"},\n                # Control\n                {\"symbol\": \"CR\", \"binary\": 0x91, \"ascii\": \"SM\", \"identify\": \"bit\",\n                    \"decimal\": \"1016\", \"name\": \"Control relay\"},\n                {\"symbol\": \"CM\", \"binary\": 0xA9, \"ascii\": \"SD\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Control register\"},\n                # Register\n                {\"symbol\": \"DM\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register\"},\n                {\"symbol\": \"D\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Data register(MC Compatible)\"},\n                {\"symbol\": \"EM\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"offset\": \"100000\", \"name\": \"Expansion register\"},\n                # File register\n                {\"symbol\": \"FM\", \"binary\": 0xAF, \"ascii\": \"R*\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Switching file register\"},\n                {\"symbol\": \"ZF\", \"binary\": 0xB0, \"ascii\": \"ZR\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Sequential file register\", \"decimal_to_ascii\": \"16\"},\n                # Link register\n                {\"symbol\": \"W\", \"binary\": 0xB4, \"ascii\": \"W*\", \"identify\": \"word\",\n                    \"decimal\": \"16\", \"name\": \"Link register\", \"decimal_to_ascii\": \"16\"},\n                # Timer\n                {\"symbol\": \"T_TN\", \"binary\": 0xC2, \"ascii\": \"TN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current timer\"},\n                {\"symbol\": \"T_TS\", \"binary\": 0xC1, \"ascii\": \"TS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact timer\"},\n                # Counter\n                {\"symbol\": \"C_CN\", \"binary\": 0xC5, \"ascii\": \"CN\", \"identify\": \"word\",\n                    \"decimal\": \"10\", \"name\": \"Current timer\"},\n                {\"symbol\": \"C_CS\", \"binary\": 0xC4, \"ascii\": \"CS\", \"identify\": \"bit\",\n                    \"decimal\": \"10\", \"name\": \"Contact counter\"},\n            ]\n        return devices\n\n    def plc_panasonic(self):\n        self.endian = \"little\"\n        self.transfer_limit = 960\n        self.prefix_byte = 22\n        devices = [\n            {\"symbol\": \"X\", \"binary\": 0x9C, \"identify\": \"bit\",\n                \"decimal\": \"10F\", \"name\": \"Input\"},\n            {\"symbol\": \"Y\", \"binary\": 0x9D, \"identify\": \"bit\",\n                \"decimal\": \"10F\", \"name\": \"Output\"},\n            {\"symbol\": \"L\", \"binary\": 0xA0, \"identify\": \"bit\",\n                \"decimal\": \"10F\", \"name\": \"Link relay\"},\n            {\"symbol\": \"R\", \"binary\": 0x90, \"identify\": \"bit\",\n                \"decimal\": \"10F\", \"name\": \"Internal relay\"},\n            {\"symbol\": \"M\", \"binary\": 0x90, \"identify\": \"bit\",\n                \"decimal\": \"10F\", \"name\": \"Internal relay(MC Compatible)\"},\n            {\"symbol\": \"R_L\", \"binary\": 0x92, \"identify\": \"bit\",\n                \"decimal\": \"10F\", \"name\": \"Latching relay\"},\n            {\"symbol\": \"DT\", \"binary\": 0xA8, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Data register\"},\n            {\"symbol\": \"D\", \"binary\": 0xA8, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Data register(MC Compatible)\"},\n            {\"symbol\": \"LD\", \"binary\": 0xB4, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Link register\"},\n            {\"symbol\": \"TE\", \"binary\": 0xC2, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Current timer\"},\n            {\"symbol\": \"T\", \"binary\": 0xC1, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Contact timer\", \"writeable\": False},\n            {\"symbol\": \"CE\", \"binary\": 0xC5, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Current counter\"},\n            {\"symbol\": \"C\", \"binary\": 0xC4, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Contact counter\", \"writeable\": False},\n            {\"symbol\": \"SR\", \"binary\": 0xC1, \"identify\": \"bit\",\n                \"decimal\": \"10\", \"name\": \"Special relay\", \"offset\": \"90000\", \"writeable\": False},\n            {\"symbol\": \"SD\", \"binary\": 0xC5, \"identify\": \"word\",\n                \"decimal\": \"10\", \"name\": \"Special data register\", \"offset\": \"90000\", \"writeable\": False},\n        ]\n\n        # FP7シリーズの場合、File registerを追加\n        if self.series in const.SERIES_PANASONIC_FP7:\n            update_devices = [\n                {\"symbol\": \"DT_R\", \"binary\": 0xAF, \"identify\": \"word\", \"decimal\": \"10\",\n                    \"name\": \"Switching file register\", \"offset\": \"100000\"},\n                {\"symbol\": \"DT_ZR\", \"binary\": 0xB0, \"identify\": \"word\", \"decimal\": \"10\",\n                    \"name\": \"Sequential file register\", \"offset\": \"100000\"},\n            ]\n            devices = [\n                x if x[\"symbol\"] not in [y[\"symbol\"] for y in update_devices]\n                else [z for z in update_devices if z[\"symbol\"] == x[\"symbol\"]] for x in devices]\n\n        # bitとwordが同時指定可能で、symbolが同じだが、オプションが異なる場合\n        # アドレスの指定に\".\"(小数点)がある場合、該当デバイスの設定を下記に変換\n        if self.has_point is True:\n            update_devices = [\n                {\"symbol\": \"X\", \"binary\": 0x9C, \"identify\": \"bit\",\n                    \"decimal\": \"10.F\", \"name\": \"Input\"},\n                {\"symbol\": \"Y\", \"binary\": 0x9D, \"identify\": \"bit\",\n                    \"decimal\": \"10.F\", \"name\": \"Output\"},\n                {\"symbol\": \"L\", \"binary\": 0xA0, \"identify\": \"bit\",\n                    \"decimal\": \"10.F\", \"name\": \"Link relay\"},\n                {\"symbol\": \"R\", \"binary\": 0x90, \"identify\": \"bit\",\n                    \"decimal\": \"10.F\", \"name\": \"Internal relay\"},\n                {\"symbol\": \"M\", \"binary\": 0x90, \"identify\": \"bit\",\n                    \"decimal\": \"10.F\", \"name\": \"Internal relay(MC Compatible)\"},\n                {\"symbol\": \"T\", \"binary\": 0xA8, \"identify\": \"bit\",\n                    \"decimal\": \"10.10\", \"name\": \"Data register\"},\n                {\"symbol\": \"C\", \"binary\": 0xC2, \"identify\": \"bit\",\n                    \"decimal\": \"10.10\", \"name\": \"Current timer\"},\n                {\"symbol\": \"SR\", \"binary\": 0xC1, \"identify\": \"bit\",\n                    \"decimal\": \"10.10\", \"name\": \"Contact timer\", \"offset\": \"90000\", \"writeable\": False},\n            ]\n            devices = [\n                x if x[\"symbol\"] not in [y[\"symbol\"] for y in update_devices]\n                else [z for z in update_devices if z[\"symbol\"] == x[\"symbol\"]][0] for x in devices]\n        return devices\n\n    # Device list\n    def devices(self):\n        if self.manufacture in const.MANUFACTURER_MITSUBISHI:\n            devices = self.plc_mitsubishi()\n\n        elif self.manufacture in const.MANUFACTURER_KEYENCE:\n            devices = self.plc_keyence()\n\n        elif self.manufacture in const.MANUFACTURER_PANASONIC:\n            devices = self.plc_panasonic()\n        else:\n            devices = []\n\n        return {\n            \"transfer_limit\": self.transfer_limit,\n            \"prefix_byte\": self.prefix_byte,\n            \"endian\": self.endian,\n            \"devices\": devices,\n            \"word_length\": self.word_length\n        }\n\n\ndef device_list(manufacture, *, series=None, has_point=False, transport=\"udp\"):\n    if series is None:\n        # Default series\n        if manufacture in const.MANUFACTURER_MITSUBISHI:\n            series = \"iq\"\n        elif manufacture in const.MANUFACTURER_KEYENCE:\n            series = \"7000\"\n        elif manufacture in const.MANUFACTURER_PANASONIC:\n            series = \"fp0\"\n\n    if has_point is None or has_point is False:\n        has_point = False\n    else:\n        has_point = True\n\n    d = DeviceList(\n        manufacture=manufacture,\n        series=series, has_point=has_point, transport=transport\n    )\n    _devices = d.devices()\n    return _devices\n\n\nif __name__ == \"__main__\":\n    manufacture = \"mitsubishi\"\n    series = \"iq\"\n    has_point = False\n    transport = \"tcp\"\n\n    devices = device_list(\n        manufacture=manufacture,\n        series=series, has_point=has_point, transport=transport,\n    )\n    print(devices)\n",
        "main.py": "import socket\nimport re\nimport struct\nimport itertools\nfrom pydantic import BaseModel\nfrom typing import Pattern\n\ntry:\n    import devices\nexcept Exception:\n    try:\n        from . import devices\n    except Exception:\n        try:\n            from slmp import devices\n        except Exception:\n            try:\n                from protocols.slmp import devices\n            except Exception:\n                try:\n                    from connection.protocols.slmp import devices\n                except Exception:\n                    from src.connection.protocols.slmp import devices\n\n\ndef flatten(data):\n    return [element\n            for item in data\n            for element in (flatten(item) if hasattr(item, '__iter__') and not isinstance(item, str) and not isinstance(item, dict) else (item, ))]\n\n\ndef try_except(data: dict, key: str, *, exception=None):\n    try:\n        return data[key]\n    except Exception:\n        return exception\n\n\ndef try_integer(data: str, *, notation=10, exception=\"default\"):\n    try:\n        return int(data, notation)\n    except Exception:\n        if exception == \"default\":\n            return data\n        else:\n            return exception\n\n\n# デバイスコードを一覧から検索\ndef find_device(symbol: str, *, manufacturer=\"Mitsubishi Electric\", series=\"MELSEC iQ-R\") -> dict:\n    if \"mitsubishi\" in manufacturer.lower():\n        manufacturer = \"mitsubishi\"\n        if \"r\" in series.lower():\n            series = \"iq-r\"\n    if \"keyence\" in manufacturer.lower():\n        manufacturer = \"keyence\"\n        if \"nano\" in series.lower():\n            series = \"nano\"\n    if \"panasonic\" in manufacturer.lower():\n        manufacturer = \"panasonic\"\n    if \"omron\" in manufacturer.lower():\n        manufacturer = \"omron\"\n\n    device_info = devices.device_list(manufacturer, series=series)\n    # devicelist = [\n    #     {\"symbol\": \"D\", \"binary\": 0xA8, \"ascii\": \"D*\", \"identify\": \"word\",\n    #         \"decimal\": \"10\", \"name\": \"Data register\"},\n    #     {\"symbol\": \"X\", \"binary\": 0x9C, \"ascii\": \"X*\", \"identify\": \"bit\",\n    #         \"decimal\": \"10\", \"name\": \"Input\"},\n    #     {\"symbol\": \"W\", \"binary\": 0xB4, \"ascii\": \"W*\", \"identify\": \"word\",\n    #         \"decimal\": \"16\", \"name\": \"Link register\"},\n    # ]\n    return next(filter(lambda x: x[\"symbol\"] == symbol, device_info[\"devices\"]), None)\n\n\n# 補数を負の10進数に変換\ndef signed_hex2int(signed_hex: int, digit: int) -> int:\n    \"\"\"\n        補数を負の10進数に変換\n    \"\"\"\n    signed = 0x01 << (digit - 1)\n    mask = 0x00\n    for num in range(digit):\n        mask = mask | (0x01 << num)\n    signed_int = (int(signed_hex ^ mask) * - 1) - 1 if (signed_hex & signed) else int(signed_hex)\n    return signed_int\n\n\n# 任意の進数表記のアドレスを10進数数値に変換\ndef convert_decimal_notation_to_integer(address: str, notation: str) -> int:\n    \"\"\"\n        任意の進数表記のアドレスを10進数数値に変換\n    \"\"\"\n    if notation == \"10\":\n        # ex: \"1234\" -> 1234\n        return int(address, 10)\n    elif notation in [\"16\", \"F\"]:\n        # ex: \"1234\"(16) -> 4660\n        return int(address, 16)\n\n    elif notation == \"108\":\n        # ex: \"1234\"(8) -> 668\n        return int(address, 8)\n    elif notation == \"1016\":\n        # ex: \"1210\" -> \"12\"(10)*16 + \"10\"(16) -> 192 + 16 -> 208\n        return try_integer(address[:-2], notation=10, exception=0) * 16 + int(address[-2:], 10)\n    elif notation == \"10F\":\n        # ex: \"12A\" -> \"12\"(10)*16 + \"A\"(16) -> 192 + 10 -> 202\n        return try_integer(address[:-1], notation=10, exception=0) * 16 + int(address[-1:], 16)\n    elif notation == \"108\":\n        # ex: \"127\"(8) -> \"12\"(10)*8 + \"7\"(8) -> 96 + 7 -> 103\n        return try_integer(address[:-1], notation=10, exception=0) * 8 + int(address[-1:], 8)\n    else:\n        raise ValueError(f\"Notation {notation} is not supported\")\n\n\n# 10進数数値のアドレスを任意の進数表記の文字列に変換\ndef convert_integer_to_decimal_notation(address: str, *, notation: str = 10, prefix_count: int = 8) -> int:\n    \"\"\"\n        10進数数値のアドレスを任意の進数表記の文字列に変換\n    \"\"\"\n    if notation == \"10\":\n        # ex: 1234 -> \"1234\"\n        return str(address, 10)\n    elif notation in [\"16\", \"F\"]:\n        # ex: 1234 -> 0x04d2\n        return f'{address:0{prefix_count}x}'\n    elif notation == \"108\":\n        return f'{address:0{prefix_count}o}'\n    # TODO\n    # elif notation == \"1016\":\n    #     # ex: \"1210\" -> \"12\"(10)*16 + \"10\"(16) -> 192 + 16 -> 208\n    #     return try_integer(address[:-2], notation=10, exception=0) * 16 + int(address[-2:], 10)\n    # elif notation == \"10F\":\n    #     # ex: \"12A\" -> \"12\"(10)*16 + \"A\"(16) -> 192 + 10 -> 202\n    #     return try_integer(address[:-1], notation=10, exception=0) * 16 + int(address[-1:], 16)\n    # elif notation == \"108\":\n    #     # ex: \"127\"(8) -> \"12\"(10)*8 + \"7\"(8) -> 96 + 7 -> 103\n    #     return try_integer(address[:-1], notation=10, exception=0) * 8 + int(address[-1:], 8)\n    else:\n        raise ValueError(f\"Notation {notation} is not supported\")\n\n\n# エラーコードを検索\ndef check_error_code(code: str) -> dict:\n    try:\n        if int(code) == 0:\n            return {\n                \"code\": code,\n                \"judge\": \"success\",\n                \"message\": \"success\"\n            }\n        else:\n            return {\n                \"code\": code,\n                \"judge\": \"error\",\n                \"message\": \"error\"\n            }\n    except Exception:\n        return {\n            \"code\": code,\n            \"judge\": \"error\",\n            \"message\": \"error\"\n        }\n\n\ndef check_error_message(message, *, code: str = None, ascii_mode: bool = False):\n    if ascii_mode:\n        return check_error_code(message[18:22])\n    else:\n        return check_error_code(message[20:22] + message[18:20])\n\n\nclass Configure(BaseModel):\n    ip_address: str = \"127.0.0.1\"\n    port: int = 0\n    type: str = \"PLC\"\n    manufacturer: str = \"Mitsubishi Electric\"\n    series: str = \"Q/L\"\n    protocol: str = \"SLMP/TCP\"\n    attributes: dict = {}\n    read_data: dict = {\n        \"word\": [],\n        \"doubleword\": [],\n        \"bulk\": [],\n    }\n    write_data: dict = {\n        \"bit\": [],\n        \"word\": [],\n        \"doubleword\": [],\n        \"string\": [],\n        \"bulk\": []\n    }\n\n\nclass Regexes(BaseModel):\n    bit: Pattern = re.compile(r\"(bit|boolean)\")\n    word: Pattern = re.compile(r\"(word|short)\")\n    dword: Pattern = re.compile(r\"(dword|doubleword|integer)\")\n    string: Pattern = re.compile(r\"string\")\n    fraction: Pattern = re.compile(r\"\\.\")\n    signed: Pattern = re.compile(r\"(\\-|\\±|s_|signed_)\")\n    tcp: Pattern = re.compile(r\"tcp\", flags=re.IGNORECASE)\n    udp: Pattern = re.compile(r\"udp\", flags=re.IGNORECASE)\n\n\nclass Communication():\n    def __init__(self, configure: dict):\n        \"\"\"\n            Parameters\n            ----------\n            configure: dict\n                network: dict\n                    ip_address: str\n                        IPアドレス\n                    port: int\n                        ポート番号\n                controller: dict\n                    type: str\n                        コントローラ種別\n                    manufacturer: str\n                        コントローラのメーカ名\n                    series: str\n                        コントローラのシリーズ\n                    protocol: str\n                        使用プロトコル名\n                    attribute: dict\n                        その他オプション\n                data: list in dict\n                    データ毎の設定\n        \"\"\"\n        self.regexes = Regexes()\n        self.base_param = {\n            \"sub_header\": [0x50, 0x00],     # 固定値 3Eフレーム\n            \"network_no\": [0x00],           # 0: 自局, 1-239: 他局\n            \"pc_no\": [0xFF],                # FF: 自局, 01-EF,FE: 他局\n            \"recipient_io\": [0x03, 0xFF],   # 03FF: 自局CPU, 03D0-03D3: 制御/待機CPU, 03E0-03E3: マルチCPU, 0000-01FF: マルチドロップ接続上のC24の管理CPU\n            \"recipient_node\": [0x00],       # 00: マルチドロップ以外, 01~1F: マルチドロップ接続上の局\n            \"cpu_timer\": [0x00, 0x10],      # CPU監視タイマ 0: 処理完了まで待機, 1-65535: 値*250ms\n        }\n        network = try_except(configure, \"network\")\n        controller = try_except(configure, \"controller\")\n        self.conf = Configure(**network, **controller)\n        self.data = try_except(configure, \"data\")\n        self.ascii_mode = try_except(self.conf.attributes, key=\"encode_mode\") in [\"ascii\", \"ASCII\"]\n\n        self.request_messages = []\n\n    def identification_unit(self):\n        # Backup 2024/05/08\n        # for data in self.data:\n        #     # word random read\n        #     if ((re.search(\"bit\", data[\"data_unit\"])) or (re.search(\"word\", data[\"data_unit\"]) and data[\"data_length\"] == 1)):\n        #         self.conf.read_data[\"word\"].append(data)\n        #     # doubleword random read\n        #     elif ((re.search(\"doubleword\", data[\"data_unit\"])) or (re.search(\"word\", data[\"data_unit\"]) and data[\"data_length\"] == 2)):\n        #         self.conf.read_data[\"doubleword\"].append(data)\n        #     # bulk read\n        #     else:\n        #         self.conf.read_data[\"bulk\"].append(data)\n\n        for data in self.data:\n            print(f\"SLMP DATA CHECK: {data}\")\n            if try_except(data, key=\"data_unit\"):\n                # doubleword random read\n                if ((self.regexes.dword.search(data[\"data_unit\"]))):\n                    self.conf.read_data[\"doubleword\"].append(data)\n                # word random read\n                elif ((self.regexes.bit.search(data[\"data_unit\"])) or (self.regexes.word.search(data[\"data_unit\"]))):\n                    self.conf.read_data[\"word\"].append(data)\n                # bulk read\n                else:\n                    self.conf.read_data[\"bulk\"].append(data)\n            else:\n                pass\n        return self.conf.read_data\n\n    # bulk read\n    def set_request_bulk_read(self):\n        \"\"\"\n            一括読出しメッセージを生成する\n        \"\"\"\n        # bulk read command set\n        self.base_param.update(command=[0x04, 0x01], sub_command=[0x00, 0x00])\n\n        bulk_data = self.conf.read_data['bulk']\n        each_device_data = {}\n        for data in bulk_data:\n            try:\n                each_device_data[data[\"device\"]].append(data)\n            except Exception:\n                each_device_data[data[\"device\"]] = [data]\n\n        # TODO: Q/L Q3UDVCPU: 399 -> OK, 400 -> NG\n        max_access_count = 399\n\n        for key, values in each_device_data.items():\n            device = find_device(symbol=key, manufacturer=self.conf.manufacturer, series=self.conf.series)\n            decimal_notation = device[\"decimal\"]\n\n            min_value = min([\n                convert_decimal_notation_to_integer(x[\"address\"].split(\".\")[0], decimal_notation)\n                + convert_decimal_notation_to_integer(try_except(device, key=\"offset\", exception=\"0\"), decimal_notation)\n                for x in values\n            ])\n            # max_value = max([convert_decimal_notation_to_integer(x[\"address\"].split(\".\")[0], decimal_notation) + int(x[\"data_length\"]) for x in values])\n            # TODO 最小のアドレス～最大のアドレス+256\n            max_value = max([\n                convert_decimal_notation_to_integer(x[\"address\"].split(\".\")[0], decimal_notation)\n                + convert_decimal_notation_to_integer(try_except(device, key=\"offset\", exception=\"0\"), decimal_notation)\n                + 256 for x in values\n            ])\n            _request = {\n                \"min\": min_value,\n                \"max\": max_value\n            }\n\n            for i in range(((max_value - min_value) // max_access_count) + 1):\n                _min_value = min_value + (max_access_count * i)\n                _max_value = min_value + (max_access_count * (i + 1))\n                if _max_value < max_value:\n                    _request.update(split_min=_min_value, split_max=_max_value)\n                else:\n                    _request.update(split_min=_min_value, split_max=max_value)\n                _request.update(device=key, count=_request[\"split_max\"] - _request[\"split_min\"])\n\n                # ASCIIモード\n                if self.ascii_mode:\n                    data_count = [\n                        int(x, 16) for x in re.findall(\"..\", f\"{24:04x}\")]\n                    request_data = [\n                        self.base_param[\"sub_header\"],\n                        self.base_param[\"network_no\"],\n                        self.base_param[\"pc_no\"],\n                        self.base_param[\"recipient_io\"],\n                        self.base_param[\"recipient_node\"],\n                        data_count,\n                        self.base_param[\"cpu_timer\"],\n                        self.base_param[\"command\"],         # command\n                        self.base_param[\"sub_command\"],     # sub command\n                    ]\n                    device_code = device[\"ascii\"]\n                    # address = f\"{_request['split_min']:06}\"\n                    reconvert_notation = try_except(device, \"decimal_to_ascii\", exception=\"10\")\n                    address = convert_integer_to_decimal_notation(_request['split_min'], notation=reconvert_notation, prefix_count=6)\n\n                    address_count = f\"{_request['count']:04}\"\n                    request_data = request_data + [device_code, address, address_count]\n                    request_message = \"\"\n                    for x in flatten(request_data):\n                        try:\n                            request_message = request_message + format(x, \"02x\")\n                        except Exception:\n                            request_message = request_message + x\n                    request_message = request_message.encode('ascii')\n                    # print(f\"request_message ASCII: {request_message}\")\n                    self.request_messages.append({**_request, \"message\": request_message, \"command\": \"bulk_read\"})\n\n                # Binaryモード\n                else:\n                    data_count = [\n                        int(x, 16) for x in re.findall(\"..\", f\"{12:04x}\")]\n\n                    request_data = [\n                        self.base_param[\"sub_header\"],\n                        self.base_param[\"network_no\"],\n                        self.base_param[\"pc_no\"],\n                        list(reversed(self.base_param[\"recipient_io\"])),\n                        self.base_param[\"recipient_node\"],\n                        list(reversed(data_count)),\n                        list(reversed(self.base_param[\"cpu_timer\"])),\n                        list(reversed(self.base_param[\"command\"])),         # command\n                        list(reversed(self.base_param[\"sub_command\"])),     # sub command\n                    ]\n                    device_code = device[\"binary\"]\n                    address = list(reversed([int(x, 16) for x in re.findall(\"..\", f\"{_request['split_min']:06x}\")]))\n                    address_count = list(reversed([int(x, 16) for x in re.findall(\"..\", f\"{_request['count']:04x}\")]))\n                    request_data = request_data + [address, device_code, address_count]\n\n                    request_message = b\"\"\n                    for x in flatten(request_data):\n                        request_message = request_message + struct.pack(\"B\", x)\n                    # print(f\"request_message Binary: {request_message.hex()}\")\n                    self.request_messages.append({**_request, \"message\": request_message, \"command\": \"bulk_read\"})\n        return self.request_messages\n\n    # random read\n    def set_request_random_read(self) -> dict:\n        \"\"\"\n            ランダム読出しメッセージを生成する\n            Return\n\n        \"\"\"\n        def device_code_address_encode(data: dict):\n            device = find_device(symbol=data[\"device\"], manufacturer=self.conf.manufacturer, series=self.conf.series)\n            decimal_notation = device[\"decimal\"]\n\n            data_address = data[\"address\"].split(\".\")[0]\n            address_integer = convert_decimal_notation_to_integer(data_address, decimal_notation)\n            try:\n                address_integer = address_integer + convert_decimal_notation_to_integer(device[\"offset\"], decimal_notation)\n            except Exception:\n                pass\n\n            if self.ascii_mode:\n                device_code = device[\"ascii\"]\n                reconvert_notation = try_except(device, \"decimal_to_ascii\", exception=\"10\")\n                address = convert_integer_to_decimal_notation(address_integer, notation=reconvert_notation, prefix_count=6)\n                # address = data_address.rjust(6, \"0\")\n                return device_code + address\n            else:\n                device_code = device[\"binary\"]\n\n                address = list(reversed([int(x, 16) for x in re.findall(\"..\", f\"{address_integer:06x}\")]))\n                return address + [device_code]\n\n        # random read command set\n        self.base_param.update(command=[0x04, 0x03], sub_command=[0x00, 0x00])\n\n        # max_access_count from device_data\n        max_access_count = 192\n\n        # Add word address request\n        word_datas = []\n        for data in self.conf.read_data['word']:\n            word_datas.append(device_code_address_encode(data))\n\n        # Add doubleword address request\n        double_datas = []\n        for data in self.conf.read_data['doubleword']:\n            double_datas.append(device_code_address_encode(data))\n\n        request_datas = []\n        request_message_data = \"\" if self.ascii_mode else b\"\"\n        word_data_count = 0\n        double_data_count = 0\n        for data in word_datas:\n            word_data_count = word_data_count + 1\n            if self.ascii_mode:\n                try:\n                    request_message_data = request_message_data + format(data, \"02x\")\n                except Exception:\n                    request_message_data = request_message_data + data\n            else:\n                for x in data:\n                    request_message_data = request_message_data + struct.pack(\"B\", x)\n            # over max_access_count more than word_datas\n            if word_data_count >= max_access_count:\n                request_datas.append({\n                    \"data\": request_message_data,\n                    \"word_count\": word_data_count,\n                    \"double_count\": double_data_count,\n                })\n                request_message_data = \"\" if self.ascii_mode else b\"\"\n                word_data_count = 0\n\n        for data in double_datas:\n            double_data_count = double_data_count + 1\n            if self.ascii_mode:\n                try:\n                    request_message_data = request_message_data + format(data, \"02x\")\n                except Exception:\n                    request_message_data = request_message_data + data\n            else:\n                for x in data:\n                    request_message_data = request_message_data + struct.pack(\"B\", x)\n            # over max_access_count more than data_count(remain word_datas + double_datas)\n            if (word_data_count + double_data_count) >= max_access_count:\n                request_datas.append({\n                    \"data\": request_message_data,\n                    \"word_count\": word_data_count,\n                    \"double_count\": double_data_count,\n                })\n                request_message_data = \"\" if self.ascii_mode else b\"\"\n                word_data_count = 0\n                double_data_count = 0\n\n        if request_message_data:\n            request_datas.append({\n                \"data\": request_message_data,\n                \"word_count\": word_data_count,\n                \"double_count\": double_data_count,\n            })\n\n        # リクエストメッセージを生成\n        for data in request_datas:\n            word_data_count = data[\"word_count\"]\n            double_data_count = data[\"double_count\"]\n            # ASCIIモード\n            if self.ascii_mode:\n                data_count = [\n                    int(x, 16) for x in re.findall(\"..\", f\"{(8 + (4 * (word_data_count + double_data_count))) * 2:04x}\")]\n                request_data = [\n                    self.base_param[\"sub_header\"],\n                    self.base_param[\"network_no\"],\n                    self.base_param[\"pc_no\"],\n                    self.base_param[\"recipient_io\"],\n                    self.base_param[\"recipient_node\"],\n                    data_count,\n                    self.base_param[\"cpu_timer\"],\n                    self.base_param[\"command\"],         # command\n                    self.base_param[\"sub_command\"],     # sub command\n                    word_data_count,                    # word access count\n                    double_data_count,                  # doubleword access count\n                    data[\"data\"]\n                ]\n                request_message = \"\"\n                for x in flatten(request_data):\n                    try:\n                        request_message = request_message + format(x, \"02x\")\n                    except Exception:\n                        request_message = request_message + x\n                request_message = request_message.encode('ascii')\n                # print(f\"request_message ASCII: {request_message}\")\n                self.request_messages.append({\n                    **data,\n                    \"message\": request_message,\n                    \"command\": \"random_read\"\n                })\n            # Binaryモード\n            else:\n                data_count = [\n                    int(x, 16) for x in re.findall(\"..\", f\"{8 + (4 * (word_data_count + double_data_count)):04x}\")]\n                request_data = [\n                    self.base_param[\"sub_header\"],\n                    self.base_param[\"network_no\"],\n                    self.base_param[\"pc_no\"],\n                    list(reversed(self.base_param[\"recipient_io\"])),\n                    self.base_param[\"recipient_node\"],\n                    list(reversed(data_count)),\n                    list(reversed(self.base_param[\"cpu_timer\"])),\n                    list(reversed(self.base_param[\"command\"])),         # command\n                    list(reversed(self.base_param[\"sub_command\"])),     # sub command\n                    word_data_count,                                    # word access count\n                    double_data_count,                                  # doubleword access count\n                    data[\"data\"]\n                ]\n                request_message = b\"\"\n                for x in flatten(request_data):\n                    request_message = request_message + struct.pack(\"B\", x)\n                # print(f\"request_message Binary: {request_message.hex()}\")\n                self.request_messages.append({**data, \"message\": request_message, \"command\": \"random_read\"})\n        return self.request_messages\n\n    # TODO bulk write\n    def set_request_message_bulk_write(self):\n        self.identification_unit()\n        \"\"\"\n            一括書き込みメッセージを生成する\n        \"\"\"\n\n    # TODO random write\n    def set_request_message_random_write(self):\n        self.identification_unit()\n        \"\"\"\n            ランダム書き込みメッセージを生成する\n        \"\"\"\n\n    def set_connection(self, *, transport_layer: str = None, timeout=10):\n        if transport_layer is None:\n            # Backup 2024-05-08\n            # if re.search(\"tcp\", self.conf.protocol, flags=re.IGNORECASE):\n            #     transport_layer = \"tcp\"\n            # elif re.search(\"udp\", self.conf.protocol, flags=re.IGNORECASE):\n            #     transport_layer = \"udp\"\n            # else:\n            #     raise ValueError(f\"This protocol: {self.conf.protocol} is unsupported.\")\n\n            if self.regexes.tcp.search(self.conf.protocol):\n                transport_layer = \"tcp\"\n            elif self.regexes.udp.search(self.conf.protocol):\n                transport_layer = \"udp\"\n            else:\n                raise ValueError(f\"This protocol: {self.conf.protocol} is unsupported.\")\n\n        if transport_layer in [\"tcp\"]:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        elif transport_layer in [\"udp\"]:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        else:\n            raise ValueError(f\"This protocol: {self.conf.protocol} is unsupported.\")\n        self.sock.settimeout(timeout)\n\n    def open(self, *, ip_address: str = None, port: int = None):\n        if ip_address is None:\n            ip_address = self.conf.ip_address\n        if port is None:\n            port = self.conf.port\n        # print(f\"ip_address: {ip_address}, port: {port}\")\n        self.sock.connect((ip_address, port))\n\n    def connection(self, *, request_messages: list = None) -> dict:\n        if request_messages is None:\n            request_messages = self.request_messages\n\n        self.responses = []\n        for request in self.request_messages:\n            response = {\"request\": request}\n\n            if isinstance(request, dict):\n                request_message = try_except(request, key=\"message\")\n            else:\n                request_message = request\n\n            self.sock.send(request_message)\n            try:\n                recieve_message = self.sock.recv(1024).hex()\n                response.update(\n                    connection={\n                        \"request_message\": request_message.hex(),\n                        \"recieve_message\": recieve_message,\n                        \"code\": 0,\n                        \"message\": \"success\"\n                    }\n                )\n            except Exception as e:\n                # print(f\"Error: {e}\")\n                response.update(\n                    connection={\n                        \"request_message\": request_message.hex(),\n                        \"recieve_message\": None,\n                        \"code\": 10060,\n                        \"message\": str(e)\n                    }\n                )\n            self.responses.append(response)\n        return self.responses\n\n    def close(self):\n        try:\n            self.sock.close()\n        except Exception:\n            print(\"Already closed\")\n\n    def divided_response_common(self, metainfo: dict, *, ascii_mode: bool = None):\n        \"\"\"\n            Argument:\n                metainfo: dict\n            Keyargument:\n                ascii_mode: bool -> flag of ascii or binary, default is None = binary mode.\n            Return:\n                code: str -> error code\n                judge: str -> result\n                message: str -> error details\n                response: str -> extraction data part from response message\n        \"\"\"\n        message = metainfo[\"connection\"][\"recieve_message\"]\n\n        if ascii_mode is None:\n            ascii_mode = self.ascii_mode\n\n        if ascii_mode:\n            check_response = \"\".join([chr(int(x, 16)) for x in re.findall(\"..\", message)])\n        else:\n            check_response = message\n\n        check_result = check_error_message(\n            message=check_response,\n            ascii_mode=ascii_mode\n        )\n\n        finish_code = try_integer(check_result[\"code\"], notation=16)\n        if finish_code == 0:\n            if ascii_mode:\n                response_data = \"\".join([chr(int(x, 16)) for x in re.findall(\"..\", message)])[22:]\n            else:\n                response_data = message[22:]\n            check_result.update(response=response_data)\n        else:\n            check_result.update(response=None)\n        metainfo.update(judge=check_result)\n        return metainfo\n\n    # TODO bulk read\n    def divided_response_bulk_read(self, *, ascii_mode=None):\n        if ascii_mode is None:\n            ascii_mode = self.ascii_mode\n\n        # デバイス名と開始アドレスで集約\n        multi_responses = [list(res) for _, res in itertools.groupby([x for x in self.responses if x[\"request\"][\"command\"] in [\"bulk_read\"] and x[\"connection\"][\"code\"] == 0], lambda x: (x[\"request\"][\"device\"] and x[\"request\"][\"min\"]))]\n\n        for res in multi_responses:\n            checked_response = [self.divided_response_common(metainfo=x, ascii_mode=ascii_mode) for x in res]\n            try:\n                join_response = b\"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n            except Exception:\n                try:\n                    join_response = \"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n                except Exception:\n                    # print(f'Bulk read has error_code: {[x[\"judge\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) != 0]}')\n                    join_response = None\n\n            if join_response:\n                for i, data in enumerate(self.conf.read_data[\"bulk\"]):\n                    # resは同じデバイス名で集約している\n                    if res[0][\"request\"][\"device\"] == data[\"device\"]:\n                        res_hex = re.findall(\"....\", join_response)\n\n                        response_min = res[0][\"request\"][\"min\"]\n                        # response_max = res[0][\"request\"][\"max\"]\n                        device = find_device(symbol=data[\"device\"], manufacturer=self.conf.manufacturer, series=self.conf.series)\n                        decimal_notation = device[\"decimal\"]\n                        address_integer = convert_decimal_notation_to_integer(data[\"address\"].split(\".\")[0], decimal_notation) + convert_decimal_notation_to_integer(try_except(device, key=\"offset\", exception=\"0\"), decimal_notation)\n                        address_min = address_integer - response_min\n                        # address_max = address_min + data[\"data_length\"] if address_min + data[\"data_length\"] <= response_max else response_max\n                        # extraction_response = res_hex[address_min: address_max]\n                        extraction_response = res_hex[address_min:]\n\n                        if data[\"data_unit\"] in [\"string\"]:\n                            _data = []\n                            for extract in extraction_response:\n                                try:\n                                    if ascii_mode:\n                                        _word_data = re.findall(\"..\", extract)\n                                    else:\n                                        _word_data = list(reversed(re.findall(\"..\", extract)))\n\n                                    if \"mitsubishi\" in self.conf.manufacturer.lower():\n                                        for x in reversed(_word_data):\n                                            if int(x, 16) == 0:\n                                                raise ValueError(\"separate null\")\n                                            else:\n                                                _data.append(chr(int(x, 16)))\n                                    else:\n                                        for x in _word_data:\n                                            if int(x, 16) == 0:\n                                                raise ValueError(\"separate null\")\n                                            else:\n                                                _data.append(chr(int(x, 16)))\n                                except Exception:\n                                    break\n                            response_string = \"\".join(flatten(_data))\n                            data.update({\"response\": response_string})\n                        else:\n                            _data = []\n                            for extract in extraction_response:\n                                if ascii_mode:\n                                    _word_data = re.findall(\"..\", extract)\n                                else:\n                                    _word_data = list(reversed(re.findall(\"..\", extract)))\n                                _data.append(int(\"\".join(_word_data), 16))\n                            data.update({\"response\": _data})\n        return {\n            \"metainfo\": multi_responses,\n            \"data\": self.conf.read_data\n        }\n\n    # random read\n    def divided_response_randam_read(self, *, ascii_mode=None):\n        if ascii_mode is None:\n            ascii_mode = self.ascii_mode\n\n        checked_response = [self.divided_response_common(metainfo=x, ascii_mode=ascii_mode)\n                        for x in self.responses\n                        if x[\"request\"][\"command\"] in [\"random_read\"] and x[\"connection\"][\"code\"] == 0]\n        try:\n            join_response = b\"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n        except Exception:\n            try:\n                join_response = \"\".join([x[\"judge\"][\"response\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) == 0])\n            except Exception:\n                # print(f'Random read has error_code: {[x[\"judge\"] for x in checked_response if try_integer(x[\"judge\"][\"code\"], notation=16) != 0]}')\n                join_response = None\n\n        if join_response:\n            data_length = 0\n            # word data convert\n            for i, data in enumerate(self.conf.read_data[\"word\"]):\n                _data = join_response[i * 4:(i + 1) * 4]\n\n                if ascii_mode:\n                    res = int(\"\".join(re.findall(\"..\", _data)), 16)\n                    data_length = (i + 1) * 2\n                else:\n                    res = int(\"\".join(list(reversed(re.findall(\"..\", _data)))), 16)\n                    data_length = (i + 1) * 4\n\n                # bit data\n                # if data[\"data_unit\"] in [\"bit\"] or re.search(\"\\\\.\", data[\"address\"]):\n                if (self.regexes.bit.search(data[\"data_unit\"])) or self.regexes.fraction.search(data[\"address\"]):\n                    res_bit = list(reversed(list(f\"{res:016b}\")))\n                    try:\n                        if data[\"address\"].split(\".\")[1].isdecimal():\n                            decimal_func = int(data[\"address\"].split(\".\")[1], 10)\n                        else:\n                            decimal_func = int(data[\"address\"].split(\".\")[1], 16)\n                    except Exception:\n                        decimal_func = 0\n                    data.update({\"response\": int(res_bit[decimal_func])})\n\n                # word data\n                else:\n                    # negative\n                    # if (re.search(\"\\\\-\", data[\"data_unit\"]) or re.search(\"\\\\±\", data[\"data_unit\"])):\n                    if (self.regexes.signed.search(data[\"data_unit\"])):\n                        data.update({\"response\": signed_hex2int(res, 16)})\n                    # positive\n                    else:\n                        data.update({\"response\": res})\n\n            # doubleword word data convert\n            for i, data in enumerate(self.conf.read_data[\"doubleword\"]):\n                _data = join_response[data_length + (i * 8):data_length + ((i + 1) * 8)]\n                if ascii_mode:\n                    res = int(\"\".join(re.findall(\"..\", _data)), 16)\n                else:\n                    res = int(\"\".join(list(reversed(re.findall(\"..\", _data)))), 16)\n\n                # negative\n                # if (re.search(\"\\\\-\", data[\"data_unit\"]) or re.search(\"\\\\±\", data[\"data_unit\"])):\n                if (self.regexes.signed.search(data[\"data_unit\"])):\n                    data.update({\"response\": signed_hex2int(res, 32)})\n                # positive\n                else:\n                    data.update({\"response\": res})\n\n        return {\n            \"metainfo\": checked_response,\n            \"data\": self.conf.read_data\n        }\n\n    def divided_read(self):\n        return (\n            self.conf.read_data[\"word\"] + self.conf.read_data[\"doubleword\"] + self.conf.read_data[\"bulk\"]\n        )\n\n    def extract_error_connection(self, data_list: list):\n        def metalist(data_list: list):\n            return flatten([try_except(x, \"metainfo\", exception=[]) for x in data_list])\n\n        meta = metalist(data_list)\n        return [x[\"judge\"] for x in meta\n                if try_integer(try_except(try_except(x, \"connection\"), \"code\"), notation=16) != 0 or try_integer(try_except(try_except(x, \"judge\"), \"code\"), notation=16) != 0]\n\n\ndef test_code():\n    configure = {\n        \"network\": {\n            # Mitsubishi PLC in NCPT\n            \"ip_address\": \"192.168.250.39\",\n            \"port\": 9600\n        },\n        \"controller\": {\n            \"type\": \"PLC\",\n            \"manufacturer\": \"Mitsubishi Electric\",\n            \"series\": \"MELSEC iQ-R\",\n            \"protocol\": \"SLMP/TCP\",\n            \"attributes\": {\n                \"encode_mode\": \"binary\"\n                # \"encode_mode\": \"ascii\"\n            }\n        },\n        # \"network\": {\n        #     # Panasonic PLC in NCPT\n        #     # パナソニックはランダム読み出し非対応!!!!!!!\n        #     \"ip_address\": \"192.168.250.5\",\n        #     \"port\": 9600\n        # },\n        # \"controller\": {\n        #     \"type\": \"PLC\",\n        #     \"manufacturer\": \"Panasonic\",\n        #     \"series\": \"FP-7\",\n        #     \"protocol\": \"SLMP/TCP\",\n        #     \"attributes\": {\n        #         \"encode_mode\": \"binary\"\n        #         # \"encode_mode\": \"ascii\"\n        #     }\n        # },\n        \"data\": [\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                # \"group\": \"count\",\n                # \"datatype\": \"input\",\n                # \"trigger_value\": None,\n                # \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 2,\n                \"data_unit\": \"+word\",\n                # \"data_unit\": \"bulk\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                \"group\": \"count\",\n                \"datatype\": \"output\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 2,\n                \"data_unit\": \"+word\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"count\",\n                \"datatype\": \"input\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 2,\n                \"data_unit\": \"-word\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"count\",\n                \"datatype\": \"output\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1002\",\n                \"data_length\": 2,\n                \"data_unit\": \"+word\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"count\",\n                \"datatype\": \"output\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1002\",\n                \"data_length\": 2,\n                \"data_unit\": \"-word\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"count\",\n                \"datatype\": \"output\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1002\",\n                \"data_length\": 2,\n                \"data_unit\": \"±word\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"error\",\n                \"datatype\": \"error_trigger\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 1,\n                \"data_unit\": \"word\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"error\",\n                \"datatype\": \"error_trigger\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 1,\n                \"data_unit\": \"bit\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 2,\n                \"group\": \"error\",\n                \"datatype\": \"error_trigger\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1002.1\",\n                \"data_length\": 1,\n                \"data_unit\": \"bit\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                \"group\": \"custom\",\n                \"datatype\": \"productname\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 10,\n                \"data_unit\": \"string\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                \"group\": \"custom\",\n                \"datatype\": \"productname\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1000\",\n                \"data_length\": 20,\n                \"data_unit\": \"bulk\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                \"group\": \"custom\",\n                \"datatype\": \"productname\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"D\",\n                \"address\": \"1100\",\n                \"data_length\": 20,\n                \"data_unit\": \"bulk\"\n            },\n            {\n                \"execute\": \"read\",\n                \"machine_id\": 1,\n                \"group\": \"custom\",\n                \"datatype\": \"productname\",\n                \"trigger_value\": None,\n                \"item_value\": None,\n                \"device\": \"W\",\n                \"address\": \"1000\",\n                \"data_length\": 10,\n                \"data_unit\": \"string\"\n            },\n        ]\n    }\n    test_data_word = [\n        {\n            \"execute\": \"read\",\n            \"machine_id\": 1,\n            \"device\": \"D\",\n            \"address\": \"1000\",\n            \"data_length\": 1,\n            \"data_unit\": \"+word\",\n        },\n    ] * 200\n    test_data_double = [\n        {\n            \"execute\": \"read\",\n            \"machine_id\": 1,\n            \"device\": \"D\",\n            \"address\": \"1000\",\n            \"data_length\": 2,\n            \"data_unit\": \"+word\",\n        },\n    ] * 200\n    configure[\"data\"].extend(test_data_word)\n    configure[\"data\"].extend(test_data_double)\n\n    configure = {\n        'network': {'ip_address': '192.168.250.39', 'port': 9600},\n        'controller': {'type': 'PLC', 'manufacturer': 'Mitsubishi Electric', 'series': 'MELSEC iQ-R', 'protocol': 'SLMP/TCP', 'attributes': {}},\n        'data': [{'execute': 'read', 'machine_id': 1, 'datatype': 'Input', 'device': 'D', 'address': '500', 'data_unit': 'word', 'trigger': None, 'item': None},\n                 {'execute': 'read', 'machine_id': 1, 'datatype': 'NG count', 'device': 'D', 'address': '5000', 'data_unit': 'word', 'trigger': '100', 'item': 'NGITEM 100'},\n                 {'execute': 'read', 'machine_id': 1, 'datatype': 'Input', 'device': 'D', 'address': '223', 'data_unit': 'word', 'trigger': None, 'item': None},\n                 {'execute': 'read', 'machine_id': 1, 'datatype': 'Actual Time', 'device': 'D', 'address': '12233', 'data_unit': '±word', 'trigger': '', 'item': None}]\n    }\n\n    con = Communication(configure=configure)\n    con.identification_unit()\n    con.set_request_random_read()\n    con.set_request_bulk_read()\n    con.set_connection()\n    con.open()\n    recv = con.connection()\n    con.close()\n    # print(f\"recv: {recv}\")\n\n    result_random = con.divided_response_randam_read()\n    if result_random:\n        print(f\"Random read meta: {result_random['metainfo']}\\n\")\n        print(f\"Word data: {result_random['data']['word']}\\n\")\n        print(f\"doubleword word data: {result_random['data']['doubleword']}\\n\")\n\n    result_bulk = con.divided_response_bulk_read()\n    if result_bulk:\n        print(f\"Bulk read meta: {result_bulk['metainfo']}\\n\")\n        print(f\"Bulk data: {result_bulk['data']['bulk']}\\n\")\n\n    response = con.divided_read()\n    data_list = [result_random, result_bulk]\n    error_connection = con.extract_error_connection(data_list)\n    print(error_connection)\n\n\nif __name__ == \"__main__\":\n    manufacturer = \"mitsubishi\"\n    series = \"iq\"\n    symbol = \"D\"\n    # device = devices.device_list(manufacturer, series=series)\n    device = find_device(symbol=symbol, manufacturer=manufacturer, series=series)\n    print(device)\n    # test_code()\n\n",
        "_main.py": "import socket\nimport struct\nimport itertools\nimport re\nimport sys\nimport pathlib\n\ntry:\n    from .. import const\n    from .. import convert\n    from .. import logger\nexcept Exception:\n    parent_dir = str(pathlib.Path(__file__).parent.parent.resolve())\n    sys.path.append(parent_dir)\n    import const\n    import convert\n    import logger\n\ntry:\n    from . import devices\nexcept Exception:\n    import devices\n\n\nlogger = logger.get_module_logger(__name__)\n\n\ndef try_except_object(obj: dict, *, key: str = None, except_key: str = None, exception=\"\"):\n    if key is None:\n        try:\n            result = obj\n        except Exception:\n            result = exception\n    else:\n        try:\n            result = obj[key]\n        except Exception:\n            if except_key is not None:\n                try:\n                    result = obj[except_key]\n                except Exception:\n                    result = exception\n            else:\n                result = exception\n    return result\n\n\nclass Connection():\n    def __init__(self):\n        pass\n\n    def __del__(self):\n        try:\n            self.sock.close()\n        except Exception:\n            pass\n\n    def check_optional(self):\n        self.telegram_data = []\n        self.segment_length = []\n        self.string_option = False\n        self.cmd_option = try_except_object(self.cmd, key=\"option\")\n\n        self.optional_data_type = try_except_object(\n            self.optional, key=\"data_type\")\n\n        # STRING OPTINONの確認。またはDataの型がstrの場合、強制的にSTRINGと扱う\n        if self.cmd_cmd in const.WRITE_COMMAND:\n            if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                self.string_option = True\n            else:\n                if isinstance(self.cmd_data, list):\n                    if (isinstance(s, str) for s in self.cmd_data):\n                        self.string_option = True\n                else:\n                    if isinstance(self.cmd_data, str):\n                        self.string_option = True\n\n            if self.string_option is True:\n                if isinstance(self.cmd_data, list):\n                    if all(isinstance(s, str) for s in self.cmd_data):\n                        self.cmd_data = \"\".join(self.cmd_data)\n\n        # TIME OPTIONの確認\n        # if self.cmd_option in const.TIME_DATA or self.optional_data_type in const.TIME_DATA:\n        #     pass\n\n        # 交信データコード(COMMUNICATION DATA CODE OPTION)の確認 Default: binary\n        self.data_code = try_except_object(\n            self.optional, key=\"data_code\", except_key=\"communication_data_code\", exception=\"binary\")\n\n    def check_withoutskip_optional(self):\n        # SKIP OPTIONの確認 listに含まれているアドレスが必要なためスキップしない＝含まれない場合スキップ\n        optional_without_skip = try_except_object(\n            self.optional, key=\"without_skip\", except_key=\"only_use_address\", exception=[])\n        self.without_skip_address = []\n        if self.cmd_cmd in const.READ_COMMAND and len(optional_without_skip) > 0:\n            for without_skip_address in optional_without_skip:\n                without_address = convert.decimal_convert(\n                    decimal=self.decimal, str_address=without_skip_address)\n                self.without_skip_address.append(\n                    without_address - self.int_min_address\n                )\n\n    def check_decimal_point(self):\n        try:\n            self.point_index = self.str_min_address.index('.')\n        except ValueError:\n            try:\n                self.point_index = self.str_max_address.index('.')\n            except ValueError:\n                self.point_index = None\n\n    def define_device_parameter(self):\n        has_point = True if self.point_index is not None or try_except_object(\n            self.protocol, key=\"point_index\", exception=None) is not None else False\n\n        device_list = devices.device_list(\n            manufacture=self.manufacture, series=self.series,\n            has_point=has_point,\n        )\n\n        _device_list_data = [x for x in device_list[\"devices\"]\n                             if x[\"symbol\"] == self.device[\"device\"]]\n        try:\n            device_list_data = _device_list_data[0]\n        except Exception:\n            raise ValueError(\"Device symbol is incorrect.\")\n        else:\n            if self.data_code in const.ASCII_DATA_CODE:\n                try:\n                    self.device_code = [device_list_data[\"ascii\"]]\n                    self.max_communicate_address_length = int(\n                        device_list[\"transfer_limit\"] / 2)\n                except Exception:\n                    raise ValueError(\n                        \"ASCII communication data code is not supported.\")\n            else:\n                self.device_code = [device_list_data[\"binary\"]]\n                self.max_communicate_address_length = device_list[\"transfer_limit\"]\n            self.prefix_byte = device_list[\"prefix_byte\"]\n            self.endian = device_list[\"endian\"]\n            self.bit_identify = device_list_data[\"identify\"]\n            self.decimal = device_list_data[\"decimal\"]\n\n            # アドレスを10進数数値に変換\n            self.int_min_address = convert.decimal_convert(\n                decimal=self.decimal, str_address=self.str_min_address)\n            self.int_max_address = convert.decimal_convert(\n                decimal=self.decimal, str_address=self.str_max_address)\n\n            self.communicate_address_length = (\n                self.int_max_address - self.int_min_address + 1)\n\n    def define_parameter(self, network: dict, protocol: dict, device: dict, cmd: dict, *, optional: dict = None):\n        try:\n            self.ip_address = network[\"ip\"]\n            try:\n                self.port = int(network[\"port\"])\n            except ValueError:\n                self.port = network[\"port\"]\n\n            self.protocol = protocol\n            self.device = device\n            self.cmd = cmd\n            self.optional = optional\n\n            self.cmd_cmd = cmd[\"cmd\"]\n            self.cmd_data = cmd[\"data\"]\n            self.transport_layer_protocol = self.protocol[\"transport_layer\"]\n            self.manufacture = self.protocol[\"manufacture\"]\n            self.str_min_address = try_except_object(\n                self.device, key=\"min\", except_key=\"minimum\", exception=None)\n            self.str_max_address = try_except_object(\n                self.device, key=\"max\", except_key=\"maximum\", exception=None)\n            self.series = self.protocol[\"series\"]\n        except Exception:\n            return {\n                \"error_code\": 20001,\n                \"message\": \"There are some missing parts in the settings.\"\n            }\n\n        # Optionalの確認, 応じてself.cmd_dataを変更する\n        try:\n            self.check_optional()\n        except Exception:\n            return {\n                \"error_code\": 20003,\n                \"message\": \"The option parameter setting is incorrect. \"\n            }\n\n        # 小数点の指定(bitの指定)の確認\n        self.check_decimal_point()\n\n        # デバイスパラメータの定義\n        try:\n            self.define_device_parameter()\n        except Exception:\n            return {\n                \"error_code\": 20002,\n                \"message\": \"Parameter setting is incorrect.\"\n            }\n\n        # 指定したアドレスを含む通信以外を無視する設定の確認\n        # 要デバイスパラメータ定義\n        try:\n            self.check_withoutskip_optional()\n        except Exception:\n            return {\n                \"error_code\": 20005,\n                \"message\": \"Setting without_skip optional has error\"\n            }\n\n        try:\n            # Socket定義\n            if self.transport_layer_protocol in const.TRANSPORT_TCP:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            else:\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.sock.settimeout(const.TRANSPORT_TIMEOUT)\n        except Exception:\n            return {\n                \"error_code\": 20010,\n                \"message\": \"Socket communication could not be established.\"\n            }\n\n        return {\n            \"error_code\": 0,\n            \"message\": \"success\"\n        }\n\n    # Converts data to binary to be read to PLC.\n    def read_command(self):\n        cmd_data = []\n        access_data_length = []\n        first_address = []\n\n        _segment = [\n            x for x in range(0, self.communicate_address_length, self.max_communicate_address_length)]\n        _segment.append(self.communicate_address_length)\n        for i_segment in range(len(_segment)):\n            try:\n                min_segment = _segment[i_segment]\n                max_segment = _segment[i_segment + 1]\n            except Exception:\n                break\n            else:\n                _segment_cmd_data = list(range(min_segment, max_segment))\n                # Skip addressのチェック(without skipが存在し、かつsegmentと重複していないものをSkip扱いとする)\n                if len(self.without_skip_address) > 0 and not (set(_segment_cmd_data) & set(self.without_skip_address)):\n                    self.skip_address_index.append(i_segment)\n\n                self.segment_length.append(len(_segment_cmd_data))\n\n                _access_data_length = format(len(_segment_cmd_data), \"04x\")\n                access_data_length.append(\n                    [int(x, 16) for x in [_access_data_length[2:4], _access_data_length[0:2]]])\n\n                if self.data_code in const.ASCII_DATA_CODE:\n                    if self.decimal in [\"10\", \"16\"]:\n                        _min_ad, _, _, = convert.each_convert(\n                            decimal=self.decimal, int_address=(self.int_min_address + min_segment))\n                        _first_address = list(\n                            re.findall(\"..\", _min_ad.zfill(6)))\n                    else:\n                        _min_ad = format(\n                            self.int_min_address + min_segment, \"06d\")\n                        _first_address = list(re.findall(\"..\", _min_ad))\n\n                else:\n                    _min_ad = format(self.int_min_address + min_segment, \"06x\")\n                    _first_address = [int(x, 16) for x in list(\n                        reversed(list(re.findall(\"..\", _min_ad))))]\n                first_address.append(_first_address)\n\n        return {\n            \"cmd_data\": cmd_data,\n            \"access_data_length\": access_data_length,\n            \"first_address\": first_address\n        }\n\n    def write_string(self, data):\n        _cmd_data = []\n\n        if isinstance(data, list) is True:\n            _data = \"\".join(data)\n        else:\n            _data = data\n\n        _data_list = [format(ord(x), \"02x\") for x in list(_data)]\n\n        it = iter(_data_list)\n        for _a, _b in itertools.zip_longest(it, it, fillvalue=\"00\"):\n            _cmd_data.append([int(_b, 16), int(_a, 16)])\n\n        _length, _mod = divmod(len(_data), 2)\n        _length += _mod\n        # The length of the string is stored at the head.\n        if self.manufacture in const.MANUFACTURER_PANASONIC:\n            self.int_min_address += 1\n            _data_length = format(str(int(_length)), \"0>4s\")\n            _cmd_data.insert(\n                0, [int(_data_length[:-2]), int(_data_length[-2:])])\n            _length += 1\n        else:\n            # 文字列のセパレータ。通常null(0x00, 0x00)がエンドコード\n            # _cmd_data.append([0, 0])\n            pass\n        return _cmd_data, _length\n\n    def write_word(self, data):\n        _cmd_data = []\n        for i in range(len(data)):\n            # positive/negative judgment\n            if data[i] >= 0:\n                _data = format(data[i], \"04x\")\n            else:\n                _data = format(\n                    data[i] & 0xffff, '04x')\n\n            it = iter(_data)\n            for _a, _b, _c, _d in zip(it, it, it, it):\n                _cmd_data.append(\n                    [int(_c + _d, 16), int(_a + _b, 16)])\n        _length = len(_cmd_data)\n        return _cmd_data, _length\n\n    def write_bit(self, data):\n        _cmd_data = []\n        _data = [format(x, \"01x\") for x in data]\n        it = iter(_data)\n        for _a, _b in itertools.zip_longest(it, it, fillvalue=\"0\"):\n            _cmd_data.append(\n                [int(_a + _b, 16)])\n        _length = len(_cmd_data) * 2\n        return _cmd_data, _length\n\n    # TODO 動作確認必須\n    # Converts data to binary to be written to PLC.\n    def write_command(self) -> dict:\n        cmd_data = []\n        access_data_length = []\n        first_address = []\n\n        _segment = [\n            x for x in range(0, self.communicate_address_length, self.max_communicate_address_length)]\n\n        _segment.append(self.communicate_address_length)\n        for i_segment in range(len(_segment)):\n            try:\n                min_segment = _segment[i_segment]\n                max_segment = _segment[i_segment + 1]\n            except Exception:\n                break\n            else:\n                _length = 0\n                _segment_cmd_data = self.cmd_data[min_segment: max_segment]\n                _cmd_data = []\n                # Word devices\n                if self.bit_identify in const.WORD_DEVICE:\n                    # Writing of character strings.\n                    if self.string_option is True:\n                        _cmd_data, _length = self.write_string(\n                            _segment_cmd_data)\n                    # Writing of integer or boolean.\n                    else:\n                        _cmd_data, _length = self.write_word(_segment_cmd_data)\n                # TODO double device\n                elif self.bit_identify in const.DOUBLE_DEVICE:\n                    pass\n                # Bit devices\n                else:\n                    _cmd_data, _length = self.write_bit(_segment_cmd_data)\n\n                if _length > 0:\n                    cmd_data.append(_cmd_data)\n                    _access_data_length = format(_length, \"04x\")\n                    access_data_length.append(\n                        [int(x, 16) for x in [_access_data_length[2:4], _access_data_length[0:2]]])\n\n                    if self.data_code in const.ASCII_DATA_CODE:\n                        if self.decimal in [\"10\", \"16\"]:\n                            _min_ad, _, _, = convert.each_convert(\n                                decimal=self.decimal, int_address=(self.int_min_address + min_segment))\n                            _first_address = list(\n                                re.findall(\"..\", _min_ad.zfill(6)))\n                        else:\n                            _min_ad = format(\n                                self.int_min_address + min_segment, \"06d\")\n                            _first_address = list(re.findall(\"..\", _min_ad))\n\n                    else:\n                        _min_ad = format(\n                            self.int_min_address + min_segment, \"06x\")\n                        _first_address = [int(x, 16) for x in list(\n                            reversed(list(re.findall(\"..\", _min_ad))))]\n                    first_address.append(_first_address)\n\n                    # _min_ad = format(self.int_min_address + min_segment, \"06x\")\n                    # first_address.append([\n                    #     int(x, 16) for x in [_min_ad[4:6], _min_ad[2:4], _min_ad[0:2]]])\n\n        return {\n            \"cmd_data\": cmd_data,\n            \"access_data_length\": access_data_length,\n            \"first_address\": first_address,\n        }\n\n    # 電文生成\n    def generate_telegram(self) -> dict:\n        self.skip_address_index = []\n\n        sub_header = [0x50, 0x00]\n        network_number = [0x00]\n        pc_number = [0xFF]\n        destination_unit_io = [0xFF, 0x03]\n        destination_unit_node_number = [0x00]\n        cpu_monitoring_timer = [0x10, 0x00]\n\n        if self.cmd_cmd in const.WRITE_COMMAND:\n            command = [0x01, 0x14]\n            command_data = self.write_command()\n        else:\n            command = [0x01, 0x04]\n            command_data = self.read_command()\n        arr_cmd_data = command_data[\"cmd_data\"]\n        arr_access_data_length = command_data[\"access_data_length\"]\n        arr_first_address = command_data[\"first_address\"]\n\n        if self.bit_identify in const.BIT_DEVICE:\n            if self.series in const.SERIES_MITSUBISHI_IQR:\n                sub_command = [0x03, 0x00]\n            else:\n                sub_command = [0x01, 0x00]\n        else:\n            if self.series in const.SERIES_MITSUBISHI_IQR:\n                sub_command = [0x02, 0x00]\n            else:\n                sub_command = [0x00, 0x00]\n\n        for i in range(len(arr_access_data_length)):\n            access_data_length = arr_access_data_length[i]\n            device_code = self.device_code\n            first_address = arr_first_address[i]\n            if self.data_code in const.ASCII_DATA_CODE:\n                try:\n                    cmd_data = list(\n                        (itertools.chain.from_iterable([reversed(x) for x in arr_cmd_data[i]])))\n                except Exception:\n                    cmd_data = []\n\n                request_data_length = list(\n                    format(24 + (len(cmd_data) * 2), \"04x\"))\n\n                _data = (\n                    sub_header + network_number + pc_number +\n                    list(reversed(destination_unit_io)) + destination_unit_node_number +\n                    request_data_length + list(reversed(cpu_monitoring_timer)) +\n                    list(reversed(command)) + list(reversed(sub_command)) +\n                    device_code + first_address + list(reversed(access_data_length)) +\n                    cmd_data\n                )\n                _binary = \"\"\n                for x in _data:\n                    try:\n                        _binary += format(x, \"02x\")\n                    except Exception:\n                        _binary += x\n\n                self.telegram_data.append(_binary.encode(\"ascii\"))\n            else:\n                try:\n                    cmd_data = list(\n                        (itertools.chain.from_iterable(arr_cmd_data[i])))\n                except Exception:\n                    cmd_data = []\n\n                _request_data_length = format(len(\n                    cpu_monitoring_timer + command + sub_command + first_address + device_code + access_data_length + cmd_data), \"04x\")\n                request_data_length = [\n                    int(x, 16) for x in [_request_data_length[2:4], _request_data_length[0:2]]]\n\n                _data = (\n                    sub_header + network_number + pc_number +\n                    destination_unit_io + destination_unit_node_number +\n                    request_data_length + cpu_monitoring_timer +\n                    command + sub_command +\n                    first_address + device_code + access_data_length +\n                    cmd_data\n                )\n                _binary = b\"\"\n                for x in _data:\n                    _binary += struct.pack(\"B\", x)\n                self.telegram_data.append(bytes(_binary))\n            self.access_data_length = access_data_length\n\n        error_code = 0\n        message = \"generate success\"\n        return {\n            \"error_code\": error_code,\n            \"message\": message,\n            \"data\": self.telegram_data,\n        }\n\n    # 電文送受信\n    def send_telegram(self, *, telegram_data=None, skip_address_index=None) -> dict:\n        some_send_data = []\n        some_recv_data = []\n        some_err_code = []\n        some_err_message = []\n        recv_data = \"\"\n        if telegram_data is None:\n            telegram_data = self.telegram_data\n        elif isinstance(telegram_data, str):\n            telegram_data = [telegram_data]\n\n        if skip_address_index is None:\n            try:\n                skip_address_index = self.skip_address_index\n            except Exception:\n                skip_address_index = []\n        else:\n            skip_address_index = []\n\n        # Connection\n        try:\n            self.sock.connect((self.ip_address, self.port))\n        except socket.error as e:\n            if e.errno is None:\n                some_err_code.append(10060)\n            else:\n                some_err_code.append(e.errno)\n            some_err_message.append(str(e))\n        else:\n            for index, telegram in enumerate(telegram_data):\n                _recv = None\n                if len(skip_address_index) > 0 and index in skip_address_index:\n                    _recv = \"skip\"\n                    _err_code = 0\n                    _err_message = \"SKIP\"\n                    recv_data += \"0000\" * self.segment_length[index]\n                else:\n                    _err_code = 9999\n                    _err_message = \"\"\n                    # 再送処理\n                    for i in range(const.RETRY_COUNT):\n                        logger.debug(\"send: {}\".format(telegram.hex()))\n                        print(\"send: {}\".format(telegram.hex()))\n\n                        # Send data\n                        self.sock.send(telegram)\n                        try:\n                            # Recieved data.\n                            _recv = self.sock.recv(1024).hex()\n                            logger.debug(\"recv: {}\".format(_recv))\n                        except socket.timeout as e:\n                            # WSAETIMEDOUT\n                            _err_code = 10060\n                            _err_message = str(e)\n                        except socket.herror as e:\n                            # WSAECONNREFUSED\n                            _err_code = 10061\n                            _err_message = str(e)\n                        except socket.gaierror as e:\n                            _err_code = 11001\n                            _err_message = str(e)\n                        except socket.error as e:\n                            _err_code = 10065\n                            _err_message = str(e)\n                        else:\n                            # ASCIIモードの場合、取得データをASCII1文字列->16進数文字列に変換\n                            if self.data_code in const.ASCII_DATA_CODE:\n                                _recv = \"\".join([chr(int(x, 16))\n                                                for x in re.findall(\"..\", _recv)])\n\n                            if len(_recv) < self.prefix_byte:\n                                _err_code = 9998 if _err_code == 9999 else _err_code\n                                _err_message = \"DATA MISSING\"\n                            else:\n                                # エラーコードを取得\n                                try:\n                                    _err_code = int(\n                                        _recv[self.prefix_byte -\n                                              2: self.prefix_byte]\n                                        + _recv[self.prefix_byte - 4:self.prefix_byte - 2], 16)\n\n                                    logger.debug(\n                                        \"Error Code:{}\".format(_err_code))\n\n                                    # エラーコードのチェック\n                                    # error code 0x00 is Success. others is Error.\n                                    if _err_code == 0:\n                                        # TODO データ欠落チェック\n                                        # readの場合 and 送信データ数 == 受信データ数 -> \"OK\"\n                                        # if self.cmd_cmd in const.READ_COMMAND:\n                                        #     if self.bit_identify in const.BIT_DEVICE:\n                                        #         if self.data_code in const.ASCII_DATA_CODE:\n                                        #             bit_length = 1\n                                        #         else:\n                                        #             bit_length = 2\n                                        #     else:\n                                        #         bit_length = 4\n\n                                        #     if (self.segment_length[index] * bit_length) == (len(_recv[self.prefix_byte:])):\n                                        #         _err_message = \"SUCCESS\"\n                                        #         break\n                                        #     else:\n                                        #         _err_message = \"MISSING DATA\"\n                                        #         break\n                                        # else:\n                                        #     _err_message = \"SUCCESS\"\n                                        #     break\n\n                                        _err_message = \"SUCCESS\"\n                                        break\n                                    else:\n                                        _err_message = \"code:{}\".format(\n                                            _err_code)\n                                except Exception as e:\n                                    _err_code = 9999 if _err_code in [\n                                        0, 9999] else _err_code\n                                    _err_message = str(\n                                        e) if _err_message == \"\" else _err_message\n                    else:\n                        logger.debug(\"Retry count: {}\".format(i))\n                        some_send_data.append(telegram)\n                        some_recv_data.append(_recv)\n                        some_err_code.append(_err_code)\n                        some_err_message.append(_err_message)\n                        break\n\n                    recv_data += _recv[self.prefix_byte:]\n\n                some_send_data.append(telegram)\n                some_recv_data.append(_recv)\n                some_err_code.append(_err_code)\n                some_err_message.append(_err_message)\n\n        try:\n            some_send_data = [x.hex() for x in some_send_data]\n        except Exception:\n            pass\n\n        self.recv_data = recv_data\n        return {\n            \"recv_data\": recv_data,\n            \"error_code\": max(some_err_code),\n            \"some_send\": some_send_data,\n            \"some_recv\": some_recv_data,\n            \"some_err_code\": some_err_code,\n            \"some_err_message\": some_err_message,\n        }\n\n    # 文字列に変換\n    @staticmethod\n    def convert_ascii_string(data: str) -> str:\n        _string_data = []\n\n        if len(data) <= 2:\n            # Asciiは0x00~0x1Fは制御文字のため文字列としてはNullと扱う\n            _1st_str = chr(int(data[:2], 16)) if int(\n                data[:2], 16) >= 20 else \"\"\n            _string_data.append(_1st_str)\n        else:\n            # Asciiは0x00~0x1Fは制御文字のため文字列としてはNullと扱う\n            _1st_str = chr(int(data[:2], 16)) if int(\n                data[:2], 16) >= 20 else \"\"\n            _2nd_str = chr(int(data[2:], 16)) if int(\n                data[2:], 16) >= 20 else \"\"\n            _string_data.append(_1st_str)\n            _string_data.append(_2nd_str)\n\n        return \"\".join(_string_data)\n\n    # 受信電文を分割\n    def devide_received(self, *, recv_data=None):\n        if self.cmd_cmd in const.WRITE_COMMAND:\n            return []\n        else:\n            if recv_data is None:\n                _devide_data = self.recv_data\n            else:\n                _devide_data = recv_data\n            _devide = []\n            _word = 4\n            _byte = 2\n\n            _count = 0\n\n            if self.bit_identify in const.BIT_DEVICE:\n                _devide = [int(x, 16) for x in _devide_data]\n            elif self.bit_identify in const.WORD_DEVICE:\n                for i in range(0, len(_devide_data), _word):\n                    if len(_devide_data[i: i + _word]) < _word:\n                        _data = _devide_data[i: i + _word] + (\"0\" * _word)\n                    else:\n                        _data = _devide_data[i: i + _word]\n\n                    # エンディアン調整\n                    if self.endian in const.ENDIAN_LITTLE:\n                        # ASCIIの場合big endianになる\n                        if self.data_code in const.ASCII_DATA_CODE:\n                            pass\n                        else:\n                            _data = _data[_byte:] + _data[:_byte]\n\n                    # 文字列として返答\n                    if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                        # [0x00]で区切り文字。\n                        # それ以降はバッファが含まれている可能性があるので無視する\n                        for i in range(0, len(_data), _byte):\n                            if len(_data[i: i + _byte]) < _byte:\n                                _byte_data = _data[i: i +\n                                                   _byte] + (\"0\" * _byte)\n                            else:\n                                _byte_data = _data[i: i + _byte]\n\n                            if _byte_data == \"00\":\n                                # パナソニック製PLCの場合、頭2wordは\"格納領域数\"と\"データ数\"のため除外\n                                if self.manufacture in const.MANUFACTURER_PANASONIC:\n                                    del _devide[:2]\n                                break\n                            else:\n                                _string_data = self.convert_ascii_string(\n                                    _byte_data)\n                                _devide.append(_string_data)\n                    # 数値として返答\n                    else:\n                        # wordデバイスをbitとして使用している場合の返答\n                        if self.bit_identify in const.WORD_DEVICE and self.point_index is not None:\n                            _bit_data = list(\n                                reversed([int(x, 16) for x in list(format(int(_data, 16), \"016b\"))]))\n                            if _count == 0 and self.communicate_address_length - 1 == 0:\n                                _min_bit = int(\n                                    self.str_min_address.rsplit(\".\", 1)[-1], 16)\n                                _max_bit = int(\n                                    self.str_max_address.rsplit(\".\", 1)[-1], 16)\n                                _devide.extend(_bit_data[_min_bit:_max_bit])\n                            elif _count == 0:\n                                _min_bit = int(\n                                    self.str_min_address.rsplit(\".\", 1)[-1], 16)\n                                _devide.extend(_bit_data[_min_bit:])\n                            elif _count == self.communicate_address_length - 1:\n                                _max_bit = int(\n                                    self.str_max_address.rsplit(\".\", 1)[-1], 16)\n                                _devide.extend(_bit_data[:_max_bit])\n                            else:\n                                _devide.extend(_bit_data)\n                        else:\n                            _devide.append(int(_data, 16))\n                        _count += 1\n\n            # 文字列の場合、結合してtextで返答\n            if self.cmd_option in const.STRING_DATA or self.optional_data_type in const.STRING_DATA:\n                _devide = \"\".join(_devide)\n\n            return _devide\n\n\ndef main(network: dict, protocol: dict, device: dict, cmd: dict, *, optional=None):\n    connection = Connection()\n    defines = connection.define_parameter(\n        network, protocol, device, cmd, optional=optional)\n\n    if defines[\"error_code\"] != 0:\n        logger.warning(defines)\n        result = {\n            \"extract\": \"\",\n            \"send\": \"\",\n            \"receive\": \"\",\n            \"error_code\": defines[\"error_code\"],\n            \"message\": defines[\"message\"]\n        }\n    else:\n        # 送信電文生成\n        generated_telegram = connection.generate_telegram()\n        logger.debug(\"send: {}\".format(generated_telegram))\n\n        # 電文送受信\n        receive_data = connection.send_telegram()\n        logger.debug(\"receive: {}\".format(receive_data))\n\n        # 受信電文からデータ部を分離\n        devided_data = connection.devide_received()\n        logger.debug(\"devide: {}\".format(devided_data))\n\n        error_code = receive_data[\"error_code\"]\n        result = {\n            \"extract\": devided_data,\n            \"send\": try_except_object(generated_telegram, key=\"data\", exception=\"\"),\n            \"receive\": receive_data[\"recv_data\"],\n            \"error_code\": error_code,\n            \"some_receive\": receive_data[\"some_recv\"],\n            \"some_error_code\": receive_data[\"some_err_code\"],\n            \"some_error_message\": receive_data[\"some_err_message\"],\n        }\n    try:\n        del connection\n    except Exception as e:\n        logger.warning(e)\n    logger.debug(\"result: {}\".format(result))\n    return result\n\n\nif __name__ == \"__main__\":\n    # 三菱\n    network = {\"ip\": \"192.168.250.39\", \"port\": 9600}\n    protocol = {\"manufacture\": \"mitsubishi\", \"series\": \"q\",\n                \"protocol\": \"slmp\", \"transport_layer\": \"tcp\", \"point_index\": None,\n                }\n    # device = {\"device\": \"M\", \"min\": \"100\", \"max\": \"115\"}  # decimal=10 bit\n    device = {\"device\": \"D\", \"min\": \"1000\", \"max\": \"1004\"}  # decimal=10 word\n    # device = {\"device\": \"B\", \"min\": \"100\", \"max\": \"115\"}  # decimal=16 bit\n    # device = {\"device\": \"W\", \"min\": \"100\", \"max\": \"115\"}  # decimal=16 word\n\n    # \"\"\"\n    # パナソニック\n    # network = {\"ip\": \"192.168.250.5\", \"port\": 9600}\n    # protocol = {\"manufacture\": \"panasonic\", \"series\": \"fp7\",\n    #             \"protocol\": \"slmp\", \"transport_layer\": \"tcp\", \"point_index\": None, }\n    # # device = {\"device\": \"X\", \"min\": \"10\", \"max\": \"1F\"}\n    # # device = {\"device\": \"X\", \"min\": \"1.0\", \"max\": \"1.0\"}\n    # # device = {\"device\": \"DT\", \"min\": \"5100\", \"max\": \"5101\"}\n    # device = {\"device\": \"DT\", \"min\": \"5000\", \"max\": \"5003\"}\n    # \"\"\"\n\n    # \"\"\"\n    # キーエンス\n    # network = {\"ip\": \"192.168.250.10\", \"port\": 5000}\n    # protocol = {\"manufacture\": \"keyence\", \"series\": \"7500\",\n    #             \"protocol\": \"slmp\", \"transport_layer\": \"tcp\", \"point_index\": None,\n    #             }\n    # # device = {\"device\": \"T_TS\", \"min\": \"100\", \"max\": \"115\"}  # decimal=10 bit\n    # device = {\"device\": \"DM\", \"min\": \"100\", \"max\": \"103\"}  # decimal=10 word\n    # # device = {\"device\": \"B\", \"min\": \"100\", \"max\": \"103\"}  # decimal=16 bit\n    # # device = {\"device\": \"W\", \"min\": \"100\", \"max\": \"115\"}  # decimal=16 word\n    # # device = {\"device\": \"M\", \"min\": \"100\", \"max\": \"103\"}  # decimal=1016 bit\n    # \"\"\"\n\n    # cmd = {\"cmd\": \"write\", \"data\": [1, 0, 0, 1], \"option\": \"\"}  # bit write\n    # cmd = {\"cmd\": \"write\", \"data\": [100, 1111,\n    #                                 22222, 33], \"option\": \"\"}  # word write\n    # cmd = {\"cmd\": \"write\", \"data\": \"abcd\", \"option\": \"\"}  # string word write\n    cmd = {\"cmd\": \"read\", \"data\": [], \"option\": \"\"}  # read\n    optional = {\n        # \"data_type\": None, or \"integer\",\n        # \"data_type\": \"string\",\n        # \"data_type\": \"time\",\n        # \"without_skip\": [\"503\", \"1001\"],\n        # \"data_code\": \"ascii\"  # \"binary\" or \"ascii\", default: \"binary\"\n    }\n    result = main(\n        network=network,\n        protocol=protocol,\n        device=device,\n        cmd=cmd,\n        optional=optional\n    )\n    logger.info(result)\n    print(result)\n\n'''\n    動作確認\n        三菱 Q61P(iQ)\n            word device     int read        ...2022/12/16\n                                write       ...2022/12/16\n                            bit read        ...2022/12/16\n                                write\n                            str read        ...2022/12/16\n                                write       ...2022/12/16\n            bit device      bit read\n                                write\n\n        三菱 (iQ-R)\n            word device     int read\n                                write\n                            bit read\n                                write\n                            str read\n                                write\n            bit device      bit read\n                                write\n            double device   int read\n                                write\n                            bit read\n                                wirte\n                            str read\n                                write\n\n        キーエンス (KV-7000)\n        キーエンス (KV-Nano)\n\n        パナソニック (FP-7)\n            word device     int read    ...2022/12/19\n                                write\n                            bit read\n                                write\n                            str read\n                                write\n            bit device      bit read\n                                write\n\n'''\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\connection\\protocols\\smb": {
        "main.py": "import socket\nimport re\nimport io\nimport struct\nimport itertools\nfrom pydantic import BaseModel\nfrom typing import Pattern\nfrom itertools import groupby\nfrom operator import itemgetter\nimport platform\nimport polars\nimport datetime\n\nfrom smb.SMBConnection import SMBConnection\n\n\ndef try_except(data: dict, key: str, *, exception=None):\n    try:\n        return data[key]\n    except Exception:\n        return exception\n\n\nclass Connect():\n    def __init__(self, username, password, remote_name, domain):\n        my_name = platform.uname().node\n        print(f\"SMB CONNECTION: username: {username}, password: {password}, my_name: {my_name}, remote_name: {remote_name}, domain: {domain}\", )\n\n        self.conn = SMBConnection(\n            username=username,\n            password=password,\n            my_name=my_name,\n            remote_name=remote_name,\n            domain=domain,\n            # use_ntlm_v2=True,\n            # is_direct_tcp=True\n        )\n\n    def open(self, *, host: str = \"0.0.0.0\", port: int = 0, timeout=5):\n        \"\"\"\n            usernameやpasswordが間違っている場合はNotReadyError\n            remote_nameが間違っている場合はNotConnectedError\n            ipやportが間違っている場合はTimeoutError\n        \"\"\"\n        try:\n            conn = self.conn.connect(host, port, timeout=timeout)\n            self.__isopen = conn\n        except Exception as e:\n            self.message = str(e)\n            self.__isopen = False\n        return self.__isopen\n\n    def close(self):\n        if self.__isopen:\n            self.conn.close()\n\n    def __del__(self):\n        try:\n            self.conn.close()\n        except Exception as e:\n            print(e)\n\n    def is_open(self):\n        try:\n            return self.__isopen\n        except Exception:\n            return False\n\n    def get_filename_objects(self, service_name, path_name, *, host=\"0.0.0.0\", port=0):\n        if self.is_open is False:\n            self.__open(host=host, port=port)\n\n        _files = self.conn.listPath(service_name, path_name)\n        self.file_list = [{\n            \"filename\": f.filename,\n            \"filesize\": f.file_size,\n            \"last_write_time\": f.last_write_time\n        } for f in _files if f.isDirectory is False]\n        return self.file_list\n\n    def get_data(self, service_name, path_name, file_name):\n        with io.BytesIO() as file:\n            self.conn.retrieveFile(\n                service_name, path_name + file_name, file)\n            file.seek(0)\n            data = file.read().decode()\n        return data\n\n\ndef get_csv_data(conn, agg_data: dict, *, strage: list = [], mode: str = \"diff\"):\n    flg_getdata = False\n\n    share_name = try_except(agg_data, key=\"share_name\", exception=None)\n    path_name = try_except(agg_data, key=\"path\", exception=\"/\")\n    reg_filename = try_except(agg_data, key=\"regex_filename\", exception=\".*.csv\")\n    group_name = share_name + path_name + reg_filename\n\n    _fileobjs = conn.get_filename_objects(service_name=share_name, path_name=path_name)\n    fileobjs = [x for x in _fileobjs if re.findall(reg_filename, x[\"filename\"]) != []]\n\n    if fileobjs != []:\n        latest_fileobj = max(fileobjs, key=lambda x: x[\"last_write_time\"])\n        filename = latest_fileobj[\"filename\"]\n        filesize = latest_fileobj[\"filesize\"]\n\n        strage_fileobj = next((item for item in strage if item[\"group\"] == group_name), None)\n        if strage_fileobj is None:\n            strage.append({\"group\": group_name, \"filename\": filename, \"filesize\": filesize})\n\n        print(f\"========== MODE: {mode}, Strage: {strage}\")\n        if mode == \"diff\":\n            # ファイル名かファイルサイズが異なる場合データ取得\n            pre_filename = try_except(strage_fileobj, key=\"filename\")\n            pre_filesize = try_except(strage_fileobj, key=\"filesize\")\n            print(f\"===== {pre_filename}, {filename}, {pre_filesize}, {filesize}\")\n            if pre_filename != filename:\n                flg_getdata = True\n                strage = [{**item, \"filename\": filename, \"filesize\": filesize} if item[\"group\"] == group_name else item for item in strage]\n            else:\n                if pre_filesize != filesize:\n                    flg_getdata = True\n                    strage = [{**item, \"filename\": filename, \"filesize\": filesize} if item[\"group\"] == group_name else item for item in strage]\n        else:\n            flg_getdata = True\n            strage = [{**item, \"filename\": filename, \"filesize\": filesize} if item[\"group\"] == group_name else item for item in strage]\n\n        print(f\"FLAG: {flg_getdata}\")\n        if flg_getdata is True:\n            csv_data = conn.get_data(share_name, path_name, latest_fileobj[\"filename\"])\n            err = 0\n            message = \"success\"\n        else:\n            csv_data = None\n            err = 9999\n            message = \"skip\"\n    else:\n        csv_data = None\n        err = 10000\n        message = \"no file\"\n\n    result = {\n        \"data\": csv_data,\n        \"strage\": strage,\n        \"error\": err,\n        \"message\": message\n    }\n    print(f\"====== RESULT: {result}\")\n    return result\n\n\ndef main(configure: dict, *, strage: list = [], mode: str = \"diff\"):\n    print(configure)\n\n    conf_network = try_except(configure, key=\"network\")\n    ctrl_attr = try_except(try_except(configure, key=\"controller\"), key=\"attributes\")\n    conf_data = try_except(configure, key=\"data\")\n\n    # Sort data by the keys we want to group by\n    sorted_data = sorted(conf_data, key=itemgetter('share_name', 'path', 'regex_filename'))\n\n    # Group by 'share_name', 'path', 'regex_filename'\n    grouped_data = [\n        list(group) for _, group in groupby(sorted_data, key=itemgetter('share_name', 'path', 'regex_filename'))\n    ]\n\n    conn = Connect(\n        username=try_except(ctrl_attr, key=\"username\"),\n        password=try_except(ctrl_attr, key=\"password\"),\n        remote_name=try_except(ctrl_attr, key=\"remotename\"),\n        domain=try_except(ctrl_attr, key=\"domain\")\n    )\n\n    opened = conn.open(\n        host=try_except(conf_network, key=\"ip_address\"),\n        port=try_except(conf_network, key=\"port\")\n    )\n\n    error_info = [{\n        \"code\": 4339346,\n        \"message\": \"Unknown Error\"\n    }]\n    if opened is True:\n        for datas in grouped_data:\n            result = get_csv_data(conn, datas[0], strage=strage, mode=mode)\n\n            # エラーコードが0 = SUCCESS or 9999 = SKIP以外の時、エラーコードを出力\n            if result[\"error\"] in [0, 9999]:\n                error_info = None\n\n                if result[\"error\"] == 0:\n                    df = polars.read_csv(io.StringIO(result[\"data\"]))\n\n                    for data in datas:\n                        column_name = try_except(data, key=\"column_name\")\n                        if column_name:\n                            column = next((col for col in df.columns if col.lower().replace(\" \", \"\") == column_name.lower().replace(\" \", \"\")), None)\n                            if column:\n                                # last_row = df.tail(1)\n                                last_row = df.filter(df[column].is_not_null()).tail(1)\n\n                                # datetimeの値を取得\n                                datetime_value = last_row[\"datetime\"][0] if \"datetime\" in last_row.columns else None\n\n                                # dateとtimeの値を取得し結合\n                                date_value = last_row[\"date\"][0] if \"date\" in last_row.columns else \"\"\n                                time_value = last_row[\"time\"][0] if \"time\" in last_row.columns else \"\"\n                                combined_date_time = f\"{date_value} {time_value}\".strip()\n\n                                # yyyy/mm/ddとhh:mm:ssの値を取得し結合\n                                date_str = last_row[\"yyyy/mm/dd\"][0] if \"yyyy/mm/dd\" in last_row.columns else \"\"\n                                time_str = last_row[\"hh:mm:ss\"][0] if \"hh:mm:ss\" in last_row.columns else \"\"\n                                combined_date_time_str = f\"{date_str} {time_str}\".strip()\n\n                                # 値が存在する場合のみ返す\n                                timestamp = ((datetime_value or combined_date_time or combined_date_time_str).replace(\"/\", \"-\") or datetime.datetime.now().replace(microsecond=0))\n\n                                # print(f\"RESULT: {timestamp}, {datetime.datetime.now().replace(microsecond=0)}\")\n\n                                data[\"response\"] = last_row[column][0]\n                                data[\"response_datetime\"] = timestamp\n\n            else:\n                error_info = [{\n                    \"code\": result[\"error\"],\n                    \"message\": \"Not find file\"\n                }]\n    else:\n        error_info = [{\n            \"code\": 10060,\n            \"message\": \"Connection Error\"\n        }]\n        print(\"not opend\")\n\n    data_list = [item for sublist in grouped_data for item in sublist]\n    return {\n        \"data_list\": data_list,\n        \"error\": error_info,\n        \"strage\": strage\n    }\n\n\nif __name__ == '__main__':\n    configure = {\n        # 'network': {'ip_address': '10.66.64.197', 'port': 139},\n        'network': {'ip_address': '192.168.16.143', 'port': 139},\n        'controller': {\n            'type': 'PC', 'manufacturer': 'Microsoft', 'series': 'Windows10', 'protocol': 'SMB',\n            'attributes': {\n                'domain': 'JP', 'password': 'ncj46119', 'username': 'J100046119',\n                'directory': '/', 'remotename': 'N0013034'}},\n        'data': [\n            {\n                'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 5,\n                'datatype': 'Input', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n                'share_name': 'share', 'column_name': 'input', 'regex_filename': '20.*_SUS_1.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            {\n                'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 6,\n                'datatype': 'Output', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n                'share_name': 'share', 'column_name': 'output', 'regex_filename': '20.*_SUS_1.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            {\n                'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 7,\n                'datatype': 'Cycle time', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n                'share_name': 'share', 'column_name': 'cycletime', 'regex_filename': '20.*_SUS_1.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            {\n                'machine_id': 4, 'machine_no': 'ccc', 'controller_connection_id': 5, 'data_location_id': 8,\n                'datatype': 'Product Model', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n                'share_name': 'share', 'column_name': 'Model', 'regex_filename': '20.*_SUS_1.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            {\n                'machine_id': 5, 'machine_no': 'ddd', 'controller_connection_id': 5, 'data_location_id': 9,\n                'datatype': 'Input', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n                'share_name': 'share', 'column_name': 'input', 'regex_filename': '20.*_SUS_2.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n            {\n                'machine_id': 5, 'machine_no': 'ddd', 'controller_connection_id': 5, 'data_location_id': 10,\n                'datatype': 'Output', 'record_table': 't_record_count', 'method': 'datafile', 'path': '/',\n                'share_name': 'share', 'column_name': 'output', 'regex_filename': '20.*_SUS_2.csv',\n                'trigger': None, 'item': None, 'is_valid': True\n            },\n        ]\n    }\n    strage = []\n\n    result = main(configure=configure, strage=strage)\n    print(result)\n\n",
        "__init__.py": ""
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils": {
        "csv_manager.py": "# ===============================================================================\n# Name      : csv_managerpy\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-07-27 14:16\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport datetime\nimport os\nimport csv\n\nfrom pydantic import BaseModel\nfrom typing import Tuple, List\n\n\nFIELDNAMES: List[str] = [\n    'timestamp',\n    'judgement',\n    #'resolution',\n    'pixels',\n    'processing_time',\n    'x',\n    'y',\n    'z',\n    'r',\n    #'num_pieces',\n    'distance',\n    #'error_message'\n    'unit'\n]\n\n\nclass LabelList(BaseModel):\n    \"\"\"データフレームにアクセスする時に使うラベルリスト\"\"\"\n    timestamp: str = FIELDNAMES[0]\n    judgement: str = FIELDNAMES[1]\n    resolution: str = FIELDNAMES[2]\n    processing_time: str = FIELDNAMES[3]\n    x: str = FIELDNAMES[4]\n    y: str = FIELDNAMES[5]\n    z: str = FIELDNAMES[6]\n    r: str = FIELDNAMES[7]\n    num_pieces: str = FIELDNAMES[8]\n    error_message: str = FIELDNAMES[9]\n\n\nclass PositionData(BaseModel):\n    \"\"\"ワークの位置情報\"\"\"\n    x: float = 0.0\n    y: float = 0.0\n    z: float = 0.0\n    r: float = 0.0\n\n\nclass InspectionResults(BaseModel):\n    \"\"\"検査結果の情報\"\"\"\n    timestamp: str = '2000-01-01 12:00:00'  # NOTE: 検査時刻 YYYY-MM-DD HH:mm:SS\n    judgement: int = 1  # NOTE: 処理結果 OK:1, NG:2, ERR:3\n    resolution: str = '-'  # NOTE: 解像度\n    processing_time: float = 0.0  # NOTE: 処理時間\n    position: PositionData = PositionData()  # NOTE: ワークの位置\n    num_pieces: float = 0  # NOTE: ワークの数\n    message: str = ''  # NOTE: エラーメッセージ\n\n\nclass CSVHandler:\n    \"\"\"Inspection ResultsをCSVファイルに書き込むクラス\"\"\"\n    Labels = LabelList()\n\n    @staticmethod\n    def create_new_csv(filename: str) -> None:\n        \"\"\"Inspection ResultsをCSVファイルに書き込む\"\"\"\n        with open(filename, 'w', newline='') as csvfile:\n            writer = csv.DictWriter(csvfile, fieldnames=FIELDNAMES)\n            writer.writeheader()\n\n    @staticmethod\n    def add_data_to_csv(result: InspectionResults, filename: str) -> None:\n        \"\"\"Inspection ResultsをCSVファイルに書き込む\"\"\"\n        with open(filename, 'a', newline='') as csvfile:\n            writer = csv.DictWriter(f=csvfile, fieldnames=FIELDNAMES)\n            writer.writerow({\n                CSVHandler.Labels.timestamp: result.timestamp,\n                CSVHandler.Labels.judgement: result.judgement,\n                CSVHandler.Labels.resolution: result.resolution,\n                CSVHandler.Labels.processing_time: result.processing_time,\n                CSVHandler.Labels.x: result.position.x,\n                CSVHandler.Labels.y: result.position.y,\n                CSVHandler.Labels.z: result.position.z,\n                CSVHandler.Labels.r: result.position.r,\n                CSVHandler.Labels.num_pieces: result.num_pieces,\n                CSVHandler.Labels.error_message: result.message\n            })\n\n\nclass CsvLogManager:\n    def __init__(self, mount_dir: str):\n        # NOTE: 各フォルダのフォーマット\n        self.year_format = '%Y'\n        self.month_format = '%Y-%m'\n        self.day_format = '%Y-%m-%d'\n\n        # NOTE: 年フォルダの上位フォルダ\n        self.mount_dir = mount_dir\n        # NOTE: 時間比較用\n        self.bottom_folder_name = ''\n        # NOTE: CSV保存フォルダ(YYYY/YYYY-MM/yyyy-mm-dd.csv)\n        self.csv_dir = ''\n        # NOTE: 初期化処理\n        self.initialize_folders()\n\n    def _create_datetime_strings(self) -> Tuple[str, str, str]:\n        \"\"\"日付データを生成\"\"\"\n        now = datetime.datetime.now()\n        y_str = now.strftime(self.year_format)\n        m_str = now.strftime(self.month_format)\n        d_str = now.strftime(self.day_format)\n        return y_str, m_str, d_str\n\n    def _get_bottom_folder_name(self) -> str:\n        \"\"\"yyyy-mm-ddの文字列取得\"\"\"\n        now = datetime.datetime.now()\n        bf_str = now.strftime(self.month_format)\n        return bf_str\n\n    def _get_csv_name(self) -> str:\n        \"\"\"画像の保存名を取得\"\"\"\n        now = datetime.datetime.now()\n        t_str = now.strftime('%Y_%m_%d')\n        return t_str\n\n    def get_timestamp(self) -> str:\n        now = datetime.datetime.now()\n        t_str = now.strftime('%Y-%m-%d %H:%M:%S')\n        return t_str\n\n    def initialize_folders(self) -> None:\n        \"\"\"初期化処理\"\"\"\n        y_str, m_str, _ = self._create_datetime_strings()\n        self.bottom_folder_name = m_str\n        self.csv_dir = os.path.join(self.mount_dir, y_str, m_str)\n\n        # NOTE: フォルダが無ければ再帰的に作成\n        if not os.path.exists(self.csv_dir):\n            os.makedirs(self.csv_dir)\n\n        # NOTE: CSVのパスを取得\n        csvname = self._get_csv_name()\n        csv_path = os.path.join(self.mount_dir, y_str, m_str, f'{csvname}.csv')\n\n        # NOTE: CSVが存在しない場合、ヘッダーをつけて作成\n        if not os.path.exists(csv_path):\n            CSVHandler.create_new_csv(csv_path)\n\n    def update_date(self) -> None:\n        \"\"\"日付フォルダのアップデート\"\"\"\n\n        # NOTE: 最下層のフォーマット形式で時刻を比較\n        bf_name = self._get_bottom_folder_name()\n        if bf_name == self.bottom_folder_name:\n            return\n        # NOTE: 画像保存フォルダを更新\n        self.initialize_folders()\n\n    def save_csv(self, data: InspectionResults) -> None:\n        \"\"\"画像の保存\"\"\"\n        csvname = self._get_csv_name()\n        path = os.path.join(self.csv_dir, f'{csvname}.csv')\n        CSVHandler.add_data_to_csv(data, path)\n\n\nif __name__ == \"__main__\":\n    # NOTE: テスト\n\n    # NOTE: インスタンス生成\n    csv_log_manager = CsvLogManager(r'C:\\Users\\J100048001\\Desktop\\log\\csv')\n\n    # NOTE: データ格納\n\n    now_time = csv_log_manager.get_timestamp()\n    data = InspectionResults(timestamp=now_time,\n                             judgement=1,\n                             processing_time=0.0,\n                             position=PositionData(x=0,\n                                                   y=0,\n                                                   r=0),\n                             num_pieces=1,\n                             error_message=''\n                             )\n\n    # NOTE: 書き込み\n    csv_log_manager.save_csv(data)\n\n    # NOTE: 日付更新\n    csv_log_manager.update_date()\n",
        "diagnosis.py": "# ===============================================================================\n# Name      : self.diagnosis.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2024-01-10 09:02\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport numpy as np\nimport cv2\nimport statistics\nfrom typing import Tuple, Any\nfrom utils.observer.status_monitor import get_raspberrypi_status\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef imshow(src):\n    import matplotlib.pyplot as plt\n    plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))\n    plt.show()\n\n\ndef calc_hist(img):\n    hist = cv2.calcHist([img], channels=[0], mask=None, histSize=[256], ranges=[0, 256])\n    hist = cv2.normalize(hist, hist, 0, 255, cv2.NORM_MINMAX)\n    hist = hist.squeeze(axis=-1)\n    return hist\n\n\ndef calc_rgb_hist(img, color: str = 'red'):\n    b, g, r = cv2.split(img)\n\n    if color == 'blue':\n        component = b\n    elif color == 'green':\n        component = g\n    else:\n        component = r\n\n    hist = calc_hist(component)\n    return hist\n\n\ndef calc_hsv_hist(img, element: str = 'hue'):\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    h, s, v = cv2.split(hsv)\n\n    if element == 'hue':\n        component = h\n    elif element == 'saturation':\n        component = s\n    else:\n        component = v\n\n    hist = calc_hist(component)\n    return hist\n\n\ndef hotelling_model(value: float,\n                    value_list: list,\n                    data_size: int,\n                    thresh: float = 8.5) -> bool:\n\n    # NOTE: 100% format or 1.0 format\n    # if thresh_percent > 1:\n    #     thresh_percent = thresh_percent / 100\n\n    # NOTE: 指定のデータサイズより多くなれば削除\n    value_list.append(valur)\n\n    if len(value_list) > data_size:\n        del value_list[0]\n    else:\n        logger.debug('There is not enough data.')\n        return True\n\n    # NOTE: 平均-分散\n    mean_v = statistics.mean(val_list[:-1])\n    variance = statistics.variance(val_list[:-1])\n\n    # NOTE: 異常スコア計算\n    try:\n        anomaly_score = (value - mean_v)**2 / variance\n    except ZeroDivisionError:\n        anomaly_score = (value - mean_v)**2 / 1\n    except Exception as e:\n        logger.error(f'{e}')\n        anomaly_score = (value - mean_v)**2 / 1\n\n    # threshold = stats.chi2.interval(alpha=per, df=1)[1]\n    threshold = 8.5\n\n    # NOTE: 異常判定\n    if anomaly_score > thresh:\n        logger.info('abnormal detected')\n        return False\n\n    return True\n\n\nclass VASTDiagnosis:\n    # NOTE: 異常検知システム with ホテリング理論\n    def __init__(self):\n        # ヒストグラム診断\n        self.similarity_th = 0.85\n        self.reference_hist = None\n        self.score_list = []\n        self.data_size = 100\n\n    def histgram_checker(self, frame: np.ndarray) -> Tuple[bool, float]:\n        # NOTE: 画像のヒストグラムで異常をチェック\n        img = frame.copy()\n\n        # NOTE: 計算量軽減のためリサイズ\n        img = cv2.resize(src=img, dsize=(640, 480))\n\n        # NOTE: ヒストグラム計算\n        hist = calc_hsv_hist(img, element='value')\n\n        # NOTE: 参照とするヒストグラムがなければreturn\n        if self.reference_hist is None:\n            self.reference_hist = hist\n            return True, 0.0\n\n        # NOTE: ヒストグラム類似度を使って異常度検知\n        score = cv2.compareHist(hist, self.reference_hist, cv2.HISTCMP_CORREL)\n        normal = hotelling_model(value=score,\n                                 value_list=self.score_list,\n                                 data_size=self.data_size)\n\n        if not normal:\n            return False, score\n\n        return True, score\n\n\nif __name__ == '__main__':\n    # hoge = np.zeros((300, 300, 3), dtype=np.uint8)\n    dia = SelfDiagnosis()\n    cap = cv2.VideoCapture(0)\n\n    _, frame = cap.read()\n    dia.set_reference_hist(frame)\n\n    while True:\n        _, frame = cap.read()\n        # dia.focus_checker(frame)\n        dia.hist_checker(frame)\n        cv2.imshow(\"jg\", frame)\n        cv2.waitKey(10)\n",
        "file_handler.py": "# ===============================================================================\n# Name      : file_handler.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2024-01-25 13:30\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport datetime\nimport cv2\nimport numpy as np\nimport json\nimport csv\nimport os\nimport shutil\nimport configparser\nfrom abc import ABCMeta\nfrom typing import Union, Tuple, Optional, Any\nimport difflib\nfrom pprint import pformat\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\nCHANGE_LOG = 'change_log.log'  # NOTE: 変更履歴\nOPERATION_HISTORY = 'operation_history.log'  # NOTE: 操作履歴\nSAVE_CHANGE_LOG = False\nSAVE_OPERATION_HISTORY = False\n\n\ndef to_string_lines(obj: Any) -> list:\n    \"\"\"dictのオブジェクトを文字列に変換&改行で分割したリストを返却\"\"\"\n    return pformat(obj).split('\\n')\n\n\ndef difference_check(dict1: dict, dict2: dict) -> str:\n    \"\"\"差分チェック\"\"\"\n    lines1 = to_string_lines(dict1)\n    lines2 = to_string_lines(dict2)\n    result = difflib.Differ().compare(lines1, lines2)\n    # print(result)\n    res_str = '\\n'.join(result)\n    res_list = res_str.split('\\n')\n    res_list = [v for v in res_list if ('+' in v) or ('-' in v) or ('?' in v)]\n    return '\\n'.join(res_list)\n\n\nclass FileHandlerABC(metaclass=ABCMeta):\n    def __init__(self, header: str):\n        self._header = header\n        # NOTE: private variable\n        self._old_config_dir: str = ''\n        self._old_config_list: list = []\n        self._error_state: bool = False\n        self._error_details: str = ''\n\n    def _set_error_state(self, msg: str = '') -> None:\n        if msg == '':\n            self._error_state = False\n            self._error_details = ''\n        else:\n            self._error_state = True\n            self._error_details = msg\n\n    @property\n    def error_state(self) -> bool:\n        return self._error_state\n\n    @property\n    def error_details(self) -> str:\n        return self._error_details\n\n    @property\n    def old_config_dir(self) -> str:\n        return self._old_config_dir\n\n    @old_config_dir.setter\n    def old_config_dir(self, modelname: str) -> None:\n        self._old_config_dir = os.path.join(self._header, f'.{modelname}')\n        print(f'Set old config dir:{self._old_config_dir}')\n        self._old_config_list = self._get_filelist(self._old_config_dir)\n\n    @property\n    def old_config_list(self) -> list:\n        self._old_config_list = self._get_filelist(self._old_config_dir)\n        return self._old_config_list\n\n    def _write_file(self,\n                    path: str,\n                    filetype: str,\n                    data: dict,\n                    mode: str = 'w',\n                    allow_user: bool = False) -> None:\n        \"\"\"ファイルの書き込み\n\n        Args:\n            path (str): _description_\n            filetype (str): json, log, csv\n            data (dict): _description_\n            mode (str, optional): w, a\n            allow_user (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        try:\n            with open(path, mode) as f:\n                if filetype == 'json':\n                    json.dump(data, f, indent=4)\n                elif filetype == 'log':\n                    f.write(data.get('message', 'nothing'))\n                elif filetype == 'csv':\n                    writer = csv.writer(f, lineterminator='\\n')\n                    # writer.writerow([data[k] for k, v in data.items()])\n                    writer.writerow([v for v in data.values()])\n                self._set_error_state()\n        except Exception as e:\n            logger.error(str(e))\n            self._set_error_state(str(e))\n            return\n\n        if allow_user:\n            os.chmod(path, 0o777)\n\n    def _read_file(self, path: str, filetype: str) -> Union[dict, None]:\n        \"\"\"ファイルの読込\n\n        Args:\n            path (str): _description_\n            filetype (str): json, log, csv\n\n        Returns:\n            Union[dict, None]: _description_\n        \"\"\"\n        try:\n            with open(path, 'r') as f:\n                if filetype == 'json':\n                    data = json.load(f)\n                elif filetype == 'ini':\n                    data = configparser.ConfigParser()\n                    data.read_file(f)\n                self._set_error_state()\n                return data\n\n        except Exception as e:\n            logger.error(str(e))\n            self._set_error_state(str(e))\n            return None\n\n    def _delete_file(self, path: str) -> bool:\n        try:\n            os.remove(path)\n            self._set_error_state()\n            return True\n        except Exception as e:\n            logger.error(str(e))\n            self._set_error_state(str(e))\n            return False\n\n    def _save_image(self, path: str, img: np.ndarray) -> None:\n        ret = cv2.imwrite(path, img)\n        if ret:\n            return\n        else:\n            self.error_type = \"Write image Error\"\n            self.message = 'path:' + path\n            self.is_usb_inserted = False\n\n    def _check_file_exist(self, path: str) -> bool:\n        ret = os.path.exists(path)\n        return ret\n\n    def _get_filelist(self, path: str) -> list:\n        filelist = []\n        try:\n            print(f'Try to get file list from:{path}')\n            filelist = os.listdir(path)\n        except Exception as e:\n            print(e)\n            filelist = []\n\n        return filelist\n\n    def _make_dir(self, path: str, allow_user: bool = False) -> None:\n        try:\n            if os.path.exists(path):\n                print(f'Already exist:{path}')\n            else:\n                print(f'Try to make dir:{path}')\n                os.makedirs(path, exist_ok=True)\n        except Exception as e:\n            self.error_type = \"Make dir Error\"\n            self.message = 'path:' + path + '\\n' + str(e)\n        else:\n            if allow_user:\n                os.chmod(path, 0o777)\n\n    def _copy_file(self, path_from: str, path_to: str) -> None:\n        try:\n            print('Try to copy file')\n            print(f'original:{path_from}')\n            print(f'copy:{path_to}')\n            shutil.copyfile(path_from, path_to)\n        except Exception as e:\n            self.error_type = \"Copy Error\"\n            self.message = f'path from:{path_from}\\npath to:{path_to}\\n' + str(e)\n            self.is_usb_inserted = False\n        else:\n            os.chmod(path_to, 0o777)\n\n    def _copy_folder(self, path_from: str, path_to: str) -> None:\n        try:\n            shutil.copytree(path_from, path_to)\n        except Exception as e:\n            self.error_type = \"Copy Error\"\n            self.message = f'path from:{path_from}\\npath to:{path_to}\\n' + str(e)\n            print(self.message)\n            self.is_usb_inserted = False\n        else:\n            os.chmod(path_to, 0o777)\n\n    def _save_change_log(self, time: str, diff: str) -> None:\n        if SAVE_CHANGE_LOG:\n            data = dict(message=f'{time}\\n{diff}\\n')\n            path = os.path.join(self._header, CHANGE_LOG)\n            self._write_file(path, 'log', data, 'a', True)\n\n    def _create_datetime_str(self) -> Tuple[str, str, str, str]:\n        # NOTE: 日付データを一括生成\n        now = datetime.datetime.now()\n        year = now.strftime('%Y')\n        month = now.strftime('%Y_%m')\n        day = now.strftime('%Y_%m_%d')\n        time = now.strftime('%Y_%m_%d_%H_%M_%S')\n        return year, month, day, time\n\n    def _get_current_time(self) -> str:\n        now = datetime.datetime.now()\n        return now.strftime('%Y-%m-%d-%H-%M-%S-%f')[:-3]\n\n\nclass FileHandler(FileHandlerABC):\n\n    def __init__(self, header: str):\n        super().__init__(header=header)\n\n    def set_header(self, header: str) -> None:\n        self._header = header\n\n    def log_message(self, modelname: str, mode: str, path: str, stat: str = '') -> str:\n        _, _, _, current_time = self._create_datetime_str()\n        return f'{current_time}, {modelname}, {mode}, {path}, {stat}\\n'\n\n    def save_operation_history(self, path: str,\n                               history_path: str,\n                               modelname: str, operation: str,\n                               msg: str = '',\n                               mode: str = 'a'):\n        if SAVE_OPERATION_HISTORY:\n            message = self.log_message(modelname, operation, path, msg)\n            self._write_file(path=history_path,\n                             filetype='log',\n                             mode=mode,\n                             data=dict(message=message))\n\n    def create_image_folder(self, basedir: str) -> str:\n        # NOTE: directory layer '%Y/%Y-%m/%Y-%m-%d'\n        _year, _month, _day, _ = self._create_datetime_str()\n        dirpath = os.path.join(basedir, _year, _month, _day)\n        ret = self._check_file_exist(dirpath)\n        if not ret:\n            self._make_dir(dirpath, allow_user=True)\n        return dirpath\n\n    def create_log_folder(self, basedir: str) -> str:\n        # NOTE: directory layer '%Y/%Y-%m/'\n        _year, _month, _, _ = self._create_datetime_str()\n        dirpath = os.path.join(basedir, _year, _month)\n        ret = self._check_file_exist(dirpath)\n        if not ret:\n            self._make_dir(dirpath, allow_user=True)\n        return dirpath\n\n    def create_csv_file(self, path: str, data_items: dict = {}) -> str:\n        ret = self._check_file_exist(path)\n        if not ret:\n            self._write_file(path, 'csv', data_items)\n\n        return path\n\n    # def check_exist_and_copy_config(self, path_from: str, path_to: str) -> None:\n    #     ret = self._check_file_exist(path_to)\n    #     if not ret:\n    #         self._make_dir(path_to, allow_user=True)\n    #         dirname = os.path.basename(os.path.dirname(path_from))\n    #         self._copy_folder(path_from, os.path.join(path_to, dirname))\n\n    def create_new_file(self, fpath: str, data: dict) -> None:\n        \"\"\"ファイル生成\"\"\"\n        self._write_file(path=fpath, filetype='json', data=data)\n\n    def load_config(self, path: str, modelname: str, *,\n                    key: str = \"\", no_log: bool = False) -> Optional[dict]:\n        data = self._read_file(path=path, filetype='json')\n        if no_log:\n            return data\n\n        history_path = os.path.join(self._header, OPERATION_HISTORY)\n\n        if data is None:\n            # NOTE: データがない時、エラー内容を記載\n            self.save_operation_history(path=path,\n                                        history_path=history_path,\n                                        modelname=modelname,\n                                        operation='load',\n                                        msg=self._error_details,\n                                        )\n            # message = self.log_message(modelname, 'load', path, self._error_details)\n            # self._write_file(path=path,\n            #                  filetype='log',\n            #                  mode='a',\n            #                  data=dict(message=message))\n        else:\n            # NOTE: データがあるけどkeyがない時\n            if key != \"\":\n                data = data.get('key', None)\n                if data is None:\n                    self.save_operation_history(path=path,\n                                                history_path=history_path,\n                                                modelname=modelname,\n                                                operation='load',\n                                                msg='no keyword')\n                    # message = self.log_message(modelname, 'load', path, 'no keyword')\n                    # self._write_file(path=path,\n                    #                  filetype='log',\n                    #                  mode='a',\n                    #                  data=dict(message=message))\n                    return None\n\n            self.save_operation_history(path=path,\n                                        history_path=history_path,\n                                        modelname=modelname,\n                                        operation='load')\n            # message = self.log_message(modelname, 'load', path)\n            # self._write_file(path=path,\n            #                  filetype='log',\n            #                  mode='a',\n            #                  data=dict(message=message))\n\n        return data\n\n    def save_config(self, path: str, modelname: str, new_param: dict) -> bool:\n        old_param = self.load_config(path, modelname, no_log=True)\n        if old_param is None:\n            return False\n        history_path = os.path.join(self._header, OPERATION_HISTORY)\n        try:\n            # NOTE: 差分があれば履歴保存\n            ret = self.save_config_change_log(modelname, new_param, old_param)\n            if ret:\n                # NOTE: 差分があればパラメータ更新\n                self._write_file(path=path, filetype='json', data=new_param)\n                # NOTE: 操作履歴\n                self.save_operation_history(path=path,\n                                            history_path=history_path,\n                                            modelname=modelname,\n                                            operation='save')\n                # message = self.log_message(modelname, 'save', path)\n                # self._write_file(path=history_path,\n                #                  filetype='log',\n                #                  mode='a',\n                #                  data=dict(message=message))\n        except Exception as e:\n            logger.error(str(e))\n            # NOTE: save operation history\n            self.save_operation_history(path=path,\n                                        history_path=history_path,\n                                        modelname=modelname,\n                                        operation='save',\n                                        msg=self._error_details)\n            # message = self.log_message(modelname, 'save', path, self._error_details)\n            # self._write_file(path=history_path,\n            #                  filetype='log',\n            #                  mode='a',\n            #                  data=dict(message=message))\n            return False\n\n        return True\n\n    def save_config_change_log(self,\n                               modelname: str,\n                               new_param: dict,\n                               old_param: dict) -> bool:\n\n        # NOTE: フォルダの有り無し確認.無ければ生成.\n        self.old_config_dir = modelname\n        ret = self._check_file_exist(self.old_config_dir)\n        if not ret:\n            self._make_dir(self.old_config_dir, allow_user=True)\n\n        # NOTE: 差分チェック\n        diff_str = difference_check(old_param, new_param)\n\n        # NOTE: 差分があった場合(Save Setteingsの空押しに対応)\n        if diff_str != '':\n            _, _, _, _time = self._create_datetime_str()\n\n            self._save_change_log(_time, diff_str)\n\n            _old_config = os.path.join(self._old_config_dir, f'{_time}.json')\n\n            self._write_file(path=_old_config, filetype='json', data=new_param)\n\n            ret = self._check_file_exist(self._old_config_dir)\n            if ret:\n                self._old_config_list = self._get_filelist(self._old_config_dir)\n\n            # NOTE: 過去ログ5超えたらpop\n            if len(self._old_config_list) > 5:\n                self._old_config_list = sorted(self._old_config_list)\n                _path = os.path.join(self._old_config_dir, self._old_config_list[0])\n                self._delete_file(_path)\n            return True\n        else:\n            return False\n\n\nif __name__ == '__main__':\n    pass\n",
        "log_manager.py": "# ===============================================================================\n# Name      : log_manager.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-07-20 17:02\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport shutil\nimport datetime\nimport os\nfrom cv2 import imwrite, resize\nfrom numpy import ndarray\nfrom typing import Tuple\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass ImgLogManager:\n    GB_UNIT: int = 1073741824\n    ENABLE_HOUR: bool = False\n\n    def __init__(self, mount_dir: str):\n        self.capacity_th = int(1 * self.GB_UNIT)  # 1GB\n        # NOTE: 各フォルダのフォーマット\n        self.year_format = '%Y'\n        self.month_format = '%Y-%m'\n        self.day_format = '%Y-%m-%d'\n        self.hour_format = '%Y-%m-%d-%H'\n\n        # NOTE: 年フォルダの上位フォルダ\n        self.mount_dir = mount_dir\n        # NOTE: 時間比較用\n        self.bottom_folder_name = ''\n        # NOTE: 画像保存フォルダ\n        self.img_dir = ''\n        # NOTE: 初期化処理\n        self.initialize_folders()\n\n    def _create_datetime_strings(self) -> Tuple[str, str, str, str, str]:\n        \"\"\"日付データを生成\"\"\"\n        now = datetime.datetime.now()\n        y_str = now.strftime(self.year_format)\n        m_str = now.strftime(self.month_format)\n        d_str = now.strftime(self.day_format)\n        h_str = now.strftime(self.hour_format)\n        t_str = now.strftime('%Y_%m_%d_%H_%M_%S')\n        return y_str, m_str, d_str, h_str, t_str\n\n    def _get_bottom_folder_name(self) -> str:\n        \"\"\"yyyy-mm-dd-hhの文字列取得\"\"\"\n        now = datetime.datetime.now()\n        if self.ENABLE_HOUR:\n            bf_str = now.strftime(self.hour_format)\n        else:\n            bf_str = now.strftime(self.day_format)\n        return bf_str\n\n    def _get_current_time(self) -> str:\n        \"\"\"画像の保存名を取得\"\"\"\n        now = datetime.datetime.now()\n        t_str = now.strftime('%Y_%m_%d_%H_%M_%S')\n        return t_str\n\n    def initialize_folders(self) -> None:\n        \"\"\"初期化処理\"\"\"\n        y_str, m_str, d_str, h_str, _ = self._create_datetime_strings()\n        if self.ENABLE_HOUR:\n            self.bottom_folder_name = h_str\n            self.img_dir = os.path.join(self.mount_dir, y_str, m_str, d_str, h_str)\n        else:\n            self.bottom_folder_name = d_str\n            self.img_dir = os.path.join(self.mount_dir, y_str, m_str, d_str)\n\n        # NOTE: フォルダが無ければ再帰的に作成\n        if not os.path.exists(self.img_dir):\n            os.makedirs(self.img_dir)\n\n    def update_date(self) -> None:\n        \"\"\"日付フォルダのアップデート\"\"\"\n        bf_name = self._get_bottom_folder_name()\n        if bf_name == self.bottom_folder_name:\n            return\n        # NOTE: 画像保存フォルダを更新\n        self.initialize_folders()\n\n    def check_capacity(self) -> bool:\n        \"\"\"容量チェック\"\"\"\n        # NOTE: USBマウント先のフォルダがあるか確認\n        # NOTE: なかったら確認しない\n        if not os.path.exists(self.mount_dir):\n            return True\n\n        # NOTE: ストレージの情報を取得（byte）\n        _, _, free = shutil.disk_usage(self.mount_dir)\n        free_gb = round(free / self.GB_UNIT, 3)\n        logger.debug(f'Free memory: {free_gb}GB')\n\n        # NOTE: 残り容量が十分ある場合True\n        if free > self.capacity_th:\n            return True\n\n        return False\n\n    def get_oldest_date(self, date_list: list, date_format: str) -> Tuple[bool, str]:\n        \"\"\"最小の日付フォルダを返す\"\"\"\n        try:\n            date_list = [datetime.datetime.strptime(date_, date_format) for date_ in date_list]\n        except Exception:\n            # NOTE: フォーマットに沿わない名前のフォルダが存在しているとき\n            # 該当フォルダが含まれる上位フォルダを削除\n            return False, ''\n\n        if len(date_list) == 0:\n            # NOTE: フォルダが見つからない場合\n            return False, ''\n\n        old_date = min(date_list)\n        old_date_str = old_date.strftime(date_format)\n        return True, old_date_str\n\n    def remove_folder(self, folder_path: str) -> None:\n        \"\"\"フォルダを再帰的に削除\"\"\"\n        shutil.rmtree(folder_path)\n\n    def perform_cleanup(self) -> None:\n        \"\"\"削除のプロセス\"\"\"\n        # NOTE: 年フォルダを確認\n        year_dir = os.listdir(self.mount_dir)\n        ret, old_date = self.get_oldest_date(year_dir, self.year_format)\n\n        # NOTE: 月フォルダを確認\n        target_dir = os.path.join(self.mount_dir, old_date)\n        month_dir = os.listdir(target_dir)\n        ret, old_date = self.get_oldest_date(month_dir, self.month_format)\n        # NOTE: 空なら削除\n        if not ret:\n            self.remove_folder(target_dir)\n            return\n\n        # NOTE: 日フォルダを確認\n        target_dir = os.path.join(target_dir, old_date)\n        day_dir = os.listdir(target_dir)\n        ret, old_date = self.get_oldest_date(day_dir, self.day_format)\n        # NOTE: 空なら削除\n        if not ret:\n            self.remove_folder(target_dir)\n            return\n\n        if self.ENABLE_HOUR:\n            # NOTE: 時フォルダを確認\n            target_dir = os.path.join(target_dir, old_date)\n            day_dir = os.listdir(target_dir)\n            ret, old_date = self.get_oldest_date(day_dir, self.hour_format)\n            # NOTE: 空なら削除\n            if not ret:\n                self.remove_folder(target_dir)\n                return\n\n        # NOTE: フォルダを削除\n        self.remove_folder(os.path.join(target_dir, old_date))\n\n    def save_image(self, img: ndarray, tag: str = '',\n                   ext: str = 'jpg', vga: bool = False) -> None:\n        \"\"\"画像の保存\"\"\"\n        # NOTE: 別のところで行う\n        # self.update_date()\n        # if not self.check_capacity():\n        #     self.perform_cleanup()\n\n        t_str = self._get_current_time()\n        path = os.path.join(self.img_dir, f'{t_str}{tag}.{ext}')\n        if vga:\n            img = resize(img, (640, 480))\n        imwrite(path, img)\n\n\nif __name__ == \"__main__\":\n    # NOTE: テスト\n    import numpy as np\n\n    img_log_manager = ImgLogManager(r'C:\\Users\\J100048001\\Desktop\\rv_vast\\log\\img')\n\n    # NOTE: 画像保存\n    img = np.zeros(shape=(100, 100, 3), dtype=np.uint8)\n    img_log_manager.save_image(img)\n\n    # NOTE: 日付更新\n    img_log_manager.update_date()\n\n    # NOTE: 容量チェック\n    if not img_log_manager.check_capacity():\n        # NOTE: 削除\n        img_log_manager.perform_cleanup()\n",
        "path_manager.py": "# ===============================================================================\n# Name      : path_manager.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-12-08 09:35\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\nimport os\n\n# NOTE: IMAGE\nORIG_IMG = 'orig.bmp'\nTEMPL_IMG = 'templ.jpg'\nMASK_IMG = 'mask.png'\n# NOTE: JSON\nCAMERA_CFG = 'camera.json'\nPARAM_CFG = 'param.json'\nCALIB_CFG = 'calib_param.json'\nOPTION_CFG = 'option.json'\nPLC_CFG = 'plc.json'\nREC_CFG = 'last_used.json'\nPLC_ADDRESS_SHEET = 'vision_setting.xlsx'\n\n\nclass ConfigPath:\n    \"\"\"\n    -data\n        |-part1\n            |-model\n                |-modelA\n                    |-orig.bmp\n                    |-templ.jpg\n                    |-mask.png\n                    |-param.json\n                |-modelB\n                    |...\n            |-last_used.json\n        |-part2\n            |-model\n                |-...\n            |-last_used.json\n        |-common\n            |-camera.json\n            |-plc.json\n            |-option.json\n    -log\n        |-img\n            |-yyyy\n                |-yyyy-mm\n                    |-yyyy-mm-dd\n                        |-yyyy-mm-dd-hh-MM-ss.jpg\n        |-csv\n            |-yyyy\n                |-yyyy-mm\n                    |-yyyy-mm-dd.csv\n\n    \"\"\"\n\n    def __init__(self, header: str, modelname: str) -> None:\n        self._header = header  # NOTE: 部品の名前フォルダ(/data/xxx/)\n        self._model_header = os.path.join(header, 'model')\n        # self._common_header = os.path.join(header, 'common')\n        self._common_header = os.path.abspath(os.path.join(header, '../', 'common'))\n        self._modelname = modelname\n        # NOTE: IMAGE PATH\n        self._orig_img = os.path.join(self._model_header, modelname, ORIG_IMG)\n        self._templ_img = os.path.join(self._model_header, modelname, TEMPL_IMG)\n        self._mask_img = os.path.join(self._model_header, modelname, MASK_IMG)\n        # NOTE: JSON PATH\n        self._param_cfg = os.path.join(self._model_header, modelname, PARAM_CFG)\n        self._calib_cfg = os.path.join(self._model_header, modelname, CALIB_CFG)\n        self._camera_cfg = os.path.join(self._common_header, CAMERA_CFG)\n        self._option_cfg = os.path.join(self._common_header, OPTION_CFG)\n        self._plc_cfg = os.path.join(self._common_header, PLC_CFG)\n        self._last_used_cfg = os.path.join(header, REC_CFG)\n        # NOTE: LOG IMG DIR\n        self._log_img_dir = os.path.abspath(os.path.join(header, '../', '../', 'log', 'img'))\n        self._log_csv_dir = os.path.abspath(os.path.join(header, '../', '../', 'log', 'csv'))\n        # NOTE: EXCEL SHEET\n        self._plc_address_sheet = os.path.abspath(os.path.join(header, '../', PLC_ADDRESS_SHEET))\n        self.orig_plc_address_sheet = os.path.join('./', PLC_ADDRESS_SHEET)\n        # NOTE: EXPORT FILE\n        self.zip_program = os.path.abspath(os.path.join(header, '../', '../', 'program.zip'))\n        self.zip_config = os.path.abspath(os.path.join(header, '../', '../', 'config.zip'))\n        self.config_folder = os.path.abspath(os.path.join(header, '../', '../', 'data'))\n\n    def update(self, modelname: str) -> None:\n        self._modelname = modelname\n        # NOTE: IMAGE PATH\n        self._orig_img = os.path.join(self._model_header, modelname, ORIG_IMG)\n        self._templ_img = os.path.join(self._model_header, modelname, TEMPL_IMG)\n        self._mask_img = os.path.join(self._model_header, modelname, MASK_IMG)\n        # NOTE: JSON PATH\n        self._param_cfg = os.path.join(self._model_header, modelname, PARAM_CFG)\n        self._calib_cfg = os.path.join(self._model_header, modelname, CALIB_CFG)\n        self._camera_cfg = os.path.join(self._common_header, CAMERA_CFG)\n        self._option_cfg = os.path.join(self._common_header, OPTION_CFG)\n        self._plc_cfg = os.path.join(self._common_header, PLC_CFG)\n        self._last_used_cfg = os.path.join(self._header, REC_CFG)\n        # NOTE: EXCEL SHEET\n        self._plc_address_sheet = os.path.abspath(os.path.join(self._header, '../', PLC_ADDRESS_SHEET))\n        self.orig_plc_address_sheet = os.path.join('./', PLC_ADDRESS_SHEET)\n\n    def set_header(self, header: str) -> None:\n        \"\"\"モデルに依存しないパスはここで更新\"\"\"\n        self._header = header\n        self._model_header = os.path.join(header, 'model')\n        # self._common_header = os.path.join(header, 'common')\n        self._common_header = os.path.abspath(os.path.join(header, '../', 'common'))\n        self._log_img_dir = os.path.abspath(os.path.join(header, '../', '../', 'log', 'img'))\n        self._log_csv_dir = os.path.abspath(os.path.join(header, '../', '../', 'log', 'csv'))\n        # NOTE: EXPORT FILE\n        self.zip_program = os.path.abspath(os.path.join(header, '../', '../', 'program.zip'))\n        self.zip_config = os.path.abspath(os.path.join(header, '../', '../', 'config.zip'))\n        self.config_folder = os.path.abspath(os.path.join(header, '../', '../', 'data'))\n        self.update(self._modelname)\n\n    @property\n    def modelname(self) -> str:\n        return self._modelname\n\n    @property\n    def orig_img(self) -> str:\n        return self._orig_img\n\n    @property\n    def templ_img(self) -> str:\n        return self._templ_img\n\n    @property\n    def mask_img(self) -> str:\n        return self._mask_img\n\n    @property\n    def param_cfg(self) -> str:\n        return self._param_cfg\n\n    @property\n    def calib_cfg(self) -> str:\n        return self._calib_cfg\n\n    @property\n    def camera_cfg(self) -> str:\n        return self._camera_cfg\n\n    @property\n    def option_cfg(self) -> str:\n        return self._option_cfg\n\n    @property\n    def plc_cfg(self) -> str:\n        return self._plc_cfg\n\n    @property\n    def last_used_cfg(self) -> str:\n        return self._last_used_cfg\n\n    @property\n    def log_img_dir(self) -> str:\n        return self._log_img_dir\n\n    @property\n    def log_csv_dir(self) -> str:\n        return self._log_csv_dir\n\n    @property\n    def plc_address_sheet(self) -> str:\n        return self._plc_address_sheet\n\n\nclass PathManager(ConfigPath):\n    __version__ = '1.0.0'\n\n    def __init__(self, header: str, modelname: str) -> None:\n        super().__init__(header=header, modelname=modelname)\n\n    def update(self, modelname: str) -> None:\n        return super().update(modelname)\n\n    def set_header(self, header: str) -> None:\n        return super().set_header(header)\n\n\nif __name__ == '__main__':\n    pass\n",
        "status_recoder.py": "# ===============================================================================\n# Name      : status_recoder.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-12-20 09:41\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\nimport os\nimport psutil\nimport subprocess\nimport csv\nimport time\nfrom threading import Thread\nfrom datetime import datetime\nfrom pydantic import BaseModel\nfrom typing import List, Tuple\n\nFIELDNAMES: List[str] = [\n    'timestamp',\n    'cpu_usage',\n    'cpu_temp',\n    'mem_usage',\n    'mem_used',\n    'mem_free',\n    'clock',\n    'volts',\n]\n\n\nclass LabelList(BaseModel):\n    \"\"\"データフレームにアクセスする時に使うラベルリスト\"\"\"\n    timestamp: str = FIELDNAMES[0]\n    cpu_usage: str = FIELDNAMES[1]\n    cpu_temp: str = FIELDNAMES[2]\n    mem_usage: str = FIELDNAMES[3]\n    mem_used: str = FIELDNAMES[4]\n    mem_free: str = FIELDNAMES[5]\n    clock: str = FIELDNAMES[6]\n    volts: str = FIELDNAMES[7]\n\n\nclass SystemInfo(BaseModel):\n    timestamp: str = ''\n    cpu_usage: float = 0.0\n    cpu_temp: float = 0.0\n    mem_usage: float = 0.0\n    mem_used: float = 0.0\n    mem_free: float = 0.0\n    clock: float = 0.0\n    volts: float = 0.0\n\n\ndef run_shell_command(command_str: str) -> str:\n    # unit_list = ['\\'C', 'V', 'M']\n    if os.name == 'nt':\n        return '0'\n\n    try:\n        proc = subprocess.run(command_str, shell=True, stdin=subprocess.PIPE,\n                              stdout=subprocess.PIPE, text=True)\n        result = proc.stdout.split(\"=\")\n        # volts = result.decode(\"utf-8\").split(\"=\")[1].strip()\n        return result[1].replace('\\n', '')\n    except subprocess.CalledProcessError:\n        return '0'\n\n\ndef get_cpu_temp() -> float:\n    try:\n        res = run_shell_command(\"vcgencmd measure_temp\")\n        res = res.replace('\\'C', '')\n        cpu_temp = round(float(res), 1)\n        return cpu_temp\n    except Exception:\n        return 0.0\n\n\ndef get_cpu_volts() -> float:\n    try:\n        res = run_shell_command(\"vcgencmd measure_volts\")\n        res = res.replace('V', '')\n        volts = round(float(res), 1)\n        return volts\n    except Exception:\n        return 0.0\n\n\ndef get_cpu_clocks() -> float:\n    try:\n        res = run_shell_command(\"vcgencmd measure_clock arm\")\n        clocks = round(float(res), 1)\n        return clocks\n    except Exception:\n        return 0.0\n\n\ndef convert_bytes_unit(byte_size: float, mem_unit: str = 'B') -> float:\n    \"\"\"\n    Converts a byte size to the specified memory unit.\n    \"\"\"\n    mem_unit_list = ['B', 'K', 'M', 'G', 'T']\n    try:\n        index = mem_unit_list.index(mem_unit)\n    except Exception:\n        return byte_size\n\n    mem_size = byte_size\n    for _ in range(index):\n        mem_size = mem_size / 1024\n    return round(mem_size, 2)\n\n\ndef get_system_info(mem_unit: str = 'M') -> SystemInfo:\n    \"\"\"\n    システム情報を取得\n    \"\"\"\n    # NOTE: CPU使用率を取得\n    cpu_usage = psutil.cpu_percent(interval=1)\n    # NOTE: メモリ使用量を取得\n    mem_info = psutil.virtual_memory()\n\n    # NOTE: CPU温度\n    cpu_temp = get_cpu_temp()\n    clocks = get_cpu_clocks()\n    volts = get_cpu_volts()\n\n    return SystemInfo(\n        timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n        cpu_usage=cpu_usage,\n        cpu_temp=cpu_temp,\n        mem_used=convert_bytes_unit(byte_size=mem_info.used,\n                                    mem_unit=mem_unit),\n        mem_free=convert_bytes_unit(byte_size=mem_info.available,\n                                    mem_unit=mem_unit),\n        mem_usage=round(number=mem_info.used / mem_info.total * 100,\n                        ndigits=2),\n        clock=clocks,\n        volts=volts\n    )\n\n\nclass CSVHandler:\n    \"\"\"Inspection ResultsをCSVファイルに書き込むクラス\"\"\"\n    Labels = LabelList()\n\n    @staticmethod\n    def create_new_csv(filename: str) -> None:\n        \"\"\"Inspection ResultsをCSVファイルに書き込む\"\"\"\n        with open(filename, 'w', newline='') as csvfile:\n            writer = csv.DictWriter(csvfile, fieldnames=FIELDNAMES)\n            writer.writeheader()\n\n    @staticmethod\n    def add_data_to_csv(result: SystemInfo, filename: str) -> None:\n        \"\"\"Inspection ResultsをCSVファイルに書き込む\"\"\"\n        with open(filename, 'a', newline='') as csvfile:\n            writer = csv.DictWriter(f=csvfile, fieldnames=FIELDNAMES)\n            writer.writerow({\n                CSVHandler.Labels.timestamp: result.timestamp,\n                CSVHandler.Labels.cpu_usage: result.cpu_usage,\n                CSVHandler.Labels.cpu_temp: result.cpu_temp,\n                CSVHandler.Labels.mem_usage: result.mem_usage,\n                CSVHandler.Labels.mem_used: result.mem_used,\n                CSVHandler.Labels.mem_free: result.mem_free,\n                CSVHandler.Labels.clock: result.clock,\n                CSVHandler.Labels.volts: result.volts,\n            })\n\n\nclass CsvLogManager:\n    def __init__(self, mount_dir: str):\n        # NOTE: 各フォルダのフォーマット\n        self.year_format = '%Y'\n        self.month_format = '%Y-%m'\n        self.day_format = '%Y-%m-%d'\n\n        # NOTE: 年フォルダの上位フォルダ\n        self.mount_dir = mount_dir\n        # NOTE: 時間比較用\n        self.bottom_folder_name = ''\n        # NOTE: CSV保存フォルダ(YYYY/YYYY-MM/yyyy-mm-dd.csv)\n        self.csv_dir = ''\n        # NOTE: 初期化処理\n        self.initialize_folders()\n\n    def _create_datetime_strings(self) -> Tuple[str, str, str]:\n        \"\"\"日付データを生成\"\"\"\n        now = datetime.now()\n        y_str = now.strftime(self.year_format)\n        m_str = now.strftime(self.month_format)\n        d_str = now.strftime(self.day_format)\n        return y_str, m_str, d_str\n\n    def _get_bottom_folder_name(self) -> str:\n        \"\"\"yyyy-mm-ddの文字列取得\"\"\"\n        now = datetime.now()\n        bf_str = now.strftime(self.month_format)\n        return bf_str\n\n    def _get_csv_name(self) -> str:\n        \"\"\"画像の保存名を取得\"\"\"\n        now = datetime.now()\n        t_str = now.strftime('%Y_%m_%d')\n        return t_str\n\n    def get_timestamp(self) -> str:\n        now = datetime.now()\n        t_str = now.strftime('%Y-%m-%d %H:%M:%S')\n        return t_str\n\n    def initialize_folders(self) -> None:\n        \"\"\"初期化処理\"\"\"\n        y_str, m_str, _ = self._create_datetime_strings()\n        self.bottom_folder_name = m_str\n        self.csv_dir = os.path.join(self.mount_dir, y_str, m_str)\n\n        # NOTE: フォルダが無ければ再帰的に作成\n        if not os.path.exists(self.csv_dir):\n            os.makedirs(self.csv_dir)\n\n        # NOTE: CSVのパスを取得\n        csvname = self._get_csv_name()\n        csv_path = os.path.join(self.mount_dir, y_str, m_str, f'{csvname}.csv')\n\n        # NOTE: CSVが存在しない場合、ヘッダーをつけて作成\n        if not os.path.exists(csv_path):\n            CSVHandler.create_new_csv(csv_path)\n\n    def update_date(self) -> None:\n        \"\"\"日付フォルダのアップデート\"\"\"\n\n        # NOTE: 最下層のフォーマット形式で時刻を比較\n        bf_name = self._get_bottom_folder_name()\n        if bf_name == self.bottom_folder_name:\n            return\n        # NOTE: 画像保存フォルダを更新\n        self.initialize_folders()\n\n    def save_csv(self, data: SystemInfo) -> None:\n        \"\"\"画像の保存\"\"\"\n        csvname = self._get_csv_name()\n        path = os.path.join(self.csv_dir, f'{csvname}.csv')\n        CSVHandler.add_data_to_csv(data, path)\n\n\nclass StatusRecoder(Thread):\n    def __init__(self, csv_dir: str, period: int = 10):\n        super(StatusRecoder, self).__init__()\n        self.stop_trigger = False\n        self.period = period\n        self.sleep_time = 0.5\n        self.csv_lm = CsvLogManager(csv_dir)\n\n    def stop(self) -> None:\n        self.stop_trigger = True\n\n    def run(self) -> None:\n        counter: int = 0\n        counter_th: int = int(self.period / self.sleep_time)\n        while not self.stop_trigger:\n            counter += 1\n            if counter > counter_th:\n                # NOTE: データ取得\n                data = get_system_info()\n                # NOTE: 書き込み\n                self.csv_lm.save_csv(data)\n                # NOTE: 日付更新\n                self.csv_lm.update_date()\n                # NOTE: カウントを初期化\n                counter = 0\n            # NOTE: スリープ\n            time.sleep(0.5)\n\n\nif __name__ == \"__main__\":\n    # NOTE: テスト\n    thread = StatusRecoder(csv_dir=os.path.join(os.path.expanduser('~/Desktop'), 'csv_dir'),\n                           period=10)\n    thread.start()\n    try:\n        while True:\n            print('something to process')\n            time.sleep(1)\n    except KeyboardInterrupt:\n        print(\"\\nProgram has been finished\")\n\n    thread.stop()\n    thread.join()\n",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\camera": {
        ".gitignore": "Unsupported file type",
        "abc_camera.py": "# ===============================================================================\n# Name      : abc_camera.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-08-16 10:21\n# Copyirght 2022 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nfrom abc import ABCMeta, abstractmethod\nfrom pydantic import BaseModel\nfrom typing import List, Union, Tuple\n\n\nclass CameraParam(BaseModel):\n    sensor_mode: int = 0\n    width: int = 640\n    height: int = 480\n    raw_width: int = 2028\n    raw_height: int = 1520\n    framerate: float = 30.0\n    auto_exposure: bool = False\n    exposure_time: float = 15.0\n    analog_gain: float = 1.0\n    digital_gain: float = 1.0\n    auto_wb: bool = True\n    color_temperature: int = 5000\n    color_gain: List[float] = [1.0, 1.0]\n    focus: float = 1000\n    buffer_size: int = 1\n    flip: int = 0\n\n\nclass Camera(metaclass=ABCMeta):\n    \"\"\"基底カメラクラス\n\n    Args:\n        metaclass (_type_, optional): _description_. Defaults to ABCMeta.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    __version__ = '1.0.3'\n\n    def __init__(self):\n        self._alive: bool = False\n        self._error_message: str = 'camera error'\n        self.param = CameraParam()\n\n    def is_opened(self) -> bool:\n        return self._alive\n\n    def load_param(self, data: Union[dict, CameraParam]) -> None:\n        if isinstance(data, dict):\n            self.param = CameraParam(**data)\n        else:\n            self.param = data\n\n    def get_parameter(self, *, format: str = 'class'):\n        \"\"\"パラメータクラスから情報を取得(生データではない)\"\"\"\n        if format == 'class':\n            return self.param\n        else:\n            return self.param.dict()\n\n    @abstractmethod\n    def set_resolution(self):\n        \"\"\"解像度の設定\"\"\"\n        pass\n\n    def set_controls(self):\n        \"\"\"WB,SS,Gainの設定(一括で行いたい場合の関数)\"\"\"\n        # NOTE: 一括で設定が必要な場合に下三つの関数を無視して継承。\n        # そうでない場合は下三つの関数をそれぞれ継承しこの関数を無視する。\n        # set_controls\n        # = set_white_balance and set_exposure_time and set_camera_gain\n        pass\n\n    @abstractmethod\n    def set_white_balance(self):\n        \"\"\"ホワイトバランスの設定\"\"\"\n        pass\n\n    @abstractmethod\n    def set_exposure_time(self):\n        \"\"\"露光時間の設定\"\"\"\n        pass\n\n    @abstractmethod\n    def set_camera_gain(self):\n        \"\"\"ゲインの設定\"\"\"\n        pass\n\n    def set_parameter(self, data: Union[dict, CameraParam]):\n        self.load_param(data)\n        self.set_resolution()\n        self.set_controls()\n        self.set_exposure_time()\n        self.set_camera_gain()\n        self.set_white_balance()\n\n    @abstractmethod\n    def capture(self):\n        \"\"\"撮影\"\"\"\n        pass\n\n    def get_metadata(self):\n        \"\"\"カメラから生データを取得\"\"\"\n        pass\n\n    # NOTE: Define the getter\n    @property\n    def sensor_mode(self) -> int:\n        return self.param.sensor_mode\n\n    @sensor_mode.setter\n    def sensor_mode(self, value: int):\n        self.param.sensor_mode = value\n\n    @property\n    def resolution(self) -> Tuple[int, int]:\n        return (self.param.width, self.param.height)\n\n    @resolution.setter\n    def resolution(self, value: Tuple[int, int]):\n        self.param.width, self.param.height = value\n\n    @property\n    def raw_resolution(self) -> Tuple[int, int]:\n        return (self.param.raw_width, self.param.raw_height)\n\n    @raw_resolution.setter\n    def raw_resolution(self, value: Tuple[int, int]):\n        self.param.raw_width, self.param.raw_height = value\n\n    @property\n    def framerate(self) -> float:\n        return self.param.framerate\n\n    @framerate.setter\n    def framerate(self, value: float):\n        self.param.framerate = value\n\n    @property\n    def auto_exposure(self) -> bool:\n        return self.param.auto_exposure\n\n    @auto_exposure.setter\n    def auto_exposure(self, value: bool):\n        self.param.auto_exposure = value\n\n    @property\n    def exposure_time(self) -> float:\n        return self.param.exposure_time\n\n    @exposure_time.setter\n    def exposure_time(self, value: float):\n        self.param.exposure_time = value\n\n    @property\n    def analog_gain(self) -> float:\n        return self.param.analog_gain\n\n    @analog_gain.setter\n    def analog_gain(self, value: float):\n        self.param.analog_gain = value\n\n    @property\n    def digital_gain(self) -> float:\n        return self.param.digital_gain\n\n    @digital_gain.setter\n    def digital_gain(self, value: float):\n        self.param.digital_gain = value\n\n    @property\n    def auto_wb(self) -> bool:\n        return self.param.auto_wb\n\n    @auto_wb.setter\n    def auto_wb(self, value: bool):\n        self.param.auto_wb = value\n\n    @property\n    def color_temperature(self) -> int:\n        return self.param.color_temperature\n\n    @color_temperature.setter\n    def color_temperature(self, value: int):\n        self.param.color_temperature = value\n\n    @property\n    def color_gain(self) -> List[float]:\n        return self.param.color_gain\n\n    @color_gain.setter\n    def color_gain(self, value: List[float]):\n        self.param.color_gain = value\n\n    @property\n    def focus(self) -> float:\n        return self.param.focus\n\n    @focus.setter\n    def focus(self, value: float):\n        self.param.focus = value\n\n    @property\n    def buffer_size(self) -> int:\n        return self.param.buffer_size\n\n    @buffer_size.setter\n    def buffer_size(self, value: int):\n        self.param.buffer_size = value\n\n    @property\n    def flip(self) -> int:\n        return self.param.flip\n\n    @flip.setter\n    def flip(self, value: int):\n        self.param.flip = value\n\n    @property\n    def error_message(self) -> str:\n        return self._error_message\n",
        "base_camera_class.py": "# ===============================================================================\n# Name      : abc_camera.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-05-20 09:45\n# Copyirght 2022 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nfrom abc import ABCMeta, abstractmethod\nfrom pydantic import BaseModel\nfrom typing import List, Union, Tuple\n\n\nclass CameraConfiguration(BaseModel):\n    sensor_mode: int = 0\n    width: int = 640\n    height: int = 480\n    raw_width: int = 2028\n    raw_height: int = 1520\n    framerate: float = 30.0\n    auto_exposure: bool = False\n    exposure_time: float = 15.0\n    analog_gain: float = 1.0\n    digital_gain: float = 1.0\n    auto_wb: bool = True\n    color_temperature: int = 5000\n    color_gain: List[float] = [1.0, 1.0]\n    focus: float = 1000\n    buffer_size: int = 1\n    flip: int = 0\n\n\nclass BaseCameraCls(metaclass=ABCMeta):\n    \"\"\"基底カメラクラス\n\n    Args:\n        metaclass (_type_, optional): _description_. Defaults to ABCMeta.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n\n    __version__ = '1.0.3'\n\n    def __init__(self):\n        self._alive: bool = False\n        self._error_message: str = 'camera error'\n        self.param = CameraConfiguration()\n\n    def isOpened(self) -> bool:\n        return self._alive\n\n    def loadCameraConfiguration(self, data: Union[dict, CameraConfiguration]) -> None:\n        if isinstance(data, dict):\n            self.param = CameraConfiguration(**data)\n        else:\n            self.param = data\n\n    def getCameraConfiguration(self, *, format: str = 'class'):\n        \"\"\"パラメータクラスから情報を取得(生データではない)\"\"\"\n        if format == 'class':\n            return self.param\n        else:\n            return self.param.dict()\n\n    @abstractmethod\n    def setCameraResolution(self):\n        \"\"\"解像度の設定\"\"\"\n        pass\n\n    @abstractmethod\n    def setWhiteBalance(self):\n        \"\"\"ホワイトバランスの設定\"\"\"\n        pass\n\n    @abstractmethod\n    def setExposureTime(self):\n        \"\"\"露光時間の設定\"\"\"\n        pass\n\n    @abstractmethod\n    def setCameraGain(self):\n        \"\"\"ゲインの設定\"\"\"\n        pass\n\n    def setCameraControls(self):\n        \"\"\"WB,SS,Gainの設定(一括で行いたい場合の関数)\"\"\"\n        # NOTE: 一括で設定が必要な場合に下三つの関数を無視して継承。\n        # そうでない場合は下三つの関数をそれぞれ継承しこの関数を無視する。\n        # set_controls\n        # = set_white_balance and set_exposure_time and set_camera_gain\n        pass\n\n    def updateCameraConfiguration(self, data: Union[dict, CameraConfiguration]):\n        self.loadCameraConfiguration(data)\n        self.setCameraResolution()\n        self.setCameraControls()\n        self.setExposureTime()\n        self.setCameraGain()\n        self.setWhiteBalance()\n\n    @abstractmethod\n    def capture(self):\n        \"\"\"撮影\"\"\"\n        pass\n\n    def getMetaDataFromCamera(self):\n        \"\"\"カメラから生データを取得\"\"\"\n        pass\n\n    # NOTE: Define the getter\n    @property\n    def sensor_mode(self) -> int:\n        return self.param.sensor_mode\n\n    @sensor_mode.setter\n    def sensor_mode(self, value: int):\n        self.param.sensor_mode = value\n\n    @property\n    def resolution(self) -> Tuple[int, int]:\n        return (self.param.width, self.param.height)\n\n    @resolution.setter\n    def resolution(self, value: Tuple[int, int]):\n        self.param.width, self.param.height = value\n\n    @property\n    def raw_resolution(self) -> Tuple[int, int]:\n        return (self.param.raw_width, self.param.raw_height)\n\n    @raw_resolution.setter\n    def raw_resolution(self, value: Tuple[int, int]):\n        self.param.raw_width, self.param.raw_height = value\n\n    @property\n    def framerate(self) -> float:\n        return self.param.framerate\n\n    @framerate.setter\n    def framerate(self, value: float):\n        self.param.framerate = value\n\n    @property\n    def auto_exposure(self) -> bool:\n        return self.param.auto_exposure\n\n    @auto_exposure.setter\n    def auto_exposure(self, value: bool):\n        self.param.auto_exposure = value\n\n    @property\n    def exposure_time(self) -> float:\n        return self.param.exposure_time\n\n    @exposure_time.setter\n    def exposure_time(self, value: float):\n        self.param.exposure_time = value\n\n    @property\n    def analog_gain(self) -> float:\n        return self.param.analog_gain\n\n    @analog_gain.setter\n    def analog_gain(self, value: float):\n        self.param.analog_gain = value\n\n    @property\n    def digital_gain(self) -> float:\n        return self.param.digital_gain\n\n    @digital_gain.setter\n    def digital_gain(self, value: float):\n        self.param.digital_gain = value\n\n    @property\n    def auto_wb(self) -> bool:\n        return self.param.auto_wb\n\n    @auto_wb.setter\n    def auto_wb(self, value: bool):\n        self.param.auto_wb = value\n\n    @property\n    def color_temperature(self) -> int:\n        return self.param.color_temperature\n\n    @color_temperature.setter\n    def color_temperature(self, value: int):\n        self.param.color_temperature = value\n\n    @property\n    def color_gain(self) -> List[float]:\n        return self.param.color_gain\n\n    @color_gain.setter\n    def color_gain(self, value: List[float]):\n        self.param.color_gain = value\n\n    @property\n    def focus(self) -> float:\n        return self.param.focus\n\n    @focus.setter\n    def focus(self, value: float):\n        self.param.focus = value\n\n    @property\n    def buffer_size(self) -> int:\n        return self.param.buffer_size\n\n    @buffer_size.setter\n    def buffer_size(self, value: int):\n        self.param.buffer_size = value\n\n    @property\n    def flip(self) -> int:\n        return self.param.flip\n\n    @flip.setter\n    def flip(self, value: int):\n        self.param.flip = value\n\n    @property\n    def error_message(self) -> str:\n        return self._error_message\n",
        "hqcamera.py": "# ===============================================================================\n# Name      : picam_imx477.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-08-16 10:23\n# Copyirght 2022 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport cv2\nimport numpy as np\nimport time\nfrom pydantic import BaseModel\nfrom typing import Union, Tuple, Optional\nfrom picamera2 import Picamera2  # type: ignore\n\ntry:\n    from .abc_camera import Camera, CameraParam\nexcept Exception:\n    from abc_camera import Camera, CameraParam  # type: ignore\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nRES_HQ = [(1332, 990), (2028, 1080), (2028, 1520), (4056, 3040), (640, 480)]\nRES_16MP = [(1280, 720), (1920, 1080), (2328, 1748),\n            (3840, 2160), (4656, 3496)]\nRES_64MP = [(1280, 720), (1920, 1080), (2328, 1748),\n            (3840, 2160), (4656, 3496)]\n\n\nclass MetaData(BaseModel):\n    \"\"\"Picamera2から取得できるメタデータクラス\"\"\"\n    SensorTimestamp: int = -1\n    ExposureTime: int = -1\n    FocusFoM: int = -1\n    SensorTemperature: float = -1.0\n    ColourCorrectionMatrix: tuple\n    FrameDuration: int = -1\n    AeLocked: bool\n    AnalogueGain: float = -1.0\n    ColourGains: Tuple[float, float]\n    DigitalGain: float = -1.0\n    ColourTemperature: int = -1\n    Lux: float = -1.0\n    SensorBlackLevels: Tuple[int, int, int, int]\n    ScalerCrop: Tuple[int, int, int, int]\n\n\nclass HQCamera(Camera):\n    \"\"\"HQCameraの制御クラス\n\n    Args:\n        Camera (_type_): _description_\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.cam = Picamera2()\n\n    def __del__(self):\n        logger.info(\"call destructor\")\n        # NOTE: 念のため例外処理\n        try:\n            self.cleanup()\n        except Exception as e:\n            print(e)\n\n    @property\n    def focus_value(self) -> float:\n        return -1.0\n\n    @focus_value.setter\n    def focus_value(self, value: float) -> None:\n        pass\n\n    def _get_nearest_value(self, candidate_: list, val: float) -> int:\n        idx = np.abs(np.asarray(candidate_) - val).argmin()\n        return candidate_[idx]\n\n    def _calculate_fps(self, exposure_time: float) -> int:\n        candidate_ = [10, 15, 20, 25, 30, 45, 50, 60]\n        fps = 1 / (exposure_time * 2.0)\n        return self._get_nearest_value(candidate_, fps)\n\n    def cleanup(self) -> None:\n        if self.cam:\n            self.cam.close()\n\n    def reset_focus_value(self) -> None:\n        pass\n\n    def set_resolution(self) -> None:\n        # NOTE: CROP解像度\n        self.cam.still_configuration.size = self.resolution\n        self.cam.still_configuration.enable_lores()\n        # NOTE: RAW解像度\n        self.cam.still_configuration.enable_raw()\n        self.cam.still_configuration.raw.size = self.raw_resolution\n        self.cam.still_configuration.buffer_count = 1\n        # NOTE: stillモードで開始\n        self.cam.start('still')\n\n    def set_controls(self) -> None:\n        with self.cam.controls as controls:\n            if not self.auto_exposure:\n                controls.ExposureTime = int(self.exposure_time * 1000)\n                controls.AnalogueGain = self.analog_gain\n            if not self.auto_wb:\n                controls.ColourGains = self.color_gain\n\n    def set_exposure_time(self) -> None:\n        pass\n\n    def set_camera_gain(self) -> None:\n        pass\n\n    def set_white_balance(self) -> None:\n        pass\n\n    def initialize_camera(self, data: Union[dict, CameraParam]):\n        # NOTE: 解像度を変更する際、カメラを再定義する必要有\n        self.cleanup()\n        self.cam = Picamera2()\n        self.set_parameter(data)\n\n    def capture(self, counter: int = 2) -> Optional[np.ndarray]:\n        try:\n            array = self.cam.capture_array('main')\n            img = cv2.cvtColor(array, cv2.COLOR_BGR2RGB)\n            if self.flip == 1:\n                img = cv2.rotate(img, cv2.ROTATE_180)\n            return img\n        except Exception as e:\n            logger.error(str(e))\n            self._error_message = str(e)\n            if counter < 0:\n                return None\n            counter -= 1\n            return self.capture(counter=counter)\n\n    def get_metadata(self) -> MetaData:\n        metadata = self.cam.capture_metadata()\n        data = MetaData(**metadata)\n        return data\n\n\nif __name__ == '__main__':\n\n    RSL = [(1332, 990), (2028, 1080), (2028, 1520), (4056, 3040), (640, 480)]\n    # RSL = [(1280, 720), (1920, 1080), (2328, 1748), (3840, 2160), (4656, 3496)]\n    afcam = HQCamera()\n    data = {\n        \"sensor_mode\": 1,\n        \"width\": 640,\n        \"height\": 480,\n        \"raw_width\": 1280,\n        \"raw_height\": 720,\n        \"framerate\": 30.0,\n        \"auto_exposure\": False,\n        \"exposure_time\": 15,\n        \"analog_gain\": 1,\n        \"digital_gain\": 1,\n        \"auto_wb\": True,\n        \"color_temperature\": 5000,\n        \"color_gain\": [1.0, 1.0],\n        \"focus\": 1000,\n        \"buffer_size\": 1,\n        \"flip\": 0\n    }\n    afcam.set_parameter(data)\n    val = afcam.get_metadata()\n\n    while True:\n        t1 = time.time()\n        array = afcam.capture()\n        t2 = time.time()\n        print(round(t2 - t1, 4))\n        # print(array.shape[:2])\n        cv2.imshow('frame', array)\n        cv2.waitKey(10)\n",
        "picam_imx477.py": "import cv2\nimport numpy as np\nimport time\nfrom pydantic import BaseModel\nfrom typing import Union, Tuple, Optional\nfrom picamera2 import Picamera2  # type: ignore\nfrom .base_camera_class import BaseCameraCls, CameraConfiguration\n\n\nRES_HQ = [(1332, 990), (2028, 1080), (2028, 1520), (4056, 3040), (640, 480)]\nRES_16MP = [(1280, 720), (1920, 1080), (2328, 1748),\n            (3840, 2160), (4656, 3496)]\nRES_64MP = [(1280, 720), (1920, 1080), (2328, 1748),\n            (3840, 2160), (4656, 3496)]\n\n\nclass MetaData(BaseModel):\n    \"\"\"Picamera2から取得できるメタデータクラス\"\"\"\n    SensorTimestamp: int = -1\n    ExposureTime: int = -1\n    FocusFoM: int = -1\n    SensorTemperature: float = -1.0\n    ColourCorrectionMatrix: tuple\n    FrameDuration: int = -1\n    AeLocked: bool\n    AnalogueGain: float = -1.0\n    ColourGains: Tuple[float, float]\n    DigitalGain: float = -1.0\n    ColourTemperature: int = -1\n    Lux: float = -1.0\n    SensorBlackLevels: Tuple[int, int, int, int]\n    ScalerCrop: Tuple[int, int, int, int]\n\n\nclass PiCamIMX477(BaseCameraCls):\n    \"\"\"HQCameraの制御クラス\n\n    Args:\n        Camera (_type_): _description_\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.cam = Picamera2()\n\n    def __del__(self):\n        try:\n            self.cleanup()\n        except Exception as e:\n            print(e)\n\n    def _get_nearest_value(self, candidate_: list, val: float) -> int:\n        idx = np.abs(np.asarray(candidate_) - val).argmin()\n        return candidate_[idx]\n\n    def _calculate_fps(self, exposure_time: float) -> int:\n        candidate_ = [10, 15, 20, 25, 30, 45, 50, 60]\n        fps = 1 / (exposure_time * 2.0)\n        return self._get_nearest_value(candidate_, fps)\n\n    def cleanup(self) -> None:\n        if self.cam:\n            self.cam.close()\n\n    def reset_focus_value(self) -> None:\n        pass\n\n    def setCameraResolution(self) -> None:\n        # NOTE: CROP解像度\n        self.cam.still_configuration.size = self.resolution\n        self.cam.still_configuration.enable_lores()\n        # NOTE: RAW解像度\n        self.cam.still_configuration.enable_raw()\n        self.cam.still_configuration.raw.size = self.raw_resolution\n        self.cam.still_configuration.buffer_count = 1\n        # NOTE: stillモードで開始\n        self.cam.start('still')\n\n    def setCameraControls(self) -> None:\n        with self.cam.controls as controls:\n            if not self.auto_exposure:\n                controls.ExposureTime = int(self.exposure_time * 1000)\n                controls.AnalogueGain = self.analog_gain\n            if not self.auto_wb:\n                controls.ColourGains = self.color_gain\n\n    def setExposureTime(self):\n        return super().setExposureTime()\n\n    def setWhiteBalance(self):\n        return super().setWhiteBalance()\n\n    def setCameraGain(self):\n        return super().setCameraGain()\n\n    def initializeCamera(self, data: Union[dict, CameraConfiguration]):\n        # NOTE: 解像度を変更する際、カメラを再定義する必要有\n        self.cleanup()\n        self.cam = Picamera2()\n        self.updateCameraConfiguration(data)\n\n    def capture(self, counter: int = 2) -> Optional[np.ndarray]:\n        try:\n            array = self.cam.capture_array('main')\n            img = cv2.cvtColor(array, cv2.COLOR_BGR2RGB)\n            if self.flip == 1:\n                img = cv2.rotate(img, cv2.ROTATE_180)\n            return img\n        except Exception as e:\n            self._error_message = str(e)\n            if counter < 0:\n                return None\n            counter -= 1\n            return self.capture(counter=counter)\n\n    def getMetaDataFromCamera(self) -> MetaData:\n        metadata = self.cam.capture_metadata()\n        data = MetaData(**metadata)\n        return data\n\n\nif __name__ == '__main__':\n\n    RSL = [(1332, 990), (2028, 1080), (2028, 1520), (4056, 3040), (640, 480)]\n    # RSL = [(1280, 720), (1920, 1080), (2328, 1748), (3840, 2160), (4656, 3496)]\n    afcam = PiCamIMX477()\n    data = {\n        \"sensor_mode\": 1,\n        \"width\": 640,\n        \"height\": 480,\n        \"raw_width\": 1280,\n        \"raw_height\": 720,\n        \"framerate\": 30.0,\n        \"auto_exposure\": False,\n        \"exposure_time\": 15,\n        \"analog_gain\": 1,\n        \"digital_gain\": 1,\n        \"auto_wb\": True,\n        \"color_temperature\": 5000,\n        \"color_gain\": [1.0, 1.0],\n        \"focus\": 1000,\n        \"buffer_size\": 1,\n        \"flip\": 0\n    }\n    afcam.updateCameraConfiguration(data)\n    val = afcam.getMetaDataFromCamera()\n\n    while True:\n        t1 = time.time()\n        array = afcam.capture()\n        t2 = time.time()\n        print(round(t2 - t1, 4))\n        # print(array.shape[:2])\n        cv2.imshow('frame', array)\n        cv2.waitKey(10)\n",
        "raspi_camera.py": "from __future__ import print_function\nimport cv2\nimport numpy as np\nimport time\nfrom picamera import PiCamera, mmal, mmalobj, exc\nfrom picamera.array import PiRGBArray  # PiYUVArray\nfrom picamera.mmalobj import to_rational\n\nfrom typing import Optional\n\ntry:\n    from .abc_camera import Camera\nexcept Exception:\n    from abc_camera import Camera\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nMMAL_PARAMETER_ANALOG_GAIN = mmal.MMAL_PARAMETER_GROUP_CAMERA + 0x59\nMMAL_PARAMETER_DIGITAL_GAIN = mmal.MMAL_PARAMETER_GROUP_CAMERA + 0x5A\n\n\ndef set_gain(camera, gain, value):\n    \"\"\"Set the analog gain of a PiCamera.\n\n    camera: the picamera.PiCamera() instance you are configuring\n    gain: either MMAL_PARAMETER_ANALOG_GAIN or MMAL_PARAMETER_DIGITAL_GAIN\n    value: a numeric value that can be converted to a rational number.\n    \"\"\"\n    if gain not in [MMAL_PARAMETER_ANALOG_GAIN, MMAL_PARAMETER_DIGITAL_GAIN]:\n        raise ValueError(\"The gain parameter was not valid\")\n    ret = mmal.mmal_port_parameter_set_rational(camera._camera.control._port,\n                                                gain,\n                                                to_rational(value))\n    if ret == 4:\n        raise exc.PiCameraMMALError(ret, \"Are you running the latest version of the userland libraries? Gain setting was introduced in late 2017.\")\n    elif ret != 0:\n        raise exc.PiCameraMMALError(ret)\n\n\ndef set_analog_gain(camera, value):\n    \"\"\"Set the gain of a PiCamera object to a given value.\"\"\"\n    set_gain(camera, MMAL_PARAMETER_ANALOG_GAIN, value)\n\n\ndef set_digital_gain(camera, value):\n    \"\"\"Set the digital gain of a PiCamera object to a given value.\"\"\"\n    set_gain(camera, MMAL_PARAMETER_DIGITAL_GAIN, value)\n\n\nclass RaspiCamera(Camera):\n    def __init__(self):\n        super().__init__()\n        self.camera = PiCamera()\n\n    def __del__(self):\n        logger.info(\"call destructor\")\n        self.cleanup()\n\n    def _get_nearest_value(self, candidate_: list, val: float):\n        idx = np.abs(np.asarray(candidate_) - val).argmin()\n        return candidate_[idx]\n\n    def calculate_fps(self, exposure_time: float):\n        candidate_ = [10, 15, 20, 25, 30, 45, 50, 60]\n        fps = 1 / (exposure_time * 2.0)\n        return self._get_nearest_value(candidate_, fps)\n\n    def set_resolution(self):\n        self.camera.sensor_mode = self.sensor_mode\n        time.sleep(0.2)\n        self.camera.resolution = self.resolution\n\n    def set_exposure_time(self):\n        if self.auto_exposure:\n            exposure_mode = \"auto\"\n            self.camera.exposure_mode = exposure_mode\n        else:\n            exposure_mode = \"off\"\n            self.camera.exposure_mode = exposure_mode\n            exposure_time = int(self.exposure_time * 1000)\n            # fps value calculated from the shutter speed.\n            self.camera.framerate = self.calculate_fps(exposure_time)\n            time.sleep(0.2)\n            self.camera.shutter_speed = exposure_time\n            time.sleep(0.2)  # warming time\n\n    def set_camera_gain(self):\n        if not self.auto_exposure:\n            set_analog_gain(self.camera, self.analog_gain)\n            set_digital_gain(self.camera, self.digital_gain)\n\n    def set_white_balance(self):\n        if self.auto_wb:\n            awb_mode = 'auto'\n            self.camera.awb_mode = awb_mode\n        else:\n            awb_mode = 'off'\n            self.camera.awb_mode = awb_mode\n            self.camera.awb_gains = (self.color_gain[0],\n                                     self.color_gain[1])\n\n    def capture(self, counter: int = 2) -> Optional[np.ndarray]:\n        try:\n            with PiRGBArray(self.camera) as np_array:\n                self.camera.capture(np_array, 'rgb', use_video_port=True)\n                img = cv2.cvtColor(np_array.array, cv2.COLOR_BGR2RGB)\n                return img\n        except Exception as e:\n            logger.error(e)\n            if counter < 0:\n                return None\n            counter -= 1\n            return self.capture(counter=counter)\n\n    def reset_gain_level(self):\n        set_analog_gain(self.camera, 1.0)\n        set_digital_gain(self.camera, 1.0)\n\n    def check_camera_connection(self) -> bool:\n        check1 = (self.camera.analog_gain == 0)\n        check2 = (self.camera.digital_gain == 0)\n        if (check1 or check2):\n            return False\n        return True\n\n    def cleanup(self):\n        if self.camera:\n            self.camera.close()\n\n    def disp_param(self):\n        logger.info(\"< Picamera Parameter >\")\n        logger.info(f\"Resolution : {self.camera.resolution}\")\n        logger.info(f\"FrameRate  : {self.camera.framerate}\")\n        logger.info(f\"SensorMode : {self.camera.sensor_mode}\")\n        logger.info(f\"ExposeMode : {self.camera.exposure_mode}\")\n        logger.info(f\"Exposure   : {self.camera.shutter_speed}[us]\")\n        logger.info(f\"AWB Mode   : {self.camera.awb_mode}\")\n        logger.info(f\"AWB Gains  : {self.camera.awb_gains}\")\n        logger.info(f\"AnalogGain : {self.camera.analog_gain}\")\n        logger.info(f\"DigitalGain: {self.camera.digital_gain}\")\n\n\ndef _main():\n    rasp_cam = RaspiCamera()\n    data = dict(sensor_mode=1,\n                width=2592,\n                height=1944,\n                framerate=30.0,\n                auto_exposure=False,\n                exposure_time=15.0,\n                analog_gain=1.0,\n                digital_gain=1.0,\n                auto_wb=False,\n                color_temperature=5000,\n                color_gain=[1.0, 1.0],\n                focus=1000,\n                buffer_size=1\n                )\n\n    rasp_cam.set_parameter(data)\n    while True:\n        hoge = rasp_cam.capture()\n        cv2.imshow(\"jg\", hoge)\n        cv2.waitKey(10)\n\n\nif __name__ == '__main__':\n    _main()\n",
        "requirements.txt": "astroid==2.11.5\ncolorama==0.4.4\ndill==0.3.5.1\nisort==5.10.1\nlazy-object-proxy==1.7.1\nmccabe==0.7.0\nnumpy==1.21.6\nobject-detection==0.1\nopencv-python==4.5.5.64\nplatformdirs==2.5.2\npylint==2.13.9\ntomli==2.0.1\ntyped-ast==1.5.4\ntyping_extensions==4.2.0\nwrapt==1.14.1\n",
        "usb_camera.py": "# ===============================================================================\n# Name      : camera.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2022-06-21 11:03\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\n\nimport cv2\nimport numpy as np\nimport time\n# import sys\nimport subprocess\n\ntry:\n    from utils.camera.abc_camera import Camera\nexcept Exception:\n    from abc_camera import Camera\n\nfrom typing import Optional, Any, Tuple, Union\n\n\nclass USBCamera(Camera):\n\n    __version__ = '0.0.1'\n\n    def __init__(self, device_port: int = 0):\n        super().__init__()\n        self.cap = cv2.VideoCapture(device_port)\n\n    def __del__(self):\n        pass\n\n    def set_resolution(self):\n        width, height = self.resolution\n        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, width)\n        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, height)\n\n    def set_exposure_time(self):\n        return super().set_exposure_time()\n\n    def set_white_balance(self):\n        return super().set_white_balance()\n\n    def set_camera_gain(self):\n        return super().set_camera_gain()\n\n    def capture(self) -> Optional[np.ndarray]:\n        try:\n            ret, frame = self.cap.read()\n            ret, frame = self.cap.read()\n            if ret:\n                return frame\n            else:\n                print(\"[ERROR] Could not grab image...\")\n                return None\n        except Exception as e:\n            print(str(e))\n            return None\n\n\nclass CameraV4L(Camera):\n    __version__ = '0.0.1'\n\n    def __init__(self, device: Union[int, str]):\n        super().__init__()\n\n        if isinstance(device, int):\n            self.device = f'/dev/video{id}'\n        elif isinstance(device, str):\n            self.device = device\n\n        self.cap = cv2.VideoCapture(self.device, cv2.CAP_V4L2)\n\n        if self.cap.isOpened() is False:\n            raise IOError\n\n    def __del__(self):\n        print(\"call destructor\")\n        self.cap.release()\n\n    def set_resolution(self):\n        width, height = self.resolution\n        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)\n        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)\n        # self.cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('Y', 'U', 'Y', 'V'))\n        if self.auto_wb:\n            self.cap.set(cv2.CAP_PROP_AUTO_WB, 1)\n        else:\n            self.cap.set(cv2.CAP_PROP_AUTO_WB, 0)\n            self.cap.set(cv2.CAP_PROP_WB_TEMPERATURE, self.color_temperature)\n\n        self.cap.set(cv2.CAP_PROP_FPS, self.framerate)\n        self.cap.set(cv2.CAP_PROP_BUFFERSIZE, self.buffer_size)\n\n    def set_white_balance(self):\n        if self.auto_wb:\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            'white_balance_temperature_auto=1'])\n        else:\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            'white_balance_temperature_auto=0'])\n            time.sleep(0.5)  # warming time\n\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            f'white_balance_temperature={self.color_temperature}'])\n\n    def set_exposure_time(self):\n        if self.auto_exposure:\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            'exposure_auto=1'])\n        else:\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            'exposure_auto=0'])\n            time.sleep(0.5)  # warming time\n\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            f'exposure_absolute={self.exposure_time*10}'])\n            time.sleep(0.5)  # warming time\n\n    def set_camera_gain(self):\n        if self.auto_exposure:\n            subprocess.run(['v4l2-ctl',\n                            '--device',\n                            self.device,\n                            '-c',\n                            f'gain={self.analog_gain}'])\n            time.sleep(0.5)  # warming time\n\n    def capture(self) -> Optional[np.ndarray]:\n        try:\n            ret, frame = self.cap.read()\n            ret, frame = self.cap.read()\n            if ret:\n                return frame\n            else:\n                print(\"[ERROR] Could not grab image...\")\n                return None\n        except Exception as e:\n            print(str(e))\n            return None\n\n\nif __name__ == \"__main__\":\n    cam = USBCamera()\n    print(cam.__version__)\n    data = dict(sensor_mode=1, height=720, width=1280)\n    cam.set_parameter(data)\n\n    print(cam.get_metadata())\n\n    frame = cam.capture()\n\n    cv2.imshow('www', frame)\n    cv2.waitKey(0)\n",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\debug": {
        "md_profiler.py": "import cProfile\nimport pstats\nimport io\nfrom datetime import datetime\n\n\ndef get_profile_data(profiler: cProfile.Profile, rank: int = 25) -> str:\n    \"\"\"関数ごとの処理時間の記録\n\n    Args:\n        profiler (cProfile.Profile): _description_\n        rank (int, optional): _description_. Defaults to 25.\n\n    Returns:\n        str: _description_\n    \"\"\"\n    buf = io.StringIO()\n    sortby = pstats.SortKey.CUMULATIVE\n    ps = pstats.Stats(profiler, stream=buf)\n\n    # NOTE: ソート処理\n    ps.strip_dirs()\n    ps.sort_stats(sortby)\n    ps.print_stats(rank)\n    # ps.strip_dirs().sort_stats(sortby).print_stats(rank)\n\n    data = buf.getvalue()\n    data = 'ncalls' + data.split('ncalls')[-1]\n    data = '\\n'.join([','.join(line.rstrip().split(None, 5)) for line in data.split('\\n')])\n    return data\n\n\ndef record_data(data: str) -> None:\n    _now = datetime.now()\n    filename = _now.strftime('%Y%m%d_%H%M%S')\n\n    with open('./tact/' + filename + '.csv', 'w+') as f:\n        # f=open(result.rsplit('.')[0]+'.csv','w')\n        f.write(data)\n        f.close()\n\n\nif __name__ == '__main__':\n    pr = cProfile.Profile()\n    pr.enable()\n    # ... do something ...\n    pr.disable()\n    data = get_profile_data(pr)\n    record_data(data)\n",
        "post_err_by_google.py": "# ===============================================================================\n# Name      : post_err_by_google.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2021-12-23 15:09\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\n\nimport requests\nimport time\nimport json\n\n\nclass Request2GoogleChat():\n    def __init__(self):\n        # self.url = \"https://chat.googleapis.com/v1/spaces/AAAA5hMEFpA/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=QGpiMZaRnB1q0r4ijclX5ckihn1m_baHN6jx0k52Ijs%3D\"\n        self.url = 'https://chat.googleapis.com/v1/spaces/AAAA5hMEFpA/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=QGpiMZaRnB1q0r4ijclX5ckihn1m_baHN6jx0k52Ijs%3D'\n\n        self.headers = {\"Content-Type\": \"application/json\"}\n\n    def post_data(self, obj: dict = None, text: str = ''):\n        if obj is None:\n            obj = {'text': text}\n        response = requests.post(self.url, data=json.dumps(obj), headers=self.headers)\n        return response.text\n\n\nclass Request2GoogleForm():\n    def __init__(self):\n        self.url = \"https://docs.google.com/forms/u/0/d/e/1FAIpQLSfH8qtSLRtbKQ6vGW5U3amFkAXxGjI393-5yC_LNWAuRLj13A/formResponse\"\n\n    def post_form(self):\n        params = {\n            'entry.815011211': 3,\n            'entry.1750047047': 5,\n        }\n        r = requests.get(self.url, params=params)\n        print(r.url)\n        print(r.status_code)\n\n\nclass Request2GoogleSpreadSheet():\n    def get_item(self):\n        obj = {'key': 'header'}\n        response = requests.get(self.url, params=obj, headers=self.headers)\n        item_lst = response.json()[0]\n        return item_lst\n\n    def __init__(self, url=None, header=None):\n        if url is not None:\n            self.url = url\n        else:\n            self.url = \"https://script.google.com/macros/s/AKfycbzUEe8lU-Mr6-y0MZD83fCHIGs9ufUG5NJI4R8XZIgZWerzex_yinmD7wXbO7SgasIGxw/exec\"\n\n        if header is not None:\n            self.header = header\n        else:\n            self.headers = {\"Content-Type\": \"application/json\"}\n\n        self.items = self.get_item()\n        print(\"items:{}\".format(self.items))\n\n    def post_data(self, obj={}):\n        response = requests.post(self.url, data=json.dumps(obj), headers=self.headers)\n        return response.text\n\n    def get_data(self, obj={}):\n        response = requests.get(self.url, params=obj, headers=self.headers)\n        return response.json()\n\n\nif __name__ == '__main__':\n\n    req_gc = Request2GoogleChat()\n    req_gc.post_data(text='5mi')\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\observer": {
        "status_monitor.py": "# ===============================================================================\n# Name      : status_monitor.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2022-11-28 15:51\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport os\nimport subprocess\nimport psutil\nfrom pydantic import BaseModel\n\n\nclass RpStatus(BaseModel):\n    temp: str\n    clock: str\n    volts: str\n    memory_cpu: str\n    memory_gpu: str\n    memory_userate: str\n\n\ndef run_shell_command(command_str: str) -> str:\n    # unit_list = ['\\'C', 'V', 'M']\n    proc = subprocess.run(command_str, shell=True, stdin=subprocess.PIPE,\n                          stdout=subprocess.PIPE, text=True)\n    result = proc.stdout.split(\"=\")\n    return result[1].replace('\\n', '')\n\n\ndef unit_converter(value_str: str) -> str:\n    value_str = value_str.replace('G', '000000')\n    value_str = value_str.replace('M', '000')\n    value_str = value_str.replace('K', '')\n    return value_str\n\n\ndef get_raspberrypi_status() -> RpStatus:\n    \"\"\"ラズパイのステータス取得\n\n    Returns:\n        RpStatus: _description_\n    \"\"\"\n    if os.name == 'nt':\n        (temp, clock, volts, memory_cpu, memory_gpu, memory_userate) = \\\n            ('0.0', '0.0', '0.0', '0.0', '0.0', '0.0')\n\n    else:\n        temp = run_shell_command(\"vcgencmd measure_temp\")\n        clock = run_shell_command(\"vcgencmd measure_clock arm\")\n        volts = run_shell_command(\"vcgencmd measure_volts\")\n        memory_cpu = run_shell_command(\"vcgencmd get_mem arm\")\n        memory_gpu = run_shell_command(\"vcgencmd get_mem gpu\")\n        memory_userate = psutil.virtual_memory().percent\n        temp = temp.replace('\\'C', '')\n        volts = volts.replace('V', '')\n        memory_cpu = unit_converter(memory_cpu)\n        memory_gpu = unit_converter(memory_gpu)\n\n    return RpStatus(\n        temp=temp,\n        clock=clock,\n        volts=volts,\n        memory_cpu=memory_cpu,\n        memory_gpu=memory_gpu,\n        memory_userate=memory_userate\n    )\n\n\nif __name__ == '__main__':\n    rp_status = get_raspberrypi_status()\n    print(rp_status)\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\plc": {
        ".gitignore": "Unsupported file type",
        "plc_base_class.py": "# ===============================================================================\n# Name      : plc_lib.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-04-19 12:00\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\n\nfrom time import perf_counter\nfrom typing import Tuple, Union\nfrom pydantic import BaseModel\ntry:\n    from .api import plc_comm\n    from .api.command_checker import check_command\nexcept Exception:\n    from api import plc_comm  # type: ignore\n    from api.command_checker import check_command  # type: ignore\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass PLCParam(BaseModel):\n    ip: str\n    port: str\n    manufacturer: str\n    series: str\n    plc_protocol: str\n    transport_protocol: str\n    bit: str   # NOTE: ビットデバイス\n    word: str   # NOTE: ワードデバイス\n    double_word: str  # NOTE: ダブルワード\n\n\ndef word2byte(word: str) -> str:\n    byte = '{:016b}'.format(int(word))\n    register = byte[::-1]\n    return register\n\n\nclass BasePLC:\n    __version__ = '1.0.0'\n\n    def __init__(self):\n        pass\n\n    def load_param(self, data: dict) -> None:\n        \"\"\"\n        PLCの通信設定を読込\n\n        Args:\n            data (dict): dict型のパラメータ\n        \"\"\"\n        self.param = PLCParam(**data)\n        self.plc_network = dict(ip=self.param.ip,\n                                port=self.param.port)\n\n        self.plc_protocol = dict(manufacture=self.param.manufacturer,\n                                 series=self.param.series,\n                                 protocol=self.param.plc_protocol,\n                                 transport_layer=self.param.transport_protocol)\n\n        # NOTE: OMRON-FINSの場合は公式サポート外なのでコマンドチェックを通す\n        if self.param.manufacturer == 'omron' and self.param.plc_protocol == 'fins':\n            self._omron_fins_flag = True\n        else:\n            self._omron_fins_flag = False\n\n    def get_time_from_plc(self) -> dict:\n        \"\"\"\n        PLCから時刻取得\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        results = plc_comm.single_communication_to_plc(\n            self.plc_network,\n            self.plc_protocol,\n            dict(device='D', min='0', max='0'),\n            dict(cmd='read', data=[], option='time')\n        )\n        return results\n\n    def get_device(self, d_type: str) -> str:\n        \"\"\"\n        デバイス名を取得\n\n        Args:\n            d_type (str): レジスタのデバイスの種類\n\n        Returns:\n            str: _description_\n        \"\"\"\n        if d_type == 'bit':\n            return self.param.bit\n        elif d_type == \"word\":\n            return self.param.word\n        else:\n            return \"\"\n\n    def write_data_to_plc(self,\n                          d_type: str = 'bit',\n                          addr: Union[str, int] = '0',\n                          addr_min: Union[str, int] = '0',\n                          addr_max: Union[str, int] = '0',\n                          data: list = None,\n                          multi: bool = False,\n                          timeout: int = 1000) -> bool:\n        \"\"\"\n        PLCのレジスタに値を書き込む関数\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類\n            addr (Union[str, int], optional): 1word分書き込むときのアドレス.\n            addr_min (Union[str, int], optional): 連番で書き込むときの最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で書き込むときの最後のアドレス.\n            data (list, optional): 書き込むデータ(list形式).\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms).\n\n        Returns:\n            bool: 通信成功ならTrue.\n        \"\"\"\n\n        device = self.get_device(d_type)\n        if multi:\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            # NOTE: 複数のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            if isinstance(addr, int):\n                addr = str(addr)\n            # NOTE: 1個のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        # NOTE: タイムアウトまで通信トライ\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='write', data=data, option='')\n            )\n\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True\n                else:\n                    return True\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Write to plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False\n\n    def read_data_from_plc(self,\n                           d_type: str = 'bit',\n                           addr: Union[str, int] = '0',\n                           addr_min: Union[str, int] = '0',\n                           addr_max: Union[str, int] = '0',\n                           multi: bool = False,\n                           timeout: int = 1000) -> Tuple[bool, list]:\n        \"\"\"\n        PLCのレジスタを読み込む関数\n\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類.\n            addr (Union[str, int], optional): 1word分読み込む時ののアドレス.\n            addr_min (Union[str, int], optional): 連番で読み込む時の最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で読み込む時の最後のアドレス.\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms)\n\n        Returns:\n            Tuple[bool, list]: 通信成功ならTrue, data.\n        \"\"\"\n\n        device = self.get_device(d_type)\n\n        if multi:\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            # NOTE: 複数のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            if isinstance(addr, int):\n                addr = str(addr)\n            # NOTE: 1個のデータレジスタを読み込む場合\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='read', data=[], option='')\n            )\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True, results['exists_data']\n                else:\n                    return True, results['exists_data']\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Read plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False, []\n\n\nif __name__ == \"__main__\":\n\n    config = dict(\n        ip='192.168.0.50',\n        port='5000',\n        manufacturer='keyence',\n        series='KV-7500',\n        plc_protocol='slmp',\n        transport_protocol='udp',\n        bit='DM',\n        word='DM',\n        double_word='DM'\n    )\n\n    plc = BasePLC()\n    plc.load_param(config)\n\n    success = plc.write_data_to_plc(d_type='word',\n                                    # addr='30',\n                                    addr_min='0',\n                                    addr_max='1',\n                                    multi=True,\n                                    data=[0, 0])\n    print(success)\n\n    success, data = plc.read_data_from_plc(d_type='word',\n                                           # addr='30',\n                                           addr_min='10',\n                                           addr_max='20',\n                                           multi=True)\n    #  data=[?1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    # data=[1])\n    print(data)\n    # print(success)\n\n    # success, data = plc.read_data_from_plc(d_type='word',\n    #                                        addr='5000',\n    #                                        )\n\n    # print(data)\n",
        "plc_seq.py": "# ===============================================================================\n# Name      : plc_sequence.py\n# Version   : 1.0.0\n# Brief     : NTSZ\n# Time-stamp: 2023-05-16 17:40\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport copy\nfrom typing import List, Tuple\nfrom time import perf_counter\n\nfrom .plc_base_class import BasePLC\nfrom .api.plc_comm import convert_signed\nfrom . import read_excel as g_set\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef word2bit(input_word_data: int) -> List[int]:\n    \"\"\"数値を16bitに変換\"\"\"\n    word_data_str = format(input_word_data, '016b')\n    word_data_ary = list(word_data_str)\n    word_data_ary.reverse()\n    # strのリストを数値に変換()\n    return list(map(int, word_data_ary))\n\n\ndef bit2word(input_binary_data: list) -> int:\n    \"\"\"16bitのlistを数値に変換\"\"\"\n    input_binary_data_buf = copy.deepcopy(input_binary_data)\n    input_binary_data_buf.reverse()\n    binary_data_str = str(input_binary_data_buf)\n    revised_binary_data_str = '0b' + binary_data_str[1:len(binary_data_str) - 1].replace(', ', '')\n    word_data = eval(revised_binary_data_str)\n    return word_data\n\n\n# ===============================================================================\n# NOTE: エクセルのアドレス関連\n# ===============================================================================\ndef get_device_map(xlsx_file: str, map_id: int) -> dict:\n    \"\"\"デバイスのINDEXを取得\"\"\"\n    if map_id == 0:\n        return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n    elif map_id == 1:\n        # NOTE: PLC->PCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n    elif map_id == 2:\n        # NOTE: PLC->PCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n    elif map_id == 3:\n        # NOTE: PC->PLCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n    elif map_id == 4:\n        # NOTE: PC->PLCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n    else:\n        return {}\n\n\ndef get_address_map(device_map: dict, header_address: int) -> dict:\n    \"\"\"アドレスマップを取得\"\"\"\n    data = {}\n    for key in device_map.keys():\n        data[key] = header_address + device_map[key]\n    return data\n\n\nclass PlcSeq(BasePLC):\n    __version__ = '1.0.0'\n\n    def __init__(self, excel_path: str):\n        super().__init__()\n        self.load_excel(excel_path)\n\n    def load_excel(self, path: str):\n        \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n        # NOTE: キーと相対アドレス0-15\n        header_address = get_device_map(path, 0)\n        self.IN_BIT_IDX = get_device_map(path, 1)\n        self.IN_WORD_IDX = get_device_map(path, 2)\n        self.OUT_BIT_IDX = get_device_map(path, 3)\n        self.OUT_WORD_IDX = get_device_map(path, 4)\n\n        # NOTE: キーと絶対アドレス\n        self.IN_BIT_AD = get_address_map(self.IN_BIT_IDX, header_address['IN_BIT_NO'])\n        self.IN_WORD_AD = get_address_map(self.IN_WORD_IDX, header_address['IN_WORD_NO'])\n        self.OUT_BIT_AD = get_address_map(self.OUT_BIT_IDX, header_address['OUT_BIT_NO'])\n        self.OUT_WORD_AD = get_address_map(self.OUT_WORD_IDX, header_address['OUT_WORD_NO'])\n\n        # NOTE: 内部保持変数 0で初期化\n        # TODO: VASTから見たOUTのBITリスト 今は6Word確保\n        self._pub_word_list = [[0 for i in range(16)] for j in range(6)]\n\n        # NOTE: エクセルからPLCのパラメータ(IP,Port,Protocol)を取得&反映\n        self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n        self.load_param(self.plc_config)\n\n    def get_plc_config(self) -> dict:\n        return self.plc_config\n\n    def update_bit_as_word(self, tag: str, key: str, val: int) -> None:\n        \"\"\"内部管理しているbitを更新\"\"\"\n        self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n    def read_bit_list(self, tag: str) -> Tuple[bool, list]:\n        \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n        ret, data = self.read_data_from_plc(d_type='bit',\n                                            addr=self.IN_BIT_AD[tag])\n        if ret:\n            bit_16 = word2bit(data[0])\n            return True, bit_16\n        else:\n            return False, [0]\n\n    def read_bit(self, tag: str, key: str) -> int:\n        \"\"\"Wordで読み取ってBitに分解\"\"\"\n        ret, data = self.read_bit_list(tag)\n        if ret:\n            s_bit = data[self.IN_BIT_IDX[key]]\n            return s_bit\n        else:\n            return -1\n\n    def write_bit_as_word(self, data: list, tag: str) -> bool:\n        \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n        bit_16 = data[self.OUT_BIT_IDX[tag]]\n        send_data = bit2word(bit_16)\n        addr = self.OUT_BIT_AD[tag]\n        ret = self.write_data_to_plc(d_type='bit',\n                                     addr=addr,\n                                     data=[send_data])\n        return ret\n\n    def check_bit(self, tag: str, key: str,\n                  val: int, timeout: int = 1000) -> bool:\n        \"\"\"PLC側のリクエスト、ステータスを確認\n\n        Args:\n            tag (str): bitの属性 request, status, complete\n            key (str): bitの名前\n            val (int): bitの値(0 or 1)が一致すればTrue\n            timeout (int, optional): タイムアウト(ms)\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        timer_count = 0\n        start_time = perf_counter()\n        addr = self.IN_BIT_AD[tag]\n        success = False\n        while timer_count < timeout:\n            # NOTE: dataはリストで返却\n            ret, data = self.read_data_from_plc(d_type='bit', addr=addr, timeout=timeout)\n\n            # NOTE: 通信失敗したらcontinue\n            if not ret:\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n\n            # NOTE: 通信に成功したら値を確認\n            bit_16 = word2bit(data[0])\n            s_bit = bit_16[self.IN_BIT_IDX[key]]\n            if s_bit == val:\n                # NOTE: 一致\n                success = True\n                break\n            else:\n                # NOTE: 不一致\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n        return success\n\n    def send_camera_status(self, capturing: bool) -> bool:\n        \"\"\"撮像ステータスの送信\"\"\"\n        # NOTE: 撮像中はcapturing = True\n        if capturing:\n            self.update_bit_as_word('STATUS_COMMON', 'CAPTURING', 1)\n        else:\n            self.update_bit_as_word('STATUS_COMMON', 'CAPTURING', 0)\n\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def send_inspection_start(self) -> None:\n        \"\"\"検査中の信号を送信\"\"\"\n        # NOTE: W(x_out).08 検査フラグ送信\n        self.update_bit_as_word('STATUS_COMMON', 'INSPECTING', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n\n    def get_inspection_config(self) -> Tuple[bool, List[int]]:\n        \"\"\"各種検査に関する番号の取得\"\"\"\n        # NOTE: DM(x_in+1,+2,+3) ワーク機種\n        # NOTE: int(self.IN_WORD_AD['MODEL_NO']+1)はPOSITION_NOがない場合の配慮\n        ret, data = self.read_data_from_plc(d_type='word',\n                                            addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n                                            addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n                                            multi=True)\n        if ret:\n            return True, data\n        else:\n            return False, [-1, -1, -1, -1]\n\n    def send_alignment_data(self, data: list) -> bool:\n        \"\"\"補正量を送信\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_base_align_data(self, data: list) -> bool:\n        \"\"\"基準量を送付\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_num_work(self, num: int) -> bool:\n        try:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NUM_WORK'],\n                data=[int(num)]\n            )\n        except Exception:\n            return False\n\n        return ret\n\n    def send_inspection_results(self,\n                                status: int,\n                                align_data: list,\n                                b_align_data: list = [],\n                                ng_code: int = 1,\n                                err_code: int = 1,\n                                ) -> bool:\n        \"\"\"結果を送信する\n\n        Args:\n            status (int): 判定結果 ok:1 ng:2 err:3\n            align_data (list): 検出した座標\n            b_align_data (list, optional): マスター登録した座標\n            ng_code (int, optional): 画像処理のNGコード\n            err_code (int, optional): 画像処理のERRORコード\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        # NOTE: 現在位置書き込み\n        ret = self.send_alignment_data(align_data)\n        # NOTE: 基準位置書き込み\n        if b_align_data:\n            ret = self.send_base_align_data(b_align_data)\n\n        # NOTE: 判定がNGの場合NGコードを出力\n        if status == 2:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NG_CODE'],\n                data=[int(ng_code)]\n            )\n        # NOTE: 判定がERRの場合ERRコードを出力\n        elif status == 3:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['ERR_CODE'],\n                data=[int(err_code)]\n            )\n\n        # NOTE: ジャッジリストを更新\n        judge_list = [0, 0, 0, 0]\n        judge_list[status] = 1\n\n        # NOTE: 検査判定を書き込み\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_OK', judge_list[1])\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_NG', judge_list[2])\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_ERR', judge_list[3])\n        self.write_bit_as_word(self._pub_word_list, 'COMPLETE_COMMON')\n        # NOTE: 検査終了を伝令\n        self.update_bit_as_word('STATUS_COMMON', 'INSPECTING', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n\n        # NOTE: PLC側で検査結果を受けとれたか確認\n        ret = self.check_bit('COMPLETE_COMMON', 'INSPECT_RECV_COMP', 1, timeout=5000)\n        if not ret:\n            return False\n\n        # NOTE: 検査結果を初期化\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_OK', 0)\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_NG', 0)\n        self.update_bit_as_word('COMPLETE_COMMON', 'INSPECT_ERR', 0)\n        self.write_bit_as_word(self._pub_word_list, 'COMPLETE_COMMON')\n        return True\n\n    def post_pc_error(self, err_code: int = 1) -> bool:\n        \"\"\"エラー出力\"\"\"\n        # NOTE: エラーコードを出力\n        self.update_bit_as_word('STATUS_COMMON', 'PC_ERR', 1)\n        ret1 = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        # NOTE: エラー信号を出力\n        ret2 = self.write_data_to_plc(d_type='word',\n                                      addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n                                      data=[int(err_code)])\n        if ret1 and ret2:\n            return True\n        return False\n\n    def reset_pc_error(self) -> bool:\n        \"\"\"PCエラーをリセット\"\"\"\n        # NOTE: エラーコードを初期化\n        self.update_bit_as_word('STATUS_COMMON', 'PC_ERR', 0)\n        ret1 = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        # NOTE: エラー信号を初期化\n        ret2 = self.write_data_to_plc(d_type='word',\n                                      addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n                                      data=[0])\n        if ret1 and ret2:\n            return True\n        return False\n\n    def pc_online(self, on: bool = True) -> bool:\n        if on:\n            self.update_bit_as_word('STATUS_COMMON', 'PC_ONLINE', 1)\n        else:\n            self.update_bit_as_word('STATUS_COMMON', 'PC_ONLINE', 0)\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def heart_beat(self, pre_beat: bool) -> bool:\n        \"\"\"ラズパイの生存をPLC側に通達\"\"\"\n        if pre_beat:\n            self.pc_online(False)\n            return False\n        else:\n            self.pc_online(True)\n            return True\n\n    # def calibration_seq(self) -> None:\n    #     # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n    #     self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n    #     self.update_bit_as_word('STATUS', 'PC_READY', 0)\n    #     self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n    #     # NOTE: キャリブレーションスタート\n    #     self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n    #     self.update_bit_as_word('STATUS', 'PC_READY', 0)\n    #     self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n\ndef _main():\n    # NOTE: トーソク用テストコード\n    import time\n    e_path = r'C:\\Users\\J100048001\\Desktop\\rv_vast\\vision_setting.xlsx'\n    plc = PlcSeq(e_path)\n\n    param = dict(ip='192.168.250.10',\n                 port='5000',\n                 manufacturer='keyence',\n                 series='',\n                 plc_protocol='slmp',\n                 transport_protocol='udp',\n                 bit='DM',\n                 word='DM',\n                 double_word='')  # NOTE: ダブルワード\n\n    plc.load_param(param)\n    pre_bit = [False]\n    pre_beat = False\n    # NOTE: 周期設定\n    _count = 0  # NOTE: 計測用カウンター\n    WAIT_TIME = 0.1  # NOTE: ループ周期(second)\n    BEAT_TIME = 1  # NOTE: ハートビート周期(second)\n    COUNT_TH = int(BEAT_TIME / WAIT_TIME)\n    pre_beat = plc.heart_beat(pre_beat)\n\n    try:\n        while True:\n            # NOTE: PLCのメモリの値（OUTPUT）を取得\n            ret, data = plc.read_bit_list(tag='REQUEST_COMMON')\n            if not ret:\n                # NOTE: 次にメモリを読みに行くまで所定の時間sleep\n                # 負荷低減のため\n                _count += 1\n                time.sleep(WAIT_TIME)\n                continue\n\n            # NOTE: 検査信号のトリガー\n            if data[plc.IN_BIT_IDX['CAPTURE_START']] == 1:\n                # NOTE: 立ち上がりでなければ再度読み込み\n                if pre_bit[0]:\n                    _count += 1\n                    time.sleep(WAIT_TIME)\n                    continue\n                # NOTE: 検査開始の電文をメインスレッドにシグナルとして送付\n\n                r = plc.send_camera_status(True)\n                time.sleep(0.5)\n                r = plc.send_camera_status(False)\n                r = plc.check_bit(tag='COMPLETE_COMMON', key='CAPTURE_RECV_COMP', val=1, timeout=5000)\n                if not r:\n                    print('errr1')\n                    break\n                r = plc.check_bit(tag='REQUEST_COMMON', key='INSPECT_START', val=1, timeout=5000)\n                if not r:\n                    print('errr2')\n\n                plc.send_inspection_start()\n                r, number_list = plc.get_inspection_config()\n                print(number_list)\n\n                plc.send_inspection_results(1, [-1111, -65000, 0, -1000])\n                # NOTE: prebitを更新\n                pre_bit[0] = True\n\n            # NOTE: 不定期にON,OFFを繰り返す\n            if _count > COUNT_TH:\n                # print('sss')\n                pre_beat = plc.heart_beat(pre_beat)\n                _count = 0\n\n            # NOTE: pre bitをオフにする\n            pre_bit[0] = False\n\n            # NOTE: カウント\n            _count += 1\n\n            # NOTE: 負荷低減のため\n            time.sleep(WAIT_TIME)\n\n    except KeyboardInterrupt:\n        pass\n\n\nif __name__ == \"__main__\":\n    # print(RANGE)\n    _main()\n",
        "plc_seq_nmoj.py": "# ===============================================================================\n# Name      : plc_sequence.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-04-19 17:16\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport copy\nfrom typing import List, Tuple\nfrom time import perf_counter, sleep\nfrom .plc_base_class import BasePLC\nfrom .api.plc_comm import convert_signed\nfrom . import read_excel as g_set\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef word2bit(input_word_data: int) -> List[int]:\n    \"\"\"数値を16bitに変換\"\"\"\n    word_data_str = format(input_word_data, '016b')\n    word_data_ary = list(word_data_str)\n    word_data_ary.reverse()\n    # strのリストを数値に変換()\n    return list(map(int, word_data_ary))\n\n\ndef bit2word(input_binary_data: list) -> int:\n    \"\"\"16bitのlistを数値に変換\"\"\"\n    input_binary_data_buf = copy.deepcopy(input_binary_data)\n    input_binary_data_buf.reverse()\n    binary_data_str = str(input_binary_data_buf)\n    revised_binary_data_str = '0b' + binary_data_str[1:len(binary_data_str) - 1].replace(', ', '')\n    word_data = eval(revised_binary_data_str)\n    return word_data\n\n\n# ===============================================================================\n# NOTE: エクセルのアドレス関連\n# ===============================================================================\ndef get_device_map(xlsx_file: str, map_id: int) -> dict:\n    \"\"\"デバイスのINDEXを取得\"\"\"\n    if map_id == 0:\n        return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n    elif map_id == 1:\n        # NOTE: PLC->PCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n    elif map_id == 2:\n        # NOTE: PLC->PCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n    elif map_id == 3:\n        # NOTE: PC->PLCのBitデバイス\n        return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n    elif map_id == 4:\n        # NOTE: PC->PLCのWordデバイス\n        return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n    else:\n        return {}\n\n\ndef get_address_map(device_map: dict, header_address: int) -> dict:\n    \"\"\"アドレスマップを取得\"\"\"\n    data = {}\n    for key in device_map.keys():\n        data[key] = header_address + device_map[key]\n    return data\n\n\nclass PlcSeq(BasePLC):\n    __version__ = '1.0.0'\n\n    def __init__(self, excel_path: str = './vision_setting.xlsx'):\n        super().__init__()\n        self.load_excel(excel_path)\n\n    def load_excel(self, path: str):\n        \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n        # NOTE: 各キー、タグのインデックス\n        header_address = get_device_map(path, 0)\n        self.IN_BIT_IDX = get_device_map(path, 1)\n        self.IN_WORD_IDX = get_device_map(path, 2)\n        self.OUT_BIT_IDX = get_device_map(path, 3)\n        self.OUT_WORD_IDX = get_device_map(path, 4)\n\n        # NOTE: 各キー、タグのアドレス\n        self.IN_BIT_AD = get_address_map(self.IN_BIT_IDX, header_address['IN_BIT_NO'])\n        self.IN_WORD_AD = get_address_map(self.IN_WORD_IDX, header_address['IN_WORD_NO'])\n        self.OUT_BIT_AD = get_address_map(self.OUT_BIT_IDX, header_address['OUT_BIT_NO'])\n        self.OUT_WORD_AD = get_address_map(self.OUT_WORD_IDX, header_address['OUT_WORD_NO'])\n\n        # NOTE: 内部保持変数 0で初期化\n        # TODO: レンジをエクセルからとってくる、今は３\n        self._pub_word_list = [[0 for i in range(16)] for j in range(3)]\n\n        self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n        self.load_param(self.plc_config)\n\n    def get_plc_config(self) -> dict:\n        return self.plc_config\n\n    def update_bit_as_word(self, tag: str, key: str, val: int) -> None:\n        \"\"\"内部管理しているbitを更新\"\"\"\n        self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n    def read_bit_list(self, tag: str = 'REQ') -> Tuple[bool, list]:\n        \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n        ret, data = self.read_data_from_plc(d_type='bit',\n                                            addr=self.IN_BIT_AD[tag])\n        if ret:\n            bit_16 = word2bit(data[0])\n            return True, bit_16\n        else:\n            return False, [0]\n\n    def read_bit(self, tag: str = 'REQ', key: str = 'INSPECT_START') -> int:\n        \"\"\"Wordで読み取ってBitに分解\"\"\"\n        ret, data = self.read_bit_list(tag)\n        if ret:\n            s_bit = data[self.IN_BIT_IDX[key]]\n            return s_bit\n        else:\n            return -1\n\n    def write_bit_as_word(self, data: list, tag: str) -> bool:\n        \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n        bit_16 = data[self.OUT_BIT_IDX[tag]]\n        send_data = bit2word(bit_16)\n        addr = self.OUT_BIT_AD[tag]\n        ret = self.write_data_to_plc(d_type='bit',\n                                     addr=addr,\n                                     data=[send_data])\n        return ret\n\n    def check_bit(self, tag: str, key: str, val: int, timeout: int = 1000) -> bool:\n        \"\"\"Bitの状態確認\"\"\"\n        timer_count = 0\n        start_time = perf_counter()\n        _match = False\n        addr = self.IN_BIT_AD[tag]\n        while timer_count < timeout:\n            # NOTE: dataはリストで返却\n            success, data = self.read_data_from_plc(d_type='bit', addr=addr, timeout=timeout)\n            if success:\n                bit_16 = word2bit(data[0])\n                s_bit = bit_16[self.IN_BIT_IDX[key]]\n                if s_bit == val:\n                    _match = True\n                    break\n                else:\n                    # NOTE: 不一致\n                    timer_count = int((perf_counter() - start_time) * 1000)\n                    continue\n            # TODO: タイムアウトと通信失敗を切り分けできるように\n            else:\n                # NOTE: 通信失敗\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n        return _match\n\n    # ===============================================================================\n    # NOTE: 通信確認\n    # ===============================================================================\n\n    def communication_confirmation(self) -> bool:\n        \"\"\"Ready信号に対する応答\"\"\"\n        # NOTE: 初回起動時、原点復帰後に実施\n\n        # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_out).08-11 <Write> プログラム起動時に初期化（検査系）\n        self.update_bit_as_word('STATUS', 'INSPECTING', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_OK', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_NG', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_ERR', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE:  W(x_out).00 <Write> PCの電源がONであることをPLCに通達\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_in).01 <Read> Request Readyがオンになっていることを確認\n        ret = self.check_bit('REQ', 'READY', 1, timeout=5000)\n        if not ret:\n            logger.debug('Timeout Request Ready [on]')\n            return False\n\n        # NOTE: W(x_out).01 <Write> PLC側のW(2).01を確認したことを通達\n        self.update_bit_as_word('STATUS', 'PC_READY', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_in).01 <Read> PLC側が通達を確認\n        ret = self.check_bit('REQ', 'READY', 0, timeout=5000)\n        if not ret:\n            logger.debug('Timeout Request Ready [off]')\n            return False\n\n        # NOTE: W(x_out).01 <Write> 初期通信確認終了\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        logger.debug('Ready Sequence Complete')\n\n        return True\n\n    def send_camera_status(self, capturing: bool) -> bool:\n        \"\"\"撮像ステータスの送信\"\"\"\n        # NOTE: 撮像中はcapturing = True\n        if capturing:\n            self.update_bit_as_word('STATUS', 'CAPTURE', 1)\n        else:\n            self.update_bit_as_word('STATUS', 'CAPTURE', 0)\n\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS')\n        return ret\n\n    def send_inspection_start(self) -> None:\n        \"\"\"検査中の信号を送信\"\"\"\n        # NOTE: W(x_out).08 検査フラグ送信\n        self.update_bit_as_word('STATUS', 'INSPECTING', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n    def get_inspection_config(self) -> Tuple[bool, int, int, int]:\n        \"\"\"検査番号の取得\"\"\"\n        # NOTE: DM(x_in+1,+2,+3) ワーク機種\n        ret, data = self.read_data_from_plc(d_type='word',\n                                            addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n                                            addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n                                            multi=True)\n        if ret:\n            return True, data[0], data[1], data[2]\n        else:\n            return False, -1, -1, -1\n\n    def send_alignment_data(self, data: list) -> bool:\n        \"\"\"補正量を送信\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_base_align_data(self, data: list) -> bool:\n        \"\"\"基準量を送付\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.write_data_to_plc(d_type='word',\n                                     addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n                                     addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n                                     multi=True,\n                                     data=send_data)\n        return ret\n\n    def send_num_work(self, num: int) -> bool:\n        try:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NUM_WORK'],\n                data=[int(num)]\n            )\n        except Exception:\n            return False\n\n        return ret\n\n    def send_inspection_results(self,\n                                status: int,\n                                data: list,\n                                b_data: list = [0, 0, 0, 0],\n                                ngcode: int = 0\n                                ) -> bool:\n        \"\"\"検査結果を送信\"\"\"\n        # NOTE: status : ok:1 ng:2 err:3\n\n        # NOTE: 現在位置書き込み\n        ret = self.send_alignment_data(data)\n        # NOTE: 基準位置書き込み\n        ret = self.send_base_align_data(b_data)\n\n        # NOTE: post NG Code\n        if status == 2:\n            ret = self.write_data_to_plc(\n                d_type='word',\n                addr=self.OUT_WORD_AD['NG_CODE'],\n                data=[int(ngcode)]\n            )\n\n        judge_list = [0, 0, 0, 0]\n        judge_list[status] = 1\n\n        # NOTE: W(x_out).08-11 検査フラグ送信\n        self.update_bit_as_word('STATUS', 'INSPECTING', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_OK', judge_list[1])\n        self.update_bit_as_word('STATUS', 'INSPECT_NG', judge_list[2])\n        self.update_bit_as_word('STATUS', 'INSPECT_ERR', judge_list[3])\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: W(x_in).09 検査終了確認\n        ret = self.check_bit('REQ', 'INSPECT_RCV', 1, timeout=5000)\n        if not ret:\n            logger.debug('Timeout Inspection Recv [on]')\n            return False\n\n        # NOTE: W(x_out).09-11 検査結果削除\n        self.update_bit_as_word('STATUS', 'INSPECT_OK', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_NG', 0)\n        self.update_bit_as_word('STATUS', 'INSPECT_ERR', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        logger.debug('Inspection Sequence Complete')\n\n        return True\n\n    def post_error_code(self, error_code: int) -> None:\n        \"\"\"エラーを吐く\"\"\"\n        self.success = self.write_data_to_plc(\n            d_type='word',\n            addr=self.OUT_WORD_AD['ERR_CODE'],\n            data=[int(error_code)]\n        )\n\n        self.update_bit_as_word('STATUS', 'PC_ERR', 1)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # # TODO: ここは無限タイムアウトじゃないと\n        # ret = self.check_bit('REQ', 'RST_PC_ERR', 1, timeout=1000)\n        # if not ret:\n        #     return\n\n        # self.update_bit_as_word('STATUS', 'PC_ERR', 0)\n        # self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n    def pc_online(self, on: bool = True) -> bool:\n        \"\"\"PC Online\"\"\"\n        if on:\n            self.update_bit_as_word('STATUS', 'PC_ONLINE', 1)\n        else:\n            self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        ret = self.write_bit_as_word(self._pub_word_list, 'STATUS')\n        return ret\n\n    def calibration_seq(self) -> None:\n        # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n        # NOTE: キャリブレーションスタート\n        self.update_bit_as_word('STATUS', 'PC_ONLINE', 0)\n        self.update_bit_as_word('STATUS', 'PC_READY', 0)\n        self.write_bit_as_word(self._pub_word_list, 'STATUS')\n\n\ndef _main():\n    plc = PlcSeq()\n\n    param = dict(ip='192.168.14.1',\n                 port='9600',\n                 manufacturer='omron',\n                 series='',\n                 plc_protocol='fins',\n                 transport_protocol='udp',\n                 bit='W',\n                 word='DM',\n                 double_word='')  # NOTE: ダブルワード\n\n    plc.load_param(param)\n\n    in_w = get_device_map('./setting_Vision_W.xlsx', 1)\n\n    try:\n        while True:\n            # NOTE: 一括読取\n            ret, data = plc.read_bit_list()\n            if ret:\n                if data[in_w['INSPECT_START']] == 1:\n\n                    print('inspection_start')\n                    plc.send_camera_status(True)\n                    sleep(1)\n                    plc.send_camera_status(False)\n                    plc.get_inspection_config()\n                    # NOTE: 単位はum\n                    ret = plc.send_inspection_results(1, [-1, 2, 3, -4])\n                    if ret:\n                        print('inspection success')\n                    else:\n                        print('inspection failed')\n\n                elif data[in_w['READY']] == 1:\n\n                    print('Communication Confirmation')\n                    ret = plc.communication_confirmation()\n                    if ret:\n                        print('commconfirm success')\n                    else:\n                        print('commconfirm failed')\n\n            plc.pc_online()\n    except KeyboardInterrupt:\n        pass\n\n\nif __name__ == \"__main__\":\n    # print(RANGE)\n    _main()\n",
        "README.md": "# NOTE: あああ\n",
        "read_excel.py": "# ===============================================================================\n# Name      : read_excel.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-05-06 16:09\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport openpyxl\nimport io\n\n\ndef getHeaderAddress(book_name: str, sheet_name: str) -> dict:\n    \"\"\"指定されたExcelファイルとシートから先頭アドレスを取得する\"\"\"\n    REF_ROW_NO = 8\n    REF_COL_NO = 2\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    in_bit = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO).value\n    in_word = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 1).value\n    out_bit = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 2).value\n    out_word = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 3).value\n    wb.close()\n    address_data = dict(IN_BIT_NO=in_bit,\n                        IN_WORD_NO=in_word,\n                        OUT_BIT_NO=out_bit,\n                        OUT_WORD_NO=out_word,\n                        )\n    return address_data\n\n\ndef getBitData(book_name: str, sheet_name: str) -> dict:\n    \"\"\"Bitのキーワードを取得\"\"\"\n    REF_ROW_NO = 3\n    REF_COL_NO = 3\n    MAX_COL_NO = 16\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    dict_data = {}\n    # 行走査\n    for row_i in range(0, sheet.max_row):\n        cell = sheet.cell(row=row_i + REF_ROW_NO, column=REF_COL_NO)\n        # 値があれば\n        if cell.value is not None:\n            # word用連想配列作成(Word要タグのID)\n            dict_data[cell.value] = row_i\n            # 列走査\n            for col_i in range(0, MAX_COL_NO):\n                cell = sheet.cell(row=row_i + REF_ROW_NO, column=REF_COL_NO + col_i)\n                # 値があれば\n                if (cell.value is not None) and (col_i != 0):\n                    # bit用連想配列作成\n                    dict_data[cell.value] = col_i - 1\n    wb.close()\n    return dict_data\n\n\ndef getWordData(book_name: str, sheet_name: str) -> dict:\n    \"\"\"Wordのキーワードを取得\"\"\"\n    REF_ROW_NO = 3\n    REF_COL_NO = 3\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    dict_data = {}\n    # 行走査\n    for row_i in range(0, sheet.max_row):\n        cell = sheet.cell(row=row_i + REF_ROW_NO, column=REF_COL_NO)\n        # 値があれば\n        if cell.value is not None:\n            # word用連想配列作成\n            dict_data[cell.value] = row_i\n    wb.close()\n    return dict_data\n\n\ndef getPLCParam(book_name: str, sheet_name: str) -> dict:\n    \"\"\"PLCの通信設定を取得\"\"\"\n    REF_ROW_NO = 4\n    REF_COL_NO = 2\n\n    with open(book_name, \"rb\") as f:\n        in_mem_file = io.BytesIO(f.read())\n    wb = openpyxl.load_workbook(in_mem_file, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    # NOTE:行走査\n    ip_address = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO).value\n    port = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 1).value\n    manufacturer = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 2).value\n    series = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 3).value\n    plc_protocol = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 4).value\n    transport_protocol = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 5).value\n    bit = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 6).value\n    word = sheet.cell(row=REF_ROW_NO, column=REF_COL_NO + 7).value\n\n    plc_param = dict(ip=ip_address,\n                     port=str(port),\n                     manufacturer=manufacturer,\n                     series=series,\n                     plc_protocol=plc_protocol,\n                     transport_protocol=transport_protocol,\n                     bit=bit,\n                     word=word,\n                     double_word='')\n    wb.close()\n    return plc_param\n\n\ndef getParamDict(book_name: str, sheet_name: str) -> dict:\n    \"\"\"RangeSheet読込\"\"\"\n    # NOTE: NMOJ 用\n    REF_COL_NO = 2\n    MAX_COL_NO = 2\n    wb = openpyxl.load_workbook(book_name, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    dict_data = {}\n    # 行走査\n    for row_i in range(1, sheet.max_row + 1):\n        cell_1 = sheet.cell(row=row_i, column=REF_COL_NO)\n        # 値があれば\n        if cell_1.value is not None:\n            # 列走査\n            for col_i in range(1, MAX_COL_NO):\n                cell_2 = sheet.cell(row=row_i, column=REF_COL_NO + col_i)\n                # 値があれば\n                if cell_2.value is not None:\n                    # bit用連想配列作成\n                    dict_data[cell_1.value] = cell_2.value\n    wb.close()\n    return dict_data\n\n\ndef getIdTable(book_name: str, sheet_name: str = 'IDTABLE') -> list:\n    # NOTE: NMOJ用\n    REF_ROW_NO = 3\n    REF_COL_NO = 2\n    # NOTE:データオンリー\n    wb = openpyxl.load_workbook(book_name, read_only=True,\n                                keep_vba=True, data_only=True)\n    sheet = wb[sheet_name]\n    data_list = []\n    # NOTE:行走査\n    for row_i in range(REF_ROW_NO, sheet.max_row + 1):\n        program_no = sheet.cell(row=row_i, column=REF_COL_NO).value\n        config_no = sheet.cell(row=row_i, column=REF_COL_NO + 1).value\n        model_no = sheet.cell(row=row_i, column=REF_COL_NO + 2).value\n        model_type = sheet.cell(row=row_i, column=REF_COL_NO + 3).value\n        model_name = sheet.cell(row=row_i, column=REF_COL_NO + 4).value\n        if program_no is None:\n            # NOTE: Noneであればbreak\n            break\n        data_list.append(\n            dict(config=config_no,\n                 program=program_no,\n                 model=model_no,\n                 mdl_type=model_type,\n                 mdl_name=model_name)\n        )\n\n    wb.close()\n    return data_list\n",
        "revision.md": "# ver1.0.0",
        "vast_plc_comm.py": "# ===============================================================================\n# Name      : plc_sequence.py\n# Version   : 1.0.0\n# Brief     : NTSZ\n# Time-stamp: 2024-01-06 15:36\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport copy\nfrom typing import List, Tuple, Union\nfrom time import perf_counter\nfrom pydantic import BaseModel\n\ntry:\n    from .api import plc_comm\n    from .api.command_checker import check_command\n    from .api.plc_comm import convert_signed\n    from . import read_excel as g_set\nexcept Exception:\n    from api import plc_comm  # type: ignore\n    from api.command_checker import check_command  # type: ignore\n    from api.plc_comm import convert_signed  # type: ignore\n    import read_excel as g_set  # type: ignore\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass PLCConfiguration(BaseModel):\n    ip: str = ''\n    port: str = ''\n    manufacturer: str = ''\n    series: str = ''\n    plc_protocol: str = ''\n    transport_protocol: str = ''\n    bit: str = ''   # NOTE: ビットデバイス\n    word: str = ''   # NOTE: ワードデバイス\n    double_word: str = ''  # NOTE: ダブルワード\n\n\ndef word2bit(input_word_data: int) -> List[int]:\n    \"\"\"数値を16bitに変換\"\"\"\n    word_data_str = format(input_word_data, '016b')\n    word_data_ary = list(word_data_str)\n    word_data_ary.reverse()\n    return list(map(int, word_data_ary))\n\n\ndef bit2word(input_binary_data: list) -> int:\n    \"\"\"16bitのlistを数値に変換\"\"\"\n    input_binary_data_buf = copy.deepcopy(input_binary_data)\n    input_binary_data_buf.reverse()\n    binary_data_str = str(input_binary_data_buf)\n    revised_binary_data_str = '0b' + binary_data_str[1:len(binary_data_str) - 1].replace(', ', '')\n    word_data = eval(revised_binary_data_str)\n    return word_data\n\n\ndef bool2int(bool_val: bool) -> int:\n    if bool_val:\n        return 1\n    else:\n        return 0\n\n\nclass BasePLCCommunication:\n    \"\"\"\n    PLCとの通信に使う基本関数\n    \"\"\"\n    __version__ = '1.0.0'\n\n    # def __init__(self):\n    #     self._vis_address: bool = False\n\n    # def enableAddress(self, enabled: bool) -> None:\n    #     self._vis_address = enabled\n\n    def loadPLCConfiguration(self, data: Union[dict, PLCConfiguration]) -> bool:\n        \"\"\"\n        PLCとの通信設定の読込\n\n        Args:\n            data (Union[dict, PLCConfiguration]): 通信設定のパラメータ\n\n        Returns:\n            bool: 入力フォーマットが間違っていた場合False\n        \"\"\"\n        if isinstance(data, dict):\n            self.param = PLCConfiguration(**data)\n        elif isinstance(data, PLCConfiguration):\n            self.param = data\n        else:\n            return False\n\n        self.plc_network = dict(ip=self.param.ip,\n                                port=self.param.port)\n\n        self.plc_protocol = dict(manufacture=self.param.manufacturer,\n                                 series=self.param.series,\n                                 protocol=self.param.plc_protocol,\n                                 transport_layer=self.param.transport_protocol)\n\n        # NOTE: OMRON-FINSの場合は公式サポート外なのでコマンドチェックを適用\n        if self.param.manufacturer == 'omron' and self.param.plc_protocol == 'fins':\n            self._omron_fins_flag = True\n        else:\n            self._omron_fins_flag = False\n\n        return True\n\n    def getTimeFromPLC(self) -> dict:\n        \"\"\"\n        PLCから時刻取得(Omronのみ対応?)\n\n        Returns:\n            dict: _description_\n        \"\"\"\n        results = plc_comm.single_communication_to_plc(\n            self.plc_network,\n            self.plc_protocol,\n            dict(device='D', min='0', max='0'),\n            dict(cmd='read', data=[], option='time')\n        )\n        return results\n\n    def getPLCDeviceName(self, d_type: str) -> str:\n        \"\"\"\n        デバイス名を取得\n\n        Args:\n            d_type (str): レジスタのデバイスの種類\n\n        Returns:\n            str: デバイス名\n        \"\"\"\n        if d_type == 'bit':\n            return self.param.bit\n        elif d_type == \"word\":\n            return self.param.word\n        else:\n            return \"\"\n\n    def writeDataToPLCDevice(self,\n                             d_type: str = 'bit',\n                             addr: Union[str, int] = '0',\n                             addr_min: Union[str, int] = '0',\n                             addr_max: Union[str, int] = '0',\n                             data: list = None,\n                             multi: bool = False,\n                             timeout: int = 1000) -> bool:\n        \"\"\"\n        PLCのレジスタに値を書き込む関数\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類\n            addr (Union[str, int], optional): 1word分書き込むときのアドレス.\n            addr_min (Union[str, int], optional): 連番で書き込むときの最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で書き込むときの最後のアドレス.\n            data (list, optional): 書き込むデータ(list形式).\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms).\n\n        Returns:\n            bool: 通信成功ならTrue.\n        \"\"\"\n\n        device = self.getPLCDeviceName(d_type)\n        if multi:\n            # NOTE: 複数のデータレジスタを書き込む場合\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            # NOTE: 1個のデータレジスタを書き込む場合\n            if isinstance(addr, int):\n                addr = str(addr)\n\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        # NOTE: タイムアウトまで通信トライ\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='write', data=data, option='')\n            )\n\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True\n                else:\n                    return True\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Write to plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False\n\n    def readDataFromPLCDevice(self,\n                              d_type: str = 'bit',\n                              addr: Union[str, int] = '0',\n                              addr_min: Union[str, int] = '0',\n                              addr_max: Union[str, int] = '0',\n                              multi: bool = False,\n                              timeout: int = 1000) -> Tuple[bool, list]:\n        \"\"\"\n        PLCのレジスタを読み込む関数\n\n\n        Args:\n            d_type (str, optional): レジスタのデバイスの種類.\n            addr (Union[str, int], optional): 1word分読み込む時ののアドレス.\n            addr_min (Union[str, int], optional): 連番で読み込む時の最初のアドレス.\n            addr_max (Union[str, int], optional): 連番で読み込む時の最後のアドレス.\n            multi (bool, optional): 連番で書き込むときはTrue.\n            timeout (int, optional): 通信のタイムアウト設定(ms)\n\n        Returns:\n            Tuple[bool, list]: 通信成功ならTrue, data.\n        \"\"\"\n\n        device = self.getPLCDeviceName(d_type)\n\n        if multi:\n            # NOTE: 複数のデータレジスタを読み込む場合\n            if isinstance(addr_min, int):\n                addr_min = str(addr_min)\n            if isinstance(addr_max, int):\n                addr_max = str(addr_max)\n\n            device_data = dict(device=device,\n                               min=addr_min,\n                               max=addr_max)\n        else:\n            # NOTE: 1個のデータレジスタを読み込む場合\n            if isinstance(addr, int):\n                addr = str(addr)\n\n            device_data = dict(device=device,\n                               min=addr,\n                               max=addr)\n\n        timer_count = 0\n        start_time = perf_counter()\n\n        while timer_count < timeout:\n            results = plc_comm.single_communication_to_plc(\n                self.plc_network,\n                self.plc_protocol,\n                device_data,\n                dict(cmd='read', data=[], option='')\n            )\n\n            # NOTE: error_code=0で通信成功\n            if results['error_code'] == 0:\n                if self._omron_fins_flag:\n                    if check_command(results['send_binary'], results['response']):\n                        return True, results['exists_data']\n                else:\n                    return True, results['exists_data']\n\n            timer_count = int((perf_counter() - start_time) * 1000)\n\n        errMsg = '[ERR] Failed to Read plc registry...' \\\n            + 'Please make sure that the LAN cable is connected.'\n        logger.error(errMsg)\n\n        return False, []\n\n\nclass PLCCommunication(BasePLCCommunication):\n    __version__ = '1.0.0'\n    \"\"\"\n    PLC通信@NPSZ&メカトロチームラダー\n    \"\"\"\n\n    def __init__(self, excel_path: str):\n        super().__init__()\n        self.updateAddressMapFromExcel(excel_path)\n        self.bit_eq_word: bool = True\n\n    # ===============================================================================\n    # NOTE: Excelからパラメータを取得する関数\n    # ===============================================================================\n\n    def getPLCDeviceMapFromExcel(self, xlsx_file: str, map_id: int) -> dict:\n        \"\"\"デバイスのINDEXを取得\"\"\"\n        if map_id == 0:\n            return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n        elif map_id == 1:\n            # NOTE: PLC->PCのBitデバイス\n            return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n        elif map_id == 2:\n            # NOTE: PLC->PCのWordデバイス\n            return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n        elif map_id == 3:\n            # NOTE: PC->PLCのBitデバイス\n            return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n        elif map_id == 4:\n            # NOTE: PC->PLCのWordデバイス\n            return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n        else:\n            return {}\n\n    def convertDeviceMapToAddressMap(self, device_map: dict, header_address: int) -> dict:\n        \"\"\"アドレスマップを取得\"\"\"\n        data = {}\n        for key in device_map.keys():\n            data[key] = header_address + device_map[key]\n        return data\n\n    def updateAddressMapFromExcel(self, path: str) -> None:\n        \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n        # NOTE: キーと相対アドレス0-15\n        header_address = self.getPLCDeviceMapFromExcel(path, 0)\n        self.IN_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 1)\n        self.IN_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 2)\n        self.OUT_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 3)\n        self.OUT_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 4)\n\n        # NOTE: キーと絶対アドレス\n        self.IN_BIT_AD = self.convertDeviceMapToAddressMap(self.IN_BIT_IDX,\n                                                           header_address['IN_BIT_NO'])\n        self.IN_WORD_AD = self.convertDeviceMapToAddressMap(self.IN_WORD_IDX,\n                                                            header_address['IN_WORD_NO'])\n        self.OUT_BIT_AD = self.convertDeviceMapToAddressMap(self.OUT_BIT_IDX,\n                                                            header_address['OUT_BIT_NO'])\n        self.OUT_WORD_AD = self.convertDeviceMapToAddressMap(self.OUT_WORD_IDX,\n                                                             header_address['OUT_WORD_NO'])\n\n        # NOTE: 内部保持変数 0で初期化\n        # TODO: VASTから見たOUTのBITリスト 今は6Word確保\n        self._pub_word_list = [[0 for i in range(16)] for j in range(6)]\n\n        # NOTE: エクセルからPLCのパラメータ(IP,Port,Protocol)を取得&反映\n        self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n        self.loadPLCConfiguration(self.plc_config)\n\n    def getPLCConfiguration(self) -> dict:\n        return self.plc_config\n\n    # ===============================================================================\n    # NOTE: ステータス管理の関数（内部ではBit管理、出力はWord出力）\n    # ===============================================================================\n\n    def setBitInWord(self, tag: str, key: str, val: int) -> None:\n        \"\"\"内部管理しているbitを更新\"\"\"\n        self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n    def readBitList(self, tag: str) -> Tuple[bool, list]:\n        \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n        ret, data = self.readDataFromPLCDevice(d_type='word',\n                                               addr=self.IN_BIT_AD[tag])\n        if not ret:\n            return False, [0]\n\n        bit_16 = word2bit(data[0])\n        return True, bit_16\n\n    def readBitState(self, tag: str, key: str) -> int:\n        \"\"\"Wordで読み取ってBitに分解\"\"\"\n        ret, data = self.readBitList(tag)\n        if ret:\n            s_bit = data[self.IN_BIT_IDX[key]]\n            return s_bit\n        else:\n            return -1\n\n    def writeBitsStateToWord(self, data: list, tag: str) -> bool:\n        \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n        bit_16 = data[self.OUT_BIT_IDX[tag]]\n        send_data = bit2word(bit_16)\n        addr = self.OUT_BIT_AD[tag]\n        ret = self.writeDataToPLCDevice(d_type='word',\n                                        addr=addr,\n                                        data=[send_data])\n        return ret\n\n    # ===============================================================================\n    # NOTE: 外部用のメソッド\n    # ===============================================================================\n\n    def setPcOnline(self, bit_on: bool) -> bool:\n        self.setBitInWord('STATUS_COMMON', 'PC_ONLINE', bool2int(bit_on))\n        return self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n\n    def setInspectionNGCode(self, ng_code: int) -> bool:\n        return self.writeDataToPLCDevice(d_type='word',\n                                         addr=self.OUT_WORD_AD['NG_CODE'],\n                                         data=[ng_code])\n\n    def setInspectionErrorCode(self, error_code: int) -> bool:\n        return self.writeDataToPLCDevice(d_type='word',\n                                         addr=self.OUT_WORD_AD['ERR_CODE'],\n                                         data=[error_code])\n\n    def setPcErrorCode(self, error_code: int) -> bool:\n        return self.writeDataToPLCDevice(d_type='word',\n                                                addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n                                                data=[error_code])\n\n    def setPcError(self, bit_on: bool) -> bool:\n        self.setBitInWord('STATUS_COMMON', 'PC_ERR', bool2int(bit_on))\n        return self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n\n    def sendCaptureInProgressSignalToPLC(self, in_progress: bool) -> bool:\n        \"\"\"撮像ステータスの送信\"\"\"\n        # NOTE: 撮像中はcapturing = True\n        self.setBitInWord('STATUS_COMMON', 'CAPTURING', bool2int(in_progress))\n        ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def sendInspectionInProgressSignalToPLC(self, in_progress: bool) -> bool:\n        \"\"\"検査中の信号を送信\"\"\"\n        # NOTE: W(x_out).08 検査フラグ送信\n        self.setBitInWord('STATUS_COMMON', 'INSPECTING', bool2int(in_progress))\n        ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n        return ret\n\n    def initializeStatus(self) -> None:\n        \"\"\"値の初期化\"\"\"\n        self.sendCaptureInProgressSignalToPLC(in_progress=False)\n        self.sendInspectionInProgressSignalToPLC(in_progress=False)\n        self.setInspectionNGCode(ng_code=0)\n        self.setInspectionErrorCode(error_code=0)\n        self.setPcErrorCode(error_code=0)\n        self.setPcError(bit_on=False)\n\n    def checkPLCAcknowledgement(self, tag: str, key: str,\n                                val: int, timeout: int = 1000) -> bool:\n        \"\"\"PLC側のリクエスト、ステータスを確認\n\n        Args:\n            tag (str): bitの属性 request, status, complete\n            key (str): bitの名前\n            val (int): bitの値(0 or 1)が一致すればTrue\n            timeout (int, optional): タイムアウト(ms)\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        timer_count = 0\n        start_time = perf_counter()\n        addr = self.IN_BIT_AD[tag]\n        success = False\n        while timer_count < timeout:\n            # NOTE: dataはリストで返却\n            ret, data = self.readDataFromPLCDevice(d_type='word', addr=addr, timeout=timeout)\n\n            # NOTE: 通信失敗したらcontinue\n            if not ret:\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n\n            # NOTE: 通信に成功したら値を確認\n            bit_16 = word2bit(data[0])\n            s_bit = bit_16[self.IN_BIT_IDX[key]]\n            if s_bit == val:\n                # NOTE: 一致\n                success = True\n                break\n            else:\n                # NOTE: 不一致\n                timer_count = int((perf_counter() - start_time) * 1000)\n                continue\n        return success\n\n    def getInspectionDataFromPLC(self) -> Tuple[bool, List[int]]:\n        \"\"\"各種検査に関する番号の取得\"\"\"\n        # NOTE: DM(x_in+1,+2,+3) ワーク機種\n        # NOTE: int(self.IN_WORD_AD['MODEL_NO']+1)はPOSITION_NOがない場合の配慮\n        ret, data = self.readDataFromPLCDevice(d_type='word',\n                                               addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n                                               addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n                                               multi=True)\n        if ret:\n            return True, data\n        else:\n            return False, [-1, -1, -1, -1]\n\n    def sendAlignmentDataToPLC(self, data: list) -> bool:\n        \"\"\"補正量を送信\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.writeDataToPLCDevice(d_type='word',\n                                        addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n                                        addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n                                        multi=True,\n                                        data=send_data)\n        return ret\n\n    def sendBasePositionDataToPLC(self, data: list) -> bool:\n        \"\"\"基準量を送付\"\"\"\n        # NOTE: 一応intに変換\n        data = [int(v) for v in data]\n        # NOTE: 符号付きの形式に変換\n        send_data = convert_signed(data)\n        ret = self.writeDataToPLCDevice(d_type='word',\n                                        addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n                                        addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n                                        multi=True,\n                                        data=send_data)\n        return ret\n\n    def sendInspectionResultToPLC(self,\n                                  status: int,\n                                  align_data: list,\n                                  b_align_data: list = [],\n                                  ng_code: int = 1,\n                                  err_code: int = 1,\n                                  ) -> bool:\n        \"\"\"結果を送信する\n\n        Args:\n            status (int): 判定結果 ok:1 ng:2 err:3\n            align_data (list): 検出した座標\n            b_align_data (list, optional): マスター登録した座標\n            ng_code (int, optional): 画像処理のNGコード\n            err_code (int, optional): 画像処理のERRORコード\n\n        Returns:\n            bool: _description_\n        \"\"\"\n        # NOTE: 現在位置書き込み\n        ret = self.sendAlignmentDataToPLC(align_data)\n        # NOTE: 基準位置書き込み\n        if b_align_data:\n            ret = self.sendBasePositionDataToPLC(b_align_data)\n\n        # NOTE: 判定がNGの場合NGコードを出力\n        if status == 2:\n            ret = self.setInspectionNGCode(ng_code=ng_code)\n        # NOTE: 判定がERRの場合ERRコードを出力\n        elif status == 3:\n            ret = self.setInspectionErrorCode(error_code=err_code)\n\n        # NOTE: ジャッジリストを更新\n        judge_list = [0, 0, 0, 0]\n        judge_list[status] = 1\n\n        # NOTE: 検査判定を書き込み\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_OK', judge_list[1])\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_NG', judge_list[2])\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_ERR', judge_list[3])\n        self.writeBitsStateToWord(self._pub_word_list, 'COMPLETE_COMMON')\n        # NOTE: 検査終了を伝令\n        self.sendInspectionInProgressSignalToPLC(in_progress=False)\n\n        # NOTE: PLC側で検査結果を受けとれたか確認\n        ret = self.checkPLCAcknowledgement('COMPLETE_COMMON', 'INSPECT_RECV_COMP', 1, timeout=5000)\n\n        # NOTE: Timeoutすることがたまにある、ラダー側の問題？\n        if not ret:\n            return False\n\n        # NOTE: 検査結果を初期化\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_OK', 0)\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_NG', 0)\n        self.setBitInWord('COMPLETE_COMMON', 'INSPECT_ERR', 0)\n        self.writeBitsStateToWord(self._pub_word_list, 'COMPLETE_COMMON')\n\n        return True\n\n    def sendPcErrorSignalToPLC(self, error_code: int = 1) -> bool:\n        \"\"\"エラー出力\"\"\"\n        # NOTE: エラーコードを出力\n        ret1 = self.setPcErrorCode(error_code=error_code)\n        # NOTE: PCエラーステータスをON\n        ret2 = self.setPcError(bit_on=True)\n\n        if ret1 and ret2:\n            return True\n        return False\n\n    def sendPcErrorResetSignalToPLC(self) -> bool:\n        \"\"\"PCエラーをリセット\"\"\"\n        # NOTE: ステータス初期化\n        self.initializeStatus()\n        return True\n\n    def sendHeartbeatSignalToPLC(self, pre_beat: bool) -> bool:\n        \"\"\"ラズパイの生存をPLC側に通達\"\"\"\n        if pre_beat:\n            self.setPcOnline(bit_on=False)\n            return False\n        else:\n            self.setPcOnline(bit_on=True)\n            return True\n\n    def sendCustomDataToPLC(self, data: list) -> bool:\n        \"\"\"カスタムデータ(int)を送信 9x2 = 18\"\"\"\n        # NOTE: 一応intに変換\n        try:\n            data = [int(v) for v in data]\n            # NOTE: 符号付きの形式に変換\n            send_data = convert_signed(list_negative=data, word_count=2)\n            ret = self.writeDataToPLCDevice(d_type='word',\n                                            addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'] + 18,\n                                            addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'] + 35,\n                                            multi=True,\n                                            data=send_data)\n            return ret\n        except Exception as e:\n            print(e)\n            return False\n\n\n# class PLCCommunicationForNMOJ(BasePLCCommunication):\n#     __version__ = '1.0.0'\n#     \"\"\"\n#     PLC通信@NMOJ&昔のラダー\n#     サッサとラダーを更新して捨て去りたい\n#     \"\"\"\n\n#     def __init__(self, excel_path: str):\n#         super().__init__()\n#         self.updateAddressMapFromExcel(excel_path)\n\n#     # ===============================================================================\n#     # NOTE: Excelからパラメータを取得する関数\n#     # ===============================================================================\n\n#     def getPLCDeviceMapFromExcel(self, xlsx_file: str, map_id: int) -> dict:\n#         \"\"\"デバイスのINDEXを取得\"\"\"\n#         if map_id == 0:\n#             return g_set.getHeaderAddress(book_name=xlsx_file, sheet_name=\"CONFIG\")\n#         elif map_id == 1:\n#             # NOTE: PLC->PCのBitデバイス\n#             return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_IN\")\n#         elif map_id == 2:\n#             # NOTE: PLC->PCのWordデバイス\n#             return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_IN\")\n#         elif map_id == 3:\n#             # NOTE: PC->PLCのBitデバイス\n#             return g_set.getBitData(book_name=xlsx_file, sheet_name=\"BIT_OUT\")\n#         elif map_id == 4:\n#             # NOTE: PC->PLCのWordデバイス\n#             return g_set.getWordData(book_name=xlsx_file, sheet_name=\"WORD_OUT\")\n#         else:\n#             return {}\n\n#     def convertDeviceMapToAddressMap(self, device_map: dict, header_address: int) -> dict:\n#         \"\"\"アドレスマップを取得\"\"\"\n#         data = {}\n#         for key in device_map.keys():\n#             data[key] = header_address + device_map[key]\n#         return data\n\n#     def updateAddressMapFromExcel(self, path: str) -> None:\n#         \"\"\"エクセルファイルからアドレスマップを取得\"\"\"\n#         # NOTE: キーと相対アドレス0-15\n#         header_address = self.getPLCDeviceMapFromExcel(path, 0)\n#         self.IN_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 1)\n#         self.IN_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 2)\n#         self.OUT_BIT_IDX = self.getPLCDeviceMapFromExcel(path, 3)\n#         self.OUT_WORD_IDX = self.getPLCDeviceMapFromExcel(path, 4)\n\n#         # NOTE: キーと絶対アドレス\n#         self.IN_BIT_AD = self.convertDeviceMapToAddressMap(self.IN_BIT_IDX,\n#                                                            header_address['IN_BIT_NO'])\n#         self.IN_WORD_AD = self.convertDeviceMapToAddressMap(self.IN_WORD_IDX,\n#                                                             header_address['IN_WORD_NO'])\n#         self.OUT_BIT_AD = self.convertDeviceMapToAddressMap(self.OUT_BIT_IDX,\n#                                                             header_address['OUT_BIT_NO'])\n#         self.OUT_WORD_AD = self.convertDeviceMapToAddressMap(self.OUT_WORD_IDX,\n#                                                              header_address['OUT_WORD_NO'])\n\n#         # NOTE: 内部保持変数 0で初期化\n#         # TODO: VASTから見たOUTのBITリスト 今は6Word確保\n#         self._pub_word_list = [[0 for i in range(16)] for j in range(6)]\n\n#         # NOTE: エクセルからPLCのパラメータ(IP,Port,Protocol)を取得&反映\n#         self.plc_config = g_set.getPLCParam(path, 'CONFIG')\n#         self.loadPLCConfiguration(self.plc_config)\n\n#     def getPLCConfiguration(self) -> dict:\n#         return self.plc_config\n\n#     # ===============================================================================\n#     # NOTE: ステータス管理の関数（内部ではBit管理、出力はWord出力）\n#     # ===============================================================================\n\n#     def setBitInWord(self, tag: str, key: str, val: int) -> None:\n#         \"\"\"内部管理しているbitを更新\"\"\"\n#         self._pub_word_list[self.OUT_BIT_IDX[tag]][self.OUT_BIT_IDX[key]] = val\n\n#     def readBitList(self, tag: str) -> Tuple[bool, list]:\n#         \"\"\"Wordで読み取ってBitをListに変換\"\"\"\n#         # NOTE: NMOJのラダーはbitデバイスで読取\n#         ret, data = self.readDataFromPLCDevice(d_type='bit',\n#                                                addr=self.IN_BIT_AD[tag])\n#         if not ret:\n#             return False, [0]\n\n#         bit_16 = word2bit(data[0])\n#         return True, bit_16\n\n#     def readBitState(self, tag: str, key: str) -> int:\n#         \"\"\"Wordで読み取ってBitに分解\"\"\"\n#         ret, data = self.readBitList(tag)\n#         if ret:\n#             s_bit = data[self.IN_BIT_IDX[key]]\n#             return s_bit\n#         else:\n#             return -1\n\n#     def writeBitsStateToWord(self, data: list, tag: str) -> bool:\n#         \"\"\"Bitの状態をWord単位で書き込む\"\"\"\n#         bit_16 = data[self.OUT_BIT_IDX[tag]]\n#         send_data = bit2word(bit_16)\n#         addr = self.OUT_BIT_AD[tag]\n#         # NOTE: NMOJのラダーはbitデバイスに書き込み\n#         ret = self.writeDataToPLCDevice(d_type='bit',\n#                                         addr=addr,\n#                                         data=[send_data])\n#         return ret\n\n#     # ===============================================================================\n#     # NOTE: 外部用のメソッド\n#     # ===============================================================================\n\n#     def setPcOnline(self, bit_on: bool) -> bool:\n#         self.setBitInWord('STATUS', 'PC_ONLINE', bool2int(bit_on))\n#         return self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#     def setInspectionNGCode(self, ng_code: int) -> bool:\n#         return self.writeDataToPLCDevice(d_type='word',\n#                                          addr=self.OUT_WORD_AD['NG_CODE'],\n#                                          data=[ng_code])\n\n#     def setInspectionErrorCode(self, error_code: int) -> bool:\n#         return self.writeDataToPLCDevice(d_type='word',\n#                                          addr=self.OUT_WORD_AD['ERR_CODE'],\n#                                          data=[error_code])\n\n#     def setPcErrorCode(self, error_code: int) -> bool:\n#         return self.writeDataToPLCDevice(d_type='word',\n#                                                 addr=self.OUT_WORD_AD['PC_ERR_CODE'],\n#                                                 data=[error_code])\n\n#     def setPcError(self, bit_on: bool) -> bool:\n#         self.setBitInWord('STATUS', 'PC_ERR', bool2int(bit_on))\n#         return self.writeBitsStateToWord(self._pub_word_list, 'STATUS_COMMON')\n\n#     def sendCaptureInProgressSignalToPLC(self, in_progress: bool) -> bool:\n#         \"\"\"撮像ステータスの送信\"\"\"\n#         # NOTE: 撮像中はcapturing = True\n#         self.setBitInWord('STATUS', 'CAPTURE', bool2int(in_progress))\n#         ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         return ret\n\n#     def sendInspectionInProgressSignalToPLC(self, in_progress: bool) -> bool:\n#         \"\"\"検査中の信号を送信\"\"\"\n#         # NOTE: W(x_out).08 検査フラグ送信\n#         self.setBitInWord('STATUS', 'INSPECTING', bool2int(in_progress))\n#         ret = self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         return ret\n\n#     def initializeStatus(self) -> None:\n#         \"\"\"値の初期化\"\"\"\n#         self.sendCaptureInProgressSignalToPLC(in_progress=False)\n#         self.sendInspectionInProgressSignalToPLC(in_progress=False)\n#         self.setInspectionNGCode(ng_code=0)\n#         self.setInspectionErrorCode(error_code=0)\n#         self.setPcErrorCode(error_code=0)\n#         self.setPcError(bit_on=False)\n\n#     def checkPLCAcknowledgement(self, tag: str, key: str,\n#                                 val: int, timeout: int = 1000) -> bool:\n#         \"\"\"PLC側のリクエスト、ステータスを確認\n\n#         Args:\n#             tag (str): bitの属性 request, status, complete\n#             key (str): bitの名前\n#             val (int): bitの値(0 or 1)が一致すればTrue\n#             timeout (int, optional): タイムアウト(ms)\n\n#         Returns:\n#             bool: _description_\n#         \"\"\"\n#         timer_count = 0\n#         start_time = perf_counter()\n#         addr = self.IN_BIT_AD[tag]\n#         success = False\n#         while timer_count < timeout:\n#             # NOTE: dataはリストで返却\n#             ret, data = self.readDataFromPLCDevice(d_type='bit', addr=addr, timeout=timeout)\n\n#             # NOTE: 通信失敗したらcontinue\n#             if not ret:\n#                 timer_count = int((perf_counter() - start_time) * 1000)\n#                 continue\n\n#             # NOTE: 通信に成功したら値を確認\n#             bit_16 = word2bit(data[0])\n#             s_bit = bit_16[self.IN_BIT_IDX[key]]\n#             if s_bit == val:\n#                 # NOTE: 一致\n#                 success = True\n#                 break\n#             else:\n#                 # NOTE: 不一致\n#                 timer_count = int((perf_counter() - start_time) * 1000)\n#                 continue\n#         return success\n\n#     def checkCommunicationWithPLC(self) -> Tuple[bool, str]:\n#         \"\"\"Ready信号に対する応答\"\"\"\n#         # NOTE: 初回起動時、原点復帰後に実施\n\n#         # NOTE: W(x_out).00-01 <Write> プログラム起動時に初期化\n#         self.setBitInWord('STATUS', 'PC_ONLINE', 0)\n#         self.setBitInWord('STATUS', 'PC_READY', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE: W(x_out).08-11 <Write> プログラム起動時に初期化（検査系）\n#         self.setBitInWord('STATUS', 'INSPECTING', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_OK', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_NG', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_ERR', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE:  W(x_out).00 <Write> PCの電源がONであることをPLCに通達\n#         self.setBitInWord('STATUS', 'PC_ONLINE', 1)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE: W(x_in).01 <Read> Request Readyがオンになっていることを確認\n#         ret = self.checkPLCAcknowledgement('REQ', 'READY', 1, timeout=5000)\n#         if not ret:\n#             logger.debug('Timeout Request Ready [on]')\n#             return False, 'Timeout Request Ready [on]'\n\n#         # NOTE: W(x_out).01 <Write> PLC側のW(2).01を確認したことを通達\n#         self.setBitInWord('STATUS', 'PC_READY', 1)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         # NOTE: W(x_in).01 <Read> PLC側が通達を確認\n#         ret = self.checkPLCAcknowledgement('REQ', 'READY', 0, timeout=5000)\n#         if not ret:\n#             logger.debug('Timeout Request Ready [off]')\n#             return False, 'Timeout Request Ready [off]'\n\n#         # NOTE: W(x_out).01 <Write> 初期通信確認終了\n#         self.setBitInWord('STATUS', 'PC_READY', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n\n#         logger.debug('Ready Sequence Complete')\n#         return True, ''\n\n#     def getInspectionDataFromPLC(self) -> Tuple[bool, List[int]]:\n#         \"\"\"各種検査に関する番号の取得\"\"\"\n#         # NOTE: DM(x_in+1,+2,+3) ワーク機種\n#         # NOTE: int(self.IN_WORD_AD['MODEL_NO']+1)はPOSITION_NOがない場合の配慮\n#         ret, data = self.readDataFromPLCDevice(d_type='word',\n#                                                addr_min=self.IN_WORD_AD['PROGRAM_NO'],\n#                                                addr_max=int(self.IN_WORD_AD['MODEL_NO'] + 1),\n#                                                multi=True)\n#         if ret:\n#             return True, data\n#         else:\n#             return False, [-1, -1, -1, -1]\n\n#     def sendCustomDataToPLC(self, data: list) -> bool:\n#         \"\"\"カスタムデータを送信 9x2 = 18\"\"\"\n#         # NOTE: 一応intに変換\n#         data = [int(v) for v in data]\n#         # NOTE: 符号付きの形式に変換\n#         send_data = convert_signed(data)\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'] + 18,\n#                                         addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'] + 35,\n#                                         multi=True,\n#                                         data=send_data)\n#         return ret\n\n#     def sendAlignmentDataToPLC(self, data: list) -> bool:\n#         \"\"\"補正量を送信\"\"\"\n#         # NOTE: 一応intに変換\n#         data = [int(v) for v in data]\n#         # NOTE: 符号付きの形式に変換\n#         send_data = convert_signed(data)\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr_min=self.OUT_WORD_AD['ALIGN_X_HIGH'],\n#                                         addr_max=self.OUT_WORD_AD['ALIGN_R_LOW'],\n#                                         multi=True,\n#                                         data=send_data)\n#         return ret\n\n#     def sendBasePositionDataToPLC(self, data: list) -> bool:\n#         \"\"\"基準量を送付\"\"\"\n#         # NOTE: 一応intに変換\n#         data = [int(v) for v in data]\n#         # NOTE: 符号付きの形式に変換\n#         send_data = convert_signed(data)\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr_min=self.OUT_WORD_AD['B_ALIGN_X_HIGH'],\n#                                         addr_max=self.OUT_WORD_AD['B_ALIGN_R_LOW'],\n#                                         multi=True,\n#                                         data=send_data)\n#         return ret\n\n#     def sendNumOfWorkPiece(self, num_work: int) -> bool:\n#         ret = self.writeDataToPLCDevice(d_type='word',\n#                                         addr=self.OUT_WORD_AD['NUM_WORK'],\n#                                         data=[int(num_work)])\n#         return ret\n\n#     def sendInspectionResultToPLC(self,\n#                                   status: int,\n#                                   align_data: list,\n#                                   b_align_data: list = [],\n#                                   ng_code: int = 1,\n#                                   err_code: int = 1,\n#                                   ) -> bool:\n#         \"\"\"結果を送信する\n\n#         Args:\n#             status (int): 判定結果 ok:1 ng:2 err:3\n#             align_data (list): 検出した座標\n#             b_align_data (list, optional): マスター登録した座標\n#             ng_code (int, optional): 画像処理のNGコード\n#             err_code (int, optional): 画像処理のERRORコード\n\n#         Returns:\n#             bool: _description_\n#         \"\"\"\n#         # NOTE: 現在位置書き込み\n#         ret = self.sendAlignmentDataToPLC(align_data)\n#         # NOTE: 基準位置書き込み\n#         if b_align_data:\n#             ret = self.sendBasePositionDataToPLC(b_align_data)\n\n#         # NOTE: 判定がNGの場合NGコードを出力\n#         if status == 2:\n#             ret = self.setInspectionNGCode(ng_code=ng_code)\n#         # NOTE: 判定がERRの場合ERRコードを出力\n#         elif status == 3:\n#             ret = self.setInspectionErrorCode(error_code=err_code)\n\n#         # NOTE: ジャッジリストを更新\n#         judge_list = [0, 0, 0, 0]\n#         judge_list[status] = 1\n\n#         # NOTE: 検査判定を書き込み\n#         self.setBitInWord('STATUS', 'INSPECT_OK', judge_list[1])\n#         self.setBitInWord('STATUS', 'INSPECT_NG', judge_list[2])\n#         self.setBitInWord('STATUS', 'INSPECT_ERR', judge_list[3])\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         # NOTE: 検査終了を伝令\n#         self.sendInspectionInProgressSignalToPLC(in_progress=False)\n\n#         # NOTE: PLC側で検査結果を受けとれたか確認\n#         ret = self.checkPLCAcknowledgement('REQ', 'INSPECT_RCV', 1, timeout=5000)\n#         if not ret:\n#             return False\n\n#         # NOTE: 検査結果を初期化\n#         self.setBitInWord('STATUS', 'INSPECT_OK', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_NG', 0)\n#         self.setBitInWord('STATUS', 'INSPECT_ERR', 0)\n#         self.writeBitsStateToWord(self._pub_word_list, 'STATUS')\n#         return True\n\n#     def sendPcErrorSignalToPLC(self, error_code: int = 1) -> bool:\n#         \"\"\"エラー出力\"\"\"\n#         # NOTE: エラーコードを出力\n#         ret1 = self.setPcErrorCode(error_code=error_code)\n#         # NOTE: PCエラーステータスをON\n#         ret2 = self.setPcError(bit_on=True)\n\n#         if ret1 and ret2:\n#             return True\n#         return False\n\n#     def sendPcErrorResetSignalToPLC(self) -> bool:\n#         \"\"\"PCエラーをリセット\"\"\"\n#         # NOTE: ステータス初期化\n#         self.initializeStatus()\n#         return True\n\n#     def sendHeartbeatSignalToPLC(self, pre_beat: bool) -> bool:\n#         \"\"\"ラズパイの生存をPLC側に通達\"\"\"\n#         if pre_beat:\n#             self.setPcOnline(bit_on=False)\n#             return False\n#         else:\n#             self.setPcOnline(bit_on=True)\n#             return True\n\n\nif __name__ == \"__main__\":\n    def set_time_from_plc(time_data: dict) -> None:\n        import subprocess\n\n        # NOTE: ERROR_CODEが-1の時, 通信失敗\n        if time_data.get('error_code') == -1:\n            return\n\n        # NOTE: 一応仮でデータが入るようにしておく\n        [year_, month_, day_, hour_, minutes_, second_, micro_second_] \\\n            = time_data.get('exists_data', [2023, 7, 7, 12, 12, 12, 12])\n\n        subprocess.run([\n            \"sudo\",\n            \"date\",\n            \"-s\",\n            \"{:02}/{:02} {:02}:{:02} 20{:02}\".format(\n                month_,\n                day_,\n                hour_,\n                minutes_,\n                year_\n            )\n        ])\n\n    plc = BasePLCCommunication()\n\n    conf = PLCConfiguration(ip='192.168.1.11',\n                            port='9600',\n                            manufacturer='omron',\n                            series='',\n                            plc_protocol='fins',\n                            transport_protocol='udp',\n                            bit='W',\n                            word='DM',\n                            double_word='',)\n\n    plc.loadPLCConfiguration(conf)\n\n    plc.getTimeFromPLC()\n",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\plc\\api": {
        "command_checker.py": "import binascii\nimport os\n\n# NOTE: command\nSA1_INDEX = 14\nSA2_INDEX = 16\n# NOTE: response\nDA1_INDEX = 8\nDA2_INDEX = 10\n# NOTE: identification\nSID_INDEX = 18\nCODE_INDEX = 20\n\n\ndef get_random_sid_str(bytes: int = 1) -> str:\n    \"\"\"SIDをランダムに設定\"\"\"\n    return str(binascii.b2a_hex(os.urandom(bytes)), 'ascii')\n\n\ndef get_random_sid(bytes: int = 1) -> bytes:\n    \"\"\"SIDをランダムに設定\"\"\"\n    return os.urandom(bytes)\n\n\ndef check_command(send_cmd: list, recv_cmd: list) -> bool:\n    \"\"\"送った指令に対する結果であるか、\n    レスポンスの文字列を見て確認する(Omron限定)\n    response\n    0: recv command\n    2: send command [command]\n    3: error command\n\n    Args:\n        response (list): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    # print(send_cmd, recv_cmd)\n\n    # check DA1 == SA1\n    if send_cmd[SA1_INDEX:SA1_INDEX + 2] != recv_cmd[DA1_INDEX:DA1_INDEX + 2]:\n        return False\n\n    # check SA2 == DA2\n    if send_cmd[SA2_INDEX:SA2_INDEX + 2] != recv_cmd[DA2_INDEX:DA2_INDEX + 2]:\n        return False\n\n    # check sid\n    if send_cmd[SID_INDEX:SID_INDEX + 2] != recv_cmd[SID_INDEX:SID_INDEX + 2]:\n        return False\n\n    # check command\n    if send_cmd[CODE_INDEX:CODE_INDEX + 4] != recv_cmd[CODE_INDEX:CODE_INDEX + 4]:\n        return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    print(get_random_sid(1))\n",
        "convert_format.py": "import sys\nimport re\nimport itertools\nimport more_itertools\ntry:\n    import logger\n    import global_vars\nexcept Exception:\n    from . import logger\n    from . import global_vars\nlogger = logger.get_module_logger(__name__)\n\n\ndef make_crc(orgcommand: bytes) -> bytes:\n    # 最初のCRCレジスタ値をFFFFhに設定\n    crc_registor = 0xFFFF\n    for data_byte in orgcommand:\n        # CRCレジスタとデータバイトのXOR\n        tmp = crc_registor ^ data_byte\n        # シフト回数を記憶\n        shift_num = 0\n        # シフトが 8回になるまで繰り返す\n        while(shift_num < 8):\n            if(tmp & 1 == 1):  # 桁あふれが1なら\n                tmp = tmp >> 1\n                shift_num += 1\n                tmp = 0xA001 ^ tmp\n            else:\n                tmp = tmp >> 1\n                shift_num += 1\n        # 計算結果をcrc_registorにセット\n        crc_registor = tmp\n    # 計算結果をbytes型へ変換\n    return crc_registor.to_bytes(2, 'little')\n\n\ndef convert_integer_to_double_hex(data: list, *, endian: str = 'big') -> list:\n    # Ex)\n    # big endian   : [10, 11, 12, 13] -> [2826, 3340]\n    # little endian: [10, 11, 12, 13] -> [2571, 3085]\n    convert_data = []\n    if endian in [\"big\", \"big_endian\"]:\n        for i in range(0, len(data), 2):\n            try:\n                convert_data.append(\n                    int(format(data[i + 1], '02x') + format(data[i], '02x'), 16))\n            except Exception:\n                convert_data.append(\n                    int(format(0, '02x') + format(data[i], '02x'), 16))\n    else:\n        for i in range(0, len(data), 2):\n            try:\n                convert_data.append(\n                    int(format(data[i], '02x') + format(data[i + 1], '02x'), 16))\n            except Exception:\n                convert_data.append(\n                    int(format(data[i], '02x') + format(0, '02x'), 16))\n\n    logger.debug('{}, {}'.format(sys._getframe().f_code.co_name, convert_data))\n    return convert_data\n\n\ndef convert_double_hex_to_integer(data: list, *, dhex: bool = False, endian: str = 'big') -> list:\n    # Ex)\n    # big endian   : [2571, 3085] -> [11, 10, 13, 12]\n    # little endian: [2571, 3085] -> [10, 11, 12, 13]\n    convert_data = []\n    if endian in [\"big\", \"big_endian\"]:\n        for i in range(len(data)):\n            string_data = format(data[i], '0x').zfill(\n                int(len(format(data[i], '0x')) + len(format(data[i], '0x')) % 2))\n            try:\n                convert_data.extend(\n                    [int(string_data[-2:], 16), int(string_data[-4:-2], 16)])\n            except Exception:\n                if dhex:\n                    convert_data.extend(\n                        [int(string_data[-2:], 16), 0])\n                else:\n                    convert_data.extend([int(string_data[-2:], 16)])\n    else:\n        for i in range(len(data)):\n            string_data = format(data[i], '0x').zfill(\n                int(len(format(data[i], '0x')) + len(format(data[i], '0x')) % 2))\n            try:\n                convert_data.extend(\n                    [int(string_data[-4:-2], 16), int(string_data[-2:], 16)])\n            except Exception:\n                if dhex:\n                    convert_data.extend(\n                        [0, int(string_data[-2:], 16)])\n                else:\n                    convert_data.extend([int(string_data[-2:], 16)])\n\n    logger.debug('{}, {}'.format(sys._getframe().f_code.co_name, convert_data))\n    return convert_data\n\n\ndef check_string_and_convert_dhex(data: list, byte_order: str, option: str) -> list:\n    try:\n        # check: data is \"string\" or \"integer\"\n        string_data = list(itertools.chain.from_iterable(\n            list(map(lambda x: list(x), data))))\n    except Exception:\n        new_data = data\n        option = option\n    else:\n        # case string\n        cmd_data = list(map(lambda x: ord(x), string_data))\n        try:\n            tmp_data = list(more_itertools.chunked(cmd_data, 2))\n        except Exception:\n            tmp_data = [cmd_data[i: i + 2] for i in range(0, len(cmd_data), 2)]\n        finally:\n            new_data = list(itertools.chain.from_iterable(list(\n                map(lambda x: convert_integer_to_double_hex(x, endian=byte_order), tmp_data))))\n            option = global_vars.g_STRING_OPTION[0]\n    finally:\n        return new_data, option\n\n\ndef check_hex_and_convert_integer(data: list, byte_order: str, *, dhex: bool = False, zero_padding: bool = True) -> list:\n    try:\n        tmp_data = [int(x, 16) for x in data]\n        print(tmp_data)\n    except Exception:\n        new_data = data\n    else:\n        if dhex:\n            new_data = convert_double_hex_to_integer(\n                tmp_data, dhex=dhex, endian=byte_order)\n        else:\n            new_data = tmp_data\n    finally:\n        return new_data\n\n\ndef convert_integer_to_another_base_number_as_string(value: int, base: int) -> str:\n    if (int(value / base)):\n        return convert_integer_to_another_base_number_as_string(int(value / base), base) + str(value % base)\n    return str(value % base)\n\n\ndef convert_number_as_string_to_another_base_and_hex_notation(value: str, base: int, *, paddings=0):\n    # 数値(string)を指定した底に変換したあと、16進数で表示する\n    try:\n        conv_hex = '0{}x'.format(paddings)\n        res_value = ''.join([format(int(i, base), conv_hex) for i in re.split(\n            '{}{}{}'.format('(', '.' * base, ')'), value) if i != ''])\n    except Exception:\n        res_value = value\n    return res_value\n\n\ndef convert_negative_integer_to_signed_hex(list_negative: list, *, word_count: int = 2) -> list:\n    # Convert from negative value to signed hexadecimal.\n    list_response = []\n    for x in list_negative:\n        r_list = []\n        value = x\n        for i in range(int(word_count)):\n            value, r = divmod(value, 65536)\n            if int(x) >= 0:\n                r_list.append(int(format(int(r), 'x'), 16))\n            else:\n                r_list.append(int(format(int(r) & 0xffff, 'x'), 16))\n        if int(value) != 0 and int(value) != -1:\n            if int(x) >= 0:\n                hex_value = [int(format(int(int(value)), 'x'), 16)]\n            else:\n                hex_value = [int(format(int(int(value)) & 0xffff, 'x'), 16)]\n        else:\n            hex_value = []\n        r_list.reverse()\n        hex_value.extend(r_list)\n        hex_value.reverse()\n        list_response.extend(hex_value)\n    return list_response\n\n\ndef convert_date_format(plc_protocol, cmd_data, res_element):\n    if cmd_data[\"option\"] in global_vars.g_TIME_OPTION:\n        if plc_protocol[\"manufacture\"] in global_vars.g_MITSUBISHI:\n            if len(res_element) >= 4:\n                exists_data = []\n                for data in res_element:\n                    try:\n                        exists_data.append(int(data, 16))\n                    except Exception:\n                        exists_data.append(int(data))\n                res_element = exists_data\n        elif plc_protocol[\"manufacture\"] in global_vars.g_PANASONIC:\n            if len(res_element) >= 4:\n                if plc_protocol[\"series\"] in [\"fp7\", \"7\"]:\n                    exists_data = []\n                    for data in res_element:\n                        exists_data.append(int(data))\n                    res_element = exists_data\n                else:\n                    exists_data = [\n                        int(res_element[2][:2]),  # year\n                        int(res_element[2][2:]),  # month\n                        int(res_element[1][:2]),  # day\n                        int(res_element[1][2:]),  # hour\n                        int(res_element[0][:2]),  # minute\n                        int(res_element[0][2:]),  # second\n                        int(res_element[3][2:])   # weekday\n                    ]\n                    res_element = exists_data\n        elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n            exists_data = []\n            for data in res_element:\n                exists_data.append(int(data))\n            res_element = exists_data\n        elif plc_protocol[\"manufacture\"] in global_vars.g_OMRON:\n            exists_data = []\n            for data in res_element:\n                exists_data.append(int(data))\n            res_element = exists_data\n    return res_element\n",
        "device_list.py": "import traceback\nimport sys\ntry:\n    import global_vars\n    import logger\nexcept Exception:\n    from . import global_vars\n    from . import logger\n\nlogger = logger.get_module_logger(__name__)\n\n\ndef devicelist(\n        manufacture: str, protocol: str, series: str, *,\n        transport_layer: str = 'tcp', period_index: int = None) -> (dict, int, int, str):\n    # A list of plc devices. (OLD VERSION)\n    # '<device name of PLC>':['decimal system', 'device code', 'data unit', (offset)]\n    try:\n        # ==== Mitsubishi Electric ====\n        if manufacture in global_vars.g_MITSUBISHI:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL1E:\n                transfer_limit = 255\n                prefix_bit = 4\n                dict_devices = {\n                    'D': ['10', (0x44, 0x20), 'w'], 'R': ['10', (0x52, 0x20), 'w'], 'TN': ['10', (0x54, 0x4E), 'w'], 'TS': ['10', (0x54, 0x53), 'b'],\n                    'CN': ['10', (0x43, 0x4E), 'w'], 'CS': ['10', (0x43, 0x53), 'b'], 'X': ['16', (0x58, 0x20), 'b'], 'Y': ['16', (0x59, 0x20), 'b'],\n                    'M': ['10', (0x4D, 0x20), 'b'], 'S': ['10', (0x53, 0x20), 'b']\n                }\n            elif protocol in global_vars.g_MCPROTOCOL3E:\n                if series in global_vars.g_SERIES_IQR:\n                    transfer_limit = 960\n                    prefix_bit = 22\n                    dict_devices = {\n                        'SM': ['10', 0x0091, 'b'], 'SD': ['10', 0x00A9, 'w'], 'X': ['16', 0x009C, 'b'], 'Y': ['16', 0x009D, 'b'],\n                        'M': ['10', 0x0090, 'b'], 'L': ['10', 0x0092, 'b'], 'F': ['10', 0x0093, 'b'], 'V': ['10', 0x0094, 'b'],\n                        'B': ['16', 0x00A0, 'b'], 'D': ['10', 0x00A8, 'w'], 'W': ['16', 0x00B4, 'w'], 'TS': ['10', 0x00C1, 'b'],\n                        'TC': ['10', 0x00C0, 'b'], 'TN': ['10', 0x00C0, 'w'], 'STS': ['10', 0x00C7, 'b'], 'STC': ['10', 0x00C6, 'b'],\n                        'STN': ['10', 0x00C8, 'w'], 'CS': ['10', 0x00C4, 'b'], 'CC': ['10', 0x00C3, 'b'], 'CN': ['10', 0x00C5, 'w'],\n                        'SB': ['16', 0x00A1, 'b'], 'SW': ['16', 0x00B5, 'w'], 'DX': ['16', 0x00A2, 'b'], 'DY': ['16', 0x00A3, 'b'],\n                        'Z': ['10', 0x00CC, 'w'], 'R': ['10', 0x00AF, 'w'], 'ZR': ['16', 0x00B0, 'w'], 'LTS': ['10', 0x0051, 'b'],\n                        'LTC': ['10', 0x0050, 'b'], 'LTN': ['10', 0x0052, 'dw'], 'LSTS': ['10', 0x0059, 'b'], 'LSTC': ['10', 0x0058, 'b'],\n                        'LSTN': ['10', 0x005A, 'dw'], 'LCS': ['10', 0x0055, 'b'], 'LCC': ['10', 0x0054, 'b'], 'LCN': ['10', 0x0056, 'dw'],\n                        'LZ': ['10', 0x00CC, 'dw'], 'RD': ['10', 0x002C, 'w']\n                    }\n                else:\n                    transfer_limit = 960\n                    prefix_bit = 22\n                    dict_devices = {\n                        'SM': ['10', 0x91, 'b'], 'SD': ['10', 0xA9, 'w'], 'X': ['16', 0x9C, 'b'], 'Y': [16, 0x9D, 'b'],\n                        'M': ['10', 0x90, 'b'], 'L': ['10', 0x92, 'b'], 'F': ['10', 0x93, 'b'], 'V': [10, 0x94, 'b'],\n                        'B': ['16', 0xA0, 'b'], 'D': ['10', 0xA8, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': [10, 0xC1, 'b'],\n                        'TC': ['10', 0xC0, 'b'], 'TN': ['10', 0xC0, 'w'], 'STS': ['10', 0xC7, 'b'], 'STC': [10, 0xC6, 'b'],\n                        'STN': ['10', 0xC8, 'w'], 'CS': ['10', 0xC4, 'b'], 'CC': ['10', 0xC3, 'b'], 'CN': [10, 0xC5, 'w'],\n                        'SB': ['16', 0xA1, 'b'], 'SW': ['16', 0xB5, 'w'], 'DX': ['16', 0xA2, 'b'], 'DY': [16, 0xA3, 'b'],\n                        'Z': ['10', 0xCC, 'w'], 'R': ['10', 0xAF, 'w'], 'ZR': ['16', 0xB0, 'w']\n                    }\n            elif protocol in global_vars.g_MCPROTOCOL4E:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            # ikeikeike\n            elif protocol in global_vars.g_COMPUTERLINK:\n                transfer_limit = 99\n                prefix_bit = 5\n                dict_devices = {\n                    'X': ['ascii', b'X', 'b'], 'Y': ['ascii', b'Y', 'b'],\n                    'M': ['ascii', b'M', 'b'], 'L': ['ascii', b'L', 'b'], 'F': ['ascii', b'F', 'b'], 'V': ['ascii', 'V', 'b'],\n                    'B': ['ascii', b'B', 'b'], 'D': ['ascii', b'D', 'w'], 'W': ['ascii', b'W', 'w'],\n                    'Z': ['ascii', b'Z', 'w'], 'R': ['ascii', b'R', 'w']\n                }\n            # ikeikeike\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Keyence\n        elif manufacture in global_vars.g_KEYENCE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                transfer_limit = 960\n                prefix_bit = 22\n                dict_devices = {\n                    'R': ['1010', 0x9c, 'b'], 'B': ['16', 0xA0, 'b'], 'MR': ['1010', 0x90, 'b'], 'LR': ['1010', 0x92, 'b'],\n                    'CR': ['1010', 0x91, 'b'], 'CM': ['10', 0xA9, 'w'], 'DM': ['10', 0xA8, 'w'], 'EM': ['10', 0xA8, 'w'],\n                    'FM': ['10', 0xAF, 'w'], 'ZF': ['16', 0xB0, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': ['10', 0xC1, 'b'],\n                    'TC': ['10', 0xC2, 'b'], 'CC': ['10', 0xC5, 'b'], 'CS': ['10', 0xC4, 'b'], 'D': ['10', 0xA8, 'w'],\n                    'M': ['1010', 0x90, 'b'], 'T': ['10', 0xC1, 'b'], 'C': ['10', 0xC5, 'b'],\n                }\n\n            elif protocol in global_vars.g_HOSTLINK:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Panasonic\n        elif manufacture in global_vars.g_PANASONIC:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                transfer_limit = 960\n                prefix_bit = 22\n                dict_devices = {\n                    'X': ['1016', 0x9C, 'b'], 'Y': ['1016', 0x9D, 'b'], 'L': ['1016', 0xA0, 'b'], 'R': ['1016', 0x90, 'b'],\n                    'R1': ['1016', 0x92, 'b'], 'DT': ['10', 0xA8, 'w'], 'LD': ['10', 0xB4, 'w'], 'EVT': ['10', 0xC2, 'w'],\n                    'T': ['10', 0xC1, 'b'], 'EVC': ['10', 0xC5, 'w'], 'C': ['10', 0xC4, 'b'], 'SR': ['1016', 0x91, 'b', 9000],\n                    'SD': ['10', 0xA9, 'w', 90000], 'SDT': ['10', 0xA9, 'w', 90000], 'D': ['10', 0xA8, 'w'],\n                }\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Omron\n        elif manufacture in global_vars.g_OMRON:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_FINS:\n                transfer_limit = 498\n                if transport_layer in global_vars.g_UDPIP:\n                    prefix_bit = 28\n                elif transport_layer in global_vars.g_TCPIP:\n                    prefix_bit = 76\n                else:\n                    prefix_bit = 76\n                dict_devices = {\n                    'CIO': ['10.10', 0x30, 'b'], 'W': ['10.10', 0x31, 'b'], 'H': ['10.10', 0x32, 'b'], 'A': ['10.10', 0x33, 'b'],\n                    'DM': ['10.10', 0x02, 'b'], 'TK': ['10.10', 0x46, 'b'], 'IR': ['10', 0xDC, 'w'], 'DR': ['10', 0xBC, 'w'],\n                    'EM0': ['10.10', 0xA0, 'b'], 'EM1': ['10.10', 0xA1, 'b'], 'EM2': ['10.10', 0xA2, 'b'], 'EM3': ['10.10', 0xA3, 'b'], 'EM4': ['10.10', 0xA4, 'b'],\n                    'EM5': ['10.10', 0xA5, 'b'], 'EM6': ['10.10', 0xA6, 'b'], 'EM7': ['10.10', 0xA7, 'b'], 'EM8': ['10.10', 0xA8, 'b'], 'EM9': ['10.10', 0xA9, 'b'],\n                    'EMA': ['10.10', 0xAA, 'b'], 'EMB': ['10.10', 0xAB, 'b'], 'EMC': ['10.10', 0xAC, 'b'], 'EMD': ['10.10', 0xAD, 'b'], 'EME': ['10.10', 0xAE, 'b'],\n                    'EMF': ['10.10', 0xAF, 'b'], 'EM10': ['10.10', 0x60, 'b'], 'EM11': ['10.10', 0x61, 'b'], 'EM12': ['10.10', 0x62, 'b'], 'EM13': [10.10, 0x63, 'b'],\n                    'EM14': ['10.10', 0x64, 'b'], 'EM15': ['10.10', 0x65, 'b'], 'EM16': ['10.10', 0x66, 'b'], 'EM17': ['10.10', 0x67, 'b'], 'EM18': ['10.10', 0x68, 'b'],\n                    'EMCB': ['10', 0x98, 'w'],\n                    'TIMS': ['10', 0x09, 'w'], 'CNTS': ['10', 0x09, 'w', 8000], 'TIMN': ['10', 0x89, 'w'], 'CNTN': ['10', 0x89, 'w', 8000],\n                    'D': ['10.10', 0x82, 'b'],\n                }\n                if period_index is None:\n                    dict_update_devices = {\n                        'CIO': ['10', 0xB0, 'w'], 'W': ['10', 0xB1, 'w'], 'H': ['10', 0xB2, 'w'], 'A': ['10', 0xB3, 'w'],\n                        'DM': ['10', 0x82, 'w'], 'TK': ['10', 0x46, 'w'],\n                        'EM0': ['10', 0xA0, 'w'], 'EM1': ['10', 0xA1, 'w'], 'EM2': ['10', 0xA2, 'w'], 'EM3': ['10', 0xA3, 'w'], 'EM4': ['10', 0xA4, 'w'],\n                        'EM5': ['10', 0xA5, 'w'], 'EM6': ['10', 0xA6, 'w'], 'EM7': ['10', 0xA7, 'w'], 'EM8': ['10', 0xA8, 'w'], 'EM9': ['10', 0xA9, 'w'],\n                        'EMA': ['10', 0xAA, 'w'], 'EMB': ['10', 0xAB, 'w'], 'EMC': ['10', 0xAC, 'w'], 'EMD': ['10', 0xAD, 'w'], 'EME': ['10', 0xAE, 'w'],\n                        'EMF': ['10', 0xAF, 'w'], 'EM10': ['10', 0x60, 'w'], 'EM11': ['10', 0x61, 'w'], 'EM12': ['10', 0x62, 'w'], 'EM13': ['10', 0x63, 'w'],\n                        'EM14': ['10', 0x64, 'w'], 'EM15': ['10', 0x65, 'w'], 'EM16': ['10', 0x66, 'w'], 'EM17': ['10', 0x67, 'w'], 'EM18': ['10', 0x68, 'w'],\n                    }\n                    dict_devices.update(dict_update_devices)\n            elif protocol in global_vars.g_CIP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Rockwell\n        elif manufacture in global_vars.g_ROCKWELL:\n            if protocol in global_vars.g_MODBUSTCP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Siemens\n        elif manufacture in global_vars.g_SIEMENS:\n            if protocol in global_vars.g_MODBUSTCP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # Schneider electric\n        elif manufacture in global_vars.g_SCHNEIDERELECTRIC:\n            if protocol in global_vars.g_MODBUSTCP:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol will be added in the future.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # ikeike-------------------------------------\n        # Xinje\n        elif manufacture in global_vars.g_XINJE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MODBUSRTU:\n                transfer_limit = 24\n                prefix_bit = 5\n                # prefix_bit = 3\n                dict_devices = {\n                    'M': ['10', 0x01, 'b'], 'X': ['10', 0x01, 'b', 4000], 'Y': ['10', 0x01, 'b', 4800],\n                    'D': ['10', 0x04, 'w'],\n                }\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                    )\n                )\n            else:\n                raise ValueError(\n                    '{},{}'.format(\n                        sys._getframe().f_code.co_name, 'This protocol name is wrong OR is Not supported.'\n                    )\n                )\n        # ikeike-------------------------------------\n        # Other manufacure\n        else:\n            raise ValueError(\n                '{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This manufacture name is wrong OR is Not supported.'\n                )\n            )\n\n        key = ['decimal', 'binary', 'character']\n        devices = {}\n        for k, v in dict_devices.items():\n            devices[k] = dict(zip(key, v))\n\n        return {\n            'device': devices,\n            'transfer_limit': transfer_limit,\n            'prefix_bit': prefix_bit,\n            'byte_order': byte_order,\n            'traceback': '',\n        }\n    except Exception:\n        return {\n            'device': {},\n            'transfer_limit': 0,\n            'prefix_bit': 0,\n            'byte_order': '',\n            'traceback': traceback.format_exc(),\n        }\n\n\ndef convert_to_decimal(n_array: str, device_parameter: dict) -> dict:\n    # Converts the number of digits set by each company to the number of\n    # digits of the communication protocol.\n    try:\n        period_index = device_parameter['min'].index('.')\n    except ValueError:\n        period_index = None\n    # Decimal number.  Ex) '1000' -> 1000(10)\n    if n_array == '10':\n        min_bit = int(device_parameter['min'],)\n        try:\n            max_bit = int(device_parameter['max'])\n        except Exception:\n            max_bit = min_bit\n    # Hexadecimal number.  Ex) '1000' -> 4096(10)\n    elif n_array == '16':\n        min_bit = int(device_parameter['min'], 16)\n        try:\n            max_bit = int(device_parameter['max'], 16)\n        except Exception:\n            max_bit = min_bit\n    # Upper digits are in decimal. The last 2 digit is a decimal number of n_array notation.\n    #  Ex) '511.15' -> 51115(10)\n    elif n_array == '10.10':\n        min_integer = str(device_parameter['min'])[:period_index]\n        if period_index is not None:\n            min_n_array = str(device_parameter['min'])[period_index + 1:]\n            min_bit = int(min_integer) * 16 + int(min_n_array)\n            try:\n                period_index_max = device_parameter['max'].index('.')\n                max_bit = (\n                    int(str(device_parameter['max'])[:period_index_max]) * 16\n                    + int(str(device_parameter['max'])[period_index_max + 1:])\n                )\n            except Exception:\n                max_bit = min_bit\n        else:\n            min_bit = int(min_integer)\n            try:\n                max_bit = int(str(device_parameter['max']))\n            except Exception:\n                max_bit = min_bit\n    # Upper digits are in decimal. The last 2 digit is a Hexadecimal number of decimal notation.\n    #  Ex) 199915 -> 1999*16+15 = 31999(10)\n    elif n_array == '1010':\n        if len(str(device_parameter['min'])) <= 2:\n            min_bit = int(str(device_parameter['min']))\n        else:\n            min_bit = (\n                int(str(device_parameter['min'])[:-2]) * 16\n                + int(str(device_parameter['min'])[-2:])\n            )\n        try:\n            if len(str(device_parameter['max'])) <= 2:\n                max_bit = int(str(device_parameter['max']))\n            else:\n                max_bit = (\n                    int(str(device_parameter['max'])[:-2]) * 16\n                    + int(str(device_parameter['max'])[-2:])\n                )\n        except Exception:\n            max_bit = min_bit\n    # Upper digits are in decimal. The last 1 digit is a Hexadecimal number of Hexadecimal notation.\n    # Ex) 109F -> 109*16+F = 1759(10)\n    elif n_array == '1016':\n        if len(str(device_parameter['min'])) <= 1:\n            min_bit = int(str(device_parameter['min']), 16)\n        else:\n            min_bit = (\n                int(str(device_parameter['min'])[:-1]) * 16\n                + int(str(device_parameter['min'])[-1:], 16)\n            )\n        try:\n            if len(str(device_parameter['max'])) <= 1:\n                max_bit = int(str(device_parameter['max']), 16)\n            else:\n                max_bit = (\n                    int(str(device_parameter['max'])[:-1]) * 16\n                    + int(str(device_parameter['max'])[-1:], 16)\n                )\n        except Exception:\n            max_bit = min_bit\n    elif n_array == 'ascii':\n        min_bit = int(device_parameter['min'])\n        max_bit = int(device_parameter['max'])\n\n    # Confirmation of large and small.\n    if min_bit > max_bit:\n        (temp_min, temp_max) = (min_bit, max_bit)\n        (min_bit, max_bit) = (temp_max, temp_min)\n    lead_number = min_bit\n    # Number of communication data and times.\n    send_length = max_bit - min_bit + 1\n    return {\n        'lead_number': lead_number,\n        'send_length': send_length,\n    }\n\n\ndef convert_to_n_array(\n        n_array: str, lead_number: int,\n        send_length: int) -> (str, str):\n    # Converts the number of digits set by each company to the number of digits of the communication protocol.\n    # Decimal number.  Ex) 1000(10) -> '1000'\n    if n_array == '10':\n        min_bit = lead_number\n        min_bit = str(min_bit)\n        max_bit = str(lead_number + send_length)\n    # Hexadecimal number.  Ex) 4096(10) -> '1000'\n    elif n_array == '16':\n        min_bit = lead_number\n        min_bit = format(min_bit, 'x')\n        max_bit = format(lead_number + send_length - 1, 'x')\n    # Upper digits are in decimal. The last 2 digit is a decimal number of decimal notation.\n    #  Ex) 51115(10) '511.15'\n    elif n_array == '10.10':\n        min_integer, min_n_array = divmod(lead_number, 16)\n        max_integer, max_n_array = divmod(lead_number + send_length, 16)\n        min_bit = str(min_integer) + \".\" + \"{02}\".format(min_n_array)\n        max_bit = str(max_integer) + \".\" + \"{02}\".format(max_n_array)\n    # Upper digits are in decimal. The last 2 digit is a Hexadecimal number of decimal notation.\n    #  Ex) 31999(10) = 1999*16+15 -> 199915\n    elif n_array == '1010':\n        min_integer, min_n_array = divmod(lead_number, 16)\n        max_integer, max_n_array = divmod(lead_number + send_length, 16)\n        min_bit = str(min_integer) + '{02}'.format(min_n_array)\n        max_bit = str(max_integer) + '{02}'.format(max_n_array)\n    # Upper digits are in decimal. The last 1 digit is a Hexadecimal number of Hexadecimal notation.\n    # Ex) 1759(10) = 109*16+F -> 109F\n    elif n_array == '1016':\n        min_integer, min_n_array = divmod(lead_number, 16)\n        max_integer, max_n_array = divmod(lead_number + send_length, 16)\n        min_bit = str(min_integer) + format(min_n_array, '01x')\n        max_bit = str(max_integer) + format(max_n_array, '01x')\n    elif n_array == 'ascii':\n        min_bit = lead_number\n        max_bit = min_bit\n    return {\n        'min_bit': min_bit,\n        'max_bit': max_bit,\n    }\n\n\ndef device_list(manufacture: str, protocol: str, series: str, *,\n                transport_layer: str = 'tcp', period_index: int = None) -> (dict, int, int, str):\n    # A list of plc devices.(LATEST VERSION)\n    # '<device name of PLC>':['decimal system', 'device code', 'data unit', (offset)]\n    try:\n        # Mitsubishi electric\n        if manufacture in global_vars.g_MITSUBISHI:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL1E:\n                dict_devices = {\n                    'D': ['10', (0x44, 0x20), 'w'], 'R': ['10', (0x52, 0x20), 'w'], 'TN': ['10', (0x54, 0x4E), 'w'], 'TS': ['10', (0x54, 0x53), 'b'],\n                    'CN': ['10', (0x43, 0x4E), 'w'], 'CS': ['10', (0x43, 0x53), 'b'], 'X': ['16', (0x58, 0x20), 'b'], 'Y': ['16', (0x59, 0x20), 'b'],\n                    'M': ['10', (0x4D, 0x20), 'b'], 'S': ['10', (0x53, 0x20), 'b']\n                }\n                transfer_limit = 255\n                prefix_bit = 4\n            elif protocol in global_vars.g_MCPROTOCOL3E:\n                if series in global_vars.g_SERIES_IQR:\n                    dict_devices = {\n                        'SM': ['10', 0x0091, 'b'], 'SD': ['10', 0x00A9, 'w'], 'X': ['16', 0x009C, 'b'], 'Y': ['16', 0x009D, 'b'],\n                        'M': ['10', 0x0090, 'b'], 'L': ['10', 0x0092, 'b'], 'F': ['10', 0x0093, 'b'], 'V': ['10', 0x0094, 'b'],\n                        'B': ['16', 0x00A0, 'b'], 'D': ['10', 0x00A8, 'w'], 'W': ['16', 0x00B4, 'w'], 'TS': ['10', 0x00C1, 'b'],\n                        'TC': ['10', 0x00C0, 'b'], 'TN': ['10', 0x00C0, 'w'], 'STS': ['10', 0x00C7, 'b'], 'STC': ['10', 0x00C6, 'b'],\n                        'STN': ['10', 0x00C8, 'w'], 'CS': ['10', 0x00C4, 'b'], 'CC': ['10', 0x00C3, 'b'], 'CN': ['10', 0x00C5, 'w'],\n                        'SB': ['16', 0x00A1, 'b'], 'SW': ['16', 0x00B5, 'w'], 'DX': ['16', 0x00A2, 'b'], 'DY': ['16', 0x00A3, 'b'],\n                        'Z': ['10', 0x00CC, 'w'], 'R': ['10', 0x00AF, 'w'], 'ZR': ['16', 0x00B0, 'w'], 'LTS': ['10', 0x0051, 'b'],\n                        'LTC': ['10', 0x0050, 'b'], 'LTN': ['10', 0x0052, 'dw'], 'LSTS': ['10', 0x0059, 'b'], 'LSTC': ['10', 0x0058, 'b'],\n                        'LSTN': ['10', 0x005A, 'dw'], 'LCS': ['10', 0x0055, 'b'], 'LCC': ['10', 0x0054, 'b'], 'LCN': ['10', 0x0056, 'dw'],\n                        'LZ': ['10', 0x00CC, 'dw'], 'RD': ['10', 0x002C, 'w']\n                    }\n                    transfer_limit = 960\n                    prefix_bit = 22\n                else:\n                    dict_devices = {\n                        'SM': ['10', 0x91, 'b'], 'SD': ['10', 0xA9, 'w'], 'X': ['16', 0x9C, 'b'], 'Y': [16, 0x9D, 'b'],\n                        'M': ['10', 0x90, 'b'], 'L': ['10', 0x92, 'b'], 'F': ['10', 0x93, 'b'], 'V': [10, 0x94, 'b'],\n                        'B': ['16', 0xA0, 'b'], 'D': ['10', 0xA8, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': [10, 0xC1, 'b'],\n                        'TC': ['10', 0xC0, 'b'], 'TN': ['10', 0xC0, 'w'], 'STS': ['10', 0xC7, 'b'], 'STC': [10, 0xC6, 'b'],\n                        'STN': ['10', 0xC8, 'w'], 'CS': ['10', 0xC4, 'b'], 'CC': ['10', 0xC3, 'b'], 'CN': [10, 0xC5, 'w'],\n                        'SB': ['16', 0xA1, 'b'], 'SW': ['16', 0xB5, 'w'], 'DX': ['16', 0xA2, 'b'], 'DY': [16, 0xA3, 'b'],\n                        'Z': ['10', 0xCC, 'w'], 'R': ['10', 0xAF, 'w'], 'ZR': ['16', 0xB0, 'w']\n                    }\n                    transfer_limit = 960\n                    prefix_bit = 22\n            elif protocol in global_vars.g_MCPROTOCOL4E:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            elif protocol in global_vars.g_COMPUTERLINK:\n                transfer_limit = 99\n                prefix_bit = 5\n                dict_devices = {\n                    'X': ['ascii', b'X', 'b'], 'Y': ['ascii', b'Y', 'b'],\n                    'M': ['ascii', b'M', 'b'], 'L': ['ascii', b'L', 'b'], 'F': ['ascii', b'F', 'b'], 'V': ['ascii', 'V', 'b'],\n                    'B': ['ascii', b'B', 'b'], 'D': ['ascii', b'D', 'w'], 'W': ['ascii', b'W', 'w'],\n                    'Z': ['ascii', b'Z', 'w'], 'R': ['ascii', b'R', 'w']\n                }\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Keyence\n        elif manufacture in global_vars.g_KEYENCE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                dict_devices = {\n                    'R': ['1010', 0x9c, 'b'], 'B': ['16', 0xA0, 'b'], 'MR': ['1010', 0x90, 'b'], 'LR': ['1010', 0x92, 'b'],\n                    'CR': ['1010', 0x91, 'b'], 'CM': ['10', 0xA9, 'w'], 'DM': ['10', 0xA8, 'w'], 'EM': ['10', 0xA8, 'w'],\n                    'FM': ['10', 0xAF, 'w'], 'ZF': ['16', 0xB0, 'w'], 'W': ['16', 0xB4, 'w'], 'TS': ['10', 0xC1, 'b'],\n                    'TC': ['10', 0xC2, 'b'], 'CC': ['10', 0xC5, 'b'], 'CS': ['10', 0xC4, 'b'], 'D': ['10', 0xA8, 'w'],\n                    'M': ['1010', 0x90, 'b'], 'T': ['10', 0xC1, 'b'], 'C': ['10', 0xC5, 'b'],\n                }\n\n                transfer_limit = 960\n                prefix_bit = 22\n            elif protocol in global_vars.g_HOSTLINK:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Panasonic\n        elif manufacture in global_vars.g_PANASONIC:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_MCPROTOCOL3E:\n                dict_devices = {\n                    'X': ['1016', 0x9C, 'b'], 'Y': ['1016', 0x9D, 'b'], 'L': ['1016', 0xA0, 'b'], 'R': ['1016', 0x90, 'b'],\n                    'R1': ['1016', 0x92, 'b'], 'DT': ['10', 0xA8, 'w'], 'LD': ['10', 0xB4, 'w'], 'EVT': ['10', 0xC2, 'w'],\n                    'T': ['10', 0xC1, 'b'], 'EVC': ['10', 0xC5, 'w'], 'C': ['10', 0xC4, 'b'], 'SR': ['1016', 0x91, 'b', 9000],\n                    'SD': ['10', 0xA9, 'w', 90000], 'SDT': ['10', 0xA9, 'w', 90000], 'D': ['10', 0xA8, 'w'],\n                }\n                transfer_limit = 960\n                prefix_bit = 22\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Omron\n        elif manufacture in global_vars.g_OMRON:\n            byte_order = 'big_endian'\n            if protocol in global_vars.g_FINS:\n                dict_devices = {\n                    'CIO': ['10.10', 0x30, 'b'], 'W': ['10.10', 0x31, 'b'], 'H': ['10.10', 0x32, 'b'], 'A': ['10.10', 0x33, 'b'],\n                    'DM': ['10.10', 0x02, 'b'], 'TK': ['10.10', 0x46, 'b'], 'IR': ['10', 0xDC, 'w'], 'DR': ['10', 0xBC, 'w'],\n                    'EM0': ['10.10', 0xA0, 'b'], 'EM1': ['10.10', 0xA1, 'b'], 'EM2': ['10.10', 0xA2, 'b'], 'EM3': ['10.10', 0xA3, 'b'], 'EM4': ['10.10', 0xA4, 'b'],\n                    'EM5': ['10.10', 0xA5, 'b'], 'EM6': ['10.10', 0xA6, 'b'], 'EM7': ['10.10', 0xA7, 'b'], 'EM8': ['10.10', 0xA8, 'b'], 'EM9': ['10.10', 0xA9, 'b'],\n                    'EMA': ['10.10', 0xAA, 'b'], 'EMB': ['10.10', 0xAB, 'b'], 'EMC': ['10.10', 0xAC, 'b'], 'EMD': ['10.10', 0xAD, 'b'], 'EME': ['10.10', 0xAE, 'b'],\n                    'EMF': ['10.10', 0xAF, 'b'], 'EM10': ['10.10', 0x60, 'b'], 'EM11': ['10.10', 0x61, 'b'], 'EM12': ['10.10', 0x62, 'b'], 'EM13': [10.10, 0x63, 'b'],\n                    'EM14': ['10.10', 0x64, 'b'], 'EM15': ['10.10', 0x65, 'b'], 'EM16': ['10.10', 0x66, 'b'], 'EM17': ['10.10', 0x67, 'b'], 'EM18': ['10.10', 0x68, 'b'],\n                    'EMCB': ['10', 0x98, 'w'],\n                    'TIMS': ['10', 0x09, 'w'], 'CNTS': ['10', 0x09, 'w', 8000], 'TIMN': ['10', 0x89, 'w'], 'CNTN': ['10', 0x89, 'w', 8000]\n                }\n                if period_index is None:\n                    dict_update_devices = {\n                        'CIO': ['10', 0xB0, 'w'], 'W': ['10', 0xB1, 'w'], 'H': ['10', 0xB2, 'w'], 'A': ['10', 0xB3, 'w'],\n                        'DM': ['10', 0x82, 'w'], 'TK': ['10', 0x46, 'w'],\n                        'EM0': ['10', 0xA0, 'w'], 'EM1': ['10', 0xA1, 'w'], 'EM2': ['10', 0xA2, 'w'], 'EM3': ['10', 0xA3, 'w'], 'EM4': ['10', 0xA4, 'w'],\n                        'EM5': ['10', 0xA5, 'w'], 'EM6': ['10', 0xA6, 'w'], 'EM7': ['10', 0xA7, 'w'], 'EM8': ['10', 0xA8, 'w'], 'EM9': ['10', 0xA9, 'w'],\n                        'EMA': ['10', 0xAA, 'w'], 'EMB': ['10', 0xAB, 'w'], 'EMC': ['10', 0xAC, 'w'], 'EMD': ['10', 0xAD, 'w'], 'EME': ['10', 0xAE, 'w'],\n                        'EMF': ['10', 0xAF, 'w'], 'EM10': ['10', 0x60, 'w'], 'EM11': ['10', 0x61, 'w'], 'EM12': ['10', 0x62, 'w'], 'EM13': ['10', 0x63, 'w'],\n                        'EM14': ['10', 0x64, 'w'], 'EM15': ['10', 0x65, 'w'], 'EM16': ['10', 0x66, 'w'], 'EM17': ['10', 0x67, 'w'], 'EM18': ['10', 0x68, 'w'],\n                    }\n                    dict_devices.update(dict_update_devices)\n                transfer_limit = 498\n                if transport_layer in global_vars.g_UDPIP:\n                    prefix_bit = 28\n                elif transport_layer in global_vars.g_TCPIP:\n                    prefix_bit = 76\n                else:\n                    prefix_bit = 76\n            elif protocol in global_vars.g_CIP:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Rockwell\n        elif manufacture in global_vars.g_ROCKWELL:\n            if protocol in global_vars.g_MODBUS:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Siemens\n        elif manufacture in global_vars.g_SIEMENS:\n            if protocol in global_vars.g_MODBUS:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Schneider electric\n        elif manufacture in global_vars.g_SCHNEIDERELECTRIC:\n            if protocol in global_vars.g_MODBUS:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol will be added in the future.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Xinje\n        elif manufacture in global_vars.g_XINJE:\n            byte_order = 'little_endian'\n            if protocol in global_vars.g_MODBUSRTU:\n                transfer_limit = 960\n                prefix_bit = 3\n                dict_devices = {\n                    'M': ['10', 0x01, 'b'], 'X': ['10', 0x01, 'b', 4000], 'Y': ['10', 0x01, 'b', 4800],\n                    'D': ['10', 0x04, 'w'],\n                }\n            elif protocol in global_vars.g_MEWTOCOL:\n                raise ValueError('{},{}'.format(\n                    sys._getframe().f_code.co_name, 'This protocol is not supported.'))\n            else:\n                raise ValueError('{},{}'.format(sys._getframe(\n                ).f_code.co_name, 'This protocol name is wrong OR is Not supported.'))\n        # Other manufacure\n        else:\n            raise ValueError('{},{}'.format(sys._getframe(\n            ).f_code.co_name, 'This manufacture name is wrong OR is Not supported.'))\n        return {\n            'device': dict_devices,\n            'transfer_limit': transfer_limit,\n            'prefix_bit': prefix_bit,\n            'byte_order': byte_order,\n            'traceback': '',\n        }\n    except Exception:\n        return {\n            'device': {},\n            'transfer_limit': 0,\n            'prefix_bit': 0,\n            'byte_order': '',\n            'traceback': traceback.format_exc(),\n        }\n\n\nif __name__ == '__main__':\n    a = []\n    for i in range(2):\n        # a.append(device_list('panasonic', 'mc_3e', 'q', transport_layer='tcp'))\n        # a.append(devicelist('panasonic', 'mc_3e', 'q', transport_layer='tcp'))\n        a.append(list(device_list('mitsubishi', 'slmp', '')['device'].keys()))\n    print(a)\n",
        "global_vars.py": "import os\nimport json\n# from dotenv import load_dotenv\nimport dotenv\ndotenv.load_dotenv()\n\n# Manifacture\ng_MITSUBISHI = [\n    'mitsubishi',\n    'mitubisi',\n    'melco',\n    'melsec'\n]\ng_KEYENCE = [\n    'keyence'\n]\ng_PANASONIC = [\n    'panasonic',\n    'matsushita',\n    'matusita'\n]\ng_OMRON = [\n    'omron'\n]\ng_ROCKWELL = [\n    'rockwell'\n]\ng_SIEMENS = [\n    'siemens'\n]\ng_SCHNEIDERELECTRIC = [\n    'schneiderelectric',\n    'schneider electric',\n    'schneider_electric'\n]\ng_XINJE = [\n    'xinje'\n]  # ikeike\n\n# Protocol.\ng_MCPROTOCOL1E = [\n    'mc_1e',\n    'mc1e',\n    'mcprotocol_1e',\n    'mcprotocol_1e_frame'\n]\ng_MCPROTOCOL2E = [\n    'mc_2e',\n    'mc2e',\n    'mcprotocol_2e',\n    'mcprotocol_2e_frame'\n]\ng_MCPROTOCOL3E = [\n    'mc_3e',\n    'mc3e',\n    'mcprotocol_3e',\n    'mcprotocol_3e_frame',\n    'slmp'\n]\ng_MCPROTOCOL4E = [\n    'mc_4e',\n    'mc4e',\n    'mcprotocol_4e',\n    'mcprotocol_4e_frame'\n]\ng_HOSTLINK = [\n    'hostlink',\n    'upperlink',\n    'host_link',\n    'upper_link'\n]\ng_MEWTOCOL = [\n    'mewtocol'\n]\ng_FINS = [\n    'fins'\n]\ng_CIP = [\n    'cip'\n]\ng_MODBUSTCP = [\n    'modbustcp',\n    'modbus_tcp'\n]\ng_ETHERNETIP = [\n    'ethernetip',\n    'ethernet_ip,'\n]\n\ng_MODBUSRTU = [\n    'modbusrtu',\n    'modbus_rtu'\n]  # ikeike\ng_COMPUTERLINK = [\n    'computerlink',\n    'computer_link',\n    'keisankilink',\n    'keisanki_link'\n]  # ikeikeike\n\n# PLC Series.\ng_SERIES_QR = ['qr', 'q', 'qna']\ng_SERIES_IQR = ['iqr', 'iq']\ng_SERIES_FX = ['fx']  # ikeikeike\n\n# Ethernet Connection.\ng_TCPIP = [\n    'tcp',\n    'tcpip',\n    'tcp_ip',\n    't'\n]\ng_UDPIP = [\n    'udp',\n    'udpip',\n    'udp_ip',\n    'u'\n]\ng_RC232C = [\n    'rc232c',\n    'rc232',\n    '232'\n]\n\n# Commands.\ng_WRITE_COMMAND = [\n    'write',\n    'w'\n]\ng_READ_COMMAND = [\n    'read',\n    'r'\n]\n\n# Command options.\ng_STRING_OPTION = [\n    'string',\n    's'\n]\ng_TIME_OPTION = [\n    'time',\n    't'\n]\n\n\n# Identify device.\ng_IFY_BIT_DEVICE = [\n    'b',\n    'bit',\n    'bits',\n    'byte',\n    'bytes'\n]\ng_IFY_WORD_DEVICE = [\n    'w',\n    'word',\n    'words'\n]\ng_IFY_D_WORD_DEVICE = [\n    'dw',\n    'd_word',\n    'd_words',\n    'double_word',\n    'double_words'\n]\n\nPLC_TIMEOUT_SECONDS = 0.5  # ikeike0.1\n\n# Error Code.\ng_ERROR_CODE = {\n    'SUCCESSFLLY_CODE': 0,\n    'FUNCTIONAL_ERRORCODE': -1,\n    'CONNECTION_ERRORCODE': -10,\n    'SKIP_PROCESS_ERRORCODE': -100,\n    'HARDWARE_ERRORCODE': -150,\n    'PLC_SEQUENCE_ERRORCODE': -200,\n}\ng_SUCCESSFLLY_CODE = 0\ng_FUNCTIONAL_ERRORCODE = -1\ng_CONNECTION_ERRORCODE = -10\ng_SKIP_PROCESS_ERRORCODE = -100\ng_HARDWARE_ERRORCODE = -150\ng_PLC_SEQUENCE_ERRORCODE = -200\n\n# MASTER DATA TYPE\ntry:\n    TYPE_ERRORDATA = json.loads(os.environ['TYPE_ERRORDATA'])\n    TYPE_WARNINGDATA = json.loads(os.environ['TYPE_WARNINGDATA'])\n    TYPE_PRODUCTIONDATA = json.loads(os.environ['TYPE_PRODUCTIONDATA'])\n    TYPE_PROGRESSDATA = json.loads(os.environ['TYPE_PROGRESSDATA'])\n    TYPE_INSPECTIONDATA = json.loads(os.environ['TYPE_INSPECTIONDATA'])\nexcept:\n    TYPE_ERRORDATA = ['error', 'run']\n    TYPE_WARNINGDATA = ['warning', 'lift']\n    TYPE_PRODUCTIONDATA = [\n        'input', 'output', 'plantime',\n        'actualtime', 'standardcycle', 'outputtarget']\n    TYPE_PROGRESSDATA = ['status', 'currentstatus']\n    TYPE_INSPECTIONDATA = ['inspect']\n\n# INTERVAL TIME\nACQUISITION_INTERVAL = {\n    'log': 1,\n    'error': 1,\n    'warning': 1,\n    'production': 10,\n    'progress': 10,\n}\n\nCONNECTION_ERROR_THRESHOLD = 5\nNOT_CONNECTION_PARAMETER = 0\nBEFORE_DATA_COUNT = 5\n\n# Grobal constants.\ng_ENABLE_OPTION = {\n    'ENABLE_MANUFACTURE': {\n        'mitsubishi': {\n            'slmp': {'device': [], 'connection_type': ['tcp', 'udp']},\n            'mcprotocol_1e': {'device': [], 'connection_type': ['tcp', 'udp']},\n            'computer_link': {'device': [], 'connection_type': ['rc232c']}\n        },\n        'keyence': {\n            'slmp': {'device': [], 'connection_type': ['tcp', 'udp']},\n        },\n        'panasonic': {\n            'slmp': {'device': [], 'connection_type': ['tcp', 'udp']},\n        },\n        'omron': {\n            'fins': {'device': [], 'connection_type': ['tcp', 'udp']},\n        },\n        'xinje': {\n            'modbus_rtu': {'device': [], 'connection_type': ['rc232c']},\n        },\n    },\n    'ENABLE_MASTER_TYPE': TYPE_ERRORDATA + TYPE_PRODUCTIONDATA + TYPE_PROGRESSDATA + TYPE_INSPECTIONDATA\n}\n",
        "logger.py": "import os\nimport logging\nimport dotenv\n\n\ndef get_module_logger(modname):\n    logger = logging.getLogger(modname)\n    handler = logging.StreamHandler()\n    formatter = logging.Formatter(\n        '%(asctime)s-%(name)s-%(levelname)s-%(message)s')\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n\n    dotenv.load_dotenv(override=True)\n    LOGGER_LEVEL = os.getenv('LOGGER_LEVEL')\n    if (LOGGER_LEVEL == 'CRITICAL'):\n        logger.setLevel(logging.CRITICAL)\n    elif (LOGGER_LEVEL == 'ERROR'):\n        logger.setLevel(logging.ERROR)\n    elif (LOGGER_LEVEL == 'WARNING'):\n        logger.setLevel(logging.WARNING)\n    elif (LOGGER_LEVEL == 'INFO'):\n        logger.setLevel(logging.INFO)\n    elif (LOGGER_LEVEL == 'DEBUG'):\n        logger.setLevel(logging.DEBUG)\n    else:\n        logger.setLevel(logging.NOTSET)\n    return logger\n",
        "plc_comm.py": "import os\nimport sys\nimport typing\nimport asyncio\nimport traceback\nimport re\nimport math\nimport struct\nimport datetime\nimport socket\n# IF client pc is NOT Windows, need pip install\nimport psutil\ntry:\n    import netifaces as ni\nexcept Exception:\n    pass\n\ntry:\n    # Rev 0.9.4=\n    from pyModbusTCP.client import ModbusClient\nexcept Exception:\n    pass\n# other script\ntry:\n    import logger\n    import global_vars\n    import device_list\n    import convert_format\n    from command_checker import get_random_sid\nexcept Exception:\n    from . import logger\n    from . import global_vars\n    from . import device_list\n    from . import convert_format\n    from .command_checker import get_random_sid\n\n\n# Logger\nlogger = logger.get_module_logger(__name__)\n\n\n# Convert from negative value to signed hexadecimal.\ndef convert_signed(list_negative: list, *, word_count: int = 2) -> list:\n    list_response = []\n    for x in list_negative:\n        len_hex = len('{:x}'.format(x).replace('-', ''))\n        r_list = []\n        value = x\n        for i in range(int(word_count)):\n            value, r = divmod(value, 65536)\n            if int(x) >= 0:\n                r_list.append(int(format(int(r), 'x'), 16))\n            else:\n                r_list.append(int(format(int(r) & 0xffff, 'x'), 16))\n        if int(value) != 0 and int(value) != -1:\n            if int(x) >= 0:\n                hex_value = [int(format(int(int(value)), 'x'), 16)]\n            else:\n                hex_value = [int(format(int(int(value)) & 0xffff, 'x'), 16)]\n        else:\n            hex_value = []\n        r_list.reverse()\n        hex_value.extend(r_list)\n        hex_value.reverse()\n        list_response.extend(hex_value)\n    return list_response\n\n\n# vvv Pre-operation to secure a node for FINS communication vvv\ndef get_class_c_host_ip(ip_address) -> int:\n    # Get the ClassC host of the IP address.\n    # Windows.\n    if os.name == \"nt\":\n        iplist = socket.gethostbyname_ex(socket.gethostname())[2]\n    # Linux or Mac.\n    else:\n        iplist = []\n        address_list = psutil.net_if_addrs()\n        for nic in address_list.keys():\n            ni.ifaddresses(nic)\n            try:\n                ip = ni.ifaddresses(nic)[ni.AF_INET][0]['addr']\n                if ip not in [\"127.0.0.1\"]:\n                    iplist.append(ip)\n            except KeyError as err:\n                logger.debug(err)\n    connection_ip = ip_address\n    same_network_ip = connection_ip.rsplit('.', 1)[0]\n    try:\n        _client_ip = [x for x in iplist if same_network_ip in x]\n        client_ip = _client_ip[0]\n        class_c_host = int(client_ip.rsplit('.', 1)[1])\n    except Exception as e:\n        logger.warning(\n            '{}:{}, {}'.format(\n                sys._getframe().f_code.co_name, e, 'No connection found. Please check your communication settings.'\n            )\n        )\n        # class_c_host = None\n        class_c_host = int(iplist[0].rsplit('.', 1)[1])\n    return class_c_host\n\n\ndef generate_node_telegram(protocol) -> bytes:\n    if protocol in global_vars.g_FINS:\n        header = (\n            struct.pack('B', 0x46)\n            + struct.pack('B', 0x49)\n            + struct.pack('B', 0x4E)\n            + struct.pack('B', 0x53)\n        )  # header(only TCP)\n        data_length = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x0C)\n        )  # data length(only TCP)\n        tcp_cmd = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n        )  # command(only TCP)\n        err_cd = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n        )  # error code(only TCP)\n        client_node_address = (\n            struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n            + struct.pack('B', 0x00)\n        )  # client node address(only TCP)\n        telegram_data = (\n            header\n            + data_length\n            + tcp_cmd\n            + err_cd\n            + client_node_address\n        )\n    else:\n        telegram_data = global_vars.g_CONNECTION_ERRORCODE\n    return telegram_data\n# ^^^ Pre-operation to secure a node for FINS communication ^^^\n\n\nclass ConnectToPlc:\n    def __init__(self, plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict) -> None:  # Initialize Configure\n        # Configure parameter.\n        self.host = str(plc_network['ip'])\n        self.port = int(plc_network['port'])\n        self.manufacture = str(plc_protocol['manufacture']).lower()\n        self.protocol = str(plc_protocol['protocol']).lower()\n        self.series = str(plc_protocol['series']).lower()\n        self.cmd = cmd_data['cmd']\n        self.option = cmd_data['option']\n\n        # Check Transport layer.\n        try:\n            self.transport_layer = str(plc_protocol['transport_layer']).lower()\n        except Exception:\n            self.transport_layer = 'tcp'\n\n        # Check float parameter.\n        try:\n            self.period_index = device_parameter['min'].index('.')\n        except ValueError:\n            self.period_index = None\n\n        # PLC register device parameter.\n        device_info = device_list.device_list(\n            self.manufacture, self.protocol, self.series, transport_layer=self.transport_layer, period_index=self.period_index)\n        self.device_list = device_info['device']\n        self.transfer_limit = device_info['transfer_limit']\n        self.prefix_bit = device_info['prefix_bit']\n        self.byte_order = device_info['byte_order']\n\n        self.option = cmd_data['option']\n        if self.option in global_vars.g_TIME_OPTION:\n            self.time_option_configure()\n        else:\n            try:\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n            except Exception:\n                self.device = None\n                self.n_array = None\n                self.device_code = None\n                self.bit_identify = \"bit\"\n\n            if self.cmd in global_vars.g_WRITE_COMMAND:\n                if self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                    self.cmd_data, self.option = convert_format.check_string_and_convert_dhex(\n                        cmd_data[\"data\"], self.byte_order, self.option)\n                    try:\n                        self.cmd_data = convert_format.convert_negative_integer_to_signed_hex(\n                            self.cmd_data, word_count=1)\n                    except Exception:\n                        pass\n                else:\n                    self.cmd_data = cmd_data[\"data\"]\n            else:\n                self.cmd_data = []\n            try:\n                convert_decimal = device_list.convert_to_decimal(\n                    self.n_array, device_parameter)\n                self.lead_number = convert_decimal['lead_number']\n                self.send_length = convert_decimal['send_length']\n                self.transfer_count = math.ceil(\n                    self.send_length / self.transfer_limit)\n                if self.send_length % 2 != 0:\n                    self.bit_odd_flag = True\n                else:\n                    self.bit_odd_flag = False\n            except Exception:\n                self.lead_number = None\n                self.send_length = None\n                self.transfer_count = 1\n                self.bit_odd_flag = None\n\n    # Get/Write timedata to PLC.\n    def time_option_configure(self):\n        device_parameter = {}\n        if self.protocol in global_vars.g_MCPROTOCOL3E:\n            if self.manufacture in global_vars.g_MITSUBISHI:\n                device_parameter[\"device\"] = \"SD\"\n                device_parameter[\"min\"] = \"210\"\n                device_parameter[\"max\"] = \"216\"\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n            elif self.manufacture in global_vars.g_PANASONIC:\n                if self.series in [\"fp7\", \"7\"]:\n                    pass\n                else:\n                    device_parameter[\"device\"] = \"SDT\"\n                    device_parameter[\"min\"] = \"54\"\n                    device_parameter[\"max\"] = \"57\"\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n            elif self.manufacture in global_vars.g_KEYENCE:\n                device_parameter[\"device\"] = \"CM\"\n                device_parameter[\"min\"] = \"700\"\n                device_parameter[\"max\"] = \"706\"\n                self.device = str(device_parameter['device']).upper()\n                self.n_array = self.device_list[self.device][0]\n                self.device_code = self.device_list[self.device][1]\n                self.bit_identify = self.device_list[self.device][2]\n        elif self.protocol in global_vars.g_FINS:\n            if self.manufacture in global_vars.g_OMRON:\n                self.device = None\n                self.n_array = None\n                self.device_code = None\n                self.bit_identify = \"bit\"\n        else:\n            self.device = None\n            self.n_array = None\n            self.device_code = None\n\n        if self.cmd in global_vars.g_WRITE_COMMAND:\n            self.cmd_data = cmd_data['data']\n        else:\n            self.cmd_data = []\n        try:\n            convert_decimal = device_list.convert_to_decimal(\n                self.n_array, device_parameter\n            )\n            self.lead_number = convert_decimal['lead_number']\n            self.send_length = convert_decimal['send_length']\n            self.transfer_count = math.ceil(\n                self.send_length / self.transfer_limit)\n            self.bit_odd_flag = False\n        except Exception:\n            self.lead_number = None\n            self.send_length = None\n            self.transfer_count = 1\n            self.bit_odd_flag = None\n\n    # Generate a telegram to be sent.\n    def generate_telegram(self, current_count: int) -> bytes:\n        try:\n            # ======= ETHERNET CONNECTION =======\n            # ======= MC Protocol / 1E Frame =======\n            if self.protocol in global_vars.g_MCPROTOCOL1E:\n                pc_number = struct.pack('B', 0xFF)\n                cpu_speed = (struct.pack('B', 0x10) + struct.pack('B', 0x00))\n                # The device code of a 1E frame consists of 4 bytes.\n                device_code = (\n                    struct.pack('B', self.device_code[1])\n                    + struct.pack('B', self.device_code[0])\n                )\n                # Extract each hexadecimal digit and reconvert for transmission.\n                #  X, Y device need to be converted from octal descriptions to hexadecimal binaries.\n                if self.device == 'X' or self.device == 'Y':\n                    lead_device = (\n                        int(self.lead_number, 8)\n                        + current_count * self.transfer_limit\n                    )\n                else:\n                    lead_device = (\n                        self.lead_number\n                        + current_count * self.transfer_limit\n                    )\n                bits = '{:08x}'.format(lead_device)\n                hex_lead_bit = (\n                    struct.pack('B', int(bits[6] + bits[7], 16))\n                    + struct.pack('B', int(bits[4] + bits[5], 16))\n                    + struct.pack('B', int(bits[2] + bits[3], 16))\n                    + struct.pack('B', int(bits[0] + bits[1], 16))\n                )\n                delimiter = struct.pack('B', 0x00)\n                # For the Read command.\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    remain_length = (\n                        self.send_length\n                        - current_count * self.transfer_limit\n                    )\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        sub_header = struct.pack('B', 0x00)\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        sub_header = struct.pack('B', 0x01)\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n                # For the Write command\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    remain_length = (\n                        self.send_length\n                        - current_count * self.transfer_limit\n                    )\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        sub_header = struct.pack('B', 0x02)\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        sub_header = struct.pack('B', 0x03)\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                        )\n                    )\n                # Check the transmission limit.\n                if remain_length >= self.transfer_limit:\n                    bits_dnum = '{:02x}'.format(self.transfer_limit)\n                else:\n                    bits_dnum = '{:02x}'.format(remain_length)\n                data_count = (\n                    struct.pack('B', int(bits_dnum[0] + bits_dnum[1], 16))\n                )\n                telegram_data = (\n                    sub_header + pc_number + cpu_speed\n                    + hex_lead_bit + device_code + data_count + delimiter\n                )\n\n            # ======= MC Protocol / 3E Frame =======\n            elif self.protocol in global_vars.g_MCPROTOCOL3E:\n                sub_header = (\n                    struct.pack('B', 0x50)\n                    + struct.pack('B', 0x00)\n                )\n                network = struct.pack('B', 0x00)\n                pc_number = struct.pack('B', 0xff)\n                unit_io = (\n                    struct.pack('B', 0xff)\n                    + struct.pack('B', 0x03)\n                )\n                unit_number = struct.pack('B', 0x00)\n                cpu_speed = (\n                    struct.pack('B', 0x10)\n                    + struct.pack('B', 0x00)\n                )\n                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                    sub_cmd = (\n                        struct.pack('B', 0x01)\n                        + struct.pack('B', 0x00)\n                    )\n                elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                    sub_cmd = (\n                        struct.pack('B', 0x00)\n                        + struct.pack('B', 0x00)\n                    )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                        )\n                    )\n                # Extract each hexadecimal digit and reconvert for transmission.\n                lead_bit = (\n                    self.lead_number + current_count * self.transfer_limit\n                )\n                device_code = struct.pack('B', self.device_code)\n                # For the Read command\n                if self.cmd in global_vars.g_READ_COMMAND:\n\n                    # Number of bits acquired\n                    bits = '{:06x}'.format(lead_bit)\n                    hex_lead_bit = (\n                        struct.pack('B', int(bits[4] + bits[5], 16))\n                        + struct.pack('B', int(bits[2] + bits[3], 16))\n                        + struct.pack('B', int(bits[0] + bits[1], 16))\n                    )\n                    remain_length = (\n                        self.send_length - current_count * self.transfer_limit\n                    )\n                    if self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        if remain_length % 2 != 0:\n                            # remain_length += 1\n                            self.odd_flag = True\n                    if remain_length >= self.transfer_limit:\n                        bits_vol = '{:04x}'.format(self.transfer_limit)\n                    else:\n                        bits_vol = '{:04x}'.format(remain_length)\n\n                    data_count = (\n                        struct.pack('B', int(bits_vol[2] + bits_vol[3], 16))\n                        + struct.pack(\n                            'B', int(bits_vol[0] + bits_vol[1], 16))\n                    )\n                    cmd = struct.pack('B', 0x01) + struct.pack('B', 0x04)\n                    data_length = (\n                        struct.pack('B', 0x0c) + struct.pack('B', 0x00))\n                    telegram_data = (\n                        sub_header\n                        + network\n                        + pc_number\n                        + unit_io\n                        + unit_number\n                        + data_length\n                        + cpu_speed\n                        + cmd\n                        + sub_cmd\n                        + hex_lead_bit\n                        + device_code\n                        + data_count\n                    )\n\n                    if self.option == 'comment':\n                        telegram_data = (\n                            sub_header\n                            + network\n                            + pc_number\n                            + unit_io\n                            + unit_number\n                            + data_length\n                            + cpu_speed\n                            + (struct.pack('B', 0xa4) + struct.pack('B', 0x45))\n                            + (struct.pack('B', 0x10) + struct.pack('B', 0x03))\n                            + hex_lead_bit\n                            + device_code\n                            + data_count\n                        )\n\n                # For the Write command\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    if (self.option in global_vars.g_STRING_OPTION and self.bit_identify in global_vars.g_IFY_WORD_DEVICE):\n                        if self.manufacture in global_vars.g_PANASONIC:\n                            bits = '{:06x}'.format(lead_bit + 1)\n                        else:\n                            bits = '{:06x}'.format(lead_bit)\n                    else:\n                        bits = '{:06x}'.format(lead_bit)\n                    hex_lead_bit = (\n                        struct.pack('B', int(bits[4] + bits[5], 16))\n                        + struct.pack('B', int(bits[2] + bits[3], 16))\n                        + struct.pack('B', int(bits[0] + bits[1], 16))\n                    )\n                    cmd = (\n                        struct.pack('B', 0x01)\n                        + struct.pack('B', 0x14)\n                    )\n                    # Write data.\n                    w_data = []\n                    temp_data = []\n                    length = 0\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        if len(self.cmd_data) % 2 != 0:\n                            self.cmd_data.append(0)\n                            self.bit_odd_flag = True\n                        it = iter(self.cmd_data)\n                        for i, j in zip(it, it):\n                            w_data.append([j, i])\n\n                    else:\n                        for i in range(len(self.cmd_data)):\n                            if self.cmd_data[i] >= 0:\n                                _hex_w_data = '{:x}'.format(self.cmd_data[i])\n                            else:\n                                _hex_w_data = format(\n                                    self.cmd_data[i] & 0xffff, 'x'\n                                )\n                            length += len(_hex_w_data) / 2\n                            if self.option in global_vars.g_STRING_OPTION:\n                                for j in range((int(len(_hex_w_data) // 4.01)) + 1):\n                                    if len(_hex_w_data) >= 2:\n                                        if j == 0:\n                                            four_hex = '{:0>4s}'.format(\n                                                _hex_w_data[-4:]\n                                            )\n                                        elif j == len(_hex_w_data) // 4:\n                                            continue\n                                        else:\n                                            four_hex = '{:0>4s}'.format(\n                                                _hex_w_data[\n                                                    (j + 1) * (-4): j * (-4)\n                                                ]\n                                            )\n                                        w_data.append(\n                                            [\n                                                int(four_hex[0]\n                                                    + four_hex[1], 16),\n                                                int(four_hex[2]\n                                                    + four_hex[3], 16)\n                                            ]\n                                        )\n                                    else:\n                                        if len(temp_data) >= 2:\n                                            temp_data = []\n                                        if j == 0:\n                                            if i % 2 == 0:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[-2:]\n                                                    )\n                                                )\n                                                if i == len(self.cmd_data):\n                                                    w_data.append(\n                                                        [int(temp_data[0], 16), 0]\n                                                    )\n                                            else:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[-2:]\n                                                    )\n                                                )\n                                                try:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            int(temp_data[1], 16)\n                                                        ]\n                                                    )\n                                                except Exception:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            0\n                                                        ]\n                                                    )\n\n                                        else:\n                                            if i % 2 == 0:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[\n                                                            (j + 1) * (-2):j * (-2)\n                                                        ]\n                                                    )\n                                                )\n                                                if i == len(self.cmd_data):\n                                                    w_data.append(\n                                                        [int(temp_data[0], 16), 0]\n                                                    )\n                                            else:\n                                                temp_data.insert(\n                                                    0, '{:0>2s}'.format(\n                                                        _hex_w_data[\n                                                            (j + 1) * (-2):j * (-2)\n                                                        ]\n                                                    )\n                                                )\n                                                try:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            int(temp_data[1], 16)\n                                                        ]\n                                                    )\n                                                except Exception:\n                                                    w_data.append(\n                                                        [\n                                                            int(temp_data[0], 16),\n                                                            0\n                                                        ]\n                                                    )\n\n                                        if i == len(self.cmd_data):\n                                            try:\n                                                w_data.append(\n                                                    [\n                                                        int(temp_data[0], 16),\n                                                        int(temp_data[1], 16)\n                                                    ]\n                                                )\n                                            except Exception:\n                                                w_data.append(\n                                                    [int(temp_data[0], 16)]\n                                                )\n                            else:\n                                for j in range(int((len(_hex_w_data) // 4.01)) + 1):\n                                    if len(_hex_w_data) <= 4:\n                                        four_hex = '{:0>4s}'.format(\n                                            _hex_w_data[-4:]\n                                        )\n                                    else:\n                                        four_hex = '{:0>4s}'.format(\n                                            _hex_w_data[(j + 1)\n                                                        * (-4):j * (-4)]\n                                        )\n                                    w_data.append(\n                                        [\n                                            int(four_hex[0] + four_hex[1], 16),\n                                            int(four_hex[2] + four_hex[3], 16)\n                                        ]\n                                    )\n                    # Number of bits acquired\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        remain_length = (\n                            len(w_data) * 2\n                            - current_count * self.transfer_limit\n                        )\n                        if remain_length >= self.transfer_limit:\n                            if self.bit_odd_flag:\n                                bits_vol = '{:04x}'.format(\n                                    self.transfer_limit - 1)\n                            else:\n                                bits_vol = '{:04x}'.format(self.transfer_limit)\n                        else:\n                            if self.bit_odd_flag:\n                                bits_vol = '{:04x}'.format(remain_length - 1)\n                            else:\n                                bits_vol = '{:04x}'.format(remain_length)\n                    else:\n                        if self.option in global_vars.g_STRING_OPTION:\n                            if self.manufacture in global_vars.g_PANASONIC:\n                                w_data_length = '{:0>4s}'.format(\n                                    str(int(length)))\n                                w_data.insert(\n                                    0, [\n                                        int(w_data_length[:-2], 10),\n                                        int(w_data_length[-2:], 10)\n                                    ]\n                                )\n                            else:\n                                w_data.append([0, 0])\n                        remain_length = (\n                            len(w_data)\n                            - current_count * self.transfer_limit\n                        )\n                        if remain_length >= self.transfer_limit:\n                            bits_vol = '{:04x}'.format(self.transfer_limit)\n                        else:\n                            bits_vol = '{:04x}'.format(remain_length)\n\n                    data_count = (\n                        struct.pack('B', int(bits_vol[2] + bits_vol[3], 16))\n                        + struct.pack('B', int(bits_vol[0] + bits_vol[1], 16))\n                    )\n                    # data_count = struct.pack('B', 2) + struct.pack('B', 0)\n\n                    # Communication data length.\n                    # If the write is bit, add to the command byte length 12, or\n                    # If the writing is a word, add x2 to the command's byte length of 12.\n                    cmd_data = b''\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        characters = 12 + int(remain_length / 2)\n                        temp_dleng = '{:04x}'.format(characters)\n                        data_length = (\n                            struct.pack('B', int(temp_dleng[2] + temp_dleng[3], 16))\n                            + struct.pack(\n                                'B', int(temp_dleng[0] + temp_dleng[1], 16)\n                            )\n                        )\n                        for i, x in enumerate(w_data):\n                            try:\n                                cmd_data += struct.pack('B', x[1] * 16 + x[0])\n                            except Exception:\n                                cmd_data += struct.pack(\"B\", x[0])\n\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        characters = 12 + remain_length * 2\n                        temp_dleng = '{:04x}'.format(characters)\n                        # temp_dleng = \"001a\"\n                        data_length = (\n                            struct.pack('B', int(temp_dleng[2] + temp_dleng[3], 16))\n                            + struct.pack(\n                                'B', int(temp_dleng[0] + temp_dleng[1], 16)\n                            )\n                        )\n                        for i, x in enumerate(w_data):\n                            cmd_data += (\n                                struct.pack('B', x[1])\n                                + struct.pack('B', x[0])\n                            )\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n\n                    telegram_data = (\n                        sub_header\n                        + network\n                        + pc_number\n                        + unit_io\n                        + unit_number\n                        + data_length\n                        + cpu_speed\n                        + cmd\n                        + sub_cmd\n                        + hex_lead_bit\n                        + device_code\n                        + data_count\n                        + cmd_data\n                    )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                        )\n                    )\n\n            # ======= FINS =======\n            elif self.protocol in global_vars.g_FINS:\n                # TCP header\n                header = (\n                    struct.pack('B', 0x46)\n                    + struct.pack('B', 0x49)\n                    + struct.pack('B', 0x4E)\n                    + struct.pack('B', 0x53)\n                )     # TCP header(only TCP)\n                tcp_cmd = (\n                    struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x02)\n                )     # TCP command(only TCP)\n                err_cd = (\n                    struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                    + struct.pack('B', 0x00)\n                )     # TCP error code(only TCP)\n                # FINS header\n                # ICF. Bit7=1:fixed value, Bit6=0:command, Bit0=0:need response\n                icf = struct.pack('B', 0x80)\n                rsv = struct.pack('B', 0x00)                # RSV. fixed value\n                # Number of allowable bridge passes. Basically 0x02, 0x07: When using network crossings up to 8 layers.\n                gct = struct.pack('B', 0x02)\n                # Destination network address. 0x00: Same network, 0x01~0x7F: Destination network\n                dna = struct.pack('B', 0x00)\n                if self.transport_layer in global_vars.g_UDPIP:\n                    client_ip_address = get_class_c_host_ip(self.host)\n                    da1 = struct.pack('B', 0x00)\n                    sa1 = struct.pack('B', client_ip_address)\n                else:\n                    # Destination node address. # 0x00: in own PLC, 0x01~20: ControllerLink, 0x01~FE: Ethernet, 0xFF: Simultaneous broadcast\n                    da1 = struct.pack('B', self.server_node)\n                    # Source node address. # 0x01~FE TCP: Specify No. 5 of the response, UDP: 4th digit of the PC-side IP address.\n                    sa1 = struct.pack('B', self.client_node)\n                # Destination Unit Address. # 0x00: CPU unit, 0xFE: ControllerLink or Ethernet unit, 0x10~1F: CPU Advanced Function Unit, 0xE1: INNER board.\n                da2 = struct.pack('B', 0x00)\n                # Source network address. # 0x00: same network, 0x01~0x7F: source network.\n                sna = struct.pack('B', 0x00)\n                # Source address. # fixed value\n                sa2 = struct.pack('B', 0x00)\n                # Service ID. # 0x00~FF Any, source identifier.\n                # sid = struct.pack('B', 0x19)\n                sid = get_random_sid(1)  # add\n\n                # no parameter format\n                if self.option in global_vars.g_TIME_OPTION:\n                    if self.cmd in global_vars.g_READ_COMMAND:\n                        cmd_code = \"0701\"\n                        cmd = (\n                            struct.pack(\"B\", int(cmd_code[0:2], 16))\n                            + struct.pack(\"B\", int(cmd_code[2:4], 16))\n                        )\n                        # Transmission length.\n                        data_length = (\n                            struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x1A)\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                            )\n                    elif self.cmd in global_vars.g_WRITE_COMMAND:\n                        cmd_code = \"0702\"\n                        cmd = (\n                            struct.pack(\"B\", int(cmd_code[0:2], 16))\n                            + struct.pack(\"B\", int(cmd_code[2:4], 16))\n                        )\n                        if len(self.cmd_data) == 5:\n                            # 秒を00にして曜日算出\n                            year = int(self.cmd_data[0])\n                            month = int(self.cmd_data[1])\n                            day = int(self.cmd_data[2])\n                            if year >= 98:\n                                year += 1900\n                            else:\n                                year += 2000\n                            add_data = [\"00\", format(\n                                datetime.date(year, month, day).weekday() + 1, \"02\")]\n                            self.cmd_data.extend(add_data)\n                        elif len(self.cmd_data) == 6:\n                            # 曜日算出\n                            year = int(self.cmd_data[0])\n                            month = int(self.cmd_data[1])\n                            day = int(self.cmd_data[2])\n                            if year >= 98:\n                                year += 1900\n                            else:\n                                year += 2000\n                            add_data = [\n                                format(datetime.date(year, month, day).weekday() + 1, \"02\")]\n                            self.cmd_data.extend(add_data)\n                        elif len(self.cmd_data) >= 7:\n                            # 7データまでを入力\n                            self.cmd_data = self.cmd_data[:7]\n                        cmd_data = b''\n                        for data in self.cmd_data:\n                            try:\n                                cmd_data += struct.pack(\"B\",\n                                                        int(str(data), 16))\n                            except Exception:\n                                pass\n                        # Data length.\n                        _data_len = '{:08x}'.format(\n                            26 + (len(self.cmd_data) * 2))\n                        data_length = (\n                            struct.pack('B', int(_data_len[0] + _data_len[1], 16))\n                            + struct.pack('B', int(_data_len[2] + _data_len[3], 16))\n                            + struct.pack('B', int(_data_len[4] + _data_len[5], 16))\n                            + struct.pack(\n                                'B', int(_data_len[6] + _data_len[7], 16))\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + cmd_data\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + cmd_data\n                            )\n                elif self.option in [\"warning\"]:\n                    cmd_code = '2102'\n                    cmd = (\n                        struct.pack('B', int(cmd_code[0:2], 16))\n                        + struct.pack('B', int(cmd_code[2:4], 16))\n                    )\n                    read_start = struct.pack(\n                        'B', 0x00) + struct.pack('B', 0x00)\n                    read_count = struct.pack(\n                        'B', 0x01) + struct.pack('B', 0x00)\n\n                    # Transmission length.\n                    data_length = (\n                        struct.pack('B', 0x00)\n                        + struct.pack('B', 0x00)\n                        + struct.pack('B', 0x00)\n                        + struct.pack('B', 0x1A)\n                    )\n                    if self.transport_layer in global_vars.g_UDPIP:\n                        telegram_data = (\n                            icf\n                            + rsv\n                            + gct\n                            + dna\n                            + da1\n                            + da2\n                            + sna\n                            + sa1\n                            + sa2\n                            + sid\n                            + cmd\n                            + read_start\n                            + read_count\n                        )\n                    else:\n                        telegram_data = (\n                            header\n                            + data_length\n                            + tcp_cmd\n                            + err_cd\n                            + icf\n                            + rsv\n                            + gct\n                            + dna\n                            + da1\n                            + da2\n                            + sna\n                            + sa1\n                            + sa2\n                            + sid\n                            + cmd\n                            + read_start\n                            + read_count\n                        )\n                else:\n                    # Devices code\n                    device_code = struct.pack('B', self.device_code)\n\n                    # Extract each hexadecimal digit and reconvert for transmission.\n                    # The first and second bytes are device numbers,\n                    # and the third byte is a bit number within the device. (In the case of word, this is basically '0x00'.)\n                    lead_device = (\n                        self.lead_number\n                        + current_count * self.transfer_limit\n                    )\n                    if self.n_array == '10.10':\n                        q, mod = divmod(lead_device, 16)\n                        bits1 = '{:04x}'.format(q)\n                        bits2 = '{:02x}'.format(mod)\n                        temp1 = int(bits1[0] + bits1[1], 16)\n                        temp2 = int(bits1[2] + bits1[3], 16)\n                        temp3 = int(bits2[0] + bits2[1], 16)\n                    else:\n                        bits = '{:04x}'.format(lead_device)\n                        temp1 = int(bits[0] + bits[1], 16)\n                        temp2 = int(bits[2] + bits[3], 16)\n                        temp3 = 0x00\n                    lead_device_number = (\n                        struct.pack('B', temp1)\n                        + struct.pack('B', temp2)\n                        + struct.pack('B', temp3)\n                    )\n\n                    # Read command telegram.\n                    if self.cmd in global_vars.g_READ_COMMAND:\n                        cmd = (\n                            struct.pack('B', 0x01)\n                            + struct.pack('B', 0x01)\n                        )\n                        # Transmission length.\n                        data_length = (\n                            struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x00)\n                            + struct.pack('B', 0x1A)\n                        )\n                        # Number of bits acquired\n                        if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                            integer_sendlength = (\n                                str(self.send_length)[\n                                    :len(str(self.send_length)) - 2\n                                ]\n                            )\n                            if integer_sendlength == '':\n                                integer_sendlength = 0\n                            few_sendlength = (\n                                str(self.send_length)[\n                                    len(str(self.send_length)) - 2:\n                                ]\n                            )\n                            remain_length = (\n                                int(integer_sendlength) * 16\n                                + int(few_sendlength)\n                                - current_count * self.transfer_limit\n                            )\n                        else:\n                            remain_length = (\n                                self.send_length\n                                - current_count * self.transfer_limit\n                            )\n\n                        # Check the transmission limit.\n                        if remain_length >= self.transfer_limit:\n                            bits_dnum = '{:04x}'.format(self.transfer_limit)\n                        else:\n                            bits_dnum = '{:04x}'.format(remain_length)\n                        device_count = (\n                            struct.pack('B', int(bits_dnum[0] + bits_dnum[1], 16))\n                            + struct.pack(\n                                'B', int(bits_dnum[2] + bits_dnum[3], 16))\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                            )\n                    # Write command telegram.\n                    elif self.cmd in global_vars.g_WRITE_COMMAND:\n                        cmd = (\n                            struct.pack('B', 0x01)\n                            + struct.pack('B', 0x02)\n                        )\n                        # Converts write data into 2 bytes of hexadecimal numbers.\n                        w_data = []\n                        for i in range(len(self.cmd_data)):\n                            if self.cmd_data[i] >= 0:\n                                _hex_w_data = '{:x}'.format(self.cmd_data[i])\n                            else:\n                                _hex_w_data = format(\n                                    self.cmd_data[i] & 0xffff, 'x'\n                                )\n                            for j in range((len(_hex_w_data) // 5) + 1):\n                                if j == 0:\n                                    four_hex = '{:0>4s}'.format(\n                                        _hex_w_data[-4:])\n                                else:\n                                    four_hex = '{:0>4s}'.format(\n                                        _hex_w_data[(j + 1) * (-4):j * (-4)]\n                                    )\n                                w_data.append(\n                                    [\n                                        int(four_hex[0] + four_hex[1], 16),\n                                        int(four_hex[2] + four_hex[3], 16)\n                                    ]\n                                )\n                        # For Big Endian, reverse order acquisition is further reversed to reverse order.\n                        for i in range(len(w_data)):\n                            if i == 0:\n                                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                    cmd_data = struct.pack('B', w_data[i][1])\n                                else:\n                                    cmd_data = (\n                                        struct.pack('B', w_data[i][0])\n                                        + struct.pack('B', w_data[i][1])\n                                    )\n                            else:\n                                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                    cmd_data = (\n                                        cmd_data\n                                        + struct.pack('B', w_data[i][1])\n                                    )\n                                else:\n                                    cmd_data = (\n                                        cmd_data\n                                        + struct.pack('B', w_data[i][0])\n                                        + struct.pack('B', w_data[i][1])\n                                    )\n                        for i in range(len(self.cmd_data)):\n                            for j in range((self.cmd_data[i] // 65535) + 1):\n                                # Number of bits acquired\n                                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                    remain_length = (\n                                        self.send_length * (len(w_data) // 17 + 1)\n                                        - (current_count * self.transfer_limit)\n                                    )\n                                else:\n                                    remain_length = (\n                                        self.send_length\n                                        - current_count * self.transfer_limit\n                                    )\n                                # Check the transmission limit.\n                                if remain_length >= self.transfer_limit:\n                                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                        bits_dnum = '{:04x}'.format(\n                                            self.transfer_limit\n                                        )\n                                    else:\n                                        bits_dnum = '{:04x}'.format(\n                                            self.transfer_limit\n                                        )\n                                elif remain_length < self.transfer_limit:\n                                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                                        bits_dnum = '{:04x}'.format(\n                                            remain_length)\n                                    else:\n                                        bits_dnum = '{:04x}'.format(\n                                            remain_length)\n                                device_count = (\n                                    struct.pack('B', int(bits_dnum[0] + bits_dnum[1], 16))\n                                    + struct.pack(\n                                        'B', int(bits_dnum[2] + bits_dnum[3], 16))\n                                )\n                        # Data length.\n                        _data_len = '{:08x}'.format(26 + (len(w_data) * 2))\n                        data_length = (\n                            struct.pack('B', int(_data_len[0] + _data_len[1], 16))\n                            + struct.pack('B', int(_data_len[2] + _data_len[3], 16))\n                            + struct.pack('B', int(_data_len[4] + _data_len[5], 16))\n                            + struct.pack(\n                                'B', int(_data_len[6] + _data_len[7], 16))\n                        )\n                        if self.transport_layer in global_vars.g_UDPIP:\n                            telegram_data = (\n                                icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                                + cmd_data\n                            )\n                        else:\n                            telegram_data = (\n                                header\n                                + data_length\n                                + tcp_cmd\n                                + err_cd\n                                + icf\n                                + rsv\n                                + gct\n                                + dna\n                                + da1\n                                + da2\n                                + sna\n                                + sa1\n                                + sa2\n                                + sid\n                                + cmd\n                                + device_code\n                                + lead_device_number\n                                + device_count\n                                + cmd_data\n                            )\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                            )\n                        )\n\n            # ======= CIP =======\n            elif self.protocol in global_vars.g_CIP:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                    )\n                )\n\n            # ======= HOST LINK (Jp:Joui LINK) =======\n            elif self.protocol in global_vars.g_HOSTLINK:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                    )\n                )\n\n            # ======= EHTERNET IP ========\n            elif self.protocol in global_vars.g_ETHERNETIP:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This cmd is not supported.'\n                    )\n                )\n\n            # ======= CONNECTION THROUGH RASPI-RC232C =======\n            # ======= MODBUS RTU =======\n            elif self.protocol in global_vars.g_MODBUSRTU:\n                rp_header = (\n                    struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                )\n                slave_addr = struct.pack('B', 0x01)\n                rp_footer = (\n                    struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                )\n                # Extract each hexadecimal digit and reconvert for transmission.\n                lead_bit = (\n                    self.lead_number\n                    + current_count * self.transfer_limit\n                )\n                bits = '{:04x}'.format(lead_bit)\n                hex_lead_bit = (\n                    struct.pack('B', int(bits[0] + bits[1], 16))\n                    + struct.pack('B', int(bits[2] + bits[3], 16))\n                )\n                # device_code  = struct.pack('B', self.device_code)\n\n                # For the Read command\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        func_code = struct.pack('B', 0x01)\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        func_code = struct.pack('B', 0x03)\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n\n                    # Number of bits acquired\n                    remain_length = (\n                        self.send_length\n                        - current_count * self.transfer_limit\n                    )\n                    if remain_length >= self.transfer_limit:\n                        bits_vol = '{:04x}'.format(self.transfer_limit)\n                    else:\n                        bits_vol = '{:04x}'.format(remain_length)\n                    data_count = (\n                        struct.pack('B', int(bits_vol[0] + bits_vol[1], 16))\n                        + struct.pack('B', int(bits_vol[2] + bits_vol[3], 16))\n                    )\n                    row_data = (\n                        slave_addr\n                        + func_code\n                        + hex_lead_bit\n                        + data_count\n                    )\n                    telegram_data = (\n                        rp_header\n                        + row_data\n                        + convert_format.make_crc(row_data)\n                        + rp_footer\n                    )\n                # For the Write command\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    pass\n\n            # ======= COMPUTER LINK =======\n            elif self.protocol in global_vars.g_COMPUTERLINK:\n                rp_header = (\n                    struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                    + struct.pack('B', 0x02)\n                )\n                slave_addr = b'\\x0500FF'\n                rp_footer = (\n                    struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                    + struct.pack('B', 0x03)\n                )\n\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                        func_code = b'BR'\n                    elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                        func_code = b'WR'\n                    else:\n                        raise ValueError(\n                            '{}, {}'.format(\n                                sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                            )\n                        )\n\n                timeout_addr = b'0'\n                # Extract each hexadecimal digit and reconvert for transmission.\n                device_code = struct.pack('B', self.device_code[0])\n                lead_data = (\n                    '{:04d}'.format(\n                        self.lead_number\n                        + current_count * self.transfer_limit\n                    )\n                ).encode()\n                remain_length = (\n                    self.send_length\n                    - current_count * self.transfer_limit\n                )\n                if remain_length >= self.transfer_limit:\n                    data_count = (\n                        '{:02x}'.format(\n                            self.transfer_limit\n                        )\n                    ).encode()\n                else:\n                    data_count = '{:02x}'.format(remain_length).encode()\n                row_data = (\n                    slave_addr\n                    + func_code\n                    + timeout_addr\n                    + device_code\n                    + lead_data\n                    + data_count\n                )\n                telegram_data = (\n                    rp_header\n                    + row_data\n                    + rp_footer\n                )\n\n            return telegram_data\n        except Exception:\n            logger.warning(traceback.format_exc())\n\n    # Telegraphic data transmission.\n    def sent_telegram(self) -> typing.Tuple[str, bytes, int]:\n        loop_count = self.transfer_count\n        res = ''\n        try:\n            # =============================\n            # MODBUS-TCP (Modbus Protocol - TCP)\n            # =============================\n            if self.protocol in global_vars.g_MODBUSTCP:\n                # Coil              Read-Write  1bit    (Discrete Output(DO)    1~9999)\n                # Input Status      Read        1bit    (Discrete Input(DI)     10001~19999)\n                # Input Register    Read        16bit   (Analog Input(AI)       30001~39999)\n                # Holding Register  Read-Write  16bit   (Analog Output(AO)      40001~49999)\n                con = ModbusClient()\n                con.host(self.host)\n                con.port(self.port)\n\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    if self.device in ['COIL', 'DO', 'DISCRETE_OUTPUT']:\n                        res = con.read_coils(self.lead_nuber, self.send_length)\n                    elif self.device in ['INPUT_STATUS', 'DI', 'DISCRETE_INPUT']:\n                        res = con.read_discrete_inputs(\n                            self.lead_nuber, self.send_length)\n                    elif self.device in ['INPUT_REGISTER', 'AI', 'ANALOG_INPUT']:\n                        res = con.read_input_registers(\n                            self.lead_nuber, self.send_length)\n                    elif self.device in ['HOLDING_REGISTER', 'AO', 'ANALOG_OUTPUT']:\n                        res = con.read_holding_register(\n                            self.lead_nuber, self.send_length)\n                    else:\n                        raise ValueError(\n                            '{},Ecode:{}'.format(\n                                sys._getframe().f_code.co_name, 'Device name is wrong.'\n                            )\n                        )\n\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    if self.device in ['DO', 'COIL', 'DISCRETE_OUTPUT']:\n                        con.write_multiple_coils(\n                            self.lead_number, self.cmd_data)\n                    elif self.device in ['HOLDING_REGISTER', 'AO', 'ANALOG_OUTPUT']:\n                        con.write_multiple_registers(\n                            self.lead_number, self.cmd_data)\n                    else:\n                        raise ValueError(\n                            '{},Ecode:{}'.format(\n                                sys._getframe().f_code.co_name, 'Device name is wrong.'\n                            )\n                        )\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This command is not supported.'\n                        )\n                    )\n\n            # =============================\n            # Socket Connection\n            # =============================\n            else:\n                # Connection initialize\n                if self.transport_layer in global_vars.g_TCPIP:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                elif self.transport_layer in global_vars.g_UDPIP:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                else:\n                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.settimeout(global_vars.PLC_TIMEOUT_SECONDS)\n                s.connect((self.host, self.port))\n\n                # ===========================\n                # Read Data Command\n                # ===========================\n                if self.cmd in global_vars.g_READ_COMMAND:\n                    for i in range(loop_count):\n                        # =============================\n                        # MC Protocol(MELSEC Communication Protocol)\n                        # =============================\n                        if self.protocol in global_vars.g_MCPROTOCOL1E + global_vars.g_MCPROTOCOL3E:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n\n                            # =============================\n                            # MC protocol/1E Frame\n                            # =============================\n                            # Check error code. '00' is success. other is error.\n                            if self.protocol in global_vars.g_MCPROTOCOL1E:\n                                ecode = recv_data[\n                                    self.prefix_bit - 2: self.prefix_bit\n                                ]\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n\n                            # =============================\n                            # MC protocol/3E Frame, SLMP(Seamless Message Protocol)\n                            # =============================\n                            elif self.protocol in global_vars.g_MCPROTOCOL3E:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                )\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    'Protcol is {}. Not support.'.format(\n                                        self.protocol\n                                    )\n                                )\n\n                            # Successfully completed.\n                            ecode = 0\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                e_bit = self.transfer_limit + self.prefix_bit\n                                res += recv_data[self.prefix_bit: e_bit]\n                            elif i == 0:\n                                res = recv_data\n\n                        # =============================\n                        # FINS(Factory Interface Netwrok Service)\n                        # =============================\n                        elif self.protocol in global_vars.g_FINS:\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                self.client_node = ''\n                                self.server_node = ''\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                # Communication for obtaining node parameters.\n                                send_nodeData = self.generate_node_telegram(\n                                    self.protocol)\n                                s.send(bytes(send_nodeData))\n                                recv_nodeData = s.recv(1024).hex()\n                                node_ecode1 = recv_nodeData[16:24]\n                                node_ecode2 = recv_nodeData[24:32]\n                                # Node error handling\n                                if int(node_ecode1, 16) not in [1, 64, 128]:\n                                    ecode = node_ecode1\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                if int(node_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = node_ecode2\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                self.client_node = int(\n                                    '0x'\n                                    + recv_nodeData[32:40], 16\n                                )\n                                self.server_node = int(\n                                    '0x' + recv_nodeData[40:48], 16\n                                )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n                            # FINS connection Error check\n                            # Check \"Connection\" error code. If command(only TCP) is not \"2\", error code is '00000000' is success. other is error.\n                            # Check error code. '0000' is success. other is error.\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                )\n                                if int(ecode, 16) not in [0, 64, 128]:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                conn_ecode1 = recv_data[16:24]\n                                conn_ecode2 = recv_data[24:32]\n                                ecode = recv_data[\n                                    self.prefix_bit - 4: self.prefix_bit\n                                ]\n                                if int(conn_ecode1, 16) not in [2, 64, 128] and int(conn_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = conn_ecode2 + ',' + ecode\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                elif int(ecode, 16) not in [0, 64, 128]:\n                                    ecode = (\n                                        recv_data[\n                                            self.prefix_bit - 4: self.prefix_bit - 2\n                                        ]\n                                        + recv_data[\n                                            self.prefix_bit - 2: self.prefix_bit\n                                        ]\n                                    )\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n                            # Successfully completed.\n                            ecode = 0\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                e_bit = self.transfer_limit + self.prefix_bit\n                                res += recv_data[self.prefix_bit:e_bit]\n                            elif i == 0:\n                                res = recv_data\n\n                        # =============================\n                        # MODBUS-RTU (Modbus Protocol - Remote Terminal Unit)\n                        # =============================\n                        elif self.protocol in global_vars.g_MODBUSRTU:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data_r = s.recv(1024)  # .hex()\n                            s.close()\n                            # Check CRC. success or error?\n                            if len(recv_data_r) > 6:\n                                row_data_r = recv_data_r[3:len(\n                                    recv_data_r) - 5]\n                                if convert_format.make_crc(row_data_r) != recv_data_r[len(recv_data_r) - 5:len(recv_data_r) - 3]:\n                                    raise ValueError(\n                                        '{}, {}'.format(\n                                            recv_data_r, 'too short recieve data'\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    '{}, {}'.format(\n                                        recv_data_r, 'too short recieve data'\n                                    )\n                                )\n                            recv_data = row_data_r\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                # このあたり不明\n                                res += recv_data\n                            elif i == 0:\n                                # Successfully completed.\n                                ecode = 0\n                                res = recv_data\n\n                        # =============================\n                        # Computer Link (PC Link)\n                        # =============================\n                        elif self.protocol in global_vars.g_COMPUTERLINK:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data_r = s.recv(1024)  # .hex()\n                            s.close()\n                            # Check CRC. success or error?\n                            if len(recv_data_r) > 6:\n                                row_data_r = recv_data_r[3:len(\n                                    recv_data_r) - 3]\n                            else:\n                                raise ValueError(\n                                    '{}, {}'.format(\n                                        recv_data_r, 'too short recieve data'\n                                    )\n                                )\n                            recv_data = row_data_r\n                            # Get bit status of all registers. Concatenate if register is transfer_limit or more\n                            if i > 0:\n                                # このあたり不明\n                                res += recv_data\n                            elif i == 0:\n                                # Successfully completed.\n                                ecode = 0\n                                res = recv_data\n\n                        else:\n                            raise ValueError(\n                                '{}, {}'.format(\n                                    sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                                )\n                            )\n\n                # =============================\n                # Write Data Command\n                # =============================\n                elif self.cmd in global_vars.g_WRITE_COMMAND:\n                    for i in range(loop_count):\n                        # =============================\n                        # MC Protocol(MELSEC Communication Protocol)\n                        # =============================\n                        if self.protocol in global_vars.g_MCPROTOCOL1E + global_vars.g_MCPROTOCOL3E:\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n\n                            # =============================\n                            # MC protocol/1E Frame\n                            # =============================\n                            if self.protocol in global_vars.g_MCPROTOCOL1E:\n                                ecode = recv_data[\n                                    self.prefix_bit - 2: self.prefix_bit\n                                ]\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n\n                            # =============================\n                            # MC protocol/3E Frame, SLMP(Seamless Message Protocol)\n                            # =============================\n                            elif self.protocol in global_vars.g_MCPROTOCOL3E:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                )\n                                if int(ecode, 16) != 0:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            # Successful handling.\n                            # Write command has no received.\n                            ecode = 0\n                            res = recv_data\n\n                        # =============================\n                        # FINS(Factory Interface Netwrok Service)\n                        # =============================\n                        elif self.protocol in global_vars.g_FINS:\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                self.client_node = self.server_node = ''\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                # Communication for obtaining node parameters.\n                                send_nodeData = self.generate_node_telegram(\n                                    self.protocol)\n                                s.send(bytes(send_nodeData))\n                                recv_nodeData = s.recv(1024).hex()\n                                node_ecode1 = recv_nodeData[16:24]\n                                node_ecode2 = recv_nodeData[24:32]\n                                # Node Error handling.\n                                if int(node_ecode1, 16) not in [1, 64, 128]:\n                                    ecode = node_ecode1\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_nodeData, send_nodeData, ecode\n                                        )\n                                    )\n                                if int(node_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = node_ecode2\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_nodeData, send_nodeData, ecode\n                                        )\n                                    )\n                                self.client_node = int(\n                                    '0x'\n                                    + recv_nodeData[32:40], 16\n                                )\n                                self.server_node = int(\n                                    '0x'\n                                    + recv_nodeData[40:48], 16\n                                )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n\n                            # Generate telegram and sent.\n                            senddata = self.generate_telegram(i)\n                            s.send(bytes(senddata))\n                            recv_data = s.recv(1024).hex()\n                            s.close()\n\n                            # FINS connection Error check\n                            # Check \"Connection\" error code. If command(only TCP) is not \"2\", error code is '00000000' is success. other is error.\n                            # Check error code. '0000' is success. other is error.\n                            if self.transport_layer in global_vars.g_UDPIP:\n                                ecode = (\n                                    recv_data[\n                                        self.prefix_bit - 4: self.prefix_bit - 2\n                                    ]\n                                    + recv_data[\n                                        self.prefix_bit - 2: self.prefix_bit\n                                    ]\n                                )\n                                if int(ecode, 16) not in [0, 64, 128]:\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            elif self.transport_layer in global_vars.g_TCPIP:\n                                conn_ecode1 = recv_data[16:24]\n                                conn_ecode2 = recv_data[24:32]\n                                ecode = recv_data[\n                                    self.prefix_bit - 4: self.prefix_bit\n                                ]\n\n                                if int(conn_ecode1, 16) not in [2, 64, 128] and int(conn_ecode2, 16) not in [0, 64, 128]:\n                                    ecode = conn_ecode2 + ',' + ecode\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                                elif int(ecode, 16) not in [0, 64, 128]:\n                                    ecode = (\n                                        recv_data[\n                                            self.prefix_bit - 4: self.prefix_bit - 2\n                                        ]\n                                        + recv_data[\n                                            self.prefix_bit - 2: self.prefix_bit\n                                        ]\n                                    )\n                                    raise ValueError(\n                                        '{}, Recv:{}, Send:{}, Ecode:{}'.format(\n                                            sys._getframe().f_code.co_name, recv_data, senddata, ecode\n                                        )\n                                    )\n                            else:\n                                raise ValueError(\n                                    '{},Ecode:{}'.format(\n                                        sys._getframe().f_code.co_name, 'Transport layer name is wrong.'\n                                    )\n                                )\n                            res = recv_data\n                            ecode = 0\n\n                        # =============================\n                        # MODBUS-RTU (Modbus Protocol - Remote Terminal Unit)\n                        # =============================\n                        elif self.protocol in global_vars.g_MODBUSRTU:\n                            pass\n\n                        else:\n                            raise ValueError(\n                                '{}, {}'.format(\n                                    sys._getframe().f_code.co_name, 'This protocol is not supported.'\n                                )\n                            )\n\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'This command is not supported.'\n                        )\n                    )\n        # Error Response Handling.\n        except Exception as err:\n            try:\n                if res == '':\n                    res = recv_data\n                else:\n                    res\n            except NameError:\n                res = str(err)\n            try:\n                senddata.hex()\n            except NameError:\n                senddata = ''\n            try:\n                recv_data\n            except NameError:\n                recv_data = ''\n            try:\n                ecode\n            except NameError:\n                ecode = -1\n            try:\n                s.close()\n            except Exception:\n                logger.warning('Socket can not closed.')\n        finally:\n            try:\n                senddata = senddata.hex()\n            except Exception:\n                pass\n            finally:\n                return res, senddata, ecode\n\n    # Parse the data in bit/word units.\n    # When it's bit, if you are reading an odd number of bits, a 0 is padded after the last bit.\n    # When it's word, it'll consolidate four digits and convert hexadecimal numbers to decimal numbers.\n\n    def extracting_elements(self, data: str, *, use_bcd: bool = False, optional: dict = {}) -> list:\n        # logger.info('string_null:{}'.format(string_option_null_break))\n        res = []\n        message = \"\"\n        try:\n            data_len = int(len(data))\n            # Perse bit unit\n            if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                if self.manufacture in global_vars.g_OMRON:\n                    for j in range(int((data_len - self.prefix_bit) / 2)):\n                        st = self.prefix_bit + j * 2\n                        ed = st + 2\n                        temp_w_recv = data[st:ed]\n                        if self.protocol in global_vars.g_FINS:\n                            w_recv = temp_w_recv\n                        res.append(w_recv)\n                # ikeike\n                elif self.protocol in global_vars.g_MODBUSRTU:\n                    # 長すぎる場合は未対応data[self.prefix_bit - 1]\n                    len_of_data = self.send_length\n                    for j in range(data_len - self.prefix_bit):\n                        val = int(data[j + self.prefix_bit])\n                        for k in range(16):\n                            if k >= len_of_data:\n                                break\n                            res.append(str(int(val % 2)))\n                            val /= 2\n                        len_of_data -= 16\n                # ikeike\n                # ikeikeike\n                elif self.protocol in global_vars.g_COMPUTERLINK:\n                    # 長すぎる場合は未対応data[self.prefix_bit - 1]\n                    for j in range(0, data_len - self.prefix_bit - 1):\n                        res.append(chr(data[j + self.prefix_bit]))\n                # ikeikeike\n                else:\n                    for j in range(data_len - self.prefix_bit):\n                        st = self.prefix_bit + j\n                        ed = st + 1\n                        b_recv = data[st:ed]\n                        res.append(b_recv)\n            # Perse word unit\n            elif self.bit_identify in global_vars.g_IFY_WORD_DEVICE:\n                if self.protocol in global_vars.g_MODBUSRTU:\n                    for j in range(0, data_len - self.prefix_bit, 2):\n                        try:\n                            res.append(\n                                format(int(data[j + self.prefix_bit]), '02x')\n                                + format(\n                                    int(data[j + 1 + self.prefix_bit]), '02x')\n                            )\n                        except Exception:\n                            res.append(\n                                format(int(data[j + self.prefix_bit], 16), '02x')\n                                + format(\n                                    int(data[j + 1 + self.prefix_bit], 16), '02x')\n                            )\n                elif self.protocol in global_vars.g_COMPUTERLINK:\n                    for j in range(0, data_len - self.prefix_bit - 1, 4):\n                        res.append(\n                            format(\n                                int((\n                                    chr(data[self.prefix_bit + j])\n                                    + chr(data[self.prefix_bit + j + 1])\n                                    + chr(data[self.prefix_bit + j + 2])\n                                    + chr(data[self.prefix_bit + j + 3])\n                                ).lower(), 16), '04x'\n                            )\n                        )\n                else:\n                    for j in range(int((data_len - self.prefix_bit) / 4)):\n                        st = self.prefix_bit + j * 4\n                        ed = st + 4\n                        temp_w_recv = data[st:ed]\n                        if self.protocol in global_vars.g_FINS:\n                            w_recv = temp_w_recv\n                        elif self.protocol in global_vars.g_MODBUSRTU:\n                            if j < 2 and int(temp_w_recv[2:]) == 0:\n                                w_recv = temp_w_recv[:2]\n                            elif j < 2 and int(temp_w_recv[:2]) == 0:\n                                w_recv = temp_w_recv[2:]\n                            else:\n                                w_recv = temp_w_recv[2:] + temp_w_recv[:2]\n                        else:\n                            w_recv = temp_w_recv[2:] + temp_w_recv[:2]\n                        res.append(w_recv)\n\n                if (self.option in global_vars.g_STRING_OPTION and self.cmd in global_vars.g_READ_COMMAND):\n                    if self.manufacture in global_vars.g_PANASONIC:\n                        _res = convert_format.check_hex_and_convert_integer(\n                            res[2:], self.byte_order, dhex=True)\n                        try:\n                            try:\n                                word_cnt = int(res[1], 16)\n                            except Exception:\n                                word_cnt = int(res[1])\n                        except Exception:\n                            word_cnt = 0\n                        res = _res[:word_cnt]\n                    # elif self.manufacture in global_vars.g_KEYENCE:\n                    #     _res = convert_format.check_hex_and_convert_integer(\n                    #         res, self.byte_order, dhex=True)\n                    #     try:\n                    #         try:\n                    #             word_cnt = int(res[1], 16)\n                    #         except Exception:\n                    #             word_cnt = int(res[1])\n                    #     except Exception:\n                    #         word_cnt = 0\n                    #     res = _res[:word_cnt]\n                    else:\n                        _res = convert_format.check_hex_and_convert_integer(\n                            res, self.byte_order, dhex=True)\n                        try:\n                            string_option_null_break = optional['string_option_null_break']\n                        except Exception:\n                            string_option_null_break = True\n                        if string_option_null_break:\n                            for i, x in enumerate(_res):\n                                if x == 0:\n                                    res = _res[:i]\n                                    break\n                        else:\n                            res = _res\n                        # logger.info(\"Res:{}, null_break:{}\".format(\n                        #    res, string_option_null_break))\n            else:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'This bit_identify is not supported.'\n                    )\n                )\n            try:\n                if use_bcd:\n                    response = res\n                else:\n                    try:\n                        response = [int(x, 16) for x in res]\n                    except Exception:\n                        response = res\n                if self.bit_identify in global_vars.g_IFY_BIT_DEVICE:\n                    if self.bit_odd_flag:\n                        try:\n                            if len(response) % 2 == 0:\n                                response.pop()\n                        except Exception:\n                            pass\n            except Exception:\n                raise ValueError(\n                    '{}, {}'.format(\n                        sys._getframe().f_code.co_name, 'System error:Response format is incorrect.'\n                    )\n                )\n        except Exception:\n            logger.warning(traceback.format_exc())\n            message = str(traceback.format_exc())\n            response = None\n        finally:\n            # logger.info('Response:{}, {}'.format(response, message))\n            return response, message\n\n\ndef adjust_max_characters_of_case_of_string(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict):\n    # In the case of string reading, the maximum number of characters is read from the PLC first.\n    #  Adjust the maximum number of characters for string reading.\n    try:\n        if (cmd_data[\"option\"] in global_vars.g_STRING_OPTION\n            and cmd_data[\"cmd\"] in global_vars.g_READ_COMMAND\n                and plc_protocol[\"manufacture\"] in global_vars.g_PANASONIC):\n            _device_info = device_list.device_list(\n                plc_protocol[\"manufacture\"], plc_protocol[\"protocol\"], plc_protocol[\n                    \"series\"], transport_layer=plc_protocol[\"transport_layer\"], period_index=plc_protocol[\"period_index\"]\n            )\n            if _device_info[\"device\"][device_parameter[\"device\"]][2] == \"w\":\n                _device_parameter = device_parameter\n                _device_parameter[\"max\"] = _device_parameter[\"min\"]\n                _cmd_data = cmd_data\n                _cmd_data[\"option\"] = \"\"\n                _connect = ConnectToPlc(\n                    plc_network,\n                    plc_protocol,\n                    _device_parameter,\n                    _cmd_data\n                )\n                _res, _send, _err = _connect.sent_telegram()\n\n                if re.fullmatch(\"[0-9a-f]+\", _res, re.I):\n                    # Parse the data in bit/word units.\n                    _res_element, _message_element = _connect.extracting_elements(\n                        _res)\n                    logger.debug('Adjust Res Element:{}'.format(_res_element))\n                else:\n                    raise ValueError(\n                        '{}, {}'.format(\n                            sys._getframe().f_code.co_name, 'Error.'\n                        )\n                    )\n                _cnv_leaddev = device_list.convert_to_decimal(\n                    _device_info[\"device\"][_device_parameter[\"device\"]][0], _device_parameter)\n                _cnv_minmax = device_list.convert_to_n_array(\n                    _device_info[\"device\"][_device_parameter[\"device\"]][0], _cnv_leaddev[\"lead_number\"], _res_element[0] + 2)\n                device_parameter[\"min\"] = _cnv_minmax[\"min_bit\"]\n                device_parameter[\"max\"] = _cnv_minmax[\"max_bit\"]\n                cmd_data[\"option\"] = global_vars.g_STRING_OPTION[0]\n    except Exception:\n        pass\n    finally:\n        return plc_network, plc_protocol, device_parameter, cmd_data\n\n\n# Use asyncio to connect to multiple PLCs in parallel.\nasync def parallel_communication_to_plc(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict, *, optional: dict = {}) -> dict:\n    res = ''\n    send = ''\n    res_element = ''\n    try:\n        # If can read max string length, fixed max device.\n        plc_network, plc_protocol, device_parameter, cmd_data = adjust_max_characters_of_case_of_string(\n            plc_network, plc_protocol, device_parameter, cmd_data)\n\n        # Connection to PLC\n        connect = ConnectToPlc(\n            plc_network,\n            plc_protocol,\n            device_parameter,\n            cmd_data\n        )\n        # Generate telegram and transmission telegram to PLC.\n        res, send, err = connect.sent_telegram()\n\n        # Is data format BCD?\n        use_bcd: bool = False\n        try:\n            if cmd_data[\"option\"] in [\"time\", \"warning\"]:\n                if plc_protocol[\"manufacture\"] in (global_vars.g_MITSUBISHI + global_vars.g_PANASONIC + global_vars.g_OMRON):\n                    use_bcd = True\n                elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n                    use_bcd = False\n        except Exception:\n            use_bcd = False\n\n        if re.fullmatch(\"[0-9a-f]+\", res, re.I):\n            # Parse the data in bit/word units.\n            res_element, message_element = connect.extracting_elements(\n                res, use_bcd=use_bcd, optional=optional)\n            logger.debug(\"Extract:{}\".format(res_element))\n            # convert date format.\n            if cmd_data[\"option\"] in global_vars.g_TIME_OPTION:\n                res_element = convert_format.convert_date_format(\n                    plc_protocol, cmd_data, res_element)\n        else:\n            raise ValueError(\n                '{}, {}'.format(\n                    sys._getframe().f_code.co_name, 'Error.'\n                )\n            )\n\n    except Exception as e:\n        if not res or res == ['']:\n            res = [e]\n            err = e\n        if not send:\n            send = ''\n        if not res_element or res_element == 0:\n            res_element = 0\n    finally:\n        return {\n            'response': res,\n            'exists_data': res_element,\n            'send_binary': send,\n            'error_code': err,\n            'message': err,\n        }\n\n\nasync def parallel_connect(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict, *, optional: dict = {}):\n    # Communicate in parallel\n    if not optional:\n        for k in plc_network:\n            optional[k] = {}\n    all_groups = await asyncio.gather(\n        *[\n            parallel_communication_to_plc(\n                plc_network[i],\n                plc_protocol[i],\n                device_parameter[i],\n                cmd_data[i],\n                optional=optional[i]\n            ) for i in device_parameter.keys()\n        ]\n    )\n    return {[j for j in device_parameter.keys()][i]: x for i, x in enumerate(all_groups)}\n\n\ndef single_communication_to_plc(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict) -> dict:\n    res = send = res_element = ''\n    try:\n        # If can read max string length, fixed max device.\n        plc_network, plc_protocol, device_parameter, cmd_data = adjust_max_characters_of_case_of_string(\n            plc_network, plc_protocol, device_parameter, cmd_data)\n\n        # Connection to PLC\n        connect = ConnectToPlc(\n            plc_network,\n            plc_protocol,\n            device_parameter,\n            cmd_data\n        )\n        # Generate telegram and transmission telegram to PLC.\n        res, send, err = connect.sent_telegram()\n\n        # Is data format BCD?\n        use_bcd: bool = False\n        try:\n            if cmd_data[\"option\"] in [\"time\", \"warning\"]:\n                if plc_protocol[\"manufacture\"] in (global_vars.g_MITSUBISHI + global_vars.g_PANASONIC + global_vars.g_OMRON):\n                    use_bcd = True\n                elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n                    use_bcd = False\n        except Exception:\n            use_bcd = False\n\n        if re.fullmatch(\"[0-9a-f]+\", res, re.I):\n            # Parse the data in bit/word units.\n            res_element, message_element = connect.extracting_elements(\n                res, use_bcd=use_bcd)\n\n            # convert date format.\n            res_element = convert_format.convert_date_format(\n                plc_protocol, cmd_data, res_element)\n        else:\n            raise ValueError(\n                '{}, {}'.format(\n                    sys._getframe().f_code.co_name, 'Error.'\n                )\n            )\n    except Exception as e:\n        if not res or res == ['']:\n            res = [e]\n            err = e\n        if not send:\n            send = ''\n        if not res_element or res_element == 0:\n            res_element = 0\n        # print(traceback.format_exc())\n    finally:\n        return {\n            'response': res,\n            'exists_data': res_element,\n            'send_binary': send,\n            'error_code': err,\n            'message': err,\n        }\n\n\ndef single_connect(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict):\n    key = [i for i in device_parameter.keys()][0]\n    # Communicate in parallel\n    all_groups = single_communication_to_plc(\n        plc_network[key],\n        plc_protocol[key],\n        device_parameter[key],\n        cmd_data[key]\n    )\n    return {key: all_groups}\n\n\ndef communication_to_plc(plc_network: dict, plc_protocol: dict, device_parameter: dict, cmd_data: dict) -> typing.Tuple[str, list, str, int]:\n    res = send = res_element = ''\n    try:\n        # If can read max string length, fixed max device.\n        plc_network, plc_protocol, device_parameter, cmd_data = adjust_max_characters_of_case_of_string(\n            plc_network, plc_protocol, device_parameter, cmd_data)\n\n        # Connection to PLC\n        connect = ConnectToPlc(\n            plc_network,\n            plc_protocol,\n            device_parameter,\n            cmd_data\n        )\n        # Generate telegram and transmission telegram to PLC.\n        res, send, err = connect.sent_telegram()\n\n        # Is data format BCD?\n        use_bcd: bool = False\n        try:\n            if cmd_data[\"option\"] in [\"time\", \"warning\"]:\n                if plc_protocol[\"manufacture\"] in (global_vars.g_MITSUBISHI + global_vars.g_PANASONIC + global_vars.g_OMRON):\n                    use_bcd = True\n                elif plc_protocol[\"manufacture\"] in global_vars.g_KEYENCE:\n                    use_bcd = False\n        except Exception:\n            use_bcd = False\n\n        if re.fullmatch(\"[0-9a-f]+\", res, re.I):\n            # Parse the data in bit/word units.\n            res_element, message_element = connect.extracting_elements(\n                res, use_bcd=use_bcd)\n\n            # convert date format.\n            res_element = convert_format.convert_date_format(\n                plc_protocol, cmd_data, res_element)\n        else:\n            raise ValueError(\n                '{}, {}'.format(\n                    sys._getframe().f_code.co_name, 'Error.'\n                )\n            )\n\n    except Exception as e:\n        if not res or res == ['']:\n            res = [e]\n            err = e\n        if not send:\n            send = ''\n        if not res_element or res_element == 0:\n            res_element = 0\n        # print(traceback.format_exc())\n    return res, res_element, send, err\n\n\ndef _main(plc_network: list, plc_protocol: list, device_parameter: list, cmd_data: list):\n    # Communicate only.\n    all_groups = communication_to_plc(\n        plc_network[0], plc_protocol[0], device_parameter[0], cmd_data[0])\n    return all_groups\n\n\nif __name__ == '__main__':\n    _plc_network = {\n        \"pqm_address\": {'ip': '10.224.136.114', 'port': '5000'},\n        # \"pqm_model\": {'ip': '10.224.136.114', 'port': '5000'},\n        # \"pqm_runmode\": {'ip': '10.224.136.114', 'port': '5000'},\n        # \"pqm_time\": {'ip': '10.224.136.114', 'port': '5000'},\n    }\n    _plc_protocol = {\n        \"pqm_address\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n        # \"pqm_model\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n        # \"pqm_runmode\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n        # \"pqm_time\": {'manufacture': 'keyence', 'series': 'kv7500', 'protocol': 'slmp', 'transport_layer': 'tcp', 'period_index': None},\n    }\n    _device_parameter = {\n        \"pqm_address\": {\"device\": \"D\", \"min\": \"200\", \"max\": \"230\"},\n        # \"pqm_model\": {\"device\": \"D\", \"min\": \"400\", \"max\": \"520\"},\n        # \"pqm_runmode\": {\"device\": \"D\", \"min\": \"700\", \"max\": \"720\"},\n        # \"pqm_time\": {\"device\": \"D\", \"min\": \"200\", \"max\": \"201\"},\n    }\n    _cmd_data = {\n        \"pqm_address\": {\"cmd\": \"read\", \"data\": [], \"option\": \"\"},\n        # \"pqm_model\": {\"cmd\": \"read\", \"data\": [], \"option\": \"string\"},\n        # \"pqm_runmode\": {\"cmd\": \"read\", \"data\": [], \"option\": \"string\"},\n        # \"pqm_time\": {\"cmd\": \"read\", \"data\": [], \"option\": \"time\"},\n    }\n    _optional = {\n        # \"pqm_address\": {},\n        # \"pqm_model\": {\"string_option_null_break\": False},\n        # \"pqm_runmode\": {\"string_option_null_break\": False},\n        # \"pqm_time\": {},\n    }\n    loop = asyncio.get_event_loop()\n    result = loop.run_until_complete(parallel_connect(\n        _plc_network, _plc_protocol, _device_parameter, _cmd_data, optional=_optional))\n    logger.info(\n        'result(recv, recv_parameter(n_array), send):{}'.format(result))\n",
        "pymodbus.py": "# from pymodbus3.client.sync import ModbusTcpClient\n\n# import logging\n# UNIT = 0x1\n\n# def run_sync_client():\n#     try:\n#         client = ModbusTcpClient('192.168.0.10', port=502)\n#         # client = ModbusClient('localhost', port=502)\n#         client.connect()\n#         #connected =1\n\n#     except:\n#         print(\"modbus error\")\n#    # \"Read write registeres simulataneously\")\n#     try:\n#         rr = client.read_holding_registers(1, 4, unit=UNIT)\n#         # following will write value 10 or 20 to address 1\n#         rq = client.write_register(4, 20, unit=UNIT)\n#         # close the client\n#         client.close()\n#         print(rr)\n#         print(rr.registers)\n#     except Exception as e:\n#         print(\"Modbus Connection returned Error \", e)\n\n\n# if __name__ == \"__main__\":\n#     run_sync_client()\n\n\n# from pyModbusTCP.client import ModbusClient\n# c = ModbusClient(host=\"127.0.0.1\", auto_open=True, auto_close=True)\n# regs = c.read_holding_registers(0, 2)\n# if regs:\n#     print(regs)\n# else:\n#     print(\"read error\")\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# read_register\n# read 10 registers and print result on stdout\n# you can use the tiny modbus server \"mbserverd\" to test this code\n# mbserverd is here: https://github.com/sourceperl/mbserverd\n# the command line modbus client mbtget can also be useful\n# mbtget is here: https://github.com/sourceperl/mbtget\nfrom pyModbusTCP.client import ModbusClient\nimport time\nSERVER_HOST = \"192.168.0.10\"  # 接続先ホスト\nSERVER_PORT = 502\nc = ModbusClient()\n# uncomment this line to see debug message\n# c.debug(True)\n# define modbus server host, port\nc.host(SERVER_HOST)\nc.port(SERVER_PORT)\nwhile True:\n    # open or reconnect TCP to server\n    if not c.is_open():\n        if not c.open():\n            print(\"unable to connect to \"+SERVER_HOST+\":\"+str(SERVER_PORT))\n    # if open() is ok, read register (modbus function 0x03)\n    if c.is_open():\n\n        # recs = c.read_coils(8192, 10)\n        # print(recs)\n        # if c.write_multiple_registers(10, [44, 55]):\n        #     print(\"write ok\")\n        # else:\n        #     print(\"write error\")\n\n        # read 10 registers at address 0, store result in regs list\n        regs = c.read_holding_registers(0, 125)\n        # if success display registers\n        if regs:\n            print(\"reg ad #0 to 9: \"+str(regs))\n    # sleep 2s before next polling\n    time.sleep(2)\n",
        "README.md": "EthernetでPLCと通信する - python.\n==============\nPLCとPCをイーサネット間で接続し、ソケット通信(TCP)で疎通します。<br>\n指定したPLCのデバイス(ビット群)にアクセスし、内容の読み書きを行います。<br>\n通信する際は通信先PLCと通信元PCのネットワーク設定をよく確認してください。<br>\n\n## 対応PLC\n三菱　　　　：MELSEC-QL /iQ-R /iQ-Fシリーズ (MCプロトコル 1E, 3Eフレーム対応機種)<br>\nキーエンス　：KV-3000 /5000 /7000 /8000シリーズ (MCプロトコル対応機種)<br>\nパナソニック：FP-0 /7シリーズ (MCプロトコル対応機種)<br>\nオムロン　　：CS /CJ /CP /NSJシリーズ (FINS通信対応機種)<br>\n\n## 使い方\n##### ~~~~~~ 辞書型 ~~~~~~\n##### PLCのネットワーク設定\n&nbsp;plc_netwok = {'com0':{'ip':'xxx.xxx.xxx.xxx', 'port':'xxxxx'},}<br>\n##### PLCの機種設定\n&nbsp;plc_protocol = {'com0':{'manufacture':'mitsubishi', 'series':'ql', 'protocol':'mc_3e', 'transport_layer':'tcp'},}<br>\n##### アクセスするPLCのデバイスの設定<br>\n&nbsp;device_parameter = {'com0':{'device':'M', 'min':'0', 'max':10},}<br>\n##### 実行内容\n###### 読出し\n&emsp;cmd_data = {'com0':{'cmd':'read', 'data':[], 'option':''},}<br>\n###### 書込み(数値)\n&emsp;cmd_data = {'com0':{'cmd':'write', 'data':[0,1,2,3,4,5,6,7,8,9,10], 'option':''},}<br>\n###### 書込み(文字列)\n&emsp;moji = ['A','B','C','D']　⇒　ASCII(10)変換 　⇒　moji_ascii = [97,98,99,100]<br>\n&emsp;cmd_data = {'com0':{'cmd':'write', 'data':[len(moji_ascii), moji_ascii[0]+moji_ascii[1]*256+moji_ascii[2]*(256**2)+moji_ascii[3]*(256**3)], 'option':'string'},}<br>\n##### 実行\n&nbsp;loop = asyncio.get_event_loop()<br>\n&nbsp;result = loop.run_until_complete(parallel_connect(plc_network, plc_protocol, device_parameter, cmd_data))<br>\n##### 結果\n&nbsp;result[n]['response']    ⇒ n台目に設定したPLCからの返答電文<br>\n&nbsp;result[n]['exists_data'] ⇒ 返答電文の内容 (書込みの場合は空)<br>\n&nbsp;result[n]['send_binary'] ⇒ PLCに送信した電文<br>\n&nbsp;result[n]['error_code']  ⇒ エラー判定。0の場合通信成功<br>\n",
        "requirements.txt": "pytz             == 2020.4\ntzlocal          == 2.1\n# numpy            == 1.19.4\n# pandas           == 1.1.5\npsycopg2         == 2.8.6\nflask            == 1.1.2\nflask-Cors       == 3.0.10\nflask-Migrate    == 2.7.0\nflask-RESTful    == 0.3.8\nflask-Script     == 2.0.6\nflask_sqlalchemy == 2.5.1\nSQLAlchemy       == 1.3.23\nrequests         == 2.25.1\ngevent           == 20.12.0\ngevent-websocket == 0.10.1\nwerkzeug         == 1.0.1\nxlrd             == 1.2.0\ntqdm             == 4.54.1\nuwsgi            == 2.0.19.1\nnetifaces        == 0.10.9\npsutil           == 5.8.0\nopenpyxl         == 3.0.7\n# numba            == 0.53.1\nuwsgidecorators  == 1.1.0\nicmplib          == 3.0\npython-dotenv    == 0.18.0\npyModbusTCP      == 0.1.10\nmore-itertools   == 8.9.0",
        "__init__.py": "import os\nimport glob\n\n__all__ = [\n    os.path.split(os.path.splitext(file)[0])[1]\n    for file in glob.glob(os.path.join(os.path.dirname(__file__), '[a-zA-Z0-9]*.py'))\n]\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\security": {
        "certification.py": "import hashlib\n\n\ndef get_cpu_serial() -> str:\n    \"\"\"Retrieve the Raspberry Pi's serial number\"\"\"\n    cpu_serial = \"0000000000000000\"\n    try:\n        with open('/proc/cpuinfo', 'r') as f:\n            for line in f:\n                if line[0:6] == 'Serial':\n                    cpu_serial = line[10:26]\n            f.close()\n    except Exception:\n        cpu_serial = \"ERROR\"\n\n    return cpu_serial\n\n\ndef get_mac_address(interface: str) -> str:\n    \"\"\"Retrieve the MAC address of a Raspberry Pi interface\"\"\"\n    try:\n        mac = open('/sys/class/net/' + interface + '/address').readline()\n    except Exception:\n        mac = \"ERROR\"\n    return mac[0:17]\n\n\ndef get_vast_id(serial: str, macaddr: str) -> str:\n    \"\"\"本体番号とMACアドレスからVASTのIDを生成\"\"\"\n\n    # remove \":\"\n    macaddr = macaddr.replace(':', '')\n\n    serial_and_mac = serial + macaddr\n\n    # convert to decimal and add\n    total = 0\n    for i, char in enumerate(serial_and_mac):\n        total += int(char, 16)\n\n    # convert to hexdecimal\n    vast_id = hex(total + int(\"0x12345678\", 16))\n\n    return vast_id\n\n\ndef get_vast_cipher(vast_id: str) -> str:\n    \"\"\"VASTのIDを暗号化\"\"\"\n    # calculate two's complement\n    cipher = \"0x\"\n    for i, char in enumerate(vast_id[2:]):\n        cipher += hex(15 - int(char, 16))[2:]\n\n    cipher = hex(int(cipher, 16) + 1)\n\n    # SHA-256 hash\n    hashed = hashlib.sha256(vast_id.encode('utf-8')).hexdigest()\n\n    return hashed\n\n\ndef check_hash(code: str) -> bool:\n    ser = get_cpu_serial()\n    mac = get_mac_address(\"wlan0\")\n    if ser == \"ERROR\" or mac == \"ERROR\":\n        return False\n    vast_id = get_vast_id(ser, mac)\n    hash = get_vast_cipher(vast_id)\n    if code == hash:\n        return True\n    return False\n\n\nif __name__ == \"__main__\":\n\n    ser = '10000000cbf98589'\n    mac = 'e4:5f:01:f0:f6:87'\n    hash = get_vast_cipher(get_vast_id(ser, mac))\n    print(hash)\n\n    # ser = get_cpu_serial()\n    # mac = get_mac_address(\"wlan0\")\n\n    # if ser != \"ERROR\" and mac != \"ERROR\":\n    #     vast_id = get_vast_id(ser, mac)\n    #     hash = get_vast_cipher(vast_id)\n\n    #     HASH_FILENAME = '/media/usb/hash.json'\n    #     data = dict(hash=hash)\n    #     ret = write_file(HASH_FILENAME, data)\n",
        "db_handler.py": "# ===============================================================================\n# Name      : eop_tray_pick.py\n# Version   : 1.0.0\n# Brief     : 4隅のマークがあるトレイからピックする\n# Time-stamp: 2023-07-19 10:12\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\n\nimport sqlite3\nfrom abc import ABCMeta, abstractmethod\nfrom typing import Optional, List\n\n\nclass DBTable(metaclass=ABCMeta):\n    def __init__(self, *, tablename: str = '', db_file: str = ''):\n        self._tablename: str = tablename\n        self._db_file: str = db_file\n\n    def setTableName(self, tablename: str) -> None:\n        self._tablename = tablename\n\n    def setDBFilePath(self, db_file: str) -> None:\n        self._db_file = db_file\n\n    def connect(self) -> None:\n        self.conn = sqlite3.connect(self._db_file)\n        self.cursor = self.conn.cursor()\n\n    @abstractmethod\n    def createTable(self) -> None:\n        pass\n\n    @abstractmethod\n    def insertRow(self, data: list) -> None:\n        pass\n\n    def updateData(self, update_dict: dict, condition_dict: dict) -> None:\n        \"\"\"データのアップデート\n\n        Args:\n            update_dict (dict): 変更するデータ\n            condition_dict (dict): 基準とするデータ\n        Examples:\n            update_dict = {'judgement': 3, 'resolution': '800x600'}\n            condition_dict = {'timestamp': '2023-07-13 10:00:00'}\n            table.updateData(update_dict, condition_dict)\n        \"\"\"\n        # NOTE: クエリ生成\n        query = f'UPDATE {self._tablename} SET '\n        set_clause = ', '.join([f'{key} = ?' for key in update_dict.keys()])\n        query += set_clause + ' WHERE '\n        where_clause = ' AND '.join([f'{key} = ?' for key in condition_dict.keys()])\n        query += where_clause\n        values = list(update_dict.values()) + list(condition_dict.values())\n\n        # NOTE: クエリ実行\n        self.cursor.execute(query, values)\n        self.conn.commit()\n\n    def deleteData(self, condition_dict: dict) -> None:\n        \"\"\"_summary_\n\n        Args:\n            condition_dict (dict): _description_\n        Examples:\n            condition_dict = {'judgement': 2}\n            table.deleteData(condition_dict)\n        \"\"\"\n        # NOTE: クエリ生成\n        query = f'DELETE FROM {self._tablename} WHERE '\n        where_clause = ' AND '.join([f'{key} = ?' for key in condition_dict.keys()])\n        query += where_clause\n        values = list(condition_dict.values())\n\n        # NOTE: クエリ実行\n        self.cursor.execute(query, values)\n        self.conn.commit()\n\n    def selectData(self, condition_dict: Optional[dict] = None):\n        \"\"\"_summary_\n\n        Returns:\n            _type_: _description_\n\n        Examples:\n            results = table.selectData()\n            for row in results:\n                print(row)\n        \"\"\"\n        query = f'SELECT * FROM {self._tablename}'\n        if condition_dict:\n            where_clause = ' AND '.join([f'{key} = ?' for key in condition_dict.keys()])\n            query += ' WHERE ' + where_clause\n            values = list(condition_dict.values())\n            self.cursor.execute(query, values)\n        else:\n            self.cursor.execute(query)\n\n        return self.cursor.fetchall()\n\n    def close(self):\n        self.cursor.close()\n        self.conn.close()\n\n\nif __name__ == '__main__':\n    from pydantic import BaseModel\n\n    FIELDNAMES: List[str] = ['timestamp', 'judgement', 'resolution', 'processing_time', 'x', 'y', 'z', 'r', 'num_pieces', 'error_message']\n\n    class LabelList(BaseModel):\n        \"\"\"データフレームにアクセスする時に使うラベルリスト\"\"\"\n        timestamp: str = FIELDNAMES[0]\n        judgement: str = FIELDNAMES[1]\n        resolution: str = FIELDNAMES[2]\n        processing_time: str = FIELDNAMES[3]\n        x: str = FIELDNAMES[4]\n        y: str = FIELDNAMES[5]\n        z: str = FIELDNAMES[6]\n        r: str = FIELDNAMES[7]\n        num_pieces: str = FIELDNAMES[8]\n        error_message: str = FIELDNAMES[9]\n\n    Labels = LabelList()\n\n    class PositionData(BaseModel):\n        \"\"\"ワークの位置情報\"\"\"\n        x: float = 0.0\n        y: float = 0.0\n        z: float = 0.0\n        r: float = 0.0\n\n    class InspectionResults(BaseModel):\n        \"\"\"検査結果の情報\"\"\"\n        timestamp: str = '2000-01-01 12:00:00'  # NOTE: 検査時刻 YYYY-MM-DD HH:mm:SS\n        judgement: int = 1  # NOTE: 処理結果 OK:1, NG:2, ERR:3\n        resolution: str = '640x480'  # NOTE: 解像度\n        processing_time: float = 0.0  # NOTE: 処理時間\n        position: PositionData = PositionData()  # NOTE: ワークの位置\n        num_pieces: int = 0  # NOTE: ワークの数\n        error_message: str = ''  # NOTE: エラーメッセージ\n\n    class CustomDBTable(DBTable):\n        def __init__(self, **kwargs):\n            super().__init__(**kwargs)\n\n        def createTable(self) -> None:\n            # NOTE: InspectionResultsテーブルを作成\n            sql_query = f'''\n                CREATE TABLE IF NOT EXISTS {self._tablename} (\n                    {Labels.timestamp} TEXT,\n                    {Labels.judgement} INTEGER,\n                    {Labels.resolution} TEXT,\n                    {Labels.processing_time} REAL,\n                    {Labels.x} REAL,\n                    {Labels.y} REAL,\n                    {Labels.z} REAL,\n                    {Labels.r} REAL,\n                    {Labels.num_pieces} INTEGER,\n                    {Labels.error_message} TEXT\n                )\n            '''\n            self.cursor.execute(sql_query)\n            self.conn.commit()\n\n        def insertRow(self, data: list) -> None:\n            # NOTE: InspectionResultsテーブルを作成\n            sql_query = f'''\n                INSERT INTO {self._tablename} (\n                    {Labels.timestamp},\n                    {Labels.judgement},\n                    {Labels.resolution},\n                    {Labels.processing_time},\n                    {Labels.x},\n                    {Labels.y},\n                    {Labels.z},\n                    {Labels.r},\n                    {Labels.num_pieces},\n                    {Labels.error_message}\n                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n            '''\n            self.cursor.executemany(sql_query, data)\n            self.conn.commit()\n\n    # NOTE: テストコード\n\n    db_file = 'inspection_results.sqlite'\n    tablename = 'hoge1'\n    table = CustomDBTable(db_file=db_file, tablename=tablename)\n\n    table.connect()\n    table.createTable()\n\n    # NOTE: データを挿入\n    data = [\n        ('2023-07-13 10:00:00', 1, '640x480', 0.0, 1.0, 3.0, 0.0, 10.0, 0, ''),\n        ('2023-07-13 10:00:01', 2, '', 1.5, 2.0, 4.0, 0.0, 20.0, 0, '')\n    ]\n    table.insertRow(data)\n\n    # NOTE: データを更新\n    update_dict = {'judgement': 3, 'resolution': '800x600'}\n    condition_dict1 = {'timestamp': '2023-07-13 10:00:00'}\n    table.updateData(update_dict, condition_dict1)\n\n    # NOTE: データを削除\n    condition_dict2 = {'judgement': 2}\n    table.deleteData(condition_dict2)\n\n    # データを選択\n    results = table.selectData()\n    for row in results:\n        print(row)\n\n    table.close()\n",
        "inspection_log_manager.py": "# ===============================================================================\n# Name      : eop_tray_pick.py\n# Version   : 1.0.0\n# Brief     : 4隅のマークがあるトレイからピックする\n# Time-stamp: 2023-07-19 18:22\n# Copyirght 2022 Hiroya Aoyama\n# ===============================================================================\nimport csv\n# import datetime\n# import numpy as np\nimport polars as pl\nimport plotly.graph_objects as go\nfrom pydantic import BaseModel\nfrom typing import List\n\n\nFIELDNAMES: List[str] = ['timestamp', 'judgement', 'resolution', 'processing_time', 'x', 'y', 'z', 'r', 'num_pieces', 'error_message']\n\n\nclass LabelList(BaseModel):\n    \"\"\"データフレームにアクセスする時に使うラベルリスト\"\"\"\n    timestamp: str = FIELDNAMES[0]\n    judgement: str = FIELDNAMES[1]\n    resolution: str = FIELDNAMES[2]\n    processing_time: str = FIELDNAMES[3]\n    x: str = FIELDNAMES[4]\n    y: str = FIELDNAMES[5]\n    z: str = FIELDNAMES[6]\n    r: str = FIELDNAMES[7]\n    num_pieces: str = FIELDNAMES[8]\n    error_message: str = FIELDNAMES[9]\n\n\nLabels = LabelList()\n\n\nclass PositionData(BaseModel):\n    \"\"\"ワークの位置情報\"\"\"\n    x: float = 0.0\n    y: float = 0.0\n    z: float = 0.0\n    r: float = 0.0\n\n\nclass InspectionResults(BaseModel):\n    \"\"\"検査結果の情報\"\"\"\n    timestamp: str = '2000-01-01 12:00:00'  # NOTE: 検査時刻 YYYY-MM-DD HH:mm:SS\n    judgement: int = 1  # NOTE: 処理結果 OK:1, NG:2, ERR:3\n    resolution: str = '640x480'  # NOTE: 解像度\n    processing_time: float = 0.0  # NOTE: 処理時間\n    position: PositionData = PositionData()  # NOTE: ワークの位置\n    num_pieces: int = 0  # NOTE: ワークの数\n    error_message: str = ''  # NOTE: エラーメッセージ\n\n\nclass InspectionResultsCSVHandler:\n    \"\"\"Inspection ResultsをCSVファイルに書き込むクラス\"\"\"\n\n    @staticmethod\n    def create_new_csv(filename: str) -> None:\n        \"\"\"Inspection ResultsをCSVファイルに書き込む\"\"\"\n        with open(filename, 'w', newline='') as csvfile:\n            writer = csv.DictWriter(csvfile, fieldnames=FIELDNAMES)\n            writer.writeheader()\n\n    @staticmethod\n    def add_data_to_csv(result: InspectionResults, filename: str) -> None:\n        \"\"\"Inspection ResultsをCSVファイルに書き込む\"\"\"\n        with open(filename, 'a', newline='') as csvfile:\n            writer = csv.DictWriter(f=csvfile, fieldnames=FIELDNAMES)\n            writer.writerow({\n                Labels.timestamp: result.timestamp,\n                Labels.judgement: result.judgement,\n                Labels.resolution: result.resolution,\n                Labels.processing_time: result.processing_time,\n                Labels.x: result.position.x,\n                Labels.y: result.position.y,\n                Labels.z: result.position.z,\n                Labels.r: result.position.r,\n                Labels.num_pieces: result.num_pieces,\n                Labels.error_message: result.error_message\n            })\n\n\nclass InspectionResultsVisualizer:\n    \"\"\"可視化関数\"\"\"\n    @staticmethod\n    def read_data_from_csv(filename: str) -> pl.DataFrame:\n        \"\"\"CSVファイルからInspection Resultsを読み取る\"\"\"\n        return pl.read_csv(filename)\n\n    @staticmethod\n    def visualize_judgement(results: pl.DataFrame) -> str:\n        \"\"\"処理結果を棒グラフで可視化する\"\"\"\n        counts = results[Labels.judgement].value_counts()\n        mapper = {1: 'OK', 2: 'NG', 3: 'ERR'}\n        # NOTE: 1, 2, 3の順番にソート\n        counts = counts.sort(Labels.judgement)\n        mapper = {1: 'OK', 2: 'NG', 3: 'ERR'}\n        counts = counts.with_columns(pl.col(Labels.judgement).apply(lambda x: mapper.get(x, 'Unknown'),\n                                                                    return_dtype=str))\n        fig = go.Figure(data=[go.Bar(x=counts[Labels.judgement],\n                                     y=counts['counts'],\n                                     marker=dict(color=['green', 'red', 'yellow']))\n                              ],\n                        )\n        fig.update_layout(title='Inspection Results - Judgement', xaxis_title='Judgement', yaxis_title='Count')\n        return fig.to_html(full_html=False)\n\n    @staticmethod\n    def visualize_time_series(results: pl.DataFrame) -> str:\n        \"\"\"時系列で検査結果を可視化する\"\"\"\n        timestamps = results[Labels.timestamp].str.strptime(pl.Datetime, '%Y-%m-%d %H:%M:%S')\n        fig = go.Figure(data=[go.Scatter(x=timestamps, y=results[Labels.judgement], mode='markers')])\n        fig.update_layout(title='Inspection Results - Time Series', xaxis_title='Timestamp', yaxis_title='Judgement')\n        return fig.to_html(full_html=False)\n\n    @staticmethod\n    def visualize_processing_time(results: pl.DataFrame) -> str:\n        \"\"\"処理時間をグラフで可視化する\"\"\"\n        timestamps = results[Labels.timestamp].str.strptime(pl.Datetime, '%Y-%m-%d %H:%M:%S')\n        fig = go.Figure(data=[go.Scatter(x=timestamps, y=results[Labels.processing_time], mode='lines')])\n        fig.update_layout(title='Inspection Results - Processing Time', xaxis_title='Time', yaxis_title='Processing Time')\n        return fig.to_html(full_html=False)\n\n    @staticmethod\n    def visualize_xy_position(results: pl.DataFrame) -> str:\n        \"\"\"X-Y位置をプロットする\"\"\"\n        fig = go.Figure(data=[go.Scatter(x=results[Labels.x], y=results[Labels.y],\n                                         mode='markers', text=results[Labels.timestamp], hovertemplate='%{text}')])\n        fig.update_layout(title='Inspection Results - X-Y Position', xaxis_title='X', yaxis_title='Y')\n        return fig.to_html(full_html=False)\n\n    @staticmethod\n    def visualize_polar_position(results: pl.DataFrame) -> str:\n        \"\"\"Rを円に配置してプロットする\"\"\"\n        fig = go.Figure(data=[go.Scatterpolar(r=[i for i in range(len(results[Labels.r]))], theta=results[Labels.r],\n                                              mode='markers', text=results[Labels.timestamp], hovertemplate='%{text}')])\n        fig.update_layout(title='Inspection Results - Polar Position', polar=dict(radialaxis=dict(visible=True)))\n        return fig.to_html(full_html=False)\n\n\nif __name__ == '__main__':\n    import sys\n    from PySide2 import QtWidgets, QtWebEngineWidgets, QtCore\n    import tempfile\n\n    def switch_graph(web_view: QtWebEngineWidgets.QWebEngineView,\n                     combo_box: QtWidgets.QComboBox,\n                     html_list: List[str]):\n\n        index = combo_box.currentIndex()\n        if index < 0:\n            return\n\n        with tempfile.NamedTemporaryFile(suffix=\".html\", delete=False) as temp_file:\n            temp_file.write(html_list[index].encode())\n            temp_file_path = temp_file.name\n\n        web_view.load(QtCore.QUrl.fromLocalFile(temp_file_path))\n\n    # NOTE: テストデータ\n    data = pl.DataFrame({\n        Labels.timestamp: ['2023-07-13 10:00:00',\n                           '2023-07-13 10:00:01',\n                           '2023-07-13 10:00:02',\n                           '2023-07-13 10:00:03',\n                           '2023-07-13 10:00:04',\n                           '2023-07-13 10:00:05',\n                           '2023-07-13 10:00:06',\n                           '2023-07-13 10:00:07',\n                           '2023-07-13 10:00:08',\n                           '2023-07-13 10:00:09'],\n        Labels.judgement: [1, 2, 2, 1, 1, 1, 1, 1, 1, 3],\n        Labels.resolution: ['', '', '', '', '', '', '', '', '', ''],\n        Labels.processing_time: [10, 20, 10, 10, 10, 20, 10, 20, 40, 10],\n        Labels.x: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n        Labels.y: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],\n        Labels.z: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        Labels.r: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n        Labels.num_pieces: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        Labels.error_message: ['', '', '', '', '', '', '', '', '', ''],\n    })\n\n    # NOTE: HTML群\n    html_str1 = InspectionResultsVisualizer.visualize_judgement(data)\n    html_str2 = InspectionResultsVisualizer.visualize_time_series(data)\n    html_str3 = InspectionResultsVisualizer.visualize_xy_position(data)\n    html_str4 = InspectionResultsVisualizer.visualize_polar_position(data)\n    html_str5 = InspectionResultsVisualizer.visualize_processing_time(data)\n\n    # NOTE: アプリケーションの起動\n    app = QtWidgets.QApplication(sys.argv)\n    window = QtWidgets.QMainWindow()\n\n    # NOTE: コンボボックスを作成\n    combo_box = QtWidgets.QComboBox()\n    combo_box.addItems(['a', 'b', 'c', 'd', 'e'])\n\n    # NOTE: WebEngineViewを作成\n    web_view = QtWebEngineWidgets.QWebEngineView()\n\n    # NOTE: レイアウトに追加\n    layout = QtWidgets.QVBoxLayout()\n    layout.addWidget(combo_box)\n    layout.addWidget(web_view)\n\n    # NOTE: 最初はhtml 1を表示しておく\n    with tempfile.NamedTemporaryFile(suffix=\".html\", delete=False) as temp_file:\n        temp_file.write(html_str1.encode())\n        temp_file_path = temp_file.name\n\n    web_view.load(QtCore.QUrl.fromLocalFile(temp_file_path))\n\n    # NOTE: コンボボックスの変更イベントでグラフを切り替え\n    combo_box.currentIndexChanged.connect(lambda: switch_graph(web_view=web_view,\n                                                               combo_box=combo_box,\n                                                               html_list=[html_str1,\n                                                                          html_str2,\n                                                                          html_str3,\n                                                                          html_str4,\n                                                                          html_str5]))\n\n    # NOTE: QtWidgetにLayoutを追加して表示\n    window.setCentralWidget(QtWidgets.QWidget())\n    window.centralWidget().setLayout(layout)\n    window.show()\n\n    # NOTE: アプリケーションの実行\n    sys.exit(app.exec_())\n",
        "inspection_results.sqlite": "Unsupported file type",
        "zip_io.py": "# ===============================================================================\n# Name      : zip_io.py\n# Version   : 1.0.0\n# Brief     : 設定ファイルやプログラムのZIP化\n# Time-stamp: 2023-07-13 09:22\n# Copyirght 2023 Hiroya Aoyama\n# ===============================================================================\nimport os\nimport subprocess\nimport zipfile\nimport traceback\nfrom pathlib import Path\nfrom queue import Queue\n\n\ndef get_traceback_info() -> str:\n    \"\"\"エラートレース\"\"\"\n    traceback_info = traceback.format_exc()\n    return traceback_info\n\n\ndef _remove_last_path_element(path: str) -> str:\n    \"\"\"\n    input : /aaa/bbb/ccc/ \\n\n    output: /aaa/bbb\n    \"\"\"\n    path_obj = Path(path)\n    return str(path_obj.parent)\n\n\ndef _get_last_path_element(path: str) -> str:\n    \"\"\"\n    input : /aaa/bbb/ccc/ \\n\n    output: ccc/\n    \"\"\"\n    path_obj = Path(path)\n    return str(path_obj.name) + os.sep\n\n\ndef _zip_proc_on_linux(in_path: str, out_path: str, pwd: str) -> bool:\n    \"\"\"Linux用PW付きZIP生成(AES256) \\n\n    [/aaa/bbb/ccc/]の[ccc/]を[/ddd/eee.zip]として出力 \\n\n    Args:\n        in_path (str): 圧縮したいフォルダのパス(/aaa/bbb/ccc)\n        out_path (str): zipファイルの出力先(/ddd/eee.zip)\n        pwd (str): ZIPに適用するパスワード\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    dist_dir = _remove_last_path_element(in_path)  # NOTE: /aaa/bbb/\n    rel_dir = _get_last_path_element(in_path)  # NOTE: ccc/\n    # NOTE ZIP CRYPTO\n    # cmd = f'cd {dist_dir} && zip -e -r -P {pwd} {out_path} {rel_dir}'\n    # NOTE: AES256\n    cmd = f'cd {dist_dir} && 7za a -tzip -p{pwd} -mem=AES256 {out_path} {rel_dir}'\n    subprocess.run(cmd, shell=True)\n    return True\n\n\ndef _unzip_proc_on_linux(in_path: str, out_path: str, pwd: str) -> bool:\n    \"\"\"Linux用PW付きZIP解凍(AES256) \\n\n    [/aaa/bbb/ccc.zip]の[ddd/]を[/eee/ddd/]として出力 \\n\n\n    Args:\n        in_path (str): 解凍したいフォルダのパス(/aaa/bbb/ccc.zip)\n        out_path (str): zipファイルの出力先(/eee/)\n        pwd (str): ZIPに適用されたパスワード\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    # cmd = f'unzip -P {pwd} -d {out_path} {in_path}'\n    cmd = f'7za x -p{pwd} -mem=AES256 -o{out_path} {in_path}'\n    subprocess.run(cmd, shell=True)\n    return True\n\n\ndef _zip_proc_on_windows(in_path: str, out_path: str, pwd: str) -> bool:\n    \"\"\"Windows用PW付きZIP生成(AES256) \\n\n    [/aaa/bbb/ccc/]の[ccc/]を[/ddd/eee.zip]として出力 \\n\n    Args:\n        in_path (str): 圧縮したいフォルダのパス(/aaa/bbb/ccc)\n        out_path (str): zipファイルの出力先(/ddd/eee.zip)\n        pwd (str): ZIPに適用するパスワード\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    try:\n        import pyzipper\n        in_path_ = Path(in_path)\n        with pyzipper.AESZipFile(out_path, 'w',\n                                 encryption=pyzipper.WZ_AES) as zf:\n\n            zf.setpassword(pwd.encode())\n            for file_path in in_path_.glob(\"**/*\"):\n                if file_path.is_file():\n                    arcname_ = in_path_.name + os.sep + str(file_path.relative_to(in_path_))\n                    zf.write(file_path, arcname=arcname_,\n                             compress_type=pyzipper.ZIP_DEFLATED)\n        return True\n    except Exception:\n        print(get_traceback_info())\n        return False\n\n\ndef _unzip_proc_on_windows(in_path: str, out_path: str, pwd: str):\n    \"\"\"Windows用PW付きZIP解凍(AES256) \\n\n    [/aaa/bbb/ccc.zip]の[ddd/]を[/eee/ddd/]として出力 \\n\n\n    Args:\n        in_path (str): 解凍したいフォルダのパス(/aaa/bbb/ccc.zip)\n        out_path (str): zipファイルの出力先(/eee/)\n        pwd (str): ZIPに適用されたパスワード\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    try:\n        import pyzipper\n        with pyzipper.AESZipFile(in_path) as zf:\n            zf.setpassword(pwd.encode())\n            zf.extractall(out_path)\n\n        return True\n    except Exception:\n        print(get_traceback_info())\n        return False\n\n\ndef zip_folder(in_path: str, out_path: str, queue: Queue) -> None:\n    \"\"\"フォルダのZIP化\n\n    Args:\n        in_path (str): 圧縮したいフォルダのパス(/aaa/bbb/ccc)\n        out_path (str): zipファイルの出力先(/ddd/eee.zip)\n        queue (Queue): 並列処理結果を返すためのキュー\n\n    Examples:\n        res_queue: Queue = Queue()\n        thread = threading.Thread(target=zio.zip_folder, args=(in_path, out_path, res_queue))\n        thread.start()\n        display_progress_bar(thread)\n        ret = res_queue.get()\n    \"\"\"\n    pwd = 'nidecncpt0723'\n    if os.path.exists(out_path):\n        # NOTE: 削除\n        os.remove(out_path)\n\n    if os.name == 'nt':\n        ret = _zip_proc_on_windows(in_path, out_path, pwd)\n    else:\n        ret = _zip_proc_on_linux(in_path, out_path, pwd)\n    queue.put(ret)\n\n\ndef unzip_folder(in_path: str, out_path: str, queue: Queue) -> None:\n    \"\"\"ZIPの解凍\n\n    Args:\n        in_path (str): 解凍したいフォルダのパス(/aaa/bbb/ccc.zip)\n        out_path (str): zipファイルの出力先(/eee/)\n        queue (Queue): 並列処理結果を返すためのキュー\n\n    Examples:\n        res_queue: Queue = Queue()\n        thread = threading.Thread(target=zio.unzip_folder, args=(in_path, out_path, res_queue))\n        thread.start()\n        display_progress_bar(thread)\n        ret = res_queue.get()\n    \"\"\"\n    pwd = 'nidecncpt0723'\n    if os.name == 'nt':\n        ret = _unzip_proc_on_windows(in_path, out_path, pwd)\n    else:\n        ret = _unzip_proc_on_linux(in_path, out_path, pwd)\n    queue.put(ret)\n\n\ndef is_zip_password_protected(zip_path: str) -> bool:\n    \"\"\"ZIPにパスワードが適用されているかチェック\n\n    Args:\n        zip_path (str): _description_\n\n    Returns:\n        bool: _description_\n    \"\"\"\n    with zipfile.ZipFile(zip_path, \"r\") as zip_file:\n        try:\n            zip_file.testzip()\n            return False\n        except RuntimeError:\n            return True\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\state_machine": {
        "demo.ipynb": "Unsupported file type",
        "State Machine.gv": "Unsupported file type",
        "State Machine.gv.pdf": "State Machine\nINSPECTION\nERROR\nEXCEPTION\nIDLING\nTO_IDLING\nBOOT\nRESET CALIBRATIONTO_CALIB\nTO_IDLING\nEXCEPTION\nTO_BOOT\nTO_INSPECT\nREADYTO_READY\nEXCEPTION\nTO_READY",
        "state_machine.py": "from typing import Any, Tuple, Optional\nfrom transitions import Machine\nfrom transitions.extensions import GraphMachine\nimport pandas as pd\nimport logging\n\n# 状態遷移を司るステートマシン\n# transitionライブラリで作るステートマシンは非常に多機能で、同じ動作でも複数のコーディング方法があったり\n# transitionの仕様の把握が必要な暗黙的な処理が多いので、作り込むと複雑すぎてメンテも大変だし可読性も下がる。\n# このライブラリはシンプルに状態遷移の機能と作成したステートマシンの図示や挙動確認だけを提供する。\n\n\nclass StateMachine(object):\n    def __init__(self, transition_csv: str = '',\n                 initial_state: str = 'BOOT',\n                 use_graph: bool = False,\n                 show_transition: bool = True,\n                 logger_id: str = \"\"):\n        \"\"\" StateMachineの引数は以下\n        transition_csv:先述の遷移を記述したcsv\n        initial_state:状態遷移の初期状態(string型)\n        use_graph:図示系の機能を使用するかどうか。使うと動作が遅くなるらしいので、デバッグ用に。\n                動作にはgraphvizのセットアップが必要。詳細は元リポジトリで\n                https://github.com/pytransitions/transitions\n        show_transition:実行した遷移をprint表示するかどうか\n        \"\"\"\n        # オプションを処理\n        self.logger = logging.getLogger(logger_id)\n        self.USE_GRAPH = use_graph\n        if show_transition:\n            before_state_change = '_action_before_state_change'\n            after_state_change = '_action_after_state_change'\n        else:\n            before_state_change = \"_action_before_state_change\"\n            after_state_change = None  # type:ignore\n        # csvファイルから状態遷移を生成\n        self.transitions = []  # type:ignore\n        self.df_transition = pd.read_csv(transition_csv)\n        # /で始まる行はコメントとして無視。\n        for index, item in self.df_transition.iterrows():\n            if item[\"Source\"][0] == \"/\":\n                self.df_transition = self.df_transition.drop(index=index)  # type:ignore\n        self._define_transitions()\n        self.initial_state = initial_state\n        # ステートマシンを作成\n        if self.USE_GRAPH:\n            self.machine = GraphMachine(model=self,\n                                        states=self.states,\n                                        initial=self.initial_state,\n                                        transitions=self.transitions,\n                                        auto_transitions=False,  # NOTE:これがないと勝手に全状態への遷移命令が作られる\n                                        before_state_change=before_state_change,\n                                        after_state_change=after_state_change,\n                                        send_event=True,\n                                        queued=True)\n        else:\n            self.machine = Machine(model=self,  # type:ignore\n                                   states=self.states,\n                                   initial=self.initial_state,\n                                   transitions=self.transitions,\n                                   auto_transitions=False,\n                                   send_event=True,\n                                   before_state_change=before_state_change,\n                                   after_state_change=after_state_change,\n                                   queued=True)\n        self.event_buf = None\n\n    def _action_before_state_change(self, event) -> None:\n        # 常に実行される。\n        # 状態遷移前に実行されるメソッド。遷移の情報を記録する。\n        self.event_buf = event\n\n    def _action_after_state_change(self, event) -> None:\n        # show_transitionオプション時\n        # 状態遷移後に実行されるメソッド。\n        # print('%s : %s => %s' % (event.event.name, event.transition.source, self.state))\n        self.logger.debug('%s : %s => %s' % (\n            event.event.name, event.transition.source, self.state))  # type: ignore\n\n    def _define_transitions(self) -> None:\n        # csvファイルから状態遷移を生成。何も複雑なことはない。\n        self.transitions = []\n        self.states = []\n        for index, item in self.df_transition.iterrows():\n            source = item[\"Source\"]\n            dest = item[\"Destination\"]\n            self.transitions.append({'trigger': item[\"Trigger\"],\n                                     'source': source,\n                                     'dest': dest})\n            self.states.append(source)\n            self.states.append(dest)\n        # 定義された状態遷移から、重複のない状態リストを作成。ステートマシンに登録するため。\n        self.states = list(set(self.states))\n\n    def get_state_transition_graph(self) -> Any:\n        # USE_GRAPHオプション使用時\n        # 状態遷移図をgraphvizのDigraphクラスで返す。\n        if self.USE_GRAPH:\n            return self.get_graph()  # type:ignore\n        else:\n            # print(\"use graph option is off\")\n            pass\n            return None\n\n    def save_state_transition_pngimg(self, output_filename) -> Any:\n        # USE_GRAPHオプション使用時\n        # 状態遷移図をpng形式で保存する。\n        if self.USE_GRAPH:\n            graph = self.get_graph()  # type:ignore\n            graph.attr('graph', rankdir=\"LR\", layout=\"dot\")\n            graph.format = \"png\"\n            graph.render(output_filename)\n            # return graph.render(output_filename)\n        else:\n            # print(\"use graph option is off\")\n            pass\n            return None\n\n    def view_state_transition(self) -> Any:\n        # USE_GRAPHオプション使用時\n        # 状態遷移図をodfで見る。\n        if self.USE_GRAPH:\n            return self.get_graph().view()  # type:ignore\n        else:\n            # print(\"use graph option is off\")\n            pass\n            return None\n\n    def is_valid_transition(self, trig) -> bool:\n        # 未定義の状態遷移を命令すると例外が出てしまう。\n        # 間違った状態遷移を指示した後も、止めずに処理を継続するには\n        # 事前確認が必要。\n        is_valid = False\n        for t in self.transitions:\n            if trig == t[\"trigger\"]:\n                source = t[\"source\"]\n                # print(len(source))\n                if isinstance(source, str):\n                    if self.state == source:  # type:ignore\n                        is_valid = True\n                else:\n                    if self.state in source:  # type:ignore\n                        is_valid = True\n        return is_valid\n\n    def get_previous_transition(self) -> Tuple[Optional[str], Optional[str], Optional[str]]:\n        # 直前に実行された遷移の情報(トリガー名、遷移元、遷移先)を返す。\n        if self.event_buf is not None:\n            source = self.event_buf.transition.source\n            dest = self.event_buf.transition.dest\n            trigger = self.event_buf.event.name\n            return trigger, source, dest\n        else:\n            return None, None, None\n\n    # ===============================================================================\n    # NOTE: 以下aoyama追記\n    # ===============================================================================\n\n    def current_state(self) -> str:\n        return self.state  # type:ignore\n\n    def transition(self, trig: str):\n        try:\n            self.trigger(trig)  # type:ignore\n            trigger, source, dest = self.get_previous_transition()\n            print(trigger, source, dest)\n        except Exception:\n            pass\n\n\nif __name__ == \"__main__\":\n    transition_csv = r\"./transition_demo.csv\"\n    stmach = StateMachine(transition_csv=transition_csv, initial_state=\"BOOT\",\n                          use_graph=False, show_transition=False)\n    # ステートマシンで定義した状態遷移を図示\n    stmach.view_state_transition()\n\n    # 状態の遷移はステートマシンのtriggerで実行する。\n    # 引数に実行したい遷移のトリガー名を入れる。\n    stmach.transition(\"TO_IDLING\")  # TO_IDLINGトリガーで定義された状態遷移を実行\n    stmach.transition(\"TO_INSPECT\")  # TO_INSPECTトリガーで定義された状態遷移を実行\n    stmach.transition(\"EXCEPTION\")  # EXCEPTIONトリガーで定義された状態遷移を実行\n    stmach.transition(\"RESET\")  # RESETトリガーで定義された状態遷移を実行\n    # 上記はBOOT => IDLING => INSPECTION => ERROR => BOOTの遷移になる。\n",
        "transition_demo.csv": "Unsupported file type",
        "_version.py": "# Definition of the version number\nimport os\nfrom io import open as io_open\n\n__all__ = [\"__version__\"]\n\n\n# PEP0440 compatible formatted version, see:\n# https://www.python.org/dev/peps/pep-0440/\n#\n# Generic release markers:\n#   X.Y.0   # For first release after an increment in Y\n#   X.Y.Z   # For bugfix releases\n#\n# Admissible pre-release markers:\n#   X.Y.ZaN   # Alpha release\n#   X.Y.ZbN   # Beta release\n#   X.Y.ZrcN  # Release Candidate\n#   X.Y.Z     # Final release\n#\n# Dev branch marker is: 'X.Y.dev' or 'X.Y.devN' where N is an integer.\n# 'X.Y.dev0' is the canonical version of 'X.Y.dev'\n#\n\nver_major = '1'\nver_minor = '0'\nver_patch = '1'\n\n# major, minor, patch, -extra\nversion_info = ver_major, ver_minor, ver_patch\n\n# Nice string for the version\n__version__ = '.'.join(map(str, version_info))\n\n\n# auto -extra based on commit hash (if not tagged as release)\nscriptdir = os.path.dirname(__file__)\ngitdir = os.path.abspath(os.path.join(scriptdir, \"..\", \".git\"))\nif os.path.isdir(gitdir):  # pragma: nocover\n    extra = None\n    # Open config file to check if we are in tqdm project\n    with io_open(os.path.join(gitdir, \"config\"), 'r') as fh_config:\n        if 'tqdm' in fh_config.read():\n            # Open the HEAD file\n            with io_open(os.path.join(gitdir, \"HEAD\"), 'r') as fh_head:\n                extra = fh_head.readline().strip()\n            # in a branch => HEAD points to file containing last commit\n            if 'ref:' in extra:\n                # reference file path\n                ref_file = extra[5:]\n                branch_name = ref_file.rsplit('/', 1)[-1]\n\n                ref_file_path = os.path.abspath(os.path.join(gitdir, ref_file))\n                # check that we are in git folder\n                # (by stripping the git folder from the ref file path)\n                if os.path.relpath(\n                        ref_file_path, gitdir).replace('\\\\', '/') != ref_file:\n                    # out of git folder\n                    extra = None\n                else:\n                    # open the ref file\n                    with io_open(ref_file_path, 'r') as fh_branch:\n                        commit_hash = fh_branch.readline().strip()\n                        extra = commit_hash[:8]\n                        if branch_name != \"master\":\n                            extra += '.' + branch_name\n\n            # detached HEAD mode, already have commit hash\n            else:\n                extra = extra[:8]\n\n    # Append commit hash (and branch) to version string if not tagged\n    if extra is not None:\n        try:\n            with io_open(os.path.join(gitdir, \"refs\", \"tags\",\n                                      'v' + __version__)) as fdv:\n                if fdv.readline().strip()[:8] != extra[:8]:\n                    __version__ += '-' + extra\n        except Exception as e:\n            if \"No such file\" not in str(e):\n                raise\n",
        "__init__.py": "from .state_machine import StateMachine\n"
    },
    "vast-vision-nocode-tool-analysis\\vastlib\\_utils\\usb": {
        "capacity_checker.py": "# ===============================================================================\n# Name      : capacity_checker.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2022-12-26 14:52\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport shutil\n# import sys\nimport datetime\nimport subprocess\nimport os\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass CapacityChecker:\n    def __init__(self, usb_mount_dir: str, img_dir: str):\n        self.gb = 1073741824  # 1GB\n        self.delete_threshold = 1073741824  # 1GB\n        self.year_format = '%Y'\n        self.month_format = '%Y-%m'\n        self.day_format = '%Y-%m-%d'\n        self.usb_mount_dir = usb_mount_dir\n        self.img_dir = img_dir\n\n    def capacity_check(self):\n        # NOTE: USBマウント先のフォルダがあるか確認\n        if not os.path.exists(self.usb_mount_dir):\n            return False\n\n        # NOTE: フォルダがUSBにマウントされているか確認\n        mount_cmd = f\"mountpoint -q {self.usb_mount_dir}; echo $?\"\n        mount_flag = int(\n            (subprocess.Popen(mount_cmd, stdout=subprocess.PIPE, shell=True).communicate()[0]).decode(\"utf-8\"))\n\n        if mount_flag != 0:\n            return False\n\n        # NOTE: ストレージの情報を取得（byte）\n        total, used, free = shutil.disk_usage(self.usb_mount_dir)\n        logger.info(f'Free memory: {round(free/self.gb, 3)}GB')\n\n        if free < self.delete_threshold:\n            self.delete_oldfile(self.img_dir)\n\n        return True\n\n    def folder_check(self, target_dir: str, dateformat: str):\n        date_list = []\n        folder_list = os.listdir(target_dir)\n        for folder in folder_list:\n            try:\n                date_data = datetime.datetime.strptime(folder, dateformat)\n                date_list.append(date_data)\n            except Exception as e:\n                logger.error(str(e))\n        # NOTE: there is no year folder\n        if len(date_list) == 0:\n            return False, None\n        else:\n            if date_list == []:\n                return False, None\n            else:\n                return True, min(date_list)\n\n    def delete_oldfile(self, target_dir: str):\n        year: datetime.date\n        month: datetime.date\n        day: datetime.date\n\n        if os.path.exists(target_dir):\n\n            success, year = self.folder_check(target_dir=target_dir,\n                                              dateformat=self.year_format)\n\n            if success:\n                if year is None:\n                    return -1\n            else:\n                logger.info(f'{target_dir} is empty')\n                return -1\n\n            month_dir = f'{target_dir}{year.strftime(self.year_format)}'\n\n            success, month = self.folder_check(target_dir=month_dir,\n                                               dateformat=self.month_format)\n            if success:\n                if month is None:\n                    return -1\n            else:\n                logger.info(f'{month_dir} is empty')\n                shutil.rmtree(f'{target_dir}{year.strftime(self.year_format)}')\n                return -1\n\n            day_dir = f'{target_dir}{month.strftime(self.year_format)}/{month.strftime(self.month_format)}'\n\n            success, day = self.folder_check(target_dir=day_dir,\n                                             dateformat=self.day_format)\n\n            if success:\n                if day is None:\n                    return -1\n            else:\n                logger.info(f'{day_dir} is empty')\n                shutil.rmtree(f'{target_dir}{month.strftime(self.year_format)}/{month.strftime(self.month_format)}')\n                return -1\n\n            # NOTE: 最も古いフォルダを削除\n            delete_folder_name = \\\n                f'{target_dir}{day.strftime(self.year_format)}/{day.strftime(self.month_format)}/{day.strftime(self.day_format)}'\n\n            try:\n                shutil.rmtree(delete_folder_name)\n                logger.info(f'Deleted: {delete_folder_name}')\n            except Exception as e:\n                logger.error(str(e))\n\n            # NOTE: 月フォルダが空になった場合削除\n            success, _ = self.folder_check(target_dir=day_dir,\n                                           dateformat=self.month_format)\n            if success:\n                pass\n            else:\n                shutil.rmtree(f'{target_dir}{month.strftime(self.year_format)}/{month.strftime(self.month_format)}')\n\n            # NOTE: 年フォルダが空になった場合削除\n            success, _ = self.folder_check(target_dir=month_dir,\n                                           dateformat=self.year_format)\n            if success:\n                pass\n            else:\n                shutil.rmtree(f'{target_dir}{year.strftime(self.year_format)}')\n\n        return 0\n\n\nif __name__ == \"__main__\":\n    cc = CapacityChecker()\n    cc.capacity_check()\n",
        "code_reader copy.py": "# ===============================================================================\n# Name      : code_reader.py\n# Version   : 1.0.0\n# Brief     :\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\n\n\"\"\"\n\n    必要なライブラリ(on raspberry pi)\n    sudo apt install libzbar0\n    sudo apt install libdmtx0 or libdmtx0b\n    pip install pyzbar == 0.1.8\n    pip install pylibdtmx == 0.1.9\n\n    # NOTE: 使い方\n    image = capture()\n    # NOTE: QRCode\n    success, data, code_img = CodeReader.read_qrcode()\n    # NOTE: DataMatrix\n    success, data, code_img = CodeReader.read_datamatrix()\n    \n    print(data)\n\"\"\"\n\nimport cv2\nimport numpy as np\n# import qrcode\nfrom pyzbar.pyzbar import decode as zbar_decode\n# from pyzbar.pyzbar import ZBarSymbol\nfrom pylibdmtx.pylibdmtx import encode as dmtx_encode\nfrom pylibdmtx.pylibdmtx import decode as dmtx_decode\nfrom PIL import Image\n# import time\nimport threading\nimport queue\nimport math\n# BARCODE_TYPE = ['EAN13','UPCA','UPCE','EAN8','CODE128','CODE39']\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\ndef imshow(src):\n    cv2.imshow(\"barcode\", src)\n    cv2.waitKey(0)\n\n\nclass CR_Daemon(threading.Thread):\n    def __init__(self, frame=None, result_queue=None):\n        super().__init__()\n        self.daemon = True\n        self.frame = frame\n        self.result_queue = result_queue\n\n    def run(self):\n        # maxcount 1\n        self.result_queue.put(dmtx_decode(self.frame, max_count=1))\n\n\ndef decode_datamatrix(frame, timeout=5):\n    res_queue: queue.Queue = queue.Queue()\n    CR_Daemon(frame=frame, result_queue=res_queue).start()\n    try:\n        return res_queue.get(block=True, timeout=timeout)\n    except queue.Empty:\n        logger.info(f'Timeout: {timeout:2f}[sec]')\n        return None\n\n\ndef rot(centerPoint, angle, X_Mat):\n    [xc, yc] = centerPoint\n    dr = angle * math.pi / 180\n\n    # 回転行列\n    R_Mat = np.array([[math.cos(dr), -math.sin(dr), xc - xc * math.cos(dr) + yc * math.sin(dr)],\n                      [math.sin(dr), math.cos(dr), yc - xc * math.sin(dr) - yc * math.cos(dr)]])\n    # [0, 0, 1]])\n    Y_Mat = np.dot(R_Mat, X_Mat)\n\n    return Y_Mat\n\n\ndef calc_polygon(rect, img_size):\n    (width, height) = img_size\n    asp = [1, 1]\n    # 対角線\n    diagonal_square = rect.height**2 + rect.width**2\n    # 一辺\n    short_length = int(math.sqrt(diagonal_square / (1.0 + (asp[1] / asp[0])**2)))\n    long_length = int(short_length * (asp[1] / asp[0]))\n    angle = math.atan(rect.height / rect.width) * 180 / math.pi\n    angle_bias = math.atan((asp[0] / asp[1])) * 180 / math.pi\n    angle = int(angle - angle_bias)\n    (xmin, ymin, xmax, ymax) = (\n        int(rect.left),\n        int(height - rect.top - rect.height),\n        int(rect.left + rect.width),\n        int(height - rect.top)\n    )\n    [xc, yc] = [int((xmin + xmax) / 2), int((ymin + ymax) / 2)]\n    xmin, ymin, xmax, ymax = int(xc - long_length / 2), \\\n        int(yc - short_length / 2), \\\n        int(xc + long_length / 2), \\\n        int(yc + short_length / 2)\n    xmat = np.array([[xmin, ymin, 1], [xmin, ymax, 1], [xmax, ymax, 1], [xmax, ymin, 1]]).T\n    ymat = rot([xc, yc], -angle, xmat)\n    pts = ymat.T.astype(np.int32)\n    return pts\n\n\ndef text_decoder(data: bytes):\n    try:\n        text = data.decode('utf-8')\n    except UnicodeDecodeError:\n        text = data.decode('shift-jis')\n    except Exception as e:\n        logger.error(str(e))\n        text = 'Decode Error'\n    return text\n\n\ndef contrast_enhancement_filter(image: np.ndarray):\n    proc_image = image.copy()\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n    proc_image = clahe.apply(proc_image)\n    return proc_image\n\n\ndef check_roi(img: np.ndarray, r_data: list) -> bool:\n    height, width = img.shape[:2]\n    if r_data[0] < 0 or r_data[2] > height:\n        return False\n    elif r_data[1] < 0 or r_data[3] > width:\n        return False\n    else:\n        return True\n\n\ndef crop_roi(img: np.ndarray, r_data: list) -> np.ndarray:\n    roi = img[r_data[0]:r_data[2], r_data[1]:r_data[3]]\n    return roi\n\n\ndef insert_roi(img: np.ndarray, roi: np.ndarray, r_data: list) -> np.ndarray:\n    img[r_data[0]:r_data[2], r_data[1]:r_data[3]] = roi\n    dst = cv2.rectangle(img, pt1=(r_data[1], r_data[0]),\n                        pt2=(r_data[3], r_data[2]),\n                        color=(200, 200, 50),\n                        thickness=3)\n    logger.info(dst.shape)\n    return dst\n\n\nclass ThreadWithResult(threading.Thread):\n    def __init__(self, group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None):\n        def function():\n            self.success, self.data, self.dst = target(*args, **kwargs)\n        super().__init__(group=group, target=function, name=name, daemon=daemon)\n\n\nclass CodeReader:\n\n    def read_code(self, img: np.ndarray):\n        thread_bar = ThreadWithResult(target=CodeReader.read_barcode, args=(img,))\n        thread_qr = ThreadWithResult(target=CodeReader.read_qrcode, args=(img,))\n        thread_mtx = ThreadWithResult(target=CodeReader.read_datamatrix, args=(img,))\n        thread_bar.start()\n        thread_qr.start()\n        thread_mtx.start()\n        thread_bar.join()\n        thread_qr.join()\n        thread_mtx.join()\n\n        if thread_bar.success:\n            return thread_bar.success, thread_bar.data, thread_bar.dst\n        elif thread_qr.success:\n            return thread_qr.success, thread_qr.data, thread_qr.dst\n        elif thread_mtx.success:\n            return thread_mtx.success, thread_mtx.data, thread_mtx.dst\n        else:\n            return False, [{'TEXT': ''}], None\n\n    @staticmethod\n    def read_barcode(img: np.ndarray, roi_data: list = None):\n        origi_img = img.copy()\n        code_img = img.copy()\n\n        if roi_data is not None:\n            s = check_roi(code_img, roi_data)\n            if not s:\n                return False, [{'TEXT': 'ROI is out of range'}], code_img\n            code_img = crop_roi(code_img, roi_data)\n\n        if code_img.ndim == 3:\n            code_img = cv2.cvtColor(code_img, cv2.COLOR_BGR2GRAY)\n        else:\n            origi_img = cv2.cvtColor(origi_img, cv2.COLOR_GRAY2BGR)\n\n        codes = zbar_decode(code_img)\n        if not(codes):\n            codes = zbar_decode(contrast_enhancement_filter(code_img))\n\n        code_img = cv2.cvtColor(code_img, cv2.COLOR_GRAY2BGR)\n\n        if codes:\n            barcodes = [code for code in codes if code.type != 'QRCODE']\n            if len(barcodes) != 0:\n                data = []\n                for barcode in barcodes:\n                    code_text = text_decoder(barcode.data)\n                    code_type = barcode.type\n                    code_polygon = barcode.polygon\n                    code_img = cv2.polylines(code_img, [np.array(code_polygon)], isClosed=True, color=(0, 255, 0), thickness=5)\n                    data.append({\n                        'TEXT': code_text,\n                        'TYPE': code_type,\n                        'POLYGON': code_polygon\n                    })\n                if roi_data is not None:\n                    code_img = insert_roi(origi_img, code_img, roi_data)\n                return True, data, code_img\n\n            else:\n                if roi_data is not None:\n                    code_img = insert_roi(origi_img, code_img, roi_data)\n                return False, [{'TEXT': ''}], None\n        else:\n            if roi_data is not None:\n                code_img = insert_roi(origi_img, code_img, roi_data)\n            return False, [{'TEXT': ''}], None\n\n    @staticmethod\n    def read_qrcode(img: np.ndarray, roi_data: list = None):\n        # from pyzbar.pyzbar import Decoded\n        # qrcode: Decoded\n        origi_img = img.copy()\n        code_img = img.copy()\n\n        if roi_data is not None:\n            s = check_roi(code_img, roi_data)\n            if not s:\n                return False, [{'TEXT': 'ROI is out of range'}], code_img\n            code_img = crop_roi(code_img, roi_data)\n\n        if code_img.ndim == 3:\n            code_img = cv2.cvtColor(code_img, cv2.COLOR_BGR2GRAY)\n        else:\n            origi_img = cv2.cvtColor(origi_img, cv2.COLOR_GRAY2BGR)\n\n        codes = zbar_decode(code_img)\n        if not(codes):\n            codes = zbar_decode(contrast_enhancement_filter(code_img))\n\n        code_img = cv2.cvtColor(code_img, cv2.COLOR_GRAY2BGR)\n\n        if codes:\n            qrcodes = [code for code in codes if code.type == 'QRCODE']\n            if len(qrcodes) != 0:\n                data = []\n                for qrcode in qrcodes:\n                    code_text = text_decoder(qrcode.data)\n                    code_type = qrcode.type\n                    code_polygon = qrcode.polygon\n                    code_img = cv2.polylines(code_img, [np.array(code_polygon)], isClosed=True, color=(0, 255, 0), thickness=5)\n                    data.append({\n                        'TEXT': code_text,\n                        'TYPE': code_type,\n                        'POLYGON': code_polygon\n                    })\n\n                if roi_data is not None:\n                    code_img = insert_roi(origi_img, code_img, roi_data)\n                return True, data, code_img\n\n            else:\n                if roi_data is not None:\n                    code_img = insert_roi(origi_img, code_img, roi_data)\n                return False, [{'TEXT': ''}], code_img\n        else:\n            if roi_data is not None:\n                code_img = insert_roi(origi_img, code_img, roi_data)\n            return False, [{'TEXT': ''}], code_img\n\n    @staticmethod\n    def read_datamatrix(img: np.ndarray, roi_data: list = None):\n        # from pylibdmtx.pylibdmtx import Decoded\n        # code: Decoded\n        origi_img = img.copy()\n        code_img = img.copy()\n\n        if roi_data is not None:\n            s = check_roi(code_img, roi_data)\n            if not s:\n                return False, [{'TEXT': 'ROI is out of range'}], code_img\n            code_img = crop_roi(code_img, roi_data)\n\n        if code_img.ndim == 3:\n            code_img = cv2.cvtColor(code_img, cv2.COLOR_BGR2GRAY)\n        else:\n            origi_img = cv2.cvtColor(origi_img, cv2.COLOR_GRAY2BGR)\n\n        codes = decode_datamatrix(code_img, timeout=0.2)\n        if not(codes):\n            codes = decode_datamatrix(contrast_enhancement_filter(code_img), timeout=0.2)\n\n        code_img = cv2.cvtColor(code_img, cv2.COLOR_GRAY2BGR)\n\n        if codes:\n            h, w = code_img.shape[:2]\n            data = []\n            # logger.info(codes)\n            for code in codes:\n                # logger.info(code)\n                code_text = text_decoder(code.data)\n                code_type = \"DATAMATRIX\"\n                code_polygon = calc_polygon(rect=code.rect, img_size=(w, h))\n                code_img = cv2.polylines(code_img, [np.array(code_polygon)], isClosed=True, color=(0, 255, 0), thickness=5)\n                data.append({\n                    'TEXT': code_text,\n                    'TYPE': code_type,\n                    'POLYGON': code_polygon\n                })\n            if roi_data is not None:\n                code_img = insert_roi(origi_img, code_img, roi_data)\n            return True, data, code_img\n        else:\n            if roi_data is not None:\n                code_img = insert_roi(origi_img, code_img, roi_data)\n            return False, [{'TEXT': ''}], code_img\n\n\nclass CodeCreator:\n    @staticmethod\n    def bit2cv(src):\n        new_image = np.array(src, dtype=np.uint8)\n        new_image = np.where(new_image == 1, 255, 0)\n        return new_image.astype(np.uint8)\n\n    @staticmethod\n    def pil2cv(src):\n        new_image = np.array(src, dtype=np.uint8)\n        if new_image.ndim == 2:\n            pass\n        elif new_image.shape[2] == 3:\n            new_image = new_image[:, :, ::-1]\n        elif new_image.shape[2] == 4:\n            new_image = new_image[:, :, [2, 1, 0, 3]]\n        return new_image\n\n    @staticmethod\n    def create_qrcode(code_txt):\n        import qrcode\n        qr = qrcode.QRCode(\n            version=1,\n            error_correction=qrcode.constants.ERROR_CORRECT_M,\n            box_size=5,  # default: 10 # セルの大きさ\n            border=0,  # default: 4 # 外枠の幅\n        )\n        qr.add_data(code_txt)\n        qr.make(fit=True)\n        img = qr.make_image()\n        # img.save('qrcode.jpg')\n        return CodeCreator.bit2cv(img)\n\n    @staticmethod\n    def create_datamatrix(code_txt, code_size='32x32'):\n        encoded = dmtx_encode(code_txt.encode('utf-8'), size=code_size)\n        code_img = Image.frombytes('RGB', (encoded.width, encoded.height), encoded.pixels)\n        return CodeCreator.pil2cv(code_img)\n",
        "code_reader.py": "# ===============================================================================\n# Name      : code_reader.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-12-06 15:17\n# Copyirght 2021 Hiroya Aoyama\n# ===============================================================================\n\"\"\"\n必要なライブラリ(on raspberry pi)\nsudo apt install libzbar0\nsudo apt install libdmtx0 or libdmtx0b\npip install pyzbar==0.1.9\npip install pylibdtmx==0.1.10\n\"\"\"\nimport cv2\nimport numpy as np\nimport traceback\nimport threading\nimport queue\n\nfrom pydantic import BaseModel\nfrom pyzbar.pyzbar import decode as zbar_decode\nfrom pylibdmtx.pylibdmtx import decode as dmtx_decode\nfrom typing import List, Union\n\ntry:\n    from logger import setup_logger\n    logger = setup_logger(__name__)\nexcept Exception:\n    from logging import getLogger\n    logger = getLogger(__name__)\n\n\nclass CodeInfo(BaseModel):\n    \"\"\"読取結果の返り値フォーマット\"\"\"\n    code_text: str = ''\n    code_type: str = ''\n    polygon: list = []\n\n\nclass CodeRect(BaseModel):\n    \"\"\"APIから返ってくるRect型の中身\"\"\"\n    left: int = 0\n    top: int = 0\n    width: int = 0\n    height: int = 0\n\n\nclass CodeReaderDaemon(threading.Thread):\n    \"\"\"APIのTimeoutが効かないので自作でTimeoutを実装\"\"\"\n\n    def __init__(self, frame: np.ndarray, result_queue: queue.Queue,\n                 *, code_type: str = 'QR'):\n        super().__init__()\n        self.daemon = True\n        self.frame = frame\n        self.result_queue = result_queue\n        self.code_type = code_type\n\n    def run(self) -> None:\n        if self.code_type == 'QR':\n            # NOTE: QRCode\n            self.result_queue.put(zbar_decode(self.frame))\n        else:\n            # NOTE: DataMatrix\n            self.result_queue.put(dmtx_decode(self.frame, max_count=1))\n\n\nclass CodeDecoder:\n    \"\"\"\n    コード読取の基底クラス\n    \"\"\"\n\n    def getErrorInfo(self) -> str:\n        \"\"\"エラートレース\"\"\"\n        traceback_info = traceback.format_exc()\n        return traceback_info\n\n    def checkKernelSize(self, k_size: int) -> int:\n        if k_size % 2 == 0:\n            k_size -= 1\n        if k_size < 3:\n            return 3\n        return k_size\n\n    def checkImageChannel(self, image: np.ndarray) -> np.ndarray:\n        \"\"\"\n        3チャンネルの画像をグレイスケールに変換\n        APIに入れるときはグレイスケールのため、チェックを実施\n        \"\"\"\n        if image.ndim == 3:\n            return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        return image\n\n    def emphasizeContrast(self, image: np.ndarray,\n                          grid_size: int = 8, thresh: float = 2.0) -> np.ndarray:\n        \"\"\"ヒストグラム平坦化\n\n        Args:\n            g_scale (np.ndarray): _description_\n            k_size (int, optional): _description_. Defaults to 8.\n            thresh (float, optional): _description_. Defaults to 2.0.\n\n        Returns:\n            np.ndarray: _description_\n        \"\"\"\n        image = self.checkImageChannel(image)\n        clahe = cv2.createCLAHE(clipLimit=thresh, tileGridSize=(grid_size, grid_size))\n        dst = clahe.apply(image)\n        return dst\n\n    def adaptiveThreshold(self, image: np.ndarray,\n                          *, k_size: int = -1, c_val: int = 10) -> np.ndarray:\n        \"\"\"適応的二値化\\n\n        k_sizeでぼかした画像と元画像の差分をとり、c_valで二値化\n\n        Args:\n            g_scale (np.ndarray): _description_\n            k_size (int, optional): _description_\n            c_val (int, optional): _description_\n\n        Returns:\n            np.ndarray: _description_\n        \"\"\"\n        h, w = image.shape[:2]\n        if k_size < 0:\n            # NOTE: 偶数であれば-1して奇数にする\n            k_size = int(min([h, w]) / 7)\n\n        k_size = self.checkKernelSize(k_size)\n\n        image = self.checkImageChannel(image)\n        dst = cv2.adaptiveThreshold(src=image,\n                                    maxValue=255,\n                                    adaptiveMethod=cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\n                                    thresholdType=cv2.THRESH_BINARY,\n                                    blockSize=k_size,\n                                    C=c_val)\n        return dst\n\n    def decodeText(self, data: bytes) -> str:\n        \"\"\"\n        テキストのデコード\n        shift-jis(主に日本語)だとdecodeでエラーが出るので例外処理追加\n        \"\"\"\n        try:\n            text = data.decode('utf-8')\n            return text\n        except UnicodeDecodeError:\n            text = data.decode('shift-jis')\n            return text\n        except Exception:\n            print(self.getErrorInfo())\n            return ''\n\n    def decodeDataMatrix(self,\n                         frame: np.ndarray,\n                         timeout: float = 1.0,\n                         use_daemon: bool = False) -> list:\n        \"\"\"Timeoutを実装したDatamatrixの読取\"\"\"\n\n        if use_daemon:\n            res_queue: queue.Queue = queue.Queue()\n            CodeReaderDaemon(frame=frame,\n                             result_queue=res_queue,\n                             code_type='DM').start()\n            try:\n                return res_queue.get(block=True, timeout=timeout)\n            except queue.Empty:\n                logger.info(f'Timeout: {timeout:2f}[sec]')\n                return []\n        else:\n            res = dmtx_decode(frame, max_count=1)\n            return res\n\n    def decodeQRCode(self, frame: np.ndarray,\n                     timeout: float = 1.0) -> list:\n        \"\"\"QRの方はただのwrapper\"\"\"\n        return zbar_decode(frame)\n\n    def calculateDiagonalCorners(self, rect: CodeRect, size: tuple) -> list:\n        \"\"\"対角二点を計算\"\"\"\n        height, _ = size\n        pt1 = (int(rect.left), int(height - rect.top))\n        pt2 = (int(rect.left + rect.width), int(height - rect.top - rect.height))\n        return [\n            (pt1[0], pt1[1]),\n            (pt2[0], pt2[1]),\n        ]\n\n    def calculateSquareCorners(self, rect: CodeRect, size: tuple) -> list:\n        \"\"\"DataMatrixの方は角4点の座標が返ってこないので自力で計算\"\"\"\n        height, _ = size\n        pt1 = (int(rect.left), int(height - rect.top))\n        pt2 = (int(rect.left + rect.width), int(height - rect.top - rect.height))\n\n        center_x = (pt1[0] + pt2[0]) / 2\n        center_y = (pt1[1] + pt2[1]) / 2\n        dx, dy = (pt2[0] - pt1[0]), (pt2[1] - pt1[1])\n        diagonal_length = np.sqrt(dx ** 2 + dy ** 2)\n        radius = diagonal_length / 2\n        unit_vector = (dx / diagonal_length, dy / diagonal_length)\n        normal_vector = (int(-unit_vector[1] * radius), int(unit_vector[0] * radius))\n\n        return [\n            (pt1[0], pt1[1]),\n            (int(center_x + normal_vector[0]), int(center_y + normal_vector[1])),\n            (pt2[0], pt2[1]),\n            (int(center_x - normal_vector[0]), int(center_y - normal_vector[1]))\n        ]\n\n    def drawPolygon(self, img: np.ndarray, polygon: Union[list, np.ndarray], *,\n                    thickness: int = 2, color: tuple = (0, 255, 0)) -> np.ndarray:\n        \"\"\"ポリゴン描画\"\"\"\n        polygon_ = [[round(pt[0]), round(pt[1])] for pt in polygon]\n        img = cv2.polylines(img=img, pts=[np.array(polygon_)],\n                            isClosed=True, color=color, thickness=thickness)\n        return img\n\n    def drawCodePosition(self, image: np.ndarray, c_info_l: List[CodeInfo]) -> np.ndarray:\n        \"\"\"コードの検出位置を描画\"\"\"\n        dst = image.copy()\n        for c_info in c_info_l:\n            dst = self.drawPolygon(dst, polygon=c_info.polygon, thickness=3)\n        return dst\n\n\nclass QRCodeReader(CodeDecoder):\n    \"\"\"\n    QRコードの読み取りクラス\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def _read(self, frame: np.ndarray) -> List[CodeInfo]:\n        \"\"\"QRコードの読み取り\"\"\"\n        image = frame.copy()\n        # NOTE: 入力チェック\n        image = self.checkImageChannel(image)\n        # NOTE: 読取\n        codes = self.decodeQRCode(image)\n        if not codes:\n            return []\n\n        # NOTE: バーコードも読取対象に入っているのでフィルタ\n        qrcodes = [code for code in codes if code.type == 'QRCODE']\n\n        if not qrcodes:\n            return []\n\n        data: List[CodeInfo] = []\n\n        for code_ in qrcodes:\n            code_text = self.decodeText(code_.data)\n            data.append(CodeInfo(code_text=code_text,\n                                 code_type=code_.type,\n                                 polygon=code_.polygon.copy()))\n        return data\n\n    def read(self, frame: np.ndarray) -> List[CodeInfo]:\n        \"\"\"\n        QRの読み取り\n        読取失敗したら色んな前処理をしてリトライする\n        \"\"\"\n        image = frame.copy()\n        res = self._read(image)\n        if res:\n            # NOTE: コードが見つかれば返す\n            return res\n\n        # NOTE: コントラスト強調でリトライ\n        img_1 = self.emphasizeContrast(image)\n        res = self._read(img_1)\n        if res:\n            # NOTE: コードが見つかれば返す\n            return res\n\n        # NOTE: 適応的二値化でリトライ\n        img_1 = self.adaptiveThreshold(image)\n        res = self._read(img_1)\n        if res:\n            # NOTE: コードが見つかれば返す\n            return res\n        return []\n\n\nclass DataMatrixReader(CodeDecoder):\n    \"\"\"\n    データマトリクスの読み取りクラス\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def _read(self, frame: np.ndarray) -> List[CodeInfo]:\n        \"\"\"データマトリクスの読み取り\"\"\"\n        image = frame.copy()\n        # NOTE: 入力チェック\n        image = self.checkImageChannel(image)\n        # NOTE: 読取\n        dmtxs = self.decodeDataMatrix(image, timeout=1.0)\n\n        if not dmtxs:\n            return []\n\n        data: List[CodeInfo] = []\n\n        for code_ in dmtxs:\n            code_text = self.decodeText(code_.data)\n            # code_polygon = self.calculateSquareCorners(rect=code_.rect,\n            #                                            size=image.shape[:2])\n            code_polygon = self.calculateDiagonalCorners(rect=code_.rect,\n                                                         size=image.shape[:2])\n            data.append(CodeInfo(code_text=code_text,\n                                 code_type='DataMatrix',\n                                 polygon=code_polygon.copy()))\n        return data\n\n    def read(self, frame: np.ndarray) -> List[CodeInfo]:\n        \"\"\"\n        DataMatrixの読み取り\n        読取失敗したら色んな前処理をしてリトライする\n        \"\"\"\n        image = frame.copy()\n        res = self._read(image)\n        if res:\n            # NOTE: コードが見つかれば返す\n            return res\n\n        # NOTE: コントラスト強調でリトライ\n        img_1 = self.emphasizeContrast(image)\n        res = self._read(img_1)\n        if res:\n            # NOTE: コードが見つかれば返す\n            return res\n\n        # NOTE: 適応的二値化でリトライ\n        img_1 = self.adaptiveThreshold(image)\n        res = self._read(img_1)\n        if res:\n            # NOTE: コードが見つかれば返す\n            return res\n        return []\n\n\nif __name__ == '__main__':\n    \"\"\"\n    テストコード\n    \"\"\"\n    def imshow(src: np.ndarray) -> None:\n        import matplotlib.pyplot as plt\n        if src.ndim == 3:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_BGR2RGB))  # type: ignore\n            plt.show()\n        else:\n            plt.imshow(cv2.cvtColor(src, cv2.COLOR_GRAY2RGB))  # type: ignore\n            plt.show()\n\n    def rotate_image(src: np.ndarray, angle: float) -> np.ndarray:\n        h, w = src.shape[:2]\n        if h == 0 or w == 0:\n            logger.error('Image has zero Dimention')\n\n        trans = cv2.getRotationMatrix2D(center=(int(w / 2), int(h / 2)),\n                                        angle=angle, scale=1)\n\n        img = cv2.warpAffine(src, trans, (w, h))\n\n        return img\n\n    # qr = QRCodeReader()\n    dmtx = DataMatrixReader()\n    image = cv2.imread(r'C:\\Users\\J100048001\\Desktop\\dmtx4.jpg')\n    image = rotate_image(image, 10)\n    image = dmtx.emphasizeContrast(image)\n    imshow(image)\n    # qr_res = qr.read(image)\n    dm_res = dmtx.read(image)\n    print(dm_res)\n\n    # qr_img = qr.drawCodePosition(image, qr_res)\n    dm_img = dmtx.drawCodePosition(image, dm_res)\n\n    imshow(dm_img)\n",
        "notice.png": "Unsupported file type",
        "usb.png": "Unsupported file type",
        "usb_handler.py": "# ===============================================================================\n# Name      : usb_handler.py\n# Version   : 1.0.0\n# Brief     :\n# Time-stamp: 2023-02-21 14:28\n# Copyirght 2021 Hiroya Aoyama [aoyama.hiroya@nidec.com]\n# ===============================================================================\nimport os\nimport subprocess\nimport time\nimport glob\nfrom typing import Tuple\n\nHOST_NAME = os.getlogin()\n\n# NOTE: usbmountがinstall済み\n# USB_MOUNT_DIR = '/media/usb/'\n# NOTE: 違う場合\n# USB_MOUNT_DIR = os.path.join('/media', HOST_NAME)\nUSB_MOUNT_DIR = '/media/'\n\n# NOTE: ラズパイ以外で使用する場合はここを変えてください（linux限定）\nPLATFORM_CODE = 'platform-fd500000.pcie-pci-0000:01:00.0-usb-'\nMEMORY_HEADER = '/dev/disk/by-path/'\nMEMORY_FOOTER = '-scsi-0:0:0:0-part1'\nCAMERA_HEADER = '/dev/v4l/by-path/'\nCAMERA_FOOTER = '-video-index0'\n\n# NOTE: 参照URL\n# https://access.redhat.com/documentation/ja-jp/red_hat_enterprise_linux/7/html/storage_administration_guide/persistent_naming-udev\n# https://www.express.nec.co.jp/linux/distributions/confirm/hba/udev/udev_rules_details_rh.html\n\n\n# NOTE: udevパスを取得\ndef get_udev_path() -> Tuple[bool, str]:\n    path_key = MEMORY_HEADER + PLATFORM_CODE + '*'\n    files = glob.glob(path_key)\n\n    if len(files) == 0:\n        return False, ''\n\n    # NOTE: footerが一致するpathを探索\n    filepath = [s for s in files if s.endswith(MEMORY_FOOTER)]\n    if len(filepath) == 0:\n        return False, ''\n\n    # NOTE: 最初に見つかったudevを返す\n    return True, filepath[0]\n\n\n# NOTE: 指定のusbポートか確認\ndef check_usb_port(udev_path: str, port: int) -> bool:\n    if udev_path == '':\n        return False\n\n    # NOTE: port番号以外を除去\n    s = str(udev_path)\n    s = s.replace(MEMORY_HEADER, '')\n    s = s.replace(MEMORY_FOOTER, '')\n    s = s.replace(PLATFORM_CODE, '')\n    s_list = s.split(':')\n\n    # NOTE: ポート番号が残っていれば\n    try:\n        port_id = s_list[2][0]\n    except Exception:\n        return False\n\n    # NOTE: ポート番号が一致していればTrue\n    if int(port_id) == port:\n        return True\n\n    return False\n\n\n# NOTE: udevの情報からdevice名を取得\ndef extract_udev_info(src: str, *, dataname: str = \"DEVNAME\") -> Tuple[bool, str]:\n    if src == '':\n        return False, ''\n\n    # NOTE: DEVNAMEの行を抽出\n    data_list = src.split(\"\\n\")\n    data = ''.join([s for s in data_list if dataname in s])\n    if data == '':\n        return False, ''\n\n    # NOTE: DEVNAMEを抽出\n    device_path = data.split(\"=\")[1]\n    return True, device_path\n\n\n# NOTE: udevの情報からdevice名を取得\ndef get_device_path(udev_path: str) -> Tuple[bool, str]:\n    result = subprocess.run(\n        [\"udevadm\", \"info\", udev_path],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n    ret, device_path = extract_udev_info(\n        src=result.stdout.decode(),\n        dataname=\"DEVNAME\"\n    )\n    return ret, device_path\n\n\n# NOTE: udevとdeviceのpathを取得\ndef get_usb_info() -> Tuple[bool, str, str]:\n    ret, udev_path = get_udev_path()\n    if not ret:\n        return False, 'udev path is not found', ''\n\n    ret, device_path = get_device_path(udev_path)\n\n    if not ret:\n        return False, 'device path is not found', ''\n\n    return True, udev_path, device_path\n\n\n# NOTE: usbがマウントされているか確認\ndef check_usb_mount() -> bool:\n    mount_cmd = f\"mountpoint -q {USB_MOUNT_DIR}; echo $?\"\n    mount_flag = int((\n        subprocess.Popen(mount_cmd, stdout=subprocess.PIPE, shell=True).communicate()[0]).decode(\"utf-8\"))\n    # NOTE: 1であればUSBが挿入されていない\n    if mount_flag == 1:\n        return False\n    return True\n\n\n# NOTE: usbをマウント\ndef mount_usb(device_path: str, target_m_point: str = USB_MOUNT_DIR,\n              timeout=500) -> bool:\n\n    inserted = check_usb_mount()\n    if inserted:\n        return True\n\n    # NOTE: 一旦アンマウント\n    command = ['sudo', 'umount', device_path]\n    _ = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    # NOTE: マウントコマンド\n    command = ['sudo', 'mount', device_path, target_m_point]\n\n    # NOTE: timeout 計測\n    time_s = time.perf_counter()\n    time_counter = 0.0\n    success = False\n    while time_counter < timeout:\n        ret = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        if ret.returncode == 0:\n            success = True\n            break\n        time_counter = int((time.perf_counter() - time_s) * 1000)\n\n    return success\n\n\n# NOTE: usbをアンマウント\ndef umount_usb(udev_path: str, timeout=500) -> bool:\n    inserted = check_usb_mount()\n    if not inserted:\n        return True\n\n    success = False\n    time_s = time.perf_counter()\n    time_counter = 0.0\n    while time_counter < timeout:\n        command = ['sudo', 'umount', udev_path]\n        ret = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        if ret.returncode == 0:\n            success = True\n            break\n        time_counter = int((time.perf_counter() - time_s) * 1000)\n\n    return success\n\n\ndef do_sync() -> None:\n    if os.name == 'nt':\n        command = 'sync'\n        subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    else:\n        os.sync()  # type: ignore\n\n\nclass USBHandler:\n    def __init__(self):\n        pass\n\n    def check_insert(self) -> bool:\n        ret, udev, dev = get_usb_info()\n        if not ret:\n            return False\n        self.udev_path = udev\n        self.device_path = dev\n        return True\n\n    def check_mount(self) -> bool:\n        return check_usb_mount()\n\n    def mount(self) -> bool:\n        return mount_usb(device_path=self.device_path,\n                         target_m_point=USB_MOUNT_DIR,\n                         timeout=500)\n\n    def umount(self) -> bool:\n        return umount_usb(udev_path=self.udev_path,\n                          timeout=500)\n\n    def sync(self) -> None:\n        do_sync()\n\n\nif __name__ == '__main__':\n    ret, udev_path, device_path = get_usb_info()\n    if not ret:\n        print(udev_path)\n\n    ret = mount_usb(device_path, USB_MOUNT_DIR, 500)\n\n    path = os.path.join(USB_MOUNT_DIR, 'test/uesr.txt')\n    f = open(path, 'w')\n    f.write('')\n    f.close()\n    # ret = umount_usb(udev_path, 500)\n    do_sync()\n"
    }
}