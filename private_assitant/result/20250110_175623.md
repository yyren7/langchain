# Dialogue History

**System:** #!/usr/bin/env python
# -*- coding: utf-8 -*-

# \~chinese 设备类型定义    \~english Device Type Definition
MV_UNKNOW_DEVICE                             = 0x00000000  # < \~chinese 未知设备类型，保留意义       \~english Unknown Device Type, Reserved
MV_GIGE_DEVICE                               = 0x00000001  # < \~chinese GigE设备                     \~english GigE Device
MV_1394_DEVICE                               = 0x00000002  # < \~chinese 1394-a/b 设备                \~english 1394-a/b Device
MV_USB_DEVICE                                = 0x00000004  # < \~chinese USB 设备                     \~english USB Device
MV_CAMERALINK_DEVICE                         = 0x00000008  # < \~chinese CameraLink设备               \~english CameraLink Device
MV_VIR_GIGE_DEVICE                           = 0x00000010  # < \~chinese 虚拟GigE设备               \~english Virtual GigE Device
MV_VIR_USB_DEVICE                            = 0x00000020  # < \~chinese 虚拟USB设备                \~english Virtual USB Device
MV_GENTL_GIGE_DEVICE                         = 0x00000040  # < \~chinese 自研网卡下GigE设备          \~english GenTL GigE Device
MV_GENTL_CAMERALINK_DEVICE                   = 0x00000080  # < \~chinese CameraLink设备            \~english GenTL CameraLink Device
MV_GENTL_CXP_DEVICE                          = 0x00000100  # < \~chinese CoaXPress设备             \~english GenTL CoaXPress Device
MV_GENTL_XOF_DEVICE                          = 0x00000200  # < \~chinese XoF设备                   \~english GenTL XoF Device

# \~chinese 采集卡类型         \~english Interface type
MV_GIGE_INTERFACE                    = 0x00000001          # < \~chinese GigE Vision采集卡        \~english GigE Vision interface
MV_CAMERALINK_INTERFACE              = 0x00000004          # < \~chinese Camera Link采集卡        \~english Camera Link interface
MV_CXP_INTERFACE                     = 0x00000008          # < \~chinese CoaXPress采集卡          \~english CoaXPress interface
MV_XOF_INTERFACE                     = 0x00000010          # < \~chinese XoFLink采集卡            \~english XoFLink interface

INFO_MAX_BUFFER_SIZE                         = 64          # < \~chinese 最大的数据信息大小           \~english Maximum data information size

MV_MAX_TLS_NUM                               = 8           # < \~chinese 最多支持的传输层实例个数     \~english The maximum number of supported transport layer instances
MV_MAX_DEVICE_NUM                            = 256         # < \~chinese 最大支持的设备个数           \~english The maximum number of supported devices

MV_MAX_INTERFACE_NUM                         = 64          #< \~chinese 最大支持的采集卡数量  \~english The maximum number of Frame Grabber interface supported

MV_MAX_SERIAL_PORT_NUM                       = 64          # \~chinese 最大支持的串口数量  \~english The maximum number of serial port supported

MV_MAX_GENTL_IF_NUM                          = 256         # < \~chinese 最大支持的GenTL数量          \~english The maximum number of GenTL supported
MV_MAX_GENTL_DEV_NUM                         = 256         # < \~chinese 最大支持的GenTL设备数量      \~english The maximum number of GenTL devices supported

# \~chinese 设备的访问模式    \~english Device Access Mode
# \~chinese 独占权限，其他APP只允许读CCP寄存器                        \~english Exclusive authority, other APP is only allowed to read the CCP register
MV_ACCESS_Exclusive                          = 1
# \~chinese 可以从5模式下抢占权限，然后以独占权限打开                 \~english You can seize the authority from the 5 mode, and then open with exclusive authority
MV_ACCESS_ExclusiveWithSwitch                = 2
# \~chinese 控制权限，其他APP允许读所有寄存器                         \~english Control authority, allows other APP reading all registers
MV_ACCESS_Control                            = 3
# \~chinese 可以从5的模式下抢占权限，然后以控制权限打开               \~english You can seize the authority from the 5 mode, and then open with control authority
MV_ACCESS_ControlWithSwitch                  = 4
# \~chinese 以可被抢占的控制权限打开                                  \~english Open with seized control authority
MV_ACCESS_ControlSwitchEnable                = 5
# \~chinese 可以从5的模式下抢占权限，然后以可被抢占的控制权限打开     \~english You can seize the authority from the 5 mode, and then open with seized control authority
MV_ACCESS_ControlSwitchEnableWithKey         = 6
# \~chinese 读模式打开设备，适用于控制权限下                          \~english Open with read mode and is available under control authority
MV_ACCESS_Monitor                            = 7

MV_MATCH_TYPE_NET_DETECT                     = 0x00000001  # < \~chinese 网络流量和丢包信息              \~english Network traffic and packet loss information
MV_MATCH_TYPE_USB_DETECT                     = 0x00000002  # < \~chinese host接收到来自U3V设备的字节总数 \~english The total number of bytes host received from U3V device

# \~chinese GigEVision IP配置    \~english GigEVision IP Configuration
MV_IP_CFG_STATIC                             = 0x05000000  # < \~chinese 静态         \~english Static
MV_IP_CFG_DHCP                               = 0x06000000  # < \~chinese DHCP         \~english DHCP
MV_IP_CFG_LLA                                = 0x04000000  # < \~chinese LLA          \~english LLA

# \~chinese GigEVision网络传输模式    \~english GigEVision Net Transfer Mode
MV_NET_TRANS_DRIVER                          = 0x00000001  # < \~chinese 驱动         \~english Driver
MV_NET_TRANS_SOCKET                          = 0x00000002  # < \~chinese Socket       \~english Socket

# \~chinese CameraLink波特率    \~english CameraLink Baud Rates (CLUINT32)
MV_CAML_BAUDRATE_9600                        = 0x00000001  # < \~chinese 9600         \~english 9600
MV_CAML_BAUDRATE_19200                       = 0x00000002  # < \~chinese 19200        \~english 19200
MV_CAML_BAUDRATE_38400                       = 0x00000004  # < \~chinese 38400        \~english 38400
MV_CAML_BAUDRATE_57600                       = 0x00000008  # < \~chinese 57600        \~english 57600
MV_CAML_BAUDRATE_115200                      = 0x00000010  # < \~chinese 115200       \~english 115200
MV_CAML_BAUDRATE_230400                      = 0x00000020  # < \~chinese 230400       \~english 230400
MV_CAML_BAUDRATE_460800                      = 0x00000040  # < \~chinese 460800       \~english 460800
MV_CAML_BAUDRATE_921600                      = 0x00000080  # < \~chinese 921600       \~english 921600
MV_CAML_BAUDRATE_AUTOMAX                     = 0x40000000  # < \~chinese 最大值       \~english Auto Max

# \~chinese 异常消息类型    \~english Exception message type
MV_EXCEPTION_DEV_DISCONNECT                  = 0x00008001  # < \~chinese 设备断开连接              \~english The device is disconnected
MV_EXCEPTION_VERSION_CHECK                   = 0x00008002  # < \~chinese SDK与驱动版本不匹配       \~english SDK does not match the driver version

MAX_EVENT_NAME_SIZE                          = 128         # < \~chinese 设备Event事件名称最大长度 \~english Max length of event name
MV_MAX_XML_SYMBOLIC_NUM                      = 64          # \~chinese 最大XML符号数               \~english Max XML Symbolic Number
MV_MAX_SYMBOLIC_LEN                          = 64          # \~chinese 最大枚举条目对应的符号长度     \~english Max Enum Entry Symbolic Number

MV_MAX_SPLIT_NUM                             = 8           # \~chinese 分时曝光时最多将源图像拆分的个数 \~english The maximum number of source image to be split in time-division exposure


**System:** # -*- coding: utf-8 -*-
# generated by 'xml2py'
# flags '-c -d -v C:\test_h\CameraParams.xml -o CameraParams_header.py'
from ctypes import *
from CameraParams_const import *
from PixelType_header import *

STRING = c_char_p

MV_PointCloudFile_Undefined = 0                  # < \~chinese 未定义的点云格式                  \~english Undefined point cloud format
MV_ACQ_MODE_CONTINUOUS = 2                       # < \~chinese 持续采集模式                      \~english Continuous Mode
MV_ACQ_MODE_MUTLI = 1                            # < \~chinese 多帧模式                          \~english Multi Mode
MV_TRIGGER_MODE_ON = 1                           # < \~chinese 打开                              \~english On
AM_CycleDetect = 6                               # < \~chinese 内部用于AccessMode循环检测         \~english used internally for AccessMode cycle detection
AM_Undefined = 5                                 # < \~chinese 对象未被初始化                     \~english Object is not yet initialized
AM_RW = 4                                        # < \~chinese 读和写                            \~english Read and Write
AM_RO = 3                                        # < \~chinese 只读                              \~english Read Only
AM_WO = 2                                        # < \~chinese 只写                              \~english Write Only
AM_NA = 1                                        # < \~chinese 不可用                            \~english Not available
AM_NI = 0                                        # < \~chinese 没有实现                          \~english Not implemented
MV_Image_Tif = 4                                 # < \~chinese Tif格式                           \~english Tif image file
MV_Image_Png = 3                                 # < \~chinese Png格式                           \~english Png image file
MV_Image_Jpeg = 2                                # < \~chinese Jpeg格式                          \~english Jpeg image file
MV_Image_Bmp = 1                                 # < \~chinese Bmp格式                           \~english Bmp image file
MV_GAIN_MODE_CONTINUOUS = 2                      # < \~chinese 连续                              \~english Gain Mode Continuous 
MV_GAIN_MODE_ONCE = 1                            # < \~chinese 单次                              \~english Gain Mode Once
MV_GrabStrategy_UpcomingImage = 3                # < \~chinese 等待下一帧图像                     \~english Wait for the next image
MV_GrabStrategy_LatestImages = 2                 # < \~chinese 获取列表中最新的图像               \~english Gets the latest image in the list
MV_GrabStrategy_LatestImagesOnly = 1             # < \~chinese 获取列表中最新的一帧图像（同时清除列表中的其余图像）         \~english Gets the most recent image in the list (while clearing the rest of the images in the list)
MV_PointCloudFile_OBJ = 3                        # < \~chinese OBJ点云格式                       \~english The point cloud format named OBJ
MV_PointCloudFile_CSV = 2                        # < \~chinese CSV点云格式                       \~english The point cloud format named CSV
MV_PointCloudFile_PLY = 1                        # < \~chinese PLY点云格式                       \~english The point cloud format named PLY
MV_ACQ_MODE_SINGLE = 0                           # < \~chinese 单帧模式                          \~english Single Mode
MV_TRIGGER_MODE_OFF = 0                          # < \~chinese 关闭                             \~english Off
MV_TRIGGER_SOURCE_SOFTWARE = 7                   # < \~chinese 软触发                           \~english Trigger source software
MV_EXPOSURE_MODE_TIMED = 0                       # < \~chinese 曝光超时模式                      \~english exposure mode timed
MV_FormatType_Undefined = 0                      # < \~chinese 未定义的格式类型                  \~english Undefined format type
MV_GAIN_MODE_OFF = 0                             # < \~chinese 关闭增益模式                     \~english Gain mode off
MV_EXPOSURE_AUTO_MODE_CONTINUOUS = 2             # < \~chinese 自动连续曝光模式                 \~english Exposure auto mode continuous
MV_EXPOSURE_AUTO_MODE_ONCE = 1                   # < \~chinese 单次自动曝光模式                 \~english Exposure auto mode once
MV_EXPOSURE_AUTO_MODE_OFF = 0                    # < \~chinese 关闭自动曝光模式                 \~english Exposure auto mode off
IFT_IValue = 0                                   # < \~chinese IValue接口类型                  \~english IValue interface
MV_GrabStrategy_OneByOne = 0                     # < \~chinese 从旧到新一帧一帧的获取图像        \~english Frame by frame from old to new
MV_FormatType_AVI = 1                            # < \~chinese AVI视频格式                     \~english AVI format type
MV_GAMMA_SELECTOR_USER = 1                       # < \~chinese gamma选择项User                 \~english This enumeration selects the type of gamma to apply
IFT_IString = 6                                  # < \~chinese IString接口类型                 \~english IString interface
MV_BALANCEWHITE_AUTO_OFF = 0                     # < \~chinese 白平衡自动关闭                   \~english Balance white auto off
MV_GAMMA_SELECTOR_SRGB = 2                       # < \~chinese gamma选择项SRGB                 \~english This enumeration selects the type of gamma to apply
IFT_IPort = 11                                   # < \~chinese IPort接口类型                   \~english IPort interface
MV_BALANCEWHITE_AUTO_CONTINUOUS = 1              # < \~chinese 白平衡自动连续                   \~english Balance white auto continuous
IFT_IEnumEntry = 10                              # < \~chinese IEnumEntry接口类型              \~english IEnumEntry interface
IFT_ICategory = 8                                # < \~chinese ICategory接口类型               \~english ICategory interface
IFT_IRegister = 7                                # < \~chinese IRegister接口类型               \~english IRegister interface
MV_Image_Undefined = 0                           # < \~chinese 未定义的图像类型                 \~english Image undefined
IFT_IFloat = 5                                   # < \~chinese IFloat接口类型                  \~english IFloat interface
IFT_IEnumeration = 9                             # < \~chinese IEnumeration接口类型            \~english IEnumeration interface
IFT_ICommand = 4                                 # < \~chinese ICommand接口类型                \~english ICommand interface
IFT_IBoolean = 3                                 # < \~chinese IBoolean接口类型                \~english IBoolean interface
IFT_IInteger = 2                                 # < \~chinese IInteger接口类型                \~english IInteger interface
MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV = 65537 # < \~chinese 表示组播模式，但本实例不接收图像数据         \~english Multicast without receive data
IFT_IBase = 1                                    # < \~chinese IBase接口类型                             \~english IBase interface
MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV = 65536   # < \~chinese 表示设置了单播，但本实例不接收图像数据       \~english Unicast without receive data
MV_BALANCEWHITE_AUTO_ONCE = 2                    # < \~chinese 单次自动白平衡                             \~english Balance white auto once
MV_GIGE_TRANSTYPE_LIMITEDBROADCAST = 2           # < \~chinese 表示局域网内广播，暂不支持                  \~english Limited broadcast mode,not support
MV_GIGE_TRANSTYPE_MULTICAST = 1                  # < \~chinese 表示组播                                  \~english Multicast mode
MV_GIGE_TRANSTYPE_UNICAST = 0                    # < \~chinese 表示单播(默认)                            \~english Unicast mode(default)
MV_GIGE_TRANSTYPE_CAMERADEFINED = 4              # < \~chinese 表示从相机获取，暂不支持                   \~english Transtype from camera,not support
MV_GIGE_TRANSTYPE_SUBNETBROADCAST = 3            # < \~chinese 表示子网内广播，暂不支持                   \~english Subnet broadcast mode,not support
MV_EXPOSURE_MODE_TRIGGER_WIDTH = 1               # < \~chinese 曝光模式触发宽                            \~english Trigger width
MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT = 5       # < \~chinese 表示用户自定义应用端接收图像数据Port号      \~english User Defined Receive Data Port
MV_TRIGGER_SOURCE_FrequencyConverter = 8         # < \~chinese 触发源变频器                              \~english Trigger source frequency converter
MV_TRIGGER_SOURCE_COUNTER0 = 4                   # < \~chinese 触发源计数器                              \~english Trigger source conuter
MV_TRIGGER_SOURCE_LINE3 = 3                      # < \~chinese LINE3 触发源                             \~english Trigger source line3
MV_TRIGGER_SOURCE_LINE2 = 2                      # < \~chinese LINE2 触发源                             \~english Trigger source line2
MV_TRIGGER_SOURCE_LINE1 = 1                      # < \~chinese LINE1 触发源                             \~english Trigger source line1
MV_TRIGGER_SOURCE_LINE0 = 0                      # < \~chinese LINE0 触发源                             \~english Trigger source line0
SortMethod_SerialNumber = 0                      # < \~chinese 按序列号排序                     \~english Sorting by SerialNumber
SortMethod_UserID = 1                            # < \~chinese 按用户自定义名字排序             \~english Sorting by UserID
SortMethod_CurrentIP_ASC = 2                     # < \~chinese 按当前IP地址排序（升序）         \~english Sorting by current IP（Ascending）
SortMethod_CurrentIP_DESC = 3                    # < \~chinese 按当前IP地址排序（降序）         \~english Sorting by current IP（Descending）
MV_IMAGE_ROTATE_90 = 1                           # < \~chinese 旋转90度         \~english Rotate 90 degrees
MV_IMAGE_ROTATE_180 = 2                          # < \~chinese 旋转180度         \~english Rotate 180 degrees
MV_IMAGE_ROTATE_270 = 3                          # < \~chinese 旋转270度         \~english Rotate 270 degrees
MV_FLIP_VERTICAL = 1                             # < \~chinese 垂直翻转          \~english flip vertical
MV_FLIP_HORIZONTAL = 2                           # < \~chinese 水平翻转         \~english flip horizontal
MV_CC_GAMMA_TYPE_NONE = 0                        # < \~chinese 不启用                       \~english Disable
MV_CC_GAMMA_TYPE_VALUE = 1                       # < \~chinese Gamma值                      \~english Gamma value
MV_CC_GAMMA_TYPE_USER_CURVE = 2                  # < \~chinese Gamma曲线                    \~english Gamma curve
MV_CC_GAMMA_TYPE_LRGB2SRGB = 3                   # < \~chinese linear RGB to sRGB           \~english linear RGB to sRGB
MV_CC_GAMMA_TYPE_SRGB2LRGB = 4                   # < \~chinese sRGB to linear RGB(仅色彩插值时支持，色彩校正时无效) \~english sRGB to linear RGB
MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE = 0x4001   # < \~chinese 异常的图像，该帧被丢弃            \~english abnormal image,the frame is discarded
MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW = 0x4002    # < \~chinese 缓存列表溢出，清除最旧的一帧       \~english Cache list overflow, clear the oldest frame
MV_CC_STREAM_EXCEPTION_LIST_EMPTY = 0x4003       # < \~chinese 缓存列表为空，该帧被丢弃           \~english Cache list is empty,the frame is discarded
MV_CC_STREAM_EXCEPTION_RECONNECTION = 0x4004    # < \~chinese 断流恢复                         \~english reconnect
MV_CC_STREAM_EXCEPTION_DISCONNECTED = 0x4005    # < \~chinese 断流,恢复失败,取流被中止    \~english reconnect fail, stream is  terminated
MV_CC_STREAM_EXCEPTION_DEVICE = 0x4006          # < \~chinese 设备异常,取流被中止         \~english device exception
MV_SPLIT_BY_LINE = 1                            #< \~chinese 源图像按行拆分成多张图像         \~english Source image split into multiple images by line

int8_t = c_int8
int16_t = c_int16
int32_t = c_int32
int64_t = c_int64
uint8_t = c_uint8
uint16_t = c_uint16
uint32_t = c_uint32
uint64_t = c_uint64
int_least8_t = c_byte
int_least16_t = c_short
int_least32_t = c_int
int_least64_t = c_long
uint_least8_t = c_ubyte
uint_least16_t = c_ushort
uint_least32_t = c_uint
uint_least64_t = c_ulong
int_fast8_t = c_byte
int_fast16_t = c_long
int_fast32_t = c_long
int_fast64_t = c_long
uint_fast8_t = c_ubyte
uint_fast16_t = c_ulong
uint_fast32_t = c_ulong
uint_fast64_t = c_ulong
intptr_t = c_long
uintptr_t = c_ulong
intmax_t = c_long
uintmax_t = c_ulong

# GigE设备信息    \~english GigE device info
class _MV_GIGE_DEVICE_INFO_(Structure):
    pass
_MV_GIGE_DEVICE_INFO_._fields_ = [
    ('nIpCfgOption', c_uint),                     # < \~chinese IP配置选项         \~english Ip config option
    ('nIpCfgCurrent', c_uint),                    # < \~chinese 当前IP地址配置     \~english IP configuration:bit31-static bit30-dhcp bit29-lla
    ('nCurrentIp', c_uint),                       # < \~chinese 当前主机IP地址     \~english Current host Ip 
    ('nCurrentSubNetMask', c_uint),               # < \~chinese 当前子网掩码       \~english curtent subnet mask
    ('nDefultGateWay', c_uint),                   # < \~chinese 默认网关           \~english Default gate way
    ('chManufacturerName', c_ubyte * 32),         # < \~chinese 厂商名称           \~english Manufacturer Name
    ('chModelName', c_ubyte * 32),                # < \~chinese 型号名称           \~english Mode name
    ('chDeviceVersion', c_ubyte * 32),            # < \~chinese 设备固件版本       \~english Device Version
    ('chManufacturerSpecificInfo', c_ubyte * 48), # < \~chinese 厂商特殊信息       \~english Manufacturer Specific Infomation
    ('chSerialNumber', c_ubyte * 16),             # < \~chinese 序列号            \~english serial number
    ('chUserDefinedName', c_ubyte * 16),          # < \~chinese 用户定义名称       \~english User Defined Name
    ('nNetExport', c_uint),                       # < \~chinese 网口Ip地址         \~english NetWork Ip address
    ('nReserved', c_uint * 4),                    # < \~chinese 保留字节           \~english Reserved bytes
]
MV_GIGE_DEVICE_INFO = _MV_GIGE_DEVICE_INFO_

# USB设备信息    \~english USB device info
class _MV_USB3_DEVICE_INFO_(Structure):
    pass
_MV_USB3_DEVICE_INFO_._fields_ = [
    ('CrtlInEndPoint', c_ubyte),                            # < \~chinese 控制输入端点          \~english Control input endpoint
    ('CrtlOutEndPoint', c_ubyte),                           # < \~chinese 控制输出端点          \~english Control output endpoint
    ('StreamEndPoint', c_ubyte),                            # < \~chinese 流端点                \~english Flow endpoint
    ('EventEndPoint', c_ubyte),                             # < \~chinese 事件端点              \~english Event endpoint
    ('idVendor', c_ushort),                                 # < \~chinese 供应商ID号            \~english Vendor ID Number
    ('idProduct', c_ushort),                                # < \~chinese 产品ID号              \~english Device ID Number
    ('nDeviceNumber', c_uint),                              # < \~chinese 设备序列号            \~english Device Serial Number
    ('chDeviceGUID', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 设备GUID号            \~english Device GUID Number
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 供应商名字            \~english Vendor Name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),        # < \~chinese 型号名字              \~english Model Name
    ('chFamilyName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 家族名字              \~english Family Name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 设备版本号            \~english Device Version
    ('chManufacturerName', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese 制造商名字            \~english Manufacturer Name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号                \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字         \~english User Defined Name
    ('nbcdUSB', c_uint),                                    # < \~chinese 支持的USB协议         \~english Support USB Protocol
    ('nDeviceAddress', c_uint),                             # < \~chinese 设备地址              \~english Device Address
    ('nReserved', c_uint * 2),                              # < \~chinese 保留字节              \~english Reserved bytes
]
MV_USB3_DEVICE_INFO = _MV_USB3_DEVICE_INFO_

# CameraLink设备信息    \~english CameraLink device info
class _MV_CamL_DEV_INFO_(Structure):
    pass
_MV_CamL_DEV_INFO_._fields_ = [
    ('chPortID', c_ubyte * INFO_MAX_BUFFER_SIZE),           # < \~chinese 端口号            \~english Port ID         
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),        # < \~chinese 设备型号          \~english Model name
    ('chFamilyName', c_ubyte * INFO_MAX_BUFFER_SIZE),       # < \~chinese 家族名字          \~english Family Name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 设备版本号        \~english Device Version
    ('chManufacturerName', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese 制造商名字        \~english Manufacturer Name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('nReserved', c_uint * 38),                             # < \~chinese 保留字节          \~english Reserved bytes
]
MV_CamL_DEV_INFO = _MV_CamL_DEV_INFO_

# 采集卡Camera Link相机信息          \~english Camera Link device information on frame grabber
class _MV_CML_DEVICE_INFO_(Structure):
    pass
_MV_CML_DEVICE_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 采集卡ID   \~english Interface ID of Frame Grabber
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 供应商名字       \~english Vendor name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号名字         \~english Model name
    ('chManufacturerInfo', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 厂商信息   \~english Manufacturer information
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 相机版本          \~english Device version
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字      \~english User defined name
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 相机ID            \~english Device ID
    ('nReserved', c_uint * 7),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_CML_DEVICE_INFO = _MV_CML_DEVICE_INFO_

# CoaXPress相机信息      \~english CoaXPress device information
class _MV_CXP_DEVICE_INFO_(Structure):
    pass
_MV_CXP_DEVICE_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 采集卡ID   \~english Interface ID of Frame Grabber
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 供应商名字       \~english Vendor name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号名字         \~english Model name
    ('chManufacturerInfo', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 厂商信息   \~english Manufacturer information
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 相机版本          \~english Device version
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字      \~english User defined name
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 相机ID            \~english Device ID
    ('nReserved', c_uint * 7),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_CXP_DEVICE_INFO = _MV_CXP_DEVICE_INFO_

# XoFLink相机信息      \~english XoFLink device information
class _MV_XOF_DEVICE_INFO_(Structure):
    pass
_MV_XOF_DEVICE_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 采集卡ID   \~english Interface ID of Frame Grabber
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 供应商名字       \~english Vendor name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号名字         \~english Model name
    ('chManufacturerInfo', c_ubyte * INFO_MAX_BUFFER_SIZE),   # < \~chinese 厂商信息   \~english Manufacturer information
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),    # < \~chinese 相机版本          \~english Device version
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 序列号            \~english Serial Number
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 用户自定义名字      \~english User defined name
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 相机ID            \~english Device ID
    ('nReserved', c_uint * 7),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_XOF_DEVICE_INFO = _MV_XOF_DEVICE_INFO_

# CameraParams.h 80
class _MV_CC_DEVICE_INFO_(Structure):
    pass
# 设备信息    \~english Device info
class N19_MV_CC_DEVICE_INFO_3DOT_0E(Union):
    pass
N19_MV_CC_DEVICE_INFO_3DOT_0E._fields_ = [
    ('stGigEInfo', MV_GIGE_DEVICE_INFO),                   # < \~chinese Gige设备信息        \~english Gige device infomation
    ('stUsb3VInfo', MV_USB3_DEVICE_INFO),                  # < \~chinese U3V设备信息         \~english u3V device information
    ('stCamLInfo', MV_CamL_DEV_INFO),                      # < \~chinese CamLink设备信息     \~english CamLink device information
    ('stCMLInfo', MV_CML_DEVICE_INFO),  # < \~chinese 采集卡CameraLink设备信息     \~english CameraLink Device Info On Frame Grabber
    ('stCXPInfo', MV_CXP_DEVICE_INFO),  # < \~chinese 采集卡CoaXPress设备信息     \~english CoaXPress Device Info On Frame Grabber
    ('stXoFInfo', MV_XOF_DEVICE_INFO),  # < \~chinese 采集卡XoF设备信息          \~english XoF Device Info On Frame Grabber
]

_MV_CC_DEVICE_INFO_._fields_ = [
    ('nMajorVer', c_ushort),                              # < \~chinese 规范的主要版本         \~english Major version of the specification.
    ('nMinorVer', c_ushort),                              # < \~chinese 规范的次要版本         \~english Minor version of the specification
    ('nMacAddrHigh', c_uint),                             # < \~chinese MAC地址高位           \~english Mac address high
    ('nMacAddrLow', c_uint),                              # < \~chinese MAC地址低位           \~english Mac address low
    ('nTLayerType', c_uint),                              # < \~chinese 设备传输层协议类型     \~english Device Transport Layer Protocol Type, e.g. MV_GIGE_DEVICE
    ('nDevTypeInfo', c_uint),                             # < \~chinese 设备类型信息         \~english Device Type Info
    ('nReserved', c_uint * 3),                            # < \~chinese 保留字节              \~english Reserved bytes
    ('SpecialInfo', N19_MV_CC_DEVICE_INFO_3DOT_0E),       # < \~chinese 不同设备特有信息       \~english Special information
]
MV_CC_DEVICE_INFO = _MV_CC_DEVICE_INFO_

# 设备信息列表    \~english Device Information List
class _MV_CC_DEVICE_INFO_LIST_(Structure):
    pass
_MV_CC_DEVICE_INFO_LIST_._fields_ = [
    ('nDeviceNum', c_uint),                                          # < \~chinese 在线设备数量         \~english Online Device Number
    ('pDeviceInfo', POINTER(MV_CC_DEVICE_INFO) * MV_MAX_DEVICE_NUM), # < \~chinese 支持最多256个设备    \~english Support up to 256 devices
]
MV_CC_DEVICE_INFO_LIST = _MV_CC_DEVICE_INFO_LIST_

# 通过GenTL枚举到的Interface信息    \~english Interface Information with GenTL
class _MV_GENTL_IF_INFO_(Structure):
    pass
_MV_GENTL_IF_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese GenTL接口ID        \~english Interface ID of GenTL
    ('chTLType', c_ubyte * INFO_MAX_BUFFER_SIZE),      # < \~chinese 传输层类型          \~english Transport Layer type
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE), # < \~chinese 设备显示名称         \~english Display name
    ('nCtiIndex', c_uint),                             # < \~chinese GenTL的cti文件索引   \~english Cti file index of GenTL 
    ('nReserved', c_uint * 8),                         # < \~chinese 保留字节             \~english Reserved bytes
]
MV_GENTL_IF_INFO = _MV_GENTL_IF_INFO_

# 通过GenTL枚举到的设备信息列表    \~english Device Information List with GenTL
class _MV_GENTL_IF_INFO_LIST_(Structure):
    pass
_MV_GENTL_IF_INFO_LIST_._fields_ = [
    ('nInterfaceNum', c_uint),                                    # < \~chinese 在线设备数量         \~english Online Device Number
    ('pIFInfo', POINTER(MV_GENTL_IF_INFO) * MV_MAX_GENTL_IF_NUM), # < \~chinese 支持最多256个设备     \~english Support up to 256 devices
]
MV_GENTL_IF_INFO_LIST = _MV_GENTL_IF_INFO_LIST_

# 通过GenTL枚举到的设备信息    \~english Device Information with GenTL
class _MV_GENTL_DEV_INFO_(Structure):
    pass
_MV_GENTL_DEV_INFO_._fields_ = [
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),          # < \~chinese GenTL接口ID         \~english Interface ID of GenTL
    ('chDeviceID', c_ubyte * INFO_MAX_BUFFER_SIZE),             # < \~chinese 设备ID              \~english Device ID
    ('chVendorName', c_ubyte * INFO_MAX_BUFFER_SIZE),           # < \~chinese 供应商名字          \~english Vendor Name
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),            # < \~chinese 型号名字            \~english Model name
    ('chTLType', c_ubyte * INFO_MAX_BUFFER_SIZE),               # < \~chinese 传输层类型          \~english Transport Layer type
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE),          # < \~chinese 显示名称           \~english Display name
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),      # < \~chinese 用户自定义名字      \~english User defined name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),         # < \~chinese 序列号             \~english Serial number
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),        # < \~chinese 设备版本号         \~english Device version
    ('nCtiIndex', c_uint),                                      # < \~chinese cti索引            \~english Cti Index
    ('nReserved', c_uint * 8),                                  # < \~chinese 保留字节           \~english Reserved bytes
]
MV_GENTL_DEV_INFO = _MV_GENTL_DEV_INFO_

# 通过GenTL枚举到的设备信息列表    \~english Device Information List with GenTL
class _MV_GENTL_DEV_INFO_LIST_(Structure):
    pass
_MV_GENTL_DEV_INFO_LIST_._fields_ = [
    ('nDeviceNum', c_uint),                                             # < \~chinese 在线设备数量         \~english Online Device Number
    ('pDeviceInfo', POINTER(MV_GENTL_DEV_INFO) * MV_MAX_GENTL_DEV_NUM), # < \~chinese GenTL设备信息       \~english device infomation of GenTL device
]
MV_GENTL_DEV_INFO_LIST = _MV_GENTL_DEV_INFO_LIST_

# Chunk内容    \~english The content of ChunkData
class _MV_CHUNK_DATA_CONTENT_(Structure):
    pass
_MV_CHUNK_DATA_CONTENT_._fields_ = [
    ('pChunkData', POINTER(c_ubyte)),  # < \~chinese 块数据             \~english Chunk data
    ('nChunkID', c_uint),              # < \~chinese 块数据ID           \~english Chunk id
    ('nChunkLen', c_uint),             # < \~chinese 块数据长度         \~english Chunk len
    ('nReserved', c_uint * 8),         # < \~chinese 保留字节           \~english Reserved bytes
]
MV_CHUNK_DATA_CONTENT = _MV_CHUNK_DATA_CONTENT_

# 输出帧的信息    \~english Output Frame Information
class _MV_FRAME_OUT_INFO_EX_(Structure):
    pass
# values for enumeration 'MvGvspPixelType'
MvGvspPixelType = c_int # enum

class N22_MV_FRAME_OUT_INFO_EX_3DOT_1E(Union):
    pass
N22_MV_FRAME_OUT_INFO_EX_3DOT_1E._fields_ = [
    ('pUnparsedChunkContent', POINTER(MV_CHUNK_DATA_CONTENT)), # < \~chinese Chunk内容         \~english Chunk Content
    ('nAligning', int64_t),                                    # < \~chinese 校准字段          \~english Aligning
]
_MV_FRAME_OUT_INFO_EX_._fields_ = [
    ('nWidth', c_ushort),
    # < \~chinese 图像宽(最大65535，超出请用nExtendWidth)    \~english Image Width (over 65535, use nExtendWidth)
    ('nHeight', c_ushort),
    # < \~chinese 图像高(最大65535，超出请用nExtendHeight)   \~english Image Height(over 65535, use nExtendHeight)
    ('enPixelType', MvGvspPixelType),                        # < \~chinese 像素格式           \~english Pixel Type
    ('nFrameNum', c_uint),                                   # < \~chinese 帧号               \~english Frame Number
    ('nDevTimeStampHigh', c_uint),                           # < \~chinese 时间戳高32位       \~english Timestamp high 32 bits
    ('nDevTimeStampLow', c_uint),                            # < \~chinese 时间戳低32位       \~english Timestamp low 32 bits
    ('nReserved0', c_uint),                                  # < \~chinese 保留，8字节对齐     \~english Reserved, 8-byte aligned
    ('nHostTimeStamp', int64_t),                             # < \~chinese 主机生成的时间戳    \~english Host-generated timestamp
    ('nFrameLen', c_uint),                                   # < \~chinese 帧的长度           \~english Frame length
    # < \~chinese 以下为chunk新增水印信息 \~english The followings are chunk add frame-specific information
    # < \~chinese 设备水印时标 \~english Device frame-specific time scale
    ('nSecondCount', c_uint),                                # < \~chinese 秒数               \~english The Seconds                         
    ('nCycleCount', c_uint),                                 # < \~chinese 周期数             \~english The Count of Cycle                
    ('nCycleOffset', c_uint),                                # < \~chinese 周期偏移量         \~english The Offset of Cycle                  
    ('fGain', c_float),                                      # < \~chinese 增益               \~english Gain
    ('fExposureTime', c_float),                              # < \~chinese 曝光时间           \~english Exposure Time
    ('nAverageBrightness', c_uint),                          # < \~chinese 平均亮度           \~english Average brightness
    # < \~chinese:白平衡相关 \~english White balance
    ('nRed', c_uint),                                        # < \~chinese 红色               \~english Red     
    ('nGreen', c_uint),                                      # < \~chinese 绿色               \~english Green
    ('nBlue', c_uint),                                       # < \~chinese 蓝色               \~english Blue
    ('nFrameCounter', c_uint),                               # < \~chinese 帧计数             \~english Frame counter
    ('nTriggerIndex', c_uint),                               # < \~chinese 触发计数           \~english Trigger index
    # < \~chinese  输入/输出 \~english Line Input/Output
    ('nInput', c_uint),                                      # < \~chinese 输入               \~english input
    ('nOutput', c_uint),                                     # < \~chinese 输出               \~english output
    # < \~chinese ROI区域 \~english ROI Region                       
    ('nOffsetX', c_ushort),                                  # < \~chinese 水平偏移量             \~english OffsetX   
    ('nOffsetY', c_ushort),                                  # < \~chinese 垂直偏移量             \~english OffsetY
    ('nChunkWidth', c_ushort),                               # < \~chinese chunk 宽              \~english The Width of Chunk
    ('nChunkHeight', c_ushort),                              # < \~chinese chunk 高               \~english The Height of Chunk
    ('nLostPacket', c_uint),                                 # < \~chinese 本帧丢包数            \~english Lost Pacekt Number In This Frame
    ('nUnparsedChunkNum', c_uint),                           # < \~chinese 未解析的Chunkdata个数 \~english Unparsed chunk number
    ('UnparsedChunkList', N22_MV_FRAME_OUT_INFO_EX_3DOT_1E), # < \~chinese 数据库链表            \~english Unparsed chunk list
    ('nExtendWidth', c_uint),                                # < \~chinese 图像宽(扩展变量)       \~english Image Width
    ('nExtendHeight', c_uint),                               # < \~chinese 图像高(扩展变量)       \~english Image Height
    ('nReserved', c_uint * 34),                              # < \~chinese 保留字节            \~english Reserved bytes
]
MV_FRAME_OUT_INFO_EX = _MV_FRAME_OUT_INFO_EX_

# \~chinese 显示帧信息   \~english Display frame information
class _MV_DISPLAY_FRAME_INFO_EX_(Structure):
    pass
_MV_DISPLAY_FRAME_INFO_EX_._fields_ = [
    ('nWidth', c_uint),                # < \~chinese 图像宽    \~english Image Width
    ('nHeight', c_uint),               # < \~chinese 图像高    \~english Image Height
    ('enPixelType', MvGvspPixelType),  # < \~chinese 像素格式            \~english Pixel Type
    ('pImageBuf', POINTER(c_ubyte)),   # < \~chinese 输入图像缓存         \~english Input image buffer
    ('nImageBufLen', c_uint),          # < \~chinese 输入图像长度         \~english Input image length
    ('enRenderMode', c_uint),          # < \~chinese 图像渲染方式 0-GDI(默认), 1-D3D, 2-OPENGL \~english Render mode 0-GDI(default), 1-D3D, 2-OPENGL
    ('nRes', c_uint * 3),              # < \~chinese 保留字节            \~english Reserved bytes
]
MV_DISPLAY_FRAME_INFO_EX = _MV_DISPLAY_FRAME_INFO_EX_

# 图像结构体，输出图像指针地址及图像信息    \~english Image Struct, output the pointer of Image and the information of the specific image
class _MV_FRAME_OUT_(Structure):
    pass
_MV_FRAME_OUT_._fields_ = [
    ('pBufAddr', POINTER(c_ubyte)),         # < \~chinese 图像指针地址         \~english pointer of image
    ('stFrameInfo', MV_FRAME_OUT_INFO_EX),  # < \~chinese 图像信息            \~english information of the specific image
    ('nRes', c_uint * 16),                  # < \~chinese 保留字节            \~english Reserved bytes
]
MV_FRAME_OUT = _MV_FRAME_OUT_

# values for enumeration '_MV_GRAB_STRATEGY_'
_MV_GRAB_STRATEGY_ = c_int # enum       
MV_GRAB_STRATEGY = _MV_GRAB_STRATEGY_   

# 网络传输的相关信息    \~english Network transmission information
class _MV_NETTRANS_INFO_(Structure):
    pass
_MV_NETTRANS_INFO_._fields_ = [
    ('nReceiveDataSize', int64_t),          # < \~chinese 已接收数据大小  [统计StartGrabbing和StopGrabbing之间的数据量]         \~english Received Data Size  [Calculate the Data Size between StartGrabbing and StopGrabbing]  
    ('nThrowFrameCount', c_int),            # < \~chinese 丢帧数量             \~english Throw frame number
    ('nNetRecvFrameCount', c_uint),         # < \~chinese 收到帧计数           \~english Receive Frame count
    ('nRequestResendPacketCount', int64_t), # < \~chinese 请求重发包数         \~english Request Resend Packet Count
    ('nResendPacketCount', int64_t),        # < \~chinese 重发包数            \~english Resend Packet Count
]
MV_NETTRANS_INFO = _MV_NETTRANS_INFO_

# 全匹配的一种信息结构体    \~english A fully matched information structure
class _MV_ALL_MATCH_INFO_(Structure):
    pass
_MV_ALL_MATCH_INFO_._fields_ = [
    ('nType', c_uint),              # < \~chinese 需要输出的信息类型                  \~english Information type need to output
    ('pInfo', c_void_p),            # < \~chinese 输出的信息缓存，由调用者分配         \~englishOutput information cache, which is allocated by the caller
    ('nInfoSize', c_uint),          # < \~chinese 信息缓存的大小                      \~english Information cache size
]
MV_ALL_MATCH_INFO = _MV_ALL_MATCH_INFO_

# 网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT    \~english Network traffic and packet loss feedback structure, the corresponding type is MV_MATCH_TYPE_NET_DETECT
class _MV_MATCH_INFO_NET_DETECT_(Structure):
    pass
_MV_MATCH_INFO_NET_DETECT_._fields_ = [
    ('nReceiveDataSize', int64_t),          # < \~chinese 已接收数据大小      \~english Received data size
    ('nLostPacketCount', int64_t),          # < \~chinese 丢失的包数量        \~english Number of packets lost
    ('nLostFrameCount', c_uint),            # < \~chinese 丢帧数量           \~english Number of frames lost
    ('nNetRecvFrameCount', c_uint),         # < \~chinese 收到帧计数           \~english Receive Frame count
    ('nRequestResendPacketCount', int64_t), # < \~chinese 请求重发包数         \~english Request Resend Packet Count
    ('nResendPacketCount', int64_t),        # < \~chinese 重发包数            \~english Resend Packet Count
]
MV_MATCH_INFO_NET_DETECT = _MV_MATCH_INFO_NET_DETECT_

# \~chinese host收到从u3v设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT    \~english The total number of bytes host received from the u3v device side, the corresponding type is MV_MATCH_TYPE_USB_DETECT
class _MV_MATCH_INFO_USB_DETECT_(Structure):
    pass
_MV_MATCH_INFO_USB_DETECT_._fields_ = [
    ('nReceiveDataSize', int64_t),   # < \~chinese 已接收数据大小      \~english Received data size
    ('nReceivedFrameCount', c_uint), # < \~chinese 已收到的帧数        \~english Number of frames received
    ('nErrorFrameCount', c_uint),    # < \~chinese 错误帧数            \~english Number of error frames
    ('nReserved', c_uint * 2),       # < \~chinese 保留字节            \~english Reserved bytes
]
MV_MATCH_INFO_USB_DETECT = _MV_MATCH_INFO_USB_DETECT_

# \~chinese 显示帧信息   \~english Display frame information
class _MV_DISPLAY_FRAME_INFO_(Structure):
    pass
_MV_DISPLAY_FRAME_INFO_._fields_ = [
    ('hWnd', c_void_p),               # < \~chinese 窗口句柄           \~english Windows handle
    ('pData', POINTER(c_ubyte)),      # < \~chinese 显示的数据         \~english Data Buffer
    ('nDataLen', c_uint),             # < \~chinese 数据长度           \~english Data Size
    ('nWidth', c_ushort),             # < \~chinese 图像宽             \~english Width
    ('nHeight', c_ushort),            # < \~chinese 图像高             \~english Height
    ('enPixelType', MvGvspPixelType), # < \~chinese 像素格式           \~english Pixel format
    ('enRenderMode', c_uint),         # < \~chinese 图像渲染方式 0-GDI(默认), 1-D3D, 2-OPENGL \~english Render mode 0-GDI(default), 1-D3D, 2-OPENGL
    ('nRes', c_uint * 3),             # < \~chinese 保留字节           \~english Reserved bytes
]
MV_DISPLAY_FRAME_INFO = _MV_DISPLAY_FRAME_INFO_

# values for enumeration 'MV_SAVE_POINT_CLOUD_FILE_TYPE'
MV_SAVE_POINT_CLOUD_FILE_TYPE = c_int # enum

# \~chinese 保存3D数据到缓存    \~english Save 3D data to buffer
class _MV_SAVE_POINT_CLOUD_PARAM_(Structure):
    pass
_MV_SAVE_POINT_CLOUD_PARAM_._fields_ = [
    ('nLinePntNum', c_uint),                                 # < \~chinese 每一行点的数量，即图像宽                                             \~english The number of points in each row,which is the width of the image
    ('nLineNum', c_uint),                                    # < \~chinese 行数，即图像高                                                       \~english The number of rows,which is the height of the image
    ('enSrcPixelType', MvGvspPixelType),                     # < \~chinese 输入数据的像素格式                                                    \~english The pixel format of the input data
    ('pSrcData', POINTER(c_ubyte)),                          # < \~chinese 输入数据缓存                                                          \~english Input data buffer
    ('nSrcDataLen', c_uint),                                 # < \~chinese 输入数据大小                                                           \~english Input data size
    ('pDstBuf', POINTER(c_ubyte)),                           # < \~chinese 输出像素数据缓存                                                        \~english Output pixel data buffer
    ('nDstBufSize', c_uint),                                 # < \~chinese 提供的输出缓冲区大小(nLinePntNum * nLineNum * (16*3 + 4) + 2048)         \~english Output buffer size provided (nLinePntNum * nLineNum * (16*3 + 4) + 2048) 
    ('nDstBufLen', c_uint),                                  # < \~chinese 输出像素数据缓存长度                                                     \~english Output pixel data buffer size
    ('enPointCloudFileType', MV_SAVE_POINT_CLOUD_FILE_TYPE), # < \~chinese 提供输出的点云文件类型                                                    \~english Output point data file type provided
    ('nReserved', c_uint * 8),                               # < \~chinese 保留字节                                                                 \~english Reserved bytes
]
MV_SAVE_POINT_CLOUD_PARAM = _MV_SAVE_POINT_CLOUD_PARAM_

# values for enumeration 'MV_SAVE_IAMGE_TYPE'
MV_SAVE_IAMGE_TYPE = c_int # enum

# \~chinese 图片保存参数    \~english Save Image Parameters
class _MV_SAVE_IMAGE_PARAM_T_EX_(Structure):
    pass
_MV_SAVE_IMAGE_PARAM_T_EX_._fields_ = [
    ('pData', POINTER(c_ubyte)),                            # < \~chinese 输入数据缓存         \~english Input Data Buffer
    ('nDataLen', c_uint),                                   # < \~chinese 输入数据大小         \~english Input Data Size
    ('enPixelType', MvGvspPixelType),                       # < \~chinese 输入数据的像素格式         \~english Input Data Pixel Format
    ('nWidth', c_ushort),                                   # < \~chinese 图像宽         \~english Image Width
    ('nHeight', c_ushort),                                  # < \~chinese 图像高         \~english Image Height
    ('pImageBuffer', POINTER(c_ubyte)),                     # < \~chinese 输出图片缓存         \~english Output Image Buffer
    ('nImageLen', c_uint),                                  # < \~chinese 输出图片大小         \~english Output Image Size
    ('nBufferSize', c_uint),                                # < \~chinese 提供的输出缓冲区大小         \~english Output buffer size provided
    ('enImageType', MV_SAVE_IAMGE_TYPE),                    # < \~chinese 输出图片格式         \~english Output Image Format
    ('nJpgQuality', c_uint),                                # < \~chinese 编码质量, (50-99]         \~english Encoding quality, (50-99]
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_uint),
    ('nReserved', c_uint * 3),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMAGE_PARAM_EX = _MV_SAVE_IMAGE_PARAM_T_EX_

class _MV_SAVE_IMAGE_PARAM_EX3_(Structure):
    pass
_MV_SAVE_IMAGE_PARAM_EX3_._fields_ = [
    ('pData', POINTER(c_ubyte)),                            # < \~chinese 输入数据缓存         \~english Input Data Buffer
    ('nDataLen', c_uint),                                   # < \~chinese 输入数据大小         \~english Input Data Size
    ('enPixelType', MvGvspPixelType),                       # < \~chinese 输入数据的像素格式         \~english Input Data Pixel Format
    ('nWidth', c_uint),                                   # < \~chinese 图像宽         \~english Image Width
    ('nHeight', c_uint),                                  # < \~chinese 图像高         \~english Image Height
    ('pImageBuffer', POINTER(c_ubyte)),                     # < \~chinese 输出图片缓存         \~english Output Image Buffer
    ('nImageLen', c_uint),                                  # < \~chinese 输出图片大小         \~english Output Image Size
    ('nBufferSize', c_uint),                                # < \~chinese 提供的输出缓冲区大小         \~english Output buffer size provided
    ('enImageType', MV_SAVE_IAMGE_TYPE),                    # < \~chinese 输出图片格式         \~english Output Image Format
    ('nJpgQuality', c_uint),                                # < \~chinese 编码质量, (50-99]         \~english Encoding quality, (50-99]
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_uint),
    ('nReserved', c_uint * 3),                              # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMAGE_PARAM_EX3 = _MV_SAVE_IMAGE_PARAM_EX3_

# \~chinese 保存BMP、JPEG、PNG、TIFF图片文件的参数    \~english Save BMP、JPEG、PNG、TIFF image file parameters
class _MV_SAVE_IMG_TO_FILE_PARAM_(Structure):
    pass
_MV_SAVE_IMG_TO_FILE_PARAM_._fields_ = [
    ('enPixelType', MvGvspPixelType),    # < \~chinese 输入数据的像素格式                    \~english The pixel format of the input data
    ('pData', POINTER(c_ubyte)),         # < \~chinese 输入数据缓存                          \~english Input Data Buffer
    ('nDataLen', c_uint),                # < \~chinese 输入数据大小                           \~english Input Data Size
    ('nWidth', c_ushort),                # < \~chinese 图像宽                                  \~english Image Width
    ('nHeight', c_ushort),               # < \~chinese 图像高                                   \~english Image Height
    ('enImageType', MV_SAVE_IAMGE_TYPE), # < \~chinese 输入图片格式                               \~english Input Image Format
    ('nQuality', c_uint),                # < \~chinese JPG编码质量(50-99]         \~english JPG Encoding quality(50-99]
    ('pImagePath', c_char * 256),        # < \~chinese 输入文件路径         \~english Input file path
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_int),             
    ('nReserved', c_uint * 8),           # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMG_TO_FILE_PARAM = _MV_SAVE_IMG_TO_FILE_PARAM_

class _MV_SAVE_IMAGE_TO_FILE_PARAM_EX_(Structure):
    pass
_MV_SAVE_IMAGE_TO_FILE_PARAM_EX_._fields_ = [
    ('nWidth', c_uint),  # < \~chinese 图像宽                                  \~english Image Width
    ('nHeight', c_uint),  # < \~chinese 图像高                                 \~english Image Height
    # < \~chinese 输入数据的像素格式                    \~english The pixel format of the input data
    ('enPixelType', MvGvspPixelType),
    ('pData', POINTER(c_ubyte)),  # < \~chinese 输入数据缓存                          \~english Input Data Buffer
    ('nDataLen', c_uint),  # < \~chinese 输入数据大小                           \~english Input Data Size
    # < \~chinese 输入图片格式                               \~english Input Image Format
    ('enImageType', MV_SAVE_IAMGE_TYPE),
    ('pcImagePath', POINTER(c_char)),  # < \~chinese 输入文件路径         \~english Input file path
    ('nQuality', c_uint),      # < \~chinese JPG编码质量(50-99]，其他格式无效    \~english JPG Encoding quality(50-99]
    # < \~chinese     ch:Bayer格式转为RGB24的插值方法 0-快速 1-均衡 2-最优 3-最优+
    # < \~english   en:Interpolation method of convert Bayer to RGB24  0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus
    ('iMethodValue', c_int),
    ('nReserved', c_uint * 8),  # < \~chinese 保留字节           \~english Reserved bytes
]
MV_SAVE_IMAGE_TO_FILE_PARAM_EX = _MV_SAVE_IMAGE_TO_FILE_PARAM_EX_

# \~chinese 图像转换结构体    \~english Pixel convert structure
class _MV_CC_PIXEL_CONVERT_PARAM_T_(Structure):
    pass
_MV_CC_PIXEL_CONVERT_PARAM_T_._fields_ = [
    ('nWidth', c_ushort),                # < \~chinese 图像宽             \~english Image Width
    ('nHeight', c_ushort),               # < \~chinese 图像高              \~english Image Height
    ('enSrcPixelType', MvGvspPixelType), # < \~chinese 源像素格式            \~english Source pixel format
    ('pSrcData', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),             # < \~chinese 输入数据大小            \~english Input data size
    ('enDstPixelType', MvGvspPixelType), # < \~chinese 目标像素格式             \~english Destination pixel format
    ('pDstBuffer', POINTER(c_ubyte)),    # < \~chinese 输出数据缓存              \~english Output data buffer
    ('nDstLen', c_uint),                 # < \~chinese 输出数据大小               \~english Output data size
    ('nDstBufferSize', c_uint),          # < \~chinese 提供的输出缓冲区大小         \~english Provided outbut buffer size
    ('nRes', c_uint * 4),                # < \~chinese 保留字节                     \~english Reserved bytes
]
MV_CC_PIXEL_CONVERT_PARAM = _MV_CC_PIXEL_CONVERT_PARAM_T_

class _MV_PIXEL_CONVERT_PARAM_EX_T_(Structure):
    pass
_MV_PIXEL_CONVERT_PARAM_EX_T_._fields_ = [
    ('nWidth', c_uint),                # < \~chinese 图像宽             \~english Image Width
    ('nHeight', c_uint),               # < \~chinese 图像高              \~english Image Height
    ('enSrcPixelType', MvGvspPixelType), # < \~chinese 源像素格式            \~english Source pixel format
    ('pSrcData', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),             # < \~chinese 输入数据大小            \~english Input data size
    ('enDstPixelType', MvGvspPixelType), # < \~chinese 目标像素格式             \~english Destination pixel format
    ('pDstBuffer', POINTER(c_ubyte)),    # < \~chinese 输出数据缓存              \~english Output data buffer
    ('nDstLen', c_uint),                 # < \~chinese 输出数据大小               \~english Output data size
    ('nDstBufferSize', c_uint),          # < \~chinese 提供的输出缓冲区大小         \~english Provided outbut buffer size
    ('nRes', c_uint * 4),                # < \~chinese 保留字节                     \~english Reserved bytes
]
MV_CC_PIXEL_CONVERT_PARAM_EX = _MV_PIXEL_CONVERT_PARAM_EX_T_

# values for enumeration '_MV_RECORD_FORMAT_TYPE_'
_MV_RECORD_FORMAT_TYPE_ = c_int # enum
MV_RECORD_FORMAT_TYPE = _MV_RECORD_FORMAT_TYPE_

# \~chinese 录像参数    \~english Record Parameters
class _MV_CC_RECORD_PARAM_T_(Structure):
    pass
_MV_CC_RECORD_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),           # < \~chinese 输入数据的像素格式                                \~english Ip config option
    ('nWidth', c_ushort),                       # < \~chinese 图像宽(指定目标参数时需为2的倍数)                   \~english Ip config option
    ('nHeight', c_ushort),                      # < \~chinese 图像高(指定目标参数时需为2的倍数)                    \~english Ip config option
    ('fFrameRate', c_float),                    # < \~chinese 帧率fps(1/16-120)                                  \~english Ip config option
    ('nBitRate', c_uint),                       # < \~chinese 码率kbps(128kbps-16Mbps)                            \~english Ip config option
    ('enRecordFmtType', MV_RECORD_FORMAT_TYPE), # < \~chinese 录像格式                                              \~english Ip config option
    ('strFilePath', STRING),                    # < \~chinese 录像文件存放路径(如果路径中存在中文，需转成utf-8)         \~english Video file storage path (if there is Chinese in the path, it needs to be converted to utf-8)
    ('nRes', c_uint * 8),                       # < \~chinese 保留字节                                                \~english Reserved bytes
]
MV_CC_RECORD_PARAM = _MV_CC_RECORD_PARAM_T_

# \~chinese 录像数据    \~english Record Data
class _MV_CC_INPUT_FRAME_INFO_T_(Structure):
    pass
_MV_CC_INPUT_FRAME_INFO_T_._fields_ = [
    ('pData', POINTER(c_ubyte)),  # < \~chinese 图像数据指针         \~english Input Data Buffer
    ('nDataLen', c_uint),         # < \~chinese  输入数据大小         \~english Input Data Size
    ('nRes', c_uint * 8),         # < \~chinese 保留字节               \~english Reserved bytes
]
MV_CC_INPUT_FRAME_INFO = _MV_CC_INPUT_FRAME_INFO_T_

# values for enumeration '_MV_CAM_ACQUISITION_MODE_'
_MV_CAM_ACQUISITION_MODE_ = c_int # enum
MV_CAM_ACQUISITION_MODE = _MV_CAM_ACQUISITION_MODE_

# values for enumeration '_MV_CAM_GAIN_MODE_'
_MV_CAM_GAIN_MODE_ = c_int # enum
MV_CAM_GAIN_MODE = _MV_CAM_GAIN_MODE_

# values for enumeration '_MV_CAM_EXPOSURE_MODE_'
_MV_CAM_EXPOSURE_MODE_ = c_int # enum
MV_CAM_EXPOSURE_MODE = _MV_CAM_EXPOSURE_MODE_

# values for enumeration '_MV_CAM_EXPOSURE_AUTO_MODE_'
_MV_CAM_EXPOSURE_AUTO_MODE_ = c_int # enum
MV_CAM_EXPOSURE_AUTO_MODE = _MV_CAM_EXPOSURE_AUTO_MODE_

# values for enumeration '_MV_CAM_TRIGGER_MODE_'
_MV_CAM_TRIGGER_MODE_ = c_int # enum
MV_CAM_TRIGGER_MODE = _MV_CAM_TRIGGER_MODE_

# values for enumeration '_MV_CAM_GAMMA_SELECTOR_'
_MV_CAM_GAMMA_SELECTOR_ = c_int # enum
MV_CAM_GAMMA_SELECTOR = _MV_CAM_GAMMA_SELECTOR_

# values for enumeration '_MV_CAM_BALANCEWHITE_AUTO_'
_MV_CAM_BALANCEWHITE_AUTO_ = c_int # enum
MV_CAM_BALANCEWHITE_AUTO = _MV_CAM_BALANCEWHITE_AUTO_

# values for enumeration '_MV_CAM_TRIGGER_SOURCE_'
_MV_CAM_TRIGGER_SOURCE_ = c_int # enum
MV_CAM_TRIGGER_SOURCE = _MV_CAM_TRIGGER_SOURCE_

# \~chinese Event事件回调信息\    \~english Event callback infomation
class _MV_EVENT_OUT_INFO_(Structure):
    pass
_MV_EVENT_OUT_INFO_._fields_ = [
    ('EventName', c_char * MAX_EVENT_NAME_SIZE), # < \~chinese Event名称       \~english Event name
    ('nEventID', c_ushort),                      # < \~chinese Event号          \~english Event ID
    ('nStreamChannel', c_ushort),                # < \~chinese 流通道序号         \~english Circulation number
    ('nBlockIdHigh', c_uint),                    # < \~chinese 帧号高位  (暂无固件支持)          \~english BlockId high, not support
    ('nBlockIdLow', c_uint),                     # < \~chinese 帧号低位  (暂无固件支持)           \~english BlockId low, not support
    ('nTimestampHigh', c_uint),                  # < \~chinese 时间戳高位            \~english Timestramp high
    ('nTimestampLow', c_uint),                   # < \~chinese 时间戳低位             \~english Timestramp low
    ('pEventData', c_void_p),                    # < \~chinese Event数据     (暂无固件支持)         \~english Event data, not support
    ('nEventDataSize', c_uint),                  # < \~chinese Event数据长度 (暂无固件支持)         \~english Event data len, not support
    ('nReserved', c_uint * 16),                  # < \~chinese 保留字节                 \~english Reserved bytes
]
MV_EVENT_OUT_INFO = _MV_EVENT_OUT_INFO_

# \~chinese 文件存取    \~english File Access
class _MV_CC_FILE_ACCESS_T(Structure):
    pass
_MV_CC_FILE_ACCESS_T._fields_ = [
    ('pUserFileName', STRING),  # < \~chinese 用户文件名         \~english User file name
    ('pDevFileName', STRING),   # < \~chinese 设备文件名          \~english Device file name
    ('nReserved', c_uint * 32), # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_FILE_ACCESS = _MV_CC_FILE_ACCESS_T

# \~chinese 文件存取进度    \~english File Access Progress
class _MV_CC_FILE_ACCESS_PROGRESS_T(Structure):
    pass
_MV_CC_FILE_ACCESS_PROGRESS_T._fields_ = [
    ('nCompleted', int64_t),     # < \~chinese 已完成的长度         \~english Completed Length
    ('nTotal', int64_t),         # < \~chinese 总长度               \~english Total Length
    ('nReserved', c_uint * 8),   # < \~chinese 保留字节              \~english Reserved bytes
]
MV_CC_FILE_ACCESS_PROGRESS = _MV_CC_FILE_ACCESS_PROGRESS_T

# values for enumeration '_MV_GIGE_TRANSMISSION_TYPE_'
_MV_GIGE_TRANSMISSION_TYPE_ = c_int # enum
MV_GIGE_TRANSMISSION_TYPE = _MV_GIGE_TRANSMISSION_TYPE_

# 传输模式，可以为单播模式、组播模式等    \~english Transmission type
class _MV_TRANSMISSION_TYPE_T(Structure):
    pass
_MV_TRANSMISSION_TYPE_T._fields_ = [
    ('enTransmissionType', MV_GIGE_TRANSMISSION_TYPE),  # < \~chinese 传输模式                      \~english Transmission type
    ('nDestIp', c_uint),                                # < \~chinese 目标IP，组播模式下有意义        \~english Destination IP
    ('nDestPort', c_ushort),                            # < \~chinese 目标Port，组播模式下有意义        \~english Destination port
    ('nReserved', c_uint * 32),                         # < \~chinese 保留字节                          \~english Reserved bytes
]
MV_TRANSMISSION_TYPE = _MV_TRANSMISSION_TYPE_T

# \~chinese 动作命令信息    \~english Action Command
class _MV_ACTION_CMD_INFO_T(Structure):
    pass
_MV_ACTION_CMD_INFO_T._fields_ = [
    ('nDeviceKey', c_uint),        # < \~chinese 设备密钥                                     \~english Device key
    ('nGroupKey', c_uint),         # < \~chinese 组键                                          \~english Group key
    ('nGroupMask', c_uint),        # < \~chinese 组掩码                                         \~english Group mask
    ('bActionTimeEnable', c_uint), # < \~chinese 只有设置成1时Action Time才有效，非1时无效         \~english Action time enable
    ('nActionTime', int64_t),      # < \~chinese 预定的时间，和主频有关                             \~english Action time
    ('pBroadcastAddress', STRING), # < \~chinese 广播包地址                                         \~english Broadcast address
    ('nTimeOut', c_uint),          # < \~chinese 等待ACK的超时时间，如果为0表示不需要ACK               \~english Timeout
    ('nReserved', c_uint * 16),    # < \~chinese 预留                                                 \~english Reserved bytes
]
MV_ACTION_CMD_INFO = _MV_ACTION_CMD_INFO_T

# \~chinese 动作命令返回信息    \~english Action Command Result
class _MV_ACTION_CMD_RESULT_T(Structure):
    pass
_MV_ACTION_CMD_RESULT_T._fields_ = [
    ('strDeviceAddress', c_ubyte * 16), # < \~chinese IP配置选项         \~english IP address of the device
    #1.0x0000:success.
    #2.0x8001:Command is not supported by the device.
    #3.0x8013:The device is not synchronized to a master clock to be used as time reference.
    #4.0x8015:A device queue or packet data has overflowed.
    #5.0x8016:The requested scheduled action command was requested at a time that is already past.
    ('nStatus', c_int),                 # < \~chinese 状态码            \~english status
    ('nReserved', c_uint * 4),          # < \~chinese 预留              \~english Reserved bytes
]
MV_ACTION_CMD_RESULT = _MV_ACTION_CMD_RESULT_T

# \~chinese 动作命令返回信息列表    \~english Action Command Result List
class _MV_ACTION_CMD_RESULT_LIST_T(Structure):
    pass
_MV_ACTION_CMD_RESULT_LIST_T._fields_ = [
    ('nNumResults', c_uint),                     # < \~chinese 返回值个数         \~english Num Results
    ('pResults', POINTER(MV_ACTION_CMD_RESULT)), # < \~chinese 动作命令返回信息        \~english action command result list
]
MV_ACTION_CMD_RESULT_LIST = _MV_ACTION_CMD_RESULT_LIST_T

# values for enumeration 'MV_XML_InterfaceType'
MV_XML_InterfaceType = c_int # enum

# values for enumeration 'MV_XML_AccessMode'
MV_XML_AccessMode = c_int # enum

# \~chinese 枚举类型值    \~english Enumeration Value
class _MVCC_ENUMVALUE_T(Structure):
    pass
_MVCC_ENUMVALUE_T._fields_ = [
    ('nCurValue', c_uint),                               # < \~chinese 当前值                \~english Current Value
    ('nSupportedNum', c_uint),                           # < \~chinese 数据的有效数据个数      \~english Number of valid data
    ('nSupportValue', c_uint * MV_MAX_XML_SYMBOLIC_NUM), # < \~chinese 支持值列表              \~english Support value list
    ('nReserved', c_uint * 4),                           # < \~chinese 预留                    \~english Reserved bytes
]
MVCC_ENUMVALUE = _MVCC_ENUMVALUE_T

# \~chinese Int类型值    \~english Int Value
class _MVCC_INTVALUE_T(Structure):
    pass
_MVCC_INTVALUE_T._fields_ = [
    ('nCurValue', c_uint),     # < \~chinese 当前值        \~english Current Value
    ('nMax', c_uint),          # < \~chinese 最大值         \~english Max Value
    ('nMin', c_uint),          # < \~chinese 最小值          \~english Min Value
    ('nInc', c_uint),          # < \~chinese 步径             \~english Step size
    ('nReserved', c_uint * 4), # < \~chinese 预留              \~english Reserved bytes
]
MVCC_INTVALUE = _MVCC_INTVALUE_T

# \~chinese Int类型值Ex    \~english Int Value Ex
class _MVCC_INTVALUE_EX_T(Structure):
    pass
_MVCC_INTVALUE_EX_T._fields_ = [
    ('nCurValue', int64_t),     # < \~chinese 当前值         \~english Current Value
    ('nMax', int64_t),          # < \~chinese 最大值          \~english Max Value
    ('nMin', int64_t),          # < \~chinese 最小值           \~english Min Value
    ('nInc', int64_t),          # < \~chinese 步径              \~english Step size
    ('nReserved', c_uint * 16), # < \~chinese 预留               \~english Reserved bytes
]
MVCC_INTVALUE_EX = _MVCC_INTVALUE_EX_T

# \~chinese Float类型值    \~english Float Value
class _MVCC_FLOATVALUE_T(Structure):
    pass
_MVCC_FLOATVALUE_T._fields_ = [
    ('fCurValue', c_float),    # < \~chinese 当前值         \~english Current Value
    ('fMax', c_float),         # < \~chinese 最大值          \~english Max Value
    ('fMin', c_float),         # < \~chinese 最小值           \~english Min Value
    ('nReserved', c_uint * 4), # < \~chinese 预留              \~english Reserved bytes
]
MVCC_FLOATVALUE = _MVCC_FLOATVALUE_T

# \~chinese String类型值    \~english String Value
class _MVCC_STRINGVALUE_T(Structure):
    pass
_MVCC_STRINGVALUE_T._fields_ = [
    ('chCurValue', c_char * 256), # < \~chinese 当前值         \~english Current Value
    ('nMaxLength', int64_t),      # < \~chinese 最大长度        \~english Max length
    ('nReserved', c_uint * 2),    # < \~chinese 预留            \~english Reserved bytes
]
MVCC_STRINGVALUE = _MVCC_STRINGVALUE_T

# \~chinese 水印信息     \~english  Frame-specific information
class _MV_CC_FRAME_SPEC_INFO_(Structure):
    pass
_MV_CC_FRAME_SPEC_INFO_._fields_ = [
    # < \~chinese 设备水印时标      \~english Device frame-specific time scale
    ('nSecondCount', c_uint),        # < \~chinese 秒数                  \~english The Seconds
    ('nCycleCount', c_uint),         # < \~chinese 周期数                 \~english The Count of Cycle
    ('nCycleOffset', c_uint),        # < \~chinese 周期偏移量              \~english The Offset of Cycle
    ('fGain', c_float),              # < \~chinese 增益                   \~english Gain
    ('fExposureTime', c_float),      # < \~chinese 曝光时间                \~english Exposure Time
    ('nAverageBrightness', c_uint),  # < \~chinese 平均亮度                \~english Average brightness
    # < \~chinese 白平衡相关        \~english White balance
    ('nRed', c_uint),    # < \~chinese 红色                   \~english Red
    ('nGreen', c_uint),  # < \~chinese 绿色                    \~english Green
    ('nBlue', c_uint),   # < \~chinese 蓝色                    \~english Blue
    ('nFrameCounter', c_uint),  # < \~chinese 总帧数           \~english Frame Counter
    ('nTriggerIndex', c_uint),  # < \~chinese 触发计数          \~english Trigger Counting
    ('nInput', c_uint),  # < \~chinese 输入                   \~english Input
    ('nOutput', c_uint), # < \~chinese 输出                   \~english Output
    # < \~chinese ROI区域           \~english ROI Region
    ('nOffsetX', c_ushort),      # < \~chinese 水平偏移量        \~english OffsetX
    ('nOffsetY', c_ushort),      # < \~chinese 垂直偏移量         \~english OffsetY
    ('nFrameWidth', c_ushort),   # < \~chinese 水印宽            \~english The Width of Chunk
    ('nFrameHeight', c_ushort),  # < \~chinese 水印高            \~english The Height of Chunk
    ('nReserved', c_uint * 16),   # < \~chinese 预留              \~english Reserved bytes
]
MV_CC_FRAME_SPEC_INFO = _MV_CC_FRAME_SPEC_INFO_

# \~chinese 无损解码参数              \~english High Bandwidth decode structure
class _MV_CC_HB_DECODE_PARAM_T_(Structure):
    pass
_MV_CC_HB_DECODE_PARAM_T_._fields_ = [
    ('pSrcBuf', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcLen', c_uint),                # < \~chinese 输入数据大小           \~english Input data size
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存           \~english Output data buffer
    ('nDstBufSize', c_uint),            # < \~chinese 提供的输出缓冲区大小     \~english Provided output buffer size
    ('nDstBufLen', c_uint),             # < \~chinese 输出数据大小            \~english Output data size
    ('enDstPixelType', MvGvspPixelType),  # < \~chinese 输出的像素格式        \~english Output pixel format
    ('stFrameInfo', MV_CC_FRAME_SPEC_INFO),  # < \~chinese 水印信息          \~english Frame Spec Info
    ('nRes', c_uint * 8),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_HB_DECODE_PARAM = _MV_CC_HB_DECODE_PARAM_T_

# values for enumeration '_MV_SORT_METHOD_'
_MV_SORT_METHOD_ = c_int  # enum
MV_SORT_METHOD = _MV_SORT_METHOD_

# values for enumeration '_MV_IMG_ROTATION_ANGLE_'
_MV_IMG_ROTATION_ANGLE_ = c_int  # enum
MV_IMG_ROTATION_ANGLE = _MV_IMG_ROTATION_ANGLE_

# values for enumeration '_MV_IMG_FLIP_TYPE_'
_MV_IMG_FLIP_TYPE_ = c_int  # enum
MV_IMG_FLIP_TYPE = _MV_IMG_FLIP_TYPE_

# values for enumeration '_MV_CC_GAMMA_TYPE_'
_MV_CC_GAMMA_TYPE_ = c_int  # enum
MV_CC_GAMMA_TYPE = _MV_CC_GAMMA_TYPE_

# values for enumeration '_MV_CC_STREAM_EXCEPTION_TYPE_'
_MV_CC_STREAM_EXCEPTION_TYPE_ = c_int  # enum
MV_CC_STREAM_EXCEPTION_TYPE = _MV_CC_STREAM_EXCEPTION_TYPE_

# values for enumeration '_MV_IMAGE_RECONSTRUCTION_METHOD_'
_MV_IMAGE_RECONSTRUCTION_METHOD_ = c_int  # enum
MV_IMAGE_RECONSTRUCTION_METHOD = _MV_IMAGE_RECONSTRUCTION_METHOD_

# \~chinese 图像旋转结构体            \~english Rotate image structure
class _MV_CC_ROTATE_IMAGE_PARAM_T_(Structure):
    pass
_MV_CC_ROTATE_IMAGE_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式              \~english pixel format
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('pSrcData', POINTER(c_ubyte)),     # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),            # < \~chinese 输入数据大小           \~english Input data length
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存           \~english Output data buffer
    ('nDstBufLen', c_uint),             # < \~chinese输出数据长度            \~english Output data length
    ('nDstBufSize', c_uint),            # < \~chinese  提供的输出缓冲区大小    \~english Provided output buffer size
    ('enRotationAngle', MV_IMG_ROTATION_ANGLE),   # < \~chinese  旋转角度               \~english Rotation angle
    ('nRes', c_uint * 8),               # < \~chinese 保留字节               \~english Reserved bytes
]
MV_CC_ROTATE_IMAGE_PARAM = _MV_CC_ROTATE_IMAGE_PARAM_T_

# \~chinese 图像翻转结构体            \~english Flip image structure
class _MV_CC_FLIP_IMAGE_PARAM_T_(Structure):
    pass
_MV_CC_FLIP_IMAGE_PARAM_T_._fields_ = [
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式              \~english pixel format
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('pSrcData', POINTER(c_ubyte)),     # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcDataLen', c_uint),            # < \~chinese 输入数据大小           \~english Input data length
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存           \~english Output data buffer
    ('nDstBufLen', c_uint),             # < \~chinese输出数据长度            \~english Output data length
    ('nDstBufSize', c_uint),            # < \~chinese  提供的输出缓冲区大小    \~english Provided output buffer size
    ('enFlipType', MV_IMG_FLIP_TYPE),   # < \~chinese  翻转类型              \~english Flip type
    ('nRes', c_uint * 8),               # < \~chinese 保留字节               \~english Reserved bytes
]
MV_CC_FLIP_IMAGE_PARAM = _MV_CC_FLIP_IMAGE_PARAM_T_

# \~chinese Gamma信息结构体           \~english Gamma info structure
class _MV_CC_GAMMA_PARAM_T_(Structure):
    pass
_MV_CC_GAMMA_PARAM_T_._fields_ = [
    ('enGammaType', MV_CC_GAMMA_TYPE),       # < \~chinese Gamma类型              \~english Gamma type
    ('fGammaValue', c_float),                # < \~chinese Gamma值[0.1,4.0]       \~english Gamma value[0.1,4.0]
    ('pGammaCurveBuf', POINTER(c_ubyte)),    # < \~chinese Gamma曲线缓存          \~english Gamma curve buffer
    ('nGammaCurveBufLen', c_uint),           # < \~chinese Gamma曲线长度          \~english Gamma curve buffer size
    ('nRes', c_uint * 8),                    # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_GAMMA_PARAM = _MV_CC_GAMMA_PARAM_T_

# \~chinese CCM参数                   \~english CCM param
class _MV_CC_CCM_PARAM_T_(Structure):
    pass
_MV_CC_CCM_PARAM_T_._fields_ = [
    ('bCCMEnable', c_bool),         # < \~chinese 是否启用CCM            \~english CCM enable
    ('nCCMat', c_int * 9),          # < \~chinese CCM矩阵[-8192~8192]   \~english Color correction matrix[-8192~8192]
    ('nRes', c_uint * 8),           # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_CCM_PARAM = _MV_CC_CCM_PARAM_T_

# \~chinese CCM参数                   \~english CCM param
class _MV_CC_CCM_PARAM_EX_T_(Structure):
    pass
_MV_CC_CCM_PARAM_EX_T_._fields_ = [
    ('bCCMEnable', c_bool),         # < \~chinese 是否启用CCM            \~english CCM enable
    ('nCCMat', c_int * 9),          # < \~chinese CCM矩阵[-65536~65536]  \~english Color correction matrix[-65536~65536]
    ('nCCMScale', c_uint),          # < \~chinese 量化系数（2的整数幂,最大65536）    \~english Quantitative scale(Integer power of 2, <= 65536)
    ('nRes', c_uint * 8),           # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_CCM_PARAM_EX = _MV_CC_CCM_PARAM_EX_T_

# \~chinese 对比度调节结构体          \~english Contrast structure
class _MV_CC_CONTRAST_PARAM_T_(Structure):
    pass
_MV_CC_CONTRAST_PARAM_T_._fields_ = [
    ('nWidth', c_uint),                 # < \~chinese 图像宽(最小8)         \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高(最小8)         \~english Image Height
    ('pSrcBuf', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english Input data buffer
    ('nSrcBufLen', c_uint),             # < \~chinese 输入数据大小           \~english Input data length
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式               \~english pixel format
    ('pDstBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存          \~english Output data buffer
    ('nDstBufSize', c_uint),            # < \~chinese提供的输出缓冲区大小     \~english Provided output buffer size
    ('nDstBufLen', c_uint),            # < \~chinese  输出数据长度           \~english Output data length
    ('nContrastFactor', c_uint),       # < \~chinese  对比度值，[1,10000]    \~english Contrast factor,[1,10000]
    ('nRes', c_uint * 8),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_CC_CONTRAST_PARAM_T = _MV_CC_CONTRAST_PARAM_T_

# \~chinese 枚举类型条目          \~english Enumeration Entry
class _MVCC_ENUMENTRY_T(Structure):
    pass
_MVCC_ENUMENTRY_T._fields_ = [
    ('nValue', c_uint),                             # < \~chinese 指定值               \~english Value
    ('chSymbolic', c_char * MV_MAX_SYMBOLIC_LEN),  # < \~chinese 指定值对应的符号       \~english Symbolic

    ('nReserved', c_uint * 4),                      # < \~chinese 预留                 \~english Reserved bytes
]
MVCC_ENUMENTRY = _MVCC_ENUMENTRY_T

# \~chinese 辅助线颜色                \~english Color of Auxiliary Line
class _MVCC_COLORF(Structure):
    pass
_MVCC_COLORF._fields_ = [
    ('fR', c_float),
    # < \~chinese 红色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度   \~english Red，Range[0.0, 1.0]
    ('fG', c_float),
    # < \~chinese 绿色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度   \~english Green，Range[0.0, 1.0]
    ('fB', c_float),
    # < \~chinese 蓝色，根据像素颜色的相对深度，范围为[0.0 , 1.0]，代表着[0, 255]的颜色深度   \~english Blue，Range[0.0, 1.0]
    ('fAlpha', c_float),
    # < \~chinese 透明度，根据像素颜色的相对透明度，范围为[0.0 , 1.0] (此参数功能暂不支持)    \~english Alpha，Range[0.0, 1.0](Not Support)
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                            \~english Reserved bytes
]
MVCC_COLORF = _MVCC_COLORF

# \~chinese 自定义点                    \~english Point defined
class _MVCC_POINTF(Structure):
    pass
_MVCC_POINTF._fields_ = [
    ('fX', c_float),
    # < \~chinese 该点距离图像左边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Left，Range[0.0, 1.0]
    ('fY', c_float),
    # < \~chinese 该点距离图像上边缘距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Top，Range[0.0, 1.0]
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                 \~english Reserved bytes
]
MVCC_POINTF = _MVCC_POINTF

# \~chinese 矩形框区域信息            \~english Rect Area Info
class _MVCC_RECT_INFO(Structure):
    pass
_MVCC_RECT_INFO._fields_ = [
    ('fTop', c_float),
    # < \~chinese 矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Top，Range[0, 1.0]
    ('fBottom', c_float),
    # < \~chinese 矩形下边缘距离图像下边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Bottom，Range[0, 1.0]
    ('fLeft', c_float),
    # < \~chinese 矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Left，Range[0, 1.0]
    ('fRight', c_float),
    # < \~chinese 矩形右边缘距离图像右边缘的距离，根据图像的相对位置，范围为[0.0 , 1.0]   \~english Distance From Right，Range[0, 1.0]
    ('stColor', MVCC_COLORF),      # < \~chinese 辅助线颜色信息                \~english Color of Auxiliary Line
    ('nLineWidth', c_uint),        # < \~chinese 辅助线宽度，宽度只能是1或2      \~english Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                     \~english Reserved bytes
]
MVCC_RECT_INFO = _MVCC_RECT_INFO

# \~chinese 圆形框区域信息            \~english Circle Area Info
class _MVCC_CIRCLE_INFO(Structure):
    pass
_MVCC_CIRCLE_INFO._fields_ = [
    ('stCenterPoint', MVCC_POINTF),  # < \~chinese 圆心信息                   \~english Circle Point Info
    ('fR1', c_float),
    # < \~chinese 宽向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错  \~english Width Radius, Range[0, 1.0]
    ('fR2', c_float),
    # < \~chinese高向半径，根据图像的相对位置[0, 1.0]，半径与圆心的位置有关，需保证画出的圆在显示框范围之内，否则报错  \~english Height Radius, Range[0, 1.0]
    ('stColor', MVCC_COLORF),      # < \~chinese 辅助线颜色信息                \~english Color of Auxiliary Line
    ('nLineWidth', c_uint),        # < \~chinese 辅助线宽度，宽度只能是1或2      \~english Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节                     \~english Reserved bytes
]
MVCC_CIRCLE_INFO = _MVCC_CIRCLE_INFO

# \~chinese 线条辅助线信息    \~english Linear Auxiliary Line Info
class _MVCC_LINES_INFO(Structure):
    pass
_MVCC_LINES_INFO._fields_ = [
    ('stStartPoint', MVCC_POINTF), # < \~chinese 线条辅助线的起始点坐标         \~english The Start Point of Auxiliary Line
    ('stEndPoint', MVCC_POINTF),   # < \~chinese线条辅助线的终点坐标            \~english The End Point of Auxiliary Line
    ('stColor', MVCC_COLORF),      # < \~chinese 辅助线颜色信息                \~english Color of Auxiliary Line
    ('nLineWidth', c_uint),        # < \~chinese 辅助线宽度，宽度只能是1或2      \~english Width of Auxiliary Line, width is 1 or 2
    ('nReserved', c_uint * 4),     # < \~chinese 保留字节             \~english Reserved bytes
]
MVCC_LINES_INFO = _MVCC_LINES_INFO

# \~chinese 图像重构后的图像列表      \~english List of images after image reconstruction
class _MV_OUTPUT_IMAGE_INFO_(Structure):
    pass
_MV_OUTPUT_IMAGE_INFO_._fields_ = [
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式               \~english pixel format
    ('pBuf', POINTER(c_ubyte)),      # < \~chinese 输出数据缓存          \~english Output data buffer
    ('nBufLen', c_uint),             # < \~chinese 输出数据长度          \~english Output data length
    ('nBufSize', c_uint),            # < \~chinese  提供的输出缓冲区大小  \~english Provided output buffer size
    ('nRes', c_uint * 8),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_OUTPUT_IMAGE_INFO = _MV_OUTPUT_IMAGE_INFO_

# \~chinese 重构图像参数信息      \~english Restructure image parameters
class _MV_RECONSTRUCT_IMAGE_PARAM_(Structure):
    pass
_MV_RECONSTRUCT_IMAGE_PARAM_._fields_ = [
    ('nWidth', c_uint),                 # < \~chinese 图像宽                \~english Image Width
    ('nHeight', c_uint),                # < \~chinese 图像高                \~english Image Height
    ('enPixelType', MvGvspPixelType),   # < \~chinese 像素格式               \~english pixel format
    ('pSrcData', POINTER(c_ubyte)),      # < \~chinese 输入数据缓存           \~english input data buffer
    ('nSrcDataLen', c_uint),             # < \~chinese 输入数据大小            \~english input data size
    ('nExposureNum', c_uint),            # < \~chinese  曝光个数(1-8]     \~english Exposure number
    ('enReconstructMethod', MV_IMAGE_RECONSTRUCTION_METHOD),   # < \~chinese 图像重构方式      \~english Image restructuring method
    ('stDstBufList', MV_OUTPUT_IMAGE_INFO * MV_MAX_SPLIT_NUM),  # < \~chinese 输出数据缓存信息  \~english Output data info
    ('nRes', c_uint * 4),                 # < \~chinese 保留字节             \~english Reserved bytes
]
MV_RECONSTRUCT_IMAGE_PARAM = _MV_RECONSTRUCT_IMAGE_PARAM_

# \~chinese 文件存取                  \~english File Access
class _MV_CC_FILE_ACCESS_E(Structure):
    pass
_MV_CC_FILE_ACCESS_E._fields_ = [
    ('pUserFileBuf', POINTER(c_char)),  # < \~chinese 用户文件数据        \~english User file data
    ('pFileBufSize', c_uint),  # < \~chinese 用户数据缓存大小       \~english data buffer size
    ('pFileBufLen', c_uint),   # < \~chinese 用户数据缓存长度       \~english data buffer len
    ('pDevFileName', STRING),           # < \~chinese 设备文件名          \~english Device file name
    ('nReserved', c_uint * 32),         # < \~chinese 保留字节            \~english Reserved bytes
]
MV_CC_FILE_ACCESS_EX = _MV_CC_FILE_ACCESS_E

# 采集卡信息            \~english Interface information
class _MV_INTERFACE_INFO_(Structure):
    pass
_MV_INTERFACE_INFO_._fields_ = [
    ('nTLayerType', c_uint),               # < \~chinese 采集卡类型    \~english Interface type
    ('nPCIEInfo', c_uint),                 # < \~chinese 采集卡的PCIE插槽信息  \~english PCIe slot information of interface
    ('chInterfaceID', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 采集卡ID    \~english Interface ID
    ('chDisplayName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 显示名称    \~english Display name
    ('chSerialNumber', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 序列号      \~english Serial number
    ('chModelName', c_ubyte * INFO_MAX_BUFFER_SIZE),     # < \~chinese 型号        \~english model name
    ('chManufacturer', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 厂商        \~english manufacturer name
    ('chDeviceVersion', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 版本号      \~english device version
    ('chUserDefinedName', c_ubyte * INFO_MAX_BUFFER_SIZE),  # < \~chinese 自定义名称 \~english user defined name
    ('nReserved', c_uint * 64),                             # < \~chinese 保留字节   \~english Reserved bytes
]
MV_INTERFACE_INFO = _MV_INTERFACE_INFO_

# 采集卡信息列表           \~english Interface Information List
class _MV_INTERFACE_INFO_LIST_(Structure):
    pass
_MV_INTERFACE_INFO_LIST_._fields_ = [
    ('nInterfaceNum', c_uint),                                          # < \~chinese 在线设备数量         \~english Online Device Number
    ('pInterfaceInfos', POINTER(MV_INTERFACE_INFO) * MV_MAX_INTERFACE_NUM), # < \~chinese 支持最多256个设备    \~english Support up to 256 devices
]
MV_INTERFACE_INFO_LIST = _MV_INTERFACE_INFO_LIST_

# 串口信息      \~english Serial Port Info
class _MV_CAML_SERIAL_PORT_(Structure):
    pass
_MV_CAML_SERIAL_PORT_._fields_ = [
    ('chSerialPort', c_char * INFO_MAX_BUFFER_SIZE),   # < \~chinese 串口号          \~english Serial Port
    ('nRes', c_uint * 4),                              # < \~chinese 保留字节        \~english Reserved bytes
]
MV_CAML_SERIAL_PORT = _MV_CAML_SERIAL_PORT_

# 本机串口列表            \~english serial port list
class _MV_CAML_SERIAL_PORT_LIST_(Structure):
    pass
_MV_CAML_SERIAL_PORT_LIST_._fields_ = [
    ('nSerialPortNum', c_uint),                                      # < \~chinese 串口数量   \~english Serial Port Num
    ('stSerialPort', MV_CAML_SERIAL_PORT * MV_MAX_SERIAL_PORT_NUM),  # < \~chinese 串口信息   \~english Serial Port Information
    ('nRes', c_uint * 4),  # < \~chinese 保留字节   \~english Reserved bytes
]
MV_CAML_SERIAL_PORT_LIST = _MV_CAML_SERIAL_PORT_LIST_

__all__ = ['_MV_ALL_MATCH_INFO_', 'MV_CC_FILE_ACCESS_PROGRESS',
           'N19_MV_CC_DEVICE_INFO_3DOT_0E', 'MV_FRAME_OUT',
           'MV_CAM_GAIN_MODE',
           'MV_ALL_MATCH_INFO',
           'MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV',
           'MV_TRIGGER_SOURCE_LINE0', 'MV_PointCloudFile_Undefined',
           'MV_TRIGGER_SOURCE_LINE2', 'MV_TRIGGER_SOURCE_LINE3',
           'AM_CycleDetect',
           'MV_GrabStrategy_UpcomingImage', 'IFT_IFloat',
           'MV_EVENT_OUT_INFO', 'MV_TRANSMISSION_TYPE',
           'uint_fast16_t', 'MV_CHUNK_DATA_CONTENT','MV_ACTION_CMD_RESULT',
           'MV_CC_INPUT_FRAME_INFO',
           '_MV_ACTION_CMD_RESULT_T',
           'AM_RO', 'IFT_IPort', 'uint_least16_t',
           '_MV_FRAME_OUT_INFO_EX_', '_MV_TRANSMISSION_TYPE_T',
           'MV_SAVE_IMAGE_PARAM_EX', 'MV_SAVE_IMAGE_PARAM_EX3', 'AM_RW', 'MV_XML_InterfaceType',
           'int32_t', '_MV_ACTION_CMD_INFO_T', 'intptr_t',
           'uint_least64_t', '_MV_NETTRANS_INFO_',
           '_MV_CAM_TRIGGER_MODE_', 'int_least32_t',
           'MV_GIGE_TRANSTYPE_SUBNETBROADCAST',
           'MV_SAVE_POINT_CLOUD_FILE_TYPE',
           'MV_ACTION_CMD_RESULT_LIST',
           'MV_BALANCEWHITE_AUTO_CONTINUOUS',
           '_MV_CHUNK_DATA_CONTENT_', 'MV_FormatType_AVI',
           '_MV_CC_PIXEL_CONVERT_PARAM_T_','_MV_PIXEL_CONVERT_PARAM_EX_T_',
           'MV_GENTL_IF_INFO',
           'MV_ACQ_MODE_SINGLE',
           'MV_TRIGGER_MODE_ON',
           'int_least16_t', 'N22_MV_FRAME_OUT_INFO_EX_3DOT_1E',
           'MV_GIGE_TRANSTYPE_LIMITEDBROADCAST', 'int_fast32_t',
           '_MV_CAM_GAIN_MODE_',
           'MV_RECORD_FORMAT_TYPE', 'MV_CC_DEVICE_INFO',
           'IFT_ICommand', '_MV_RECORD_FORMAT_TYPE_',
           '_MV_CAM_ACQUISITION_MODE_',
           '_MVCC_STRINGVALUE_T',
           'MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV',
           '_MV_MATCH_INFO_NET_DETECT_', 'MVCC_INTVALUE',
           'MV_PointCloudFile_OBJ', '_MV_GIGE_TRANSMISSION_TYPE_',
           '_MV_CC_RECORD_PARAM_T_',
           '_MV_GENTL_IF_INFO_', 'MV_EXPOSURE_MODE_TIMED', 'intmax_t',
           'int16_t',
           'MV_DISPLAY_FRAME_INFO', '_MV_CC_FILE_ACCESS_PROGRESS_T',
           '_MV_GRAB_STRATEGY_', '_MV_SAVE_IMG_TO_FILE_PARAM_', '_MV_SAVE_IMAGE_TO_FILE_PARAM_EX_',
           'int_fast64_t',
           'MV_XML_AccessMode',
           'MV_GAIN_MODE_ONCE', 'IFT_IInteger',
           'MV_CAM_BALANCEWHITE_AUTO', 'int_least8_t',
           'MV_PointCloudFile_CSV', 'IFT_IBase',
           'MV_TRIGGER_MODE_OFF', 'MV_Image_Bmp',
           '_MV_GENTL_DEV_INFO_', 'MV_CC_FILE_ACCESS',
           '_MV_CAM_EXPOSURE_AUTO_MODE_',
           'uint_least8_t',
           'MV_ACTION_CMD_INFO',
           '_MV_CC_INPUT_FRAME_INFO_T_',
           'MV_GENTL_DEV_INFO_LIST', '_MV_CAM_TRIGGER_SOURCE_',
           'MV_GRAB_STRATEGY',
           'IFT_IEnumeration', 'uint64_t', 'uint8_t',
           '_MV_GENTL_DEV_INFO_LIST_',
           'MV_CAM_GAMMA_SELECTOR',
           'MV_CamL_DEV_INFO', 'MV_GENTL_IF_INFO_LIST',
           'MV_CAM_TRIGGER_MODE', 'MV_GIGE_TRANSTYPE_MULTICAST',
           'uint16_t', 'uint_fast8_t',
           '_MV_ACTION_CMD_RESULT_LIST_T',
           '_MV_MATCH_INFO_USB_DETECT_',
           '_MVCC_ENUMVALUE_T',
           'MV_SAVE_POINT_CLOUD_PARAM', '_MV_CC_DEVICE_INFO_',
           'IFT_IBoolean',
           'MV_MATCH_INFO_USB_DETECT', 'MV_PointCloudFile_PLY',
           'MVCC_ENUMVALUE',
           'IFT_IString',
           'MV_ACQ_MODE_CONTINUOUS',
           'MV_TRIGGER_SOURCE_FrequencyConverter',
           'MV_TRIGGER_SOURCE_COUNTER0',
           'MV_GAIN_MODE_OFF', '_MV_CC_DEVICE_INFO_LIST_',
           'MV_GIGE_DEVICE_INFO', '_MV_SAVE_IMAGE_PARAM_T_EX_', '_MV_SAVE_IMAGE_PARAM_EX3_',
           'AM_NA', 'uint_least32_t',
           'MV_CC_PIXEL_CONVERT_PARAM', 'MV_CC_PIXEL_CONVERT_PARAM_EX','AM_NI',
           '_MVCC_INTVALUE_EX_T', 'uintptr_t', 'MV_Image_Tif',
           'MVCC_FLOATVALUE', 'MV_GIGE_TRANSTYPE_CAMERADEFINED',
           '_MV_GENTL_IF_INFO_LIST_', 'MV_NETTRANS_INFO',
           'IFT_IRegister', 'MV_GIGE_TRANSMISSION_TYPE',
           'MV_EXPOSURE_AUTO_MODE_ONCE', 'MV_GIGE_TRANSTYPE_UNICAST',
           'int8_t', '_MV_GIGE_DEVICE_INFO_', 'IFT_IValue', 'AM_WO',
           'int_fast8_t',
           'MV_GAMMA_SELECTOR_SRGB','int_least64_t',
           'MV_GrabStrategy_LatestImagesOnly',
           'MV_EXPOSURE_AUTO_MODE_OFF', 'MV_CAM_EXPOSURE_AUTO_MODE',
           'MV_EXPOSURE_AUTO_MODE_CONTINUOUS',
           'MV_CAM_ACQUISITION_MODE', 'AM_Undefined',
           'MV_MATCH_INFO_NET_DETECT',
           '_MV_CC_FILE_ACCESS_T',
           '_MV_DISPLAY_FRAME_INFO_','MV_GrabStrategy_OneByOne',
           'MV_TRIGGER_SOURCE_SOFTWARE', 'MV_FormatType_Undefined',
           'MV_BALANCEWHITE_AUTO_ONCE',
           'uintmax_t', 'int_fast16_t',
           '_MV_CAM_EXPOSURE_MODE_','MV_BALANCEWHITE_AUTO_OFF',
           'int64_t', 'MV_Image_Undefined', 'MV_GAIN_MODE_CONTINUOUS',
           'uint_fast32_t',
           'MV_CAM_TRIGGER_SOURCE', 'MV_GrabStrategy_LatestImages',
           'MV_Image_Png',
           'MV_Image_Jpeg', '_MV_CamL_DEV_INFO_',
           '_MVCC_FLOATVALUE_T',
           'MV_FRAME_OUT_INFO_EX', '_MV_SAVE_POINT_CLOUD_PARAM_',
           '_MV_CAM_BALANCEWHITE_AUTO_', 'MV_CC_RECORD_PARAM',
           '_MV_USB3_DEVICE_INFO_',
           'MVCC_INTVALUE_EX', 'MV_EXPOSURE_MODE_TRIGGER_WIDTH',
           'MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT',
           'MV_SAVE_IAMGE_TYPE','MV_GENTL_DEV_INFO',
           'MV_CAM_EXPOSURE_MODE',
           'MVCC_STRINGVALUE',
           'MvGvspPixelType',
           'MV_CC_DEVICE_INFO_LIST',
           'MV_TRIGGER_SOURCE_LINE1',
           'uint_fast64_t','_MVCC_INTVALUE_T',
           'IFT_ICategory',
           'MV_SAVE_IMG_TO_FILE_PARAM', 'MV_SAVE_IMAGE_TO_FILE_PARAM_EX', '_MV_FRAME_OUT_',
           'MV_GAMMA_SELECTOR_USER',
           'uint32_t', '_MV_CAM_GAMMA_SELECTOR_', 'MV_ACQ_MODE_MUTLI',
           'MV_USB3_DEVICE_INFO', '_MV_EVENT_OUT_INFO_', 'MV_CC_FRAME_SPEC_INFO', 'MV_CC_HB_DECODE_PARAM',
           'MV_SORT_METHOD', '_MV_SORT_METHOD_',
           'SortMethod_SerialNumber', 'SortMethod_UserID', 'SortMethod_CurrentIP_ASC', 'SortMethod_CurrentIP_DESC',
           '_MV_IMG_ROTATION_ANGLE_', 'MV_IMG_ROTATION_ANGLE',
           'MV_IMAGE_ROTATE_90', 'MV_IMAGE_ROTATE_180', 'MV_IMAGE_ROTATE_270',
           '_MV_IMG_FLIP_TYPE_', 'MV_IMG_FLIP_TYPE', 'MV_FLIP_VERTICAL', 'MV_FLIP_HORIZONTAL',
           '_MV_CC_GAMMA_TYPE_', 'MV_CC_GAMMA_TYPE', 'MV_CC_GAMMA_TYPE_NONE', 'MV_CC_GAMMA_TYPE_VALUE',
           'MV_CC_GAMMA_TYPE_USER_CURVE', 'MV_CC_GAMMA_TYPE_LRGB2SRGB', 'MV_CC_GAMMA_TYPE_SRGB2LRGB',
           'MV_CC_STREAM_EXCEPTION_TYPE', '_MV_CC_STREAM_EXCEPTION_TYPE_',
           'MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE', 'MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW',
           'MV_CC_STREAM_EXCEPTION_LIST_EMPTY', 'MV_CC_STREAM_EXCEPTION_RECONNECTION',
           'MV_CC_STREAM_EXCEPTION_DISCONNECTED', 'MV_CC_STREAM_EXCEPTION_DEVICE', 
           '_MV_IMAGE_RECONSTRUCTION_METHOD_', 'MV_IMAGE_RECONSTRUCTION_METHOD', 'MV_SPLIT_BY_LINE',
           'MVCC_COLORF', '_MVCC_COLORF', '_MVCC_POINTF', 'MVCC_POINTF', '_MVCC_RECT_INFO', 'MVCC_RECT_INFO',
           '_MVCC_CIRCLE_INFO', 'MVCC_CIRCLE_INFO', '_MVCC_LINES_INFO', 'MVCC_LINES_INFO', '_MV_OUTPUT_IMAGE_INFO_',
           'MV_OUTPUT_IMAGE_INFO', 'MV_RECONSTRUCT_IMAGE_PARAM', '_MV_RECONSTRUCT_IMAGE_PARAM_',
           '_MVCC_ENUMENTRY_T', 'MVCC_ENUMENTRY','_MV_CC_CONTRAST_PARAM_T_', 'MV_CC_CONTRAST_PARAM_T',
           '_MV_CC_CCM_PARAM_EX_T_', 'MV_CC_CCM_PARAM_EX', 'MV_CC_CCM_PARAM', '_MV_CC_CCM_PARAM_T_',
           'MV_CC_GAMMA_PARAM', '_MV_CC_GAMMA_PARAM_T_', 'MV_CC_FLIP_IMAGE_PARAM', '_MV_CC_FLIP_IMAGE_PARAM_T_',
           '_MV_CC_ROTATE_IMAGE_PARAM_T_', 'MV_CC_ROTATE_IMAGE_PARAM', 'MV_CC_FILE_ACCESS_EX', '_MV_CC_FILE_ACCESS_E',
           '_MV_DISPLAY_FRAME_INFO_EX_', 'MV_DISPLAY_FRAME_INFO_EX', 'MV_CML_DEVICE_INFO', '_MV_CML_DEVICE_INFO_',
           'MV_CXP_DEVICE_INFO', '_MV_CXP_DEVICE_INFO_', '_MV_XOF_DEVICE_INFO_', 'MV_XOF_DEVICE_INFO',
           '_MV_INTERFACE_INFO_LIST_', 'MV_INTERFACE_INFO_LIST', '_MV_INTERFACE_INFO_', 'MV_INTERFACE_INFO',
           '_MV_CAML_SERIAL_PORT_LIST_', 'MV_CAML_SERIAL_PORT_LIST', '_MV_CAML_SERIAL_PORT_', 'MV_CAML_SERIAL_PORT']


**System:** # -- coding: utf-8 --

import sys
import copy
import ctypes

from ctypes import *

from PixelType_header import *
from CameraParams_const import *
from CameraParams_header import *
from MvErrorDefine_const import *

# Python3.8版本修改Dll加载策略, 默认不再搜索Path环境变量, 同时增加winmode参数以兼容旧版本
dllname = "MvCameraControl.dll"
if "winmode" in ctypes.WinDLL.__init__.__code__.co_varnames:
    MvCamCtrldll = WinDLL(dllname, winmode=0)
else:
    MvCamCtrldll = WinDLL(dllname)


# 用于回调函数传入相机实例
class _MV_PY_OBJECT_(Structure):
    pass


_MV_PY_OBJECT_._fields_ = [
    ('PyObject', py_object),
]
MV_PY_OBJECT = _MV_PY_OBJECT_


class MvCamera():

    def __init__(self):
        self._handle = c_void_p()  # 记录当前连接设备的句柄
        self.handle = pointer(self._handle)  # 创建句柄指针

    '''
    Part1 ch: 相机的控制和取流接口 | en: Camera control and streaming
    '''

    # ch:初始化SDK | en: Initialize SDK
    @staticmethod
    def MV_CC_Initialize():
        MvCamCtrldll.MV_CC_Initialize.restype = c_int
        # C原型：int __stdcall MV_CC_Initialize();
        return MvCamCtrldll.MV_CC_Initialize()

    # ch:反初始化SDK | en: Finalize SDK
    @staticmethod
    def MV_CC_Finalize():
        MvCamCtrldll.MV_CC_Finalize.restype = c_int
        # C原型：int __stdcall MV_CC_Finalize();
        return MvCamCtrldll.MV_CC_Finalize()

    # ch:获取SDK版本号 | en:Get SDK Version
    @staticmethod
    def MV_CC_GetSDKVersion():
        MvCamCtrldll.MV_CC_GetSDKVersion.restype = c_uint
        # C原型：unsigned int __stdcall MV_CC_GetSDKVersion();
        return MvCamCtrldll.MV_CC_GetSDKVersion()

    # ch:获取支持的传输层 | en:Get supported Transport Layer
    @staticmethod
    def MV_CC_EnumerateTls():
        MvCamCtrldll.MV_CC_EnumerateTls.restype = c_uint
        # C原型：int __stdcall MV_CC_EnumerateTls();
        return MvCamCtrldll.MV_CC_EnumerateTls()

    # ch:枚举设备 | en:Enumerate Device
    @staticmethod
    def MV_CC_EnumDevices(nTLayerType, stDevList):
        MvCamCtrldll.MV_CC_EnumDevices.argtype = (c_uint, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevices.restype = c_uint
        # C原型:int __stdcall MV_CC_EnumDevices(unsigned int nTLayerType, MV_CC_DEVICE_INFO_LIST* pstDevList)
        return MvCamCtrldll.MV_CC_EnumDevices(c_uint(nTLayerType), byref(stDevList))

    # ch:根据厂商名字枚举设备 | en:Enumerate device according to manufacture name
    @staticmethod
    def MV_CC_EnumDevicesEx(nTLayerType, stDevList, strManufacturerName):
        MvCamCtrldll.MV_CC_EnumDevicesEx.argtype = (c_uint, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevicesEx.restype = c_uint
        # C原型:int __stdcall MV_CC_EnumDevicesEx(IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST* pstDevList,
        #                                         IN const char* strManufacturerName);
        return MvCamCtrldll.MV_CC_EnumDevicesEx(c_uint(nTLayerType), byref(stDevList),
                                                strManufacturerName.encode('ascii'))

    # ch:枚举设备扩展（可指定排序方式枚举、根据厂商名字过滤） | en: Enumerate device according to the specified ordering
    @staticmethod
    def MV_CC_EnumDevicesEx2(nTLayerType, stDevList, strManufacturerName, enSortMethod):
        MvCamCtrldll.MV_CC_EnumDevicesEx2.argtype = (c_uint, c_void_p, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_EnumDevicesEx2.restype = c_uint
        # C原型:int __stdcall MV_CC_EnumDevicesEx2(IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST* pstDevList,
        #                                          IN const char* strManufacturerName, IN MV_SORT_METHOD enSortMethod);
        return MvCamCtrldll.MV_CC_EnumDevicesEx2(c_uint(nTLayerType), byref(stDevList),
                                                 strManufacturerName.encode('ascii'), c_uint(enSortMethod))

    # ch:设备是否可达 | en:Is the device accessible
    @staticmethod
    def MV_CC_IsDeviceAccessible(stDevInfo, nAccessMode):
        MvCamCtrldll.MV_CC_IsDeviceAccessible.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_IsDeviceAccessible.restype = c_uint
        # C原型：bool __stdcall MV_CC_IsDeviceAccessible(IN MV_CC_DEVICE_INFO* pstDevInfo, IN unsigned int nAccessMode);
        return MvCamCtrldll.MV_CC_IsDeviceAccessible(byref(stDevInfo), nAccessMode)

    # ch:枚举采集卡 | en:Enumerate frame grabbers
    @staticmethod
    def MV_CC_EnumInterfaces(nTLayerType, stInterfaceInfoList):
        MvCamCtrldll.MV_CC_EnumInterfaces.argtype = (c_uint, c_void_p)
        MvCamCtrldll.MV_CC_EnumInterfaces.restype = c_uint
        # C原型：bool __stdcall MV_CC_EnumInterfaces(IN unsigned int nTLayerType,
        #                                           IN OUT MV_INTERFACE_INFO_LIST* pInterfaceInfoList);
        return MvCamCtrldll.MV_CC_EnumInterfaces(c_uint(nTLayerType), byref(stInterfaceInfoList))

    # ch:创建采集卡句柄 | en:Create frame grabber handle
    def MV_CC_CreateInterface(self, stInterfaceInfo):
        MvCamCtrldll.MV_CC_CreateInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_CreateInterface.restype = c_uint
        # C原型：MV_CC_CreateInterface(IN OUT void ** handle, IN MV_INTERFACE_INFO* pInterfaceInfo);
        return MvCamCtrldll.MV_CC_CreateInterface(byref(self.handle), byref(stInterfaceInfo))

    # ch:通过采集卡ID创建采集卡句柄 | en:Create frame grabber handle by frame grabber ID
    def MV_CC_CreateInterfaceByID(self, InterfaceID):
        MvCamCtrldll.MV_CC_CreateInterfaceByID.argtype = c_void_p
        MvCamCtrldll.MV_CC_CreateInterfaceByID.restype = c_uint
        # C原型：MV_CC_CreateInterfaceByID(IN OUT void ** handle, IN char* pInterfaceID);
        return MvCamCtrldll.MV_CC_CreateInterfaceByID(byref(self.handle), InterfaceID.encode('ascii'))

    # ch:打开采集卡 | en:Open frame grabber
    def MV_CC_OpenInterface(self):
        MvCamCtrldll.MV_CC_OpenInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_OpenInterface.restype = c_uint
        # C原型：int __stdcall MV_CC_OpenInterface(IN void* handle, IN char* pReserved);
        return MvCamCtrldll.MV_CC_OpenInterface(self.handle, 0)

    # ch:关闭采集卡 | en:Close frame grabber
    def MV_CC_CloseInterface(self):
        MvCamCtrldll.MV_CC_CloseInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_CloseInterface.restype = c_uint
        # C原型：int __stdcall MV_CC_CloseInterface(IN void* handle);
        return MvCamCtrldll.MV_CC_CloseInterface(self.handle)

    # ch:销毁采集卡句柄 | en:Destroy frame grabber handle
    def MV_CC_DestroyInterface(self):
        MvCamCtrldll.MV_CC_DestroyInterface.argtype = c_void_p
        MvCamCtrldll.MV_CC_DestroyInterface.restype = c_uint
        # C原型：int __stdcall MV_CC_DestroyInterface(IN void* handle);
        return MvCamCtrldll.MV_CC_DestroyInterface(self.handle)

    # ch:通过采集卡句柄枚举设备 | en:Enumerate Devices with interface handle
    def MV_CC_EnumDevicesByInterface(self, stDevList):
        MvCamCtrldll.MV_CC_EnumDevicesByInterface.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevicesByInterface.restype = c_uint
        # C原型：int MV_CC_EnumDevicesByInterface(IN void* handle, OUT MV_CC_DEVICE_INFO_LIST* pstDevList)
        return MvCamCtrldll.MV_CC_EnumDevicesByInterface(self.handle, byref(stDevList))

    # ch: 设置SDK日志路径 | en: Set SDK log path
    def MV_CC_SetSDKLogPath(self, SDKLogPath):
        MvCamCtrldll.MV_CC_SetSDKLogPath.argtype = c_void_p
        MvCamCtrldll.MV_CC_SetSDKLogPath.restype = c_uint
        # C原型:int MV_CC_SetSDKLogPath(IN const char * strSDKLogPath);
        return MvCamCtrldll.MV_CC_SetSDKLogPath(SDKLogPath.encode('ascii'))

    # ch:创建设备句柄 | en:Create Device Handle
    def MV_CC_CreateHandle(self, stDevInfo):
        MvCamCtrldll.MV_CC_CreateHandle.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_CreateHandle.restype = c_uint
        # C原型:int MV_CC_CreateHandle(void ** handle, MV_CC_DEVICE_INFO* pstDevInfo)
        return MvCamCtrldll.MV_CC_CreateHandle(byref(self.handle), byref(stDevInfo))

    # ch:创建句柄（不生成日志） | en:Create Device Handle without log
    def MV_CC_CreateHandleWithoutLog(self, stDevInfo):
        MvCamCtrldll.MV_CC_CreateHandleWithoutLog.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_CreateHandleWithoutLog.restype = c_uint
        # C原型:int MV_CC_CreateHandleWithoutLog(void ** handle, MV_CC_DEVICE_INFO* pstDevInfo)
        return MvCamCtrldll.MV_CC_CreateHandleWithoutLog(byref(self.handle), byref(stDevInfo))

    # ch:销毁设备句柄 | en:Destroy Device Handle
    def MV_CC_DestroyHandle(self):
        MvCamCtrldll.MV_CC_DestroyHandle.argtype = c_void_p
        MvCamCtrldll.MV_CC_DestroyHandle.restype = c_uint
        return MvCamCtrldll.MV_CC_DestroyHandle(self.handle)

    # ch:打开设备 | en:Open Device
    def MV_CC_OpenDevice(self, nAccessMode=MV_ACCESS_Exclusive, nSwitchoverKey=0):
        MvCamCtrldll.MV_CC_OpenDevice.argtype = (c_void_p, c_uint32, c_uint16)
        MvCamCtrldll.MV_CC_OpenDevice.restype = c_uint
        # C原型:int MV_CC_OpenDevice(void* handle, unsigned int nAccessMode, unsigned short nSwitchoverKey)
        return MvCamCtrldll.MV_CC_OpenDevice(self.handle, nAccessMode, nSwitchoverKey)

    # ch:关闭设备 | en:Close Device
    def MV_CC_CloseDevice(self):
        MvCamCtrldll.MV_CC_CloseDevice.argtype = c_void_p
        MvCamCtrldll.MV_CC_CloseDevice.restype = c_uint
        return MvCamCtrldll.MV_CC_CloseDevice(self.handle)

    # ch:判断设备是否处于连接状态 | en: Is The Device Connected
    def MV_CC_IsDeviceConnected(self):
        MvCamCtrldll.MV_CC_IsDeviceConnected.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_IsDeviceConnected.restype = c_bool
        # C原型：bool __stdcall MV_CC_IsDeviceConnected(IN void* handle);
        return MvCamCtrldll.MV_CC_IsDeviceConnected(self.handle)

    # ch:注册图像数据回调 | en:Register the image callback function
    def MV_CC_RegisterImageCallBackEx(self, CallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterImageCallBackEx.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterImageCallBackEx.restype = c_uint
        # C原型:int MV_CC_RegisterImageCallBackEx(void* handle,
        #                        void(* cbOutput)(unsigned char * pData, MV_FRAME_OUT_INFO_EX* pFrameInfo, void* pUser),
        #                        void* pUser);
        return MvCamCtrldll.MV_CC_RegisterImageCallBackEx(self.handle, CallBackFun, pUser)

    # ch:注册取流回调 | en:Register the image callback function
    def MV_CC_RegisterImageCallBackForRGB(self, CallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterImageCallBackForRGB.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterImageCallBackForRGB.restype = c_uint
        # C原型:int MV_CC_RegisterImageCallBackForRGB(void* handle,
        #                        void(* cbOutput)(unsigned char * pData, MV_FRAME_OUT_INFO_EX* pFrameInfo, void* pUser),
        #                        void* pUser);
        return MvCamCtrldll.MV_CC_RegisterImageCallBackForRGB(self.handle, CallBackFun, pUser)

    # ch:注册取流回调 | en:Register the image callback function
    def MV_CC_RegisterImageCallBackForBGR(self, CallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterImageCallBackForBGR.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterImageCallBackForBGR.restype = c_uint
        # C原型:int MV_CC_RegisterImageCallBackForBGR(void* handle,
        #                         void(* cbOutput)(unsigned char * pData,MV_FRAME_OUT_INFO_EX* pFrameInfo, void* pUser),
        #                         void* pUser);
        return MvCamCtrldll.MV_CC_RegisterImageCallBackForBGR(self.handle, CallBackFun, pUser)

    # ch:开始取流 | en:Start Grabbing
    def MV_CC_StartGrabbing(self):
        MvCamCtrldll.MV_CC_StartGrabbing.argtype = c_void_p
        MvCamCtrldll.MV_CC_StartGrabbing.restype = c_uint
        return MvCamCtrldll.MV_CC_StartGrabbing(self.handle)

    # ch:停止取流 | en:Stop Grabbing
    def MV_CC_StopGrabbing(self):
        MvCamCtrldll.MV_CC_StopGrabbing.argtype = c_void_p
        MvCamCtrldll.MV_CC_StopGrabbing.restype = c_uint
        return MvCamCtrldll.MV_CC_StopGrabbing(self.handle)

    # ch:获取一帧RGB数据，此函数为查询式获取，每次调用查询内部缓存有无数据，有数据则获取数据，无数据返回错误码
    # en:Get one frame of RGB data, this function is using query to get data query whether the internal cache has data,
    # get data if there has, return error code if no data
    def MV_CC_GetImageForRGB(self, pData, nDataSize, stFrameInfo, nMsec):
        MvCamCtrldll.MV_CC_GetImageForRGB.argtype = (c_void_p, c_void_p, c_uint, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetImageForRGB.restype = c_uint
        # C原型:int MV_CC_GetImageForRGB(IN void* handle, IN OUT unsigned char * pData , IN unsigned int nDataSize,
        #                               IN OUT MV_FRAME_OUT_INFO_EX* pstFrameInfo, int nMsec);
        return MvCamCtrldll.MV_CC_GetImageForRGB(self.handle, pData, nDataSize, byref(stFrameInfo), nMsec)

    # ch:获取一帧BGR数据，此函数为查询式获取，每次调用查询内部缓存有无数据，有数据则获取数据，无数据返回错误码
    # en:Get one frame of BGR data, this function is using query to get data query whether the internal cache has data,
    # get data if there has, return error code if no data
    def MV_CC_GetImageForBGR(self, pData, nDataSize, stFrameInfo, nMsec):
        MvCamCtrldll.MV_CC_GetImageForBGR.argtype = (c_void_p, c_void_p, c_uint, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetImageForBGR.restype = c_uint
        # C原型:int MV_CC_GetImageForBGR(IN void* handle, IN OUT unsigned char * pData , IN unsigned int nDataSize,
        #                               IN OUT MV_FRAME_OUT_INFO_EX* pstFrameInfo, int nMsec);
        return MvCamCtrldll.MV_CC_GetImageForBGR(self.handle, pData, nDataSize, byref(stFrameInfo), nMsec)

    # ch:使用内部缓存获取一帧图片（与MV_CC_Display不能同时使用）
    # en:Get a frame of an image using an internal cache(Cannot be used together with the interface of MV_CC_Display)
    def MV_CC_GetImageBuffer(self, stFrame, nMsec):
        MvCamCtrldll.MV_CC_GetImageBuffer.argtype = (c_void_p, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetImageBuffer.restype = c_uint
        # C原型:int MV_CC_GetImageBuffer(IN void* handle, OUT MV_FRAME_OUT* pstFrame, IN unsigned int nMsec);
        return MvCamCtrldll.MV_CC_GetImageBuffer(self.handle, byref(stFrame), nMsec)

    # ch:释放图像缓存（与MV_CC_GetImageBuffer配套使用）
    # en:Free image buffer(this interface can free image buffer, used with MV_CC_GetImageBuffer)
    def MV_CC_FreeImageBuffer(self, stFrame):
        MvCamCtrldll.MV_CC_FreeImageBuffer.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FreeImageBuffer.restype = c_uint
        # C原型:int MV_CC_FreeImageBuffer(IN void* handle, IN MV_FRAME_OUT* pstFrame);
        return MvCamCtrldll.MV_CC_FreeImageBuffer(self.handle, byref(stFrame))

    # ch:采用超时机制获取一帧图片，SDK内部等待直到有数据时返回
    # en:Timeout mechanism is used to get image, and the SDK waits inside until the data is returned
    def MV_CC_GetOneFrameTimeout(self, pData, nDataSize, stFrameInfo, nMsec=1000):
        MvCamCtrldll.MV_CC_GetOneFrameTimeout.argtype = (c_void_p, c_void_p, c_uint, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_GetOneFrameTimeout.restype = c_uint
        # C原型:int MV_CC_GetOneFrameTimeout(void* handle, unsigned char * pData , unsigned int nDataSize,
        #                                    MV_FRAME_OUT_INFO_EX* pFrameInfo, unsigned int nMsec)
        return MvCamCtrldll.MV_CC_GetOneFrameTimeout(self.handle, pData, nDataSize, byref(stFrameInfo), nMsec)

    # ch:清除取流数据缓存 | en:if Image buffers has retrieved the data，Clear them
    def MV_CC_ClearImageBuffer(self):
        MvCamCtrldll.MV_CC_ClearImageBuffer.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_ClearImageBuffer.restype = c_uint
        # C原型:int MV_CC_ClearImageBuffer(IN void* handle);
        return MvCamCtrldll.MV_CC_ClearImageBuffer(self.handle)

    # ch:获取当前图像缓存区的有效图像个数 | en: Get the number of valid images in the current image buffer
    def MV_CC_GetValidImageNum(self, nValidImageNum):
        MvCamCtrldll.MV_CC_GetValidImageNum.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetValidImageNum.restype = c_uint
        # C原型:int MV_CC_GetValidImageNum(IN void* handle, OUT unsigned int *pnValidImageNum);
        return MvCamCtrldll.MV_CC_GetValidImageNum(self.handle, byref(nValidImageNum))

    # ch:显示一帧图像
    # en:Display one frame image,the maximum resolution supported is 16384 * 163840
    def MV_CC_DisplayOneFrame(self, stDisplayInfo):
        MvCamCtrldll.MV_CC_DisplayOneFrame.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DisplayOneFrame.restype = c_uint
        # C原型:int MV_CC_DisplayOneFrame(IN void* handle, IN MV_DISPLAY_FRAME_INFO* pstDisplayInfo);
        return MvCamCtrldll.MV_CC_DisplayOneFrame(self.handle, byref(stDisplayInfo))

    # ch:显示一帧图像, 支持RGB8_Packed，BGR8_Packed，Mono8三种像素格式的渲染宽高大小至int类型
    # en:Get a frame of an image using an internal cache
    #    This API support rendering in three pixel formats:RGB8_Packed,BGR8_Packed and Mono8,width and height to int.
    def MV_CC_DisplayOneFrameEx(self, hWnd, stDisplayInfo):
        MvCamCtrldll.MV_CC_DisplayOneFrameEx.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DisplayOneFrameEx.restype = c_uint
        # C原型:int MV_CC_DisplayOneFrameEx(IN void* handle, IN void* hWnd, IN MV_DISPLAY_FRAME_INFO_EX* pstDisplayInfo);
        return MvCamCtrldll.MV_CC_DisplayOneFrameEx(self.handle, hWnd, byref(stDisplayInfo))

    # ch:设置SDK内部图像缓存节点个数，大于等于1，在抓图前调用
    # en:Set the number of the internal image cache nodes in SDK, Greater than or equal to 1,
    # to be called before the capture
    def MV_CC_SetImageNodeNum(self, nNum):
        MvCamCtrldll.MV_CC_SetImageNodeNum.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetImageNodeNum.restype = c_uint
        # C原型:int MV_CC_SetImageNodeNum(IN void* handle, unsigned int nNum);
        return MvCamCtrldll.MV_CC_SetImageNodeNum(self.handle, c_uint(nNum))

    # ch:设置取流策略 | en:Set Grab Strategy
    def MV_CC_SetGrabStrategy(self, enGrabStrategy):
        MvCamCtrldll.MV_CC_SetGrabStrategy.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetGrabStrategy.restype = c_uint
        # C原型:int MV_CC_SetGrabStrategy(IN void* handle, IN MV_GRAB_STRATEGY enGrabStrategy);
        return MvCamCtrldll.MV_CC_SetGrabStrategy(self.handle, c_uint(enGrabStrategy))

    # ch:设置输出缓存个数（只有在MV_GrabStrategy_LatestImages策略下才有效，范围：1-ImageNodeNum）
    # en:Set The Size of Output Queue(Only work under the strategy of MV_GrabStrategy_LatestImages，rang：1-ImageNodeNum)
    def MV_CC_SetOutputQueueSize(self, nOutputQueueSize):
        MvCamCtrldll.MV_CC_SetOutputQueueSize.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetOutputQueueSize.restype = c_uint
        # C原型:int MV_CC_SetOutputQueueSize(IN void* handle, IN unsigned int nOutputQueueSize);
        return MvCamCtrldll.MV_CC_SetOutputQueueSize(self.handle, nOutputQueueSize)

    # ch:获取设备信息，取流之前调用 | en:Get device information
    def MV_CC_GetDeviceInfo(self, stDevInfo):
        MvCamCtrldll.MV_CC_GetDeviceInfo.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetDeviceInfo.restype = c_uint
        # C原型:int MV_CC_GetDeviceInfo(IN void * handle, IN OUT MV_CC_DEVICE_INFO* pstDevInfo);
        return MvCamCtrldll.MV_CC_GetDeviceInfo(self.handle, byref(stDevInfo))

    # ch:获取各种类型的信息 | en:Get various type of information
    def MV_CC_GetAllMatchInfo(self, stInfo):
        MvCamCtrldll.MV_CC_GetAllMatchInfo.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetAllMatchInfo.restype = c_uint
        # C原型:int MV_CC_GetAllMatchInfo(IN void* handle, IN OUT MV_ALL_MATCH_INFO* pstInfo);
        return MvCamCtrldll.MV_CC_GetAllMatchInfo(self.handle, byref(stInfo))

    '''
    Part2 ch: 相机属性万能配置接口 | en: Camera attribute nodes universal interface 
    '''
    # ch:获取Integer属性值 | en:Get Integer value
    def MV_CC_GetIntValueEx(self, strKey, stIntValue):
        MvCamCtrldll.MV_CC_GetIntValueEx.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetIntValueEx.restype = c_uint
        # C原型:int MV_CC_GetIntValueEx(IN void* handle,IN const char* strKey,OUT MVCC_INTVALUE_EX *pstIntValue);
        return MvCamCtrldll.MV_CC_GetIntValueEx(self.handle, strKey.encode('ascii'), byref(stIntValue))

    # ch:设置Integer型属性值 | en:Set Integer value
    def MV_CC_SetIntValueEx(self, strKey, nValue):
        MvCamCtrldll.MV_CC_SetIntValueEx.argtype = (c_void_p, c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetIntValueEx.restype = c_uint
        # C原型:int MV_CC_SetIntValueEx(IN void* handle,IN const char* strKey,IN int64_t nValue);
        return MvCamCtrldll.MV_CC_SetIntValueEx(self.handle, strKey.encode('ascii'), c_uint(nValue))

    # ch:获取Integer型属性值 | en:Get Integer value
    def MV_CC_GetIntValue(self, strKey, stIntValue):
        MvCamCtrldll.MV_CC_GetIntValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetIntValue.restype = c_uint
        # C原型:int MV_CC_GetIntValue(void* handle,char* strKey,MVCC_INTVALUE *pIntValue)
        return MvCamCtrldll.MV_CC_GetIntValue(self.handle, strKey.encode('ascii'), byref(stIntValue))

    # ch:设置Integer型属性值 | en:Set Integer value
    def MV_CC_SetIntValue(self, strKey, nValue):
        MvCamCtrldll.MV_CC_SetIntValue.argtype = (c_void_p, c_void_p, c_uint32)
        MvCamCtrldll.MV_CC_SetIntValue.restype = c_uint
        # C原型:int MV_CC_SetIntValue(void* handle, char* strKey, unsigned int nValue)
        return MvCamCtrldll.MV_CC_SetIntValue(self.handle, strKey.encode('ascii'), c_uint32(nValue))

    # ch:获取Enum属性值 | en:Get Enum value
    def MV_CC_GetEnumValue(self, strKey, stEnumValue):
        MvCamCtrldll.MV_CC_GetEnumValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetEnumValue.restype = c_uint
        # C原型:int MV_CC_GetEnumValue(void* handle,char* strKey,MVCC_ENUMVALUE *pEnumValue)
        return MvCamCtrldll.MV_CC_GetEnumValue(self.handle, strKey.encode('ascii'), byref(stEnumValue))

    # ch:设置Enum型属性值 | en:Set Enum value
    def MV_CC_SetEnumValue(self, strKey, nValue):
        MvCamCtrldll.MV_CC_SetEnumValue.argtype = (c_void_p, c_void_p, c_uint32)
        MvCamCtrldll.MV_CC_SetEnumValue.restype = c_uint
        # C原型:int MV_CC_SetEnumValue(void* handle,char* strKey,unsigned int nValue)
        return MvCamCtrldll.MV_CC_SetEnumValue(self.handle, strKey.encode('ascii'), c_uint32(nValue))

    # ch:获取Enum型节点指定值的符号 | en: Get the symbolic of the specified value of the Enum type node
    def MV_CC_GetEnumEntrySymbolic(self, strKey, stEnumEntry):
        MvCamCtrldll.MV_CC_GetEnumEntrySymbolic.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetEnumEntrySymbolic.restype = c_uint
        # C原型:int MV_CC_GetEnumEntrySymbolic(IN void* handle,IN const char* strKey,
        #                                     IN OUT MVCC_ENUMENTRY* pstEnumEntry);
        return MvCamCtrldll.MV_CC_GetEnumEntrySymbolic(self.handle, strKey.encode('ascii'), byref(stEnumEntry))

    # ch:设置Enum型属性值 | en:Set Enum value
    def MV_CC_SetEnumValueByString(self, strKey, sValue):
        MvCamCtrldll.MV_CC_SetEnumValueByString.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetEnumValueByString.restype = c_uint
        # C原型:int MV_CC_SetEnumValueByString(void* handle,char* strKey,char* sValue)
        return MvCamCtrldll.MV_CC_SetEnumValueByString(self.handle, strKey.encode('ascii'), sValue.encode('ascii'))

    # ch:获取Float型属性值 | en:Get Float value
    def MV_CC_GetFloatValue(self, strKey, stFloatValue):
        MvCamCtrldll.MV_CC_GetFloatValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetFloatValue.restype = c_uint
        # C原型:int MV_CC_GetFloatValue(void* handle,char* strKey,MVCC_FLOATVALUE *pFloatValue)
        return MvCamCtrldll.MV_CC_GetFloatValue(self.handle, strKey.encode('ascii'), byref(stFloatValue))

    # ch:设置Float型属性值 | en:Set float value
    def MV_CC_SetFloatValue(self, strKey, fValue):
        MvCamCtrldll.MV_CC_SetFloatValue.argtype = (c_void_p, c_void_p, c_float)
        MvCamCtrldll.MV_CC_SetFloatValue.restype = c_uint
        # C原型:int MV_CC_SetFloatValue(void* handle,char* strKey,float fValue)
        return MvCamCtrldll.MV_CC_SetFloatValue(self.handle, strKey.encode('ascii'), c_float(fValue))

    # ch:获取Boolean型属性值 | en:Get Boolean value
    def MV_CC_GetBoolValue(self, strKey, BoolValue):
        MvCamCtrldll.MV_CC_GetBoolValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetBoolValue.restype = c_uint
        # C原型:int MV_CC_GetBoolValue(void* handle,char* strKey,bool *pBoolValue)
        return MvCamCtrldll.MV_CC_GetBoolValue(self.handle, strKey.encode('ascii'), byref(BoolValue))

    # ch:设置Boolean型属性值 | en:Set Boolean value
    def MV_CC_SetBoolValue(self, strKey, bValue):
        MvCamCtrldll.MV_CC_SetBoolValue.argtype = (c_void_p, c_void_p, c_bool)
        MvCamCtrldll.MV_CC_SetBoolValue.restype = c_uint
        # C原型:int MV_CC_SetBoolValue(void* handle,char* strKey,bool bValue)
        return MvCamCtrldll.MV_CC_SetBoolValue(self.handle, strKey.encode('ascii'), bValue)

    # ch:获取String型属性值 | en:Get String value
    def MV_CC_GetStringValue(self, strKey, StringValue):
        MvCamCtrldll.MV_CC_GetStringValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetStringValue.restype = c_uint
        # C原型:int MV_CC_GetStringValue(void* handle,char* strKey,MVCC_STRINGVALUE *pStringValue)
        return MvCamCtrldll.MV_CC_GetStringValue(self.handle, strKey.encode('ascii'), byref(StringValue))

    # ch:设置String型属性值 | en:Set String value
    def MV_CC_SetStringValue(self, strKey, sValue):
        MvCamCtrldll.MV_CC_SetStringValue.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetStringValue.restype = c_uint
        # C原型:int MV_CC_SetStringValue(void* handle,char* strKey,char * sValue)
        return MvCamCtrldll.MV_CC_SetStringValue(self.handle, strKey.encode('ascii'), sValue.encode('ascii'))

    # ch:设置Command型属性值 | en:Send Command
    def MV_CC_SetCommandValue(self, strKey):
        MvCamCtrldll.MV_CC_SetCommandValue.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetCommandValue.restype = c_uint
        # C原型:int MV_CC_SetCommandValue(void* handle,char* strKey)
        return MvCamCtrldll.MV_CC_SetCommandValue(self.handle, strKey.encode('ascii'))

    # ch:读内存 | en:Read Memory
    def MV_CC_ReadMemory(self, pBuffer, nAddress, nLength):
        MvCamCtrldll.MV_CC_ReadMemory.argtype = (c_void_p, c_void_p, c_uint, c_uint)
        MvCamCtrldll.MV_CC_ReadMemory.restype = c_uint
        # C原型:int MV_CC_ReadMemory(IN void* handle , void *pBuffer, int64_t nAddress, int64_t nLength);
        return MvCamCtrldll.MV_CC_ReadMemory(self.handle, pBuffer, c_uint(nAddress), nLength)

    # ch:写内存 | en:Write Memory
    def MV_CC_WriteMemory(self, pBuffer, nAddress, nLength):
        MvCamCtrldll.MV_CC_WriteMemory.argtype = (c_void_p, c_void_p, c_uint, c_uint)
        MvCamCtrldll.MV_CC_WriteMemory.restype = c_uint
        # C原型:int MV_CC_WriteMemory(IN void* handle, const void *pBuffer, int64_t nAddress, int64_t nLength);
        return MvCamCtrldll.MV_CC_WriteMemory(self.handle, pBuffer, c_uint(nAddress), nLength)

    # ch:清除GenICam节点缓存 | en:Invalidate GenICam Nodes
    def MV_CC_InvalidateNodes(self):
        MvCamCtrldll.MV_CC_InvalidateNodes.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_InvalidateNodes.restype = c_uint
        # C原型:int MV_CC_InvalidateNodes(IN void* handle);
        return MvCamCtrldll.MV_CC_InvalidateNodes(self.handle)

    # ch:获取设备属性树XML | en:Get camera feature tree XML
    def MV_XML_GetGenICamXML(self, pData, nDataSize, pnDataLen):
        MvCamCtrldll.MV_XML_GetGenICamXML.argtype = (c_void_p, c_void_p, c_uint, c_void_p)
        MvCamCtrldll.MV_XML_GetGenICamXML.restype = c_uint
        # C原型:int MV_XML_GetGenICamXML(IN void* handle, IN OUT unsigned char* pData,
        #                               IN unsigned int nDataSize, OUT unsigned int* pnDataLen);
        return MvCamCtrldll.MV_XML_GetGenICamXML(self.handle, pData, c_uint(nDataSize), byref(pnDataLen))

    # ch:获得当前节点的访问模式 | en:Get Access mode of cur node
    def MV_XML_GetNodeAccessMode(self, strName, penAccessMode):
        MvCamCtrldll.MV_XML_GetNodeAccessMode.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_XML_GetNodeAccessMode.restype = c_uint
        # C原型:int MV_XML_GetNodeAccessMode(IN void* handle,
        #                                   IN const char * strName, OUT MV_XML_AccessMode *penAccessMode);
        return MvCamCtrldll.MV_XML_GetNodeAccessMode(self.handle, strName.encode('ascii'), byref(penAccessMode))

    # ch:获得当前节点的类型 | en:Get Interface Type of cur node
    def MV_XML_GetNodeInterfaceType(self, strName, penInterfaceType):
        MvCamCtrldll.MV_XML_GetNodeInterfaceType.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_XML_GetNodeInterfaceType.restype = c_uint
        # C原型:int MV_XML_GetNodeInterfaceType(IN void* handle,
        #                                      IN const char * strName, OUT MV_XML_InterfaceType *penInterfaceType);
        return MvCamCtrldll.MV_XML_GetNodeInterfaceType(self.handle, strName.encode('ascii'), byref(penInterfaceType))

    # ch:保存设备属性 | en:Save camera feature
    def MV_CC_FeatureSave(self, strFileName):
        MvCamCtrldll.MV_CC_FeatureSave.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FeatureSave.restype = c_uint
        # C原型:int MV_CC_FeatureSave(void* handle, char* pFileName)
        return MvCamCtrldll.MV_CC_FeatureSave(self.handle, strFileName.encode('ascii'))

    # ch:导入设备属性 | en:Load camera feature
    def MV_CC_FeatureLoad(self, strFileName):
        MvCamCtrldll.MV_CC_FeatureLoad.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FeatureLoad.restype = c_uint
        # C原型:int MV_CC_FeatureLoad(void* handle, char* pFileName)
        return MvCamCtrldll.MV_CC_FeatureLoad(self.handle, strFileName.encode('ascii'))

    # ch:从设备读取文件 | en:Read the file from the camera
    def MV_CC_FileAccessRead(self, stFileAccess):
        MvCamCtrldll.MV_CC_FileAccessRead.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessRead.restype = c_uint
        # C原型:int MV_CC_FileAccessRead(void* handle, MV_CC_FILE_ACCESS * pstFileAccess)
        return MvCamCtrldll.MV_CC_FileAccessRead(self.handle, byref(stFileAccess))

    # ch:从设备读取文件,文件是Data数据 | en:Read the file from the camera
    def MV_CC_FileAccessReadEx(self, stFileAccessEx):
        MvCamCtrldll.MV_CC_FileAccessReadEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessReadEx.restype = c_uint
        # C原型:int MV_CC_FileAccessReadEx(IN void* handle, IN OUT MV_CC_FILE_ACCESS_EX * pstFileAccessEx)
        return MvCamCtrldll.MV_CC_FileAccessReadEx(self.handle, byref(stFileAccessEx))

    # ch:将文件写入设备 | en:Write the file to camera
    def MV_CC_FileAccessWrite(self, stFileAccess):
        MvCamCtrldll.MV_CC_FileAccessWrite.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessWrite.restype = c_uint
        # C原型:int MV_CC_FileAccessWrite(void* handle, MV_CC_FILE_ACCESS * pstFileAccess)
        return MvCamCtrldll.MV_CC_FileAccessWrite(self.handle, byref(stFileAccess))

    # ch:将文件写入设备,参数是文件data | en:Write the file to camera
    def MV_CC_FileAccessWriteEx(self, stFileAccessEx):
        MvCamCtrldll.MV_CC_FileAccessWriteEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FileAccessWriteEx.restype = c_uint
        # C原型:int MV_CC_FileAccessWriteEx(IN void* handle, IN MV_CC_FILE_ACCESS_EX * pstFileAccessEx)
        return MvCamCtrldll.MV_CC_FileAccessWriteEx(self.handle, byref(stFileAccessEx))

    # ch:获取文件存取进度 | en:Get File Access Progress
    def MV_CC_GetFileAccessProgress(self, stFileAccessProgress):
        MvCamCtrldll.MV_CC_GetFileAccessProgress.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetFileAccessProgress.restype = c_uint
        # C原型:int MV_CC_GetFileAccessProgress(void* handle, MV_CC_FILE_ACCESS_PROGRESS * pstFileAccessProgress)
        return MvCamCtrldll.MV_CC_GetFileAccessProgress(self.handle, byref(stFileAccessProgress))

    ''' Part3 ch: 相机升级 | en: Camera upgrade '''

    # ch:设备本地升级 | en: Device Local Upgrade
    def MV_CC_LocalUpgrade(self, strFilePathName):
        MvCamCtrldll.MV_CC_LocalUpgrade.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_LocalUpgrade.restype = c_uint
        # C原型:int MV_CC_LocalUpgrade(IN void* handle, const void* strFilePathName);
        return MvCamCtrldll.MV_CC_LocalUpgrade(self.handle, strFilePathName.encode('ascii'))

    # ch:获取升级进度 | en: Get Upgrade Progress
    def MV_CC_GetUpgradeProcess(self, nProcess):
        MvCamCtrldll.MV_CC_GetUpgradeProcess.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_GetUpgradeProcess.restype = c_uint
        # C原型:int MV_CC_GetUpgradeProcess(IN void* handle, unsigned int* pnProcess);
        return MvCamCtrldll.MV_CC_GetUpgradeProcess(self.handle, byref(nProcess))

    ''' Part4  ch: 注册异常回调和事件接口 | en: Enrol abnormal callbacks and event interface '''

    # ch:注册异常消息回调 | en:Register Exception Message CallBack, call after open device
    def MV_CC_RegisterExceptionCallBack(self, ExceptionCallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterExceptionCallBack.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterExceptionCallBack.restype = c_uint
        # C原型:int MV_CC_RegisterExceptionCallBack(void* handle,
        #                                          void(* cbException)(unsigned int nMsgType, void* pUser),void* pUser)
        return MvCamCtrldll.MV_CC_RegisterExceptionCallBack(self.handle, ExceptionCallBackFun, pUser)

    # ch:注册全部事件回调，在打开设备之后调用 | en:Register event callback, which is called after the device is opened
    def MV_CC_RegisterAllEventCallBack(self, EventCallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterAllEventCallBack.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterAllEventCallBack.restype = c_uint
        # C原型:int MV_CC_RegisterAllEventCallBack(void* handle,
        #                       void(__stdcall* cbEvent)(MV_EVENT_OUT_INFO * pEventInfo, void* pUser), void* pUser);
        return MvCamCtrldll.MV_CC_RegisterAllEventCallBack(self.handle, EventCallBackFun, pUser)

    # ch:注册单个事件回调，在打开设备之后调用 | en:Register single event callback, which is called after the device is opened
    def MV_CC_RegisterEventCallBackEx(self, pEventName, EventCallBackFun, pUser):
        MvCamCtrldll.MV_CC_RegisterEventCallBackEx.argtype = (c_void_p, c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RegisterEventCallBackEx.restype = c_uint
        # C原型:int MV_CC_RegisterEventCallBackEx(void* handle, char* pEventName,
        #                                     void(* cbEvent)(MV_EVENT_OUT_INFO * pEventInfo, void* pUser),void* pUser)
        return MvCamCtrldll.MV_CC_RegisterEventCallBackEx(self.handle, pEventName.encode('ascii'), EventCallBackFun,
                                                          pUser)

    # ch:开启设备指定事件 | en: Enable specified event of device
    def MV_CC_EventNotificationOn(self, strEventName):
        MvCamCtrldll.MV_CC_EventNotificationOn.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EventNotificationOn.restype = c_uint
        # C原型:int MV_CC_EventNotificationOn(IN void* handle, IN const char* strEventName)
        return MvCamCtrldll.MV_CC_EventNotificationOn(self.handle, strEventName.encode('ascii'))

    # ch:关闭设备指定事件 | en: Disable specified event of device
    def MV_CC_EventNotificationOff(self, strEventName):
        MvCamCtrldll.MV_CC_EventNotificationOff.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EventNotificationOff.restype = c_uint
        # C原型:int MV_CC_EventNotificationOff(IN void* handle, IN const char* strEventName)
        return MvCamCtrldll.MV_CC_EventNotificationOff(self.handle, strEventName.encode('ascii'))

    '''Part5 ch: 仅GigE设备支持的接口 | en: Only support GigE interface '''

    # ch:设置枚举超时时间，仅支持GigE协议，范围 0-UINT_MAX | en：Set enumerate device timeout,only GigE support
    # 在调用MV_CC_EnumDevices等枚举接口前使用该接口，可设置枚举GIGE设备的网卡最大超时时间（默认100ms）,来加快枚举GIGE设备的速度
    # Before calling enum device interfaces,call MV_GIGE_SetEnumDevTimeout to set max timeout,
    # can reduce the maximum timeout to speed up the enumeration of GigE devices
    def MV_GIGE_SetEnumDevTimeout(self, nMilTimeout):
        MvCamCtrldll.MV_GIGE_SetEnumDevTimeout.argtype = (c_uint)
        MvCamCtrldll.MV_GIGE_SetEnumDevTimeout.restype = c_uint
        # C原型:int MV_GIGE_SetEnumDevTimeout(IN unsigned int nMilTimeout)
        return MvCamCtrldll.MV_GIGE_SetEnumDevTimeout(c_uint(nMilTimeout))

    # ch:强制修改IP | en：Force IP
    def MV_GIGE_ForceIpEx(self, nIP, nSubNetMask, nDefaultGateWay):
        MvCamCtrldll.MV_GIGE_ForceIpEx.argtype = (c_void_p, c_uint, c_uint, c_uint)
        MvCamCtrldll.MV_GIGE_ForceIpEx.restype = c_uint
        # C原型:int MV_GIGE_ForceIpEx(void* handle, unsigned int nIP,
        #                            unsigned int nSubNetMask, unsigned int nDefaultGateWay)
        return MvCamCtrldll.MV_GIGE_ForceIpEx(self.handle, c_uint(nIP), c_uint(nSubNetMask), c_uint(nDefaultGateWay))

    # ch:配置IP方式 | en: IP configuration method
    def MV_GIGE_SetIpConfig(self, nType):
        MvCamCtrldll.MV_GIGE_SetIpConfig.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetIpConfig.restype = c_uint
        # C原型:int MV_GIGE_SetIpConfig(void* handle, unsigned int nType)
        return MvCamCtrldll.MV_GIGE_SetIpConfig(self.handle, c_uint(nType))

    # ch:设置仅使用某种模式,type: MV_NET_TRANS_x，不设置时，默认优先使用driver
    # en: Set to use only one mode,type: MV_NET_TRANS_x. When do not set, priority is to use driver by default
    def MV_GIGE_SetNetTransMode(self, nType):
        MvCamCtrldll.MV_GIGE_SetNetTransMode.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetNetTransMode.restype = c_uint
        # C原型:int MV_GIGE_SetNetTransMode(IN void* handle, unsigned int nType);
        return MvCamCtrldll.MV_GIGE_SetNetTransMode(self.handle, c_uint(nType))

    # ch:获取网络传输信息 | en: Get net transmission information
    def MV_GIGE_GetNetTransInfo(self, pstInfo):
        MvCamCtrldll.MV_GIGE_GetNetTransInfo.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetNetTransInfo.restype = c_uint
        # C原型:int MV_GIGE_GetNetTransInfo(IN void* handle, MV_NETTRANS_INFO* pstInfo);
        return MvCamCtrldll.MV_GIGE_GetNetTransInfo(self.handle, byref(pstInfo))

    # ch:设置枚举命令的回复包类型 | en: Setting the ACK mode of devices Discovery
    def MV_GIGE_SetDiscoveryMode(self, nMode):
        MvCamCtrldll.MV_GIGE_SetDiscoveryMode.argtype = (c_uint)
        MvCamCtrldll.MV_GIGE_SetDiscoveryMode.restype = c_uint
        # C原型:int MV_GIGE_SetDiscoveryMode(unsigned int nMode);
        return MvCamCtrldll.MV_GIGE_SetDiscoveryMode(c_uint(nMode))

    # ch:设置GVSP取流超时时间| en: Set GVSP streaming timeout
    def MV_GIGE_SetGvspTimeout(self, nMillisec):
        MvCamCtrldll.MV_GIGE_SetGvspTimeout.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetGvspTimeout.restype = c_uint
        # C原型:int MV_GIGE_SetGvspTimeout(void* handle, unsigned int nMillisec);
        return MvCamCtrldll.MV_GIGE_SetGvspTimeout(self.handle, c_uint(nMillisec))

    # ch:获取GVSP取流超时时间 | en: Get GVSP streaming timeout
    def MV_GIGE_GetGvspTimeout(self, pnMillisec):
        MvCamCtrldll.MV_GIGE_GetGvspTimeout.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetGvspTimeout.restype = c_uint
        # C原型:int MV_GIGE_GetGvspTimeout(IN void* handle, unsigned int* pnMillisec);
        return MvCamCtrldll.MV_GIGE_GetGvspTimeout(self.handle, byref(pnMillisec))

    # ch:设置GVCP命令超时时间| en: Set GVCP cammand timeout
    def MV_GIGE_SetGvcpTimeout(self, nMillisec):
        MvCamCtrldll.MV_GIGE_SetGvcpTimeout.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetGvcpTimeout.restype = c_uint
        # C原型:int MV_GIGE_SetGvcpTimeout(void* handle, unsigned int nMillisec);
        return MvCamCtrldll.MV_GIGE_SetGvcpTimeout(self.handle, c_uint(nMillisec))

    # ch:获取GVCP命令超时时间 | en: Get GVCP cammand timeout
    def MV_GIGE_GetGvcpTimeout(self, pnMillisec):
        MvCamCtrldll.MV_GIGE_GetGvcpTimeout.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetGvcpTimeout.restype = c_uint
        # C原型:int MV_GIGE_GetGvcpTimeout(IN void* handle, unsigned int* pnMillisec);
        return MvCamCtrldll.MV_GIGE_GetGvcpTimeout(self.handle, byref(pnMillisec))

    # ch:设置重传GVCP命令次数| en: Set the number of retry GVCP cammand
    def MV_GIGE_SetRetryGvcpTimes(self, nRetryGvcpTimes):
        MvCamCtrldll.MV_GIGE_SetRetryGvcpTimes.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetRetryGvcpTimes.restype = c_uint
        # C原型:int MV_GIGE_SetRetryGvcpTimes(IN void* handle, unsigned int nRetryGvcpTimes);
        return MvCamCtrldll.MV_GIGE_SetRetryGvcpTimes(self.handle, c_uint(nRetryGvcpTimes))

    # ch:获取重传GVCP命令次数| en: Get the number of retry GVCP cammand
    def MV_GIGE_GetRetryGvcpTimes(self, pnRetryGvcpTimes):
        MvCamCtrldll.MV_GIGE_GetRetryGvcpTimes.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetRetryGvcpTimes.restype = c_uint
        # C原型:int MV_GIGE_GetRetryGvcpTimes(IN void* handle, unsigned int* pnRetryGvcpTimes);
        return MvCamCtrldll.MV_GIGE_GetRetryGvcpTimes(self.handle, byref(pnRetryGvcpTimes))

    # ch:获取网络最佳包大小 | en:Get the optimal Packet Size, Only support GigE Camera
    def MV_CC_GetOptimalPacketSize(self):
        MvCamCtrldll.MV_CC_GetOptimalPacketSize.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_GetOptimalPacketSize.restype = c_uint
        # C原型:int __stdcall MV_CC_GetOptimalPacketSize(void* handle);
        return MvCamCtrldll.MV_CC_GetOptimalPacketSize(self.handle)

    # ch:设置是否打开重发包支持，及重发包设置| en: Set whethe to enable resend, and set resend
    def MV_GIGE_SetResend(self, bEnable, nMaxResendPercent=10, nResendTimeout=50):
        MvCamCtrldll.MV_GIGE_SetResend.argtype = (c_void_p, c_uint, c_uint, c_uint)
        MvCamCtrldll.MV_GIGE_SetResend.restype = c_uint
        # C原型:int  MV_GIGE_SetResend(void* handle, unsigned int bEnable,
        # unsigned int nMaxResendPercent = 10, unsigned int nResendTimeout = 50);
        return MvCamCtrldll.MV_GIGE_SetResend(self.handle, c_uint(bEnable), c_uint(nMaxResendPercent),
                                              c_uint(nResendTimeout))

    # ch:设置重传命令最大尝试次数 | en: set the max resend retry times
    def MV_GIGE_SetResendMaxRetryTimes(self, nRetryTimes):
        MvCamCtrldll.MV_GIGE_SetResendMaxRetryTimes.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetResendMaxRetryTimes.restype = c_uint
        # C原型:int MV_GIGE_SetResendMaxRetryTimes(void* handle, unsigned int nRetryTimes);
        return MvCamCtrldll.MV_GIGE_SetResendMaxRetryTimes(self.handle, c_uint(nRetryTimes))

    # ch:获取重传命令最大尝试次数 | en: get the max resend retry times
    def MV_GIGE_GetResendMaxRetryTimes(self, nRetryTimes):
        MvCamCtrldll.MV_GIGE_GetResendMaxRetryTimes.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetResendMaxRetryTimes.restype = c_uint
        # C原型:int MV_GIGE_GetResendMaxRetryTimes(void* handle, unsigned int* pnRetryTimes);
        return MvCamCtrldll.MV_GIGE_GetResendMaxRetryTimes(self.handle, byref(nRetryTimes))

    # ch:设置同一重传包多次请求之间的时间间隔 | en: set time interval between same resend requests
    def MV_GIGE_SetResendTimeInterval(self, nMillisec):
        MvCamCtrldll.MV_GIGE_SetResendTimeInterval.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_GIGE_SetResendTimeInterval.restype = c_uint
        # C原型:int MV_GIGE_SetResendTimeInterval(void* handle, unsigned int nMillisec)
        return MvCamCtrldll.MV_GIGE_SetResendTimeInterval(self.handle, c_uint(nMillisec))

    # ch:获取同一重传包多次请求之间的时间间隔 | en: get time interval between same resend requests
    def MV_GIGE_GetResendTimeInterval(self, nMillisec):
        MvCamCtrldll.MV_GIGE_GetResendTimeInterval.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetResendTimeInterval.restype = c_uint
        # C原型:int MV_GIGE_GetResendTimeInterval(void* handle, unsigned int* pnMillisec)
        return MvCamCtrldll.MV_GIGE_GetResendTimeInterval(self.handle, byref(nMillisec))

    # ch:设置传输模式，可以为单播模式、组播模式等 |en:Set transmission type,Unicast or Multicast
    def MV_GIGE_SetTransmissionType(self, stTransmissionType):
        MvCamCtrldll.MV_GIGE_SetTransmissionType.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_SetTransmissionType.restype = c_uint
        # C原型:int MV_GIGE_SetTransmissionType(void* handle, MV_TRANSMISSION_TYPE * pstTransmissionType)
        return MvCamCtrldll.MV_GIGE_SetTransmissionType(self.handle, byref(stTransmissionType))

    # ch:发出动作命令 | en:Issue Action Command
    def MV_GIGE_IssueActionCommand(self, pstActionCmdInfo, pstActionCmdResults):
        MvCamCtrldll.MV_GIGE_IssueActionCommand.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_IssueActionCommand.restype = c_uint
        # C原型:int  MV_GIGE_IssueActionCommand(IN MV_ACTION_CMD_INFO* pstActionCmdInfo,
        # OUT MV_ACTION_CMD_RESULT_LIST* pstActionCmdResults);
        return MvCamCtrldll.MV_GIGE_IssueActionCommand(byref(pstActionCmdInfo), byref(pstActionCmdResults))

    # ch:获取组播状态 | en:Get Multicast Status
    def MV_GIGE_GetMulticastStatus(self, pstDevInfo, pbStatus):
        MvCamCtrldll.MV_GIGE_GetMulticastStatus.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_GIGE_GetMulticastStatus.restype = c_uint
        # C原型:int MV_GIGE_GetMulticastStatus(IN MV_CC_DEVICE_INFO* pstDevInfo, OUT bool* pbStatus);
        return MvCamCtrldll.MV_GIGE_GetMulticastStatus(byref(pstDevInfo), byref(pbStatus))

    ''' Part6 ch: 仅CameraLink 设备支持的接口 | en: Only support camlink device interface'''

    # ch:获取串口信息列表| en: Get serial port information list
    def MV_CAML_GetSerialPortList(self, stSerialPortList):
        MvCamCtrldll.MV_CAML_GetSerialPortList.argtype = c_void_p
        MvCamCtrldll.MV_CAML_GetSerialPortList.restype = c_uint
        # C原型:int __stdcall MV_CAML_GetSerialPortList(IN OUT MV_CAML_SERIAL_PORT_LIST* pstSerialPortList);
        return MvCamCtrldll.MV_CAML_GetSerialPortList(byref(stSerialPortList))

    # ch:设置指定串口，camera link仅在该串口下枚举| en: Set the specified enumeration serial port
    def MV_CAML_SetEnumSerialPorts(self, stSerialPortList):
        MvCamCtrldll.MV_CAML_SetEnumSerialPorts.argtype = c_void_p
        MvCamCtrldll.MV_CAML_SetEnumSerialPorts.restype = c_uint
        # C原型:int __stdcall MV_CAML_SetEnumSerialPorts(IN MV_CAML_SERIAL_PORT_LIST* pstSerialPortList);
        return MvCamCtrldll.MV_CAML_SetEnumSerialPorts(byref(stSerialPortList))

    # ch:设置设备波特率| en: Set device bauderate using one of the CL_BAUDRATE_XXXX value
    def MV_CAML_SetDeviceBaudrate(self, nBaudrate):
        MvCamCtrldll.MV_CAML_SetDeviceBaudrate.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CAML_SetDeviceBaudrate.restype = c_uint
        # C原型:int MV_CAML_SetDeviceBaudrate(IN void* handle, unsigned int nBaudrate);
        return MvCamCtrldll.MV_CAML_SetDeviceBaudrate(self.handle, c_uint(nBaudrate))

    # ch:获取设备波特率 | en:Returns the current device bauderate, using one of the CL_BAUDRATE_XXXX value
    def MV_CAML_GetDeviceBaudrate(self, pnCurrentBaudrate):
        MvCamCtrldll.MV_CAML_GetDeviceBaudrate.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CAML_GetDeviceBaudrate.restype = c_uint
        # C原型:int MV_CAML_GetDeviceBaudrate(IN void* handle,unsigned int* pnCurrentBaudrate);
        return MvCamCtrldll.MV_CAML_GetDeviceBaudrate(self.handle, byref(pnCurrentBaudrate))

    # ch:获取设备与主机间连接支持的波特率 | en:Returns supported bauderates of the combined device and host interface
    def MV_CAML_GetSupportBaudrates(self, pnBaudrateAblity):
        MvCamCtrldll.MV_CAML_GetSupportBaudrates.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CAML_GetSupportBaudrates.restype = c_uint
        # C原型:int MV_CAML_GetSupportBaudrates(IN void* handle,unsigned int* pnBaudrateAblity);
        return MvCamCtrldll.MV_CAML_GetSupportBaudrates(self.handle, byref(pnBaudrateAblity))

    # ch:设置串口操作等待时长 | en: Sets the timeout for operations on the serial port
    def MV_CAML_SetGenCPTimeOut(self, nMillisec):
        MvCamCtrldll.MV_CAML_SetGenCPTimeOut.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CAML_SetGenCPTimeOut.restype = c_uint
        # C原型:int MV_CAML_SetGenCPTimeOut(IN void* handle, unsigned int nMillisec);
        return MvCamCtrldll.MV_CAML_SetGenCPTimeOut(self.handle, c_uint(nMillisec))

    ''' Part7 ch: 仅U3V设备支持的接口 | en: Only support U3V device interface '''

    # ch:设置U3V的传输包大小 | en: Set transfer size of U3V device
    def MV_USB_SetTransferSize(self, nTransferSize):
        MvCamCtrldll.MV_USB_SetTransferSize.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetTransferSize.restype = c_uint
        # C原型:int MV_USB_SetTransferSize(IN void* handle, unsigned int nTransferSize);
        return MvCamCtrldll.MV_USB_SetTransferSize(self.handle, c_uint(nTransferSize))

    # ch:获取U3V的传输包大小 | en:Get transfer size of U3V device
    def MV_USB_GetTransferSize(self, pnTransferSize):
        MvCamCtrldll.MV_USB_GetTransferSize.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_GetTransferSize.restype = c_uint
        # C原型:int MV_USB_GetTransferSize(IN void* handle, unsigned int* pnTransferSize);
        return MvCamCtrldll.MV_USB_GetTransferSize(self.handle, byref(pnTransferSize))

    # ch:设置U3V的传输通道个数 | en: Set transfer ways of U3V device
    def MV_USB_SetTransferWays(self, nTransferWays):
        MvCamCtrldll.MV_USB_SetTransferWays.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetTransferWays.restype = c_uint
        # C原型:int MV_USB_SetTransferWays(IN void* handle, unsigned int nTransferWays);
        return MvCamCtrldll.MV_USB_SetTransferWays(self.handle, c_uint(nTransferWays))

    # ch:获取U3V的传输通道个数 | en:Get transfer ways of U3V device
    def MV_USB_GetTransferWays(self, pnTransferWays):
        MvCamCtrldll.MV_USB_GetTransferWays.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_GetTransferWays.restype = c_uint
        # C原型:int MV_USB_GetTransferWays(IN void* handle, unsigned int* pnTransferWays);
        return MvCamCtrldll.MV_USB_GetTransferWays(self.handle, byref(pnTransferWays))

    # ch:注册流异常消息回调，在打开设备之后调用（只支持U3V相机）
    # en: Register the stream exception callback, which is called after the device is opened.
    # Only the U3V camera is supported
    def MV_USB_RegisterStreamExceptionCallBack(self, CallBackFun, pUser):
        MvCamCtrldll.MV_USB_RegisterStreamExceptionCallBack.argtype = (c_void_p, c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_RegisterStreamExceptionCallBack.restype = c_uint
        # C原型:int MV_USB_RegisterStreamExceptionCallBack(
        # void* handle,
        # void(__stdcall* cbException)(MV_CC_STREAM_EXCEPTION_TYPE enExceptionType, void* pUser),
        # void* pUser);
        return MvCamCtrldll.MV_USB_RegisterStreamExceptionCallBack(self.handle, CallBackFun, pUser)

    # ch:设置U3V的事件缓存节点个数 | en: Set the number of U3V device event cache nodes
    def MV_USB_SetEventNodeNum(self, nEventNodeNum):
        MvCamCtrldll.MV_USB_SetEventNodeNum.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetEventNodeNum.restype = c_uint
        # C原型:int MV_USB_SetEventNodeNum(IN void* handle, unsigned int nEventNodeNum)
        return MvCamCtrldll.MV_USB_SetEventNodeNum(self.handle, c_uint(nEventNodeNum))

    # ch:设置U3V的同步读写超时时间,范围为0 ~ UINT_MAX(最小值包含0，最大值根据操作系统位数决定) | en: Set Sync timeout
    def MV_USB_SetSyncTimeOut(self, nMills):
        MvCamCtrldll.MV_USB_SetSyncTimeOut.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_USB_SetSyncTimeOut.restype = c_uint
        # C原型:int MV_USB_SetSyncTimeOut(IN void* handle, unsigned int nMills);
        return MvCamCtrldll.MV_USB_SetSyncTimeOut(self.handle, c_uint(nMills))

    # ch:获取U3V相机同步读写超时时间 | en: Get Sync timeout
    def MV_USB_GetSyncTimeOut(self, nMills):
        MvCamCtrldll.MV_USB_GetSyncTimeOut.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_USB_GetSyncTimeOut.restype = c_uint
        # C原型:int MV_USB_GetSyncTimeOut(IN void* handle, unsigned int* pnMills);
        return MvCamCtrldll.MV_USB_GetSyncTimeOut(self.handle, byref(nMills))

    ''' Part8 ch: GenTL相关接口 | en: GenTL related interface '''

    # ch:通过GenTL枚举Interfaces | en:Enumerate Interfaces with GenTL
    def MV_CC_EnumInterfacesByGenTL(stIFList, strGenTLPath):
        MvCamCtrldll.MV_CC_EnumInterfacesByGenTL.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumInterfacesByGenTL.restype = c_uint
        # C原型:int MV_CC_EnumInterfacesByGenTL(IN OUT MV_GENTL_IF_INFO_LIST* pstIFList, IN const char * strGenTLPath);
        return MvCamCtrldll.MV_CC_EnumInterfacesByGenTL(byref(stIFList), strGenTLPath.encode('ascii'))

    # ch:通过GenTL Interface枚举设备 | en:Enumerate Devices with GenTL interface
    def MV_CC_EnumDevicesByGenTL(stIFInfo, stDevList):
        MvCamCtrldll.MV_CC_EnumDevicesByGenTL.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_EnumDevicesByGenTL.restype = c_uint
        # C原型:int MV_CC_EnumDevicesByGenTL(IN MV_GENTL_IF_INFO* pstIFInfo, IN OUT MV_GENTL_DEV_INFO_LIST* pstDevList);
        return MvCamCtrldll.MV_CC_EnumDevicesByGenTL(stIFInfo, byref(stDevList))

    # ch:卸载cti库 | en: Unload cti library
    @staticmethod
    def MV_CC_UnloadGenTLLibrary(GenTLPath):
        MvCamCtrldll.MV_CC_UnloadGenTLLibrary.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_UnloadGenTLLibrary.restype = c_uint
        # C原型:int MV_CC_UnloadGenTLLibrary(IN const char * pGenTLPath);
        return MvCamCtrldll.MV_CC_UnloadGenTLLibrary(GenTLPath.encode('ascii'))

    # ch:通过GenTL设备信息创建设备句柄 | en:Create Device Handle with GenTL Device Info
    def MV_CC_CreateHandleByGenTL(self, stDevInfo):
        MvCamCtrldll.MV_CC_CreateHandleByGenTL.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_CreateHandleByGenTL.restype = c_uint
        # C原型:int MV_CC_CreateHandleByGenTL(OUT void ** handle, IN const MV_GENTL_DEV_INFO* pstDevInfo);
        return MvCamCtrldll.MV_CC_CreateHandleByGenTL(byref(self.handle), byref(stDevInfo))

    ''' Part9 ch: 图像保存、格式转换等相关接口 | en: Related image save and format convert interface '''

    # ch:保存图片，支持Bmp和Jpeg | en:Save image, support Bmp and Jpeg.
    def MV_CC_SaveImageEx2(self, stSaveParam):
        MvCamCtrldll.MV_CC_SaveImageEx2.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageEx2.restype = c_uint
        # C原型:int MV_CC_SaveImageEx2(void* handle, MV_SAVE_IMAGE_PARAM_EX* pSaveParam)
        return MvCamCtrldll.MV_CC_SaveImageEx2(self.handle, byref(stSaveParam))

    # ch:保存图片，支持Bmp和Jpeg MV_CC_SaveImageEx3比MV_CC_SaveImageEx2 支持图像大小到Int
    # en:Save image, support Bmp and Jpeg.this API support the parameter nWidth nHeight to unsigned int.
    def MV_CC_SaveImageEx3(self, stSaveParam):
        MvCamCtrldll.MV_CC_SaveImageEx3.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageEx3.restype = c_uint
        # C原型:int MV_CC_SaveImageEx3(IN void* handle, MV_SAVE_IMAGE_PARAM_EX3* pstSaveParam)
        return MvCamCtrldll.MV_CC_SaveImageEx3(self.handle, byref(stSaveParam))

    # ch:保存图像到文件 | en:Save the image file
    def MV_CC_SaveImageToFile(self, stSaveFileParam):
        MvCamCtrldll.MV_CC_SaveImageToFile.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageToFile.restype = c_uint
        # C原型:int MV_CC_SaveImageToFile(IN void* handle, MV_SAVE_IMG_TO_FILE_PARAM* pstSaveFileParam);
        return MvCamCtrldll.MV_CC_SaveImageToFile(self.handle, byref(stSaveFileParam))

    # ch:保存图像到文件,支持保存的图像长乘宽乘像素大小至UINT_MAX, 其中MV_CC_SaveImageToFile支持最大至USHRT_MAX
    # en:Save the image file,Comparing with the API MV_CC_SaveImageToFile,
    # this API support the parameter nWidth * nHeight * pixelsize to UINT_MAX.
    def MV_CC_SaveImageToFileEx(self, stSaveFileParam):
        MvCamCtrldll.MV_CC_SaveImageToFileEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SaveImageToFileEx.restype = c_uint
        # C原型:int MV_CC_SaveImageToFileEx(IN void* handle,  MV_SAVE_IMAGE_TO_FILE_PARAM_EX* pstSaveFileParam);
        return MvCamCtrldll.MV_CC_SaveImageToFileEx(self.handle, byref(stSaveFileParam))

    # ch:保存3D点云数据，支持PLY、CSV和OBJ三种格式 | en:Save 3D point data, support PLY、CSV and OBJ
    def MV_CC_SavePointCloudData(self, stPointDataParam):
        MvCamCtrldll.MV_CC_SavePointCloudData.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SavePointCloudData.restype = c_uint
        # C原型:int MV_CC_SavePointCloudData(IN void* handle, MV_SAVE_POINT_CLOUD_PARAM* pstPointDataParam);
        return MvCamCtrldll.MV_CC_SavePointCloudData(self.handle, byref(stPointDataParam))

    # ch:图像旋转 | en: Rotate image
    def MV_CC_RotateImage(self, stRotateParam):
        MvCamCtrldll.MV_CC_RotateImage.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_RotateImage.restype = c_uint
        # C原型:int MV_CC_RotateImage(IN void* handle, IN OUT MV_CC_ROTATE_IMAGE_PARAM* pstRotateParam);
        return MvCamCtrldll.MV_CC_RotateImage(self.handle, byref(stRotateParam))

    # ch:图像翻转 | en:Flip image
    def MV_CC_FlipImage(self, stFlipParam):
        MvCamCtrldll.MV_CC_FlipImage.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_FlipImage.restype = c_uint
        # C原型:int MV_CC_FlipImage(IN void* handle, IN OUT MV_CC_FLIP_IMAGE_PARAM* pstFlipParam);
        return MvCamCtrldll.MV_CC_FlipImage(self.handle, byref(stFlipParam))

    # ch:像素格式转换 | en:Pixel format conversion
    def MV_CC_ConvertPixelType(self, stConvertParam):
        MvCamCtrldll.MV_CC_ConvertPixelType.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ConvertPixelType.restype = c_uint
        # C原型:int MV_CC_ConvertPixelType(void* handle, MV_CC_PIXEL_CONVERT_PARAM* pstCvtParam)
        return MvCamCtrldll.MV_CC_ConvertPixelType(self.handle, byref(stConvertParam))

    # ch:像素格式转换,接口支持转换的图像长乘宽乘像素大小至UINT_MAX
    # en:Pixel format conversion,comparing with the API MV_CC_ConvertPixelType,
    # this API support the parameter nWidth * nHeight * pixelsize to UINT_MAX.
    def MV_CC_ConvertPixelTypeEx(self, stConvertParam):
        MvCamCtrldll.MV_CC_ConvertPixelTypeEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ConvertPixelTypeEx.restype = c_uint
        # C原型:int MV_CC_ConvertPixelTypeEx(IN void* handle, IN OUT MV_CC_PIXEL_CONVERT_PARAM_EX* pstCvtParam);
        return MvCamCtrldll.MV_CC_ConvertPixelTypeEx(self.handle, byref(stConvertParam))

    # ch:插值算法类型设置 | en:Interpolation algorithm type setting
    def MV_CC_SetBayerCvtQuality(self, nBayerCvtQuality):
        MvCamCtrldll.MV_CC_SetBayerCvtQuality.argtype = (c_void_p, c_uint)
        MvCamCtrldll.MV_CC_SetBayerCvtQuality.restype = c_uint
        # C原型:int MV_CC_SetBayerCvtQuality(IN void* handle, IN unsigned int nBayerCvtQuality);
        return MvCamCtrldll.MV_CC_SetBayerCvtQuality(self.handle, c_uint(nBayerCvtQuality))

    # ch:插值算法平滑使能设置 | en: Filter type of the bell interpolation quality algorithm setting
    def MV_CC_SetBayerFilterEnable(self, bFilterEnable):
        MvCamCtrldll.MV_CC_SetBayerFilterEnable.argtype = (c_void_p, c_bool)
        MvCamCtrldll.MV_CC_SetBayerFilterEnable.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerFilterEnable(IN void* handle, IN bool bFilterEnable);
        return MvCamCtrldll.MV_CC_SetBayerFilterEnable(self.handle, c_bool(bFilterEnable))

    # ch:设置Bayer格式的Gamma值 | en: Set Gamma value
    def MV_CC_SetBayerGammaValue(self, fBayerGammaValue):
        MvCamCtrldll.MV_CC_SetBayerGammaValue.argtype = (c_void_p, c_float)
        MvCamCtrldll.MV_CC_SetBayerGammaValue.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerGammaValue(IN void* handle, IN float fBayerGammaValue);
        return MvCamCtrldll.MV_CC_SetBayerGammaValue(self.handle, c_float(fBayerGammaValue))

    # ch:设置Mono8/bayer格式的Gamma值 | en:Set Gamma value
    def MV_CC_SetGammaValue(self, enSrcPixelType, fGammaValue):
        MvCamCtrldll.MV_CC_SetGammaValue.argtype = (c_void_p, c_int, c_float)
        MvCamCtrldll.MV_CC_SetGammaValue.restype = c_uint
        # C原型:int MV_CC_SetGammaValue(IN void* handle, enum MvGvspPixelType enSrcPixelType, IN float fGammaValue);
        return MvCamCtrldll.MV_CC_SetGammaValue(self.handle, c_int(enSrcPixelType), c_float(fGammaValue))

    # ch：设置Bayer格式的Gamma信息 | en: Set Gamma param
    def MV_CC_SetBayerGammaParam(self, stGammaParam):
        MvCamCtrldll.MV_CC_SetBayerGammaParam.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetBayerGammaParam.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerGammaParam(IN void* handle, IN MV_CC_GAMMA_PARAM* pstGammaParam);
        return MvCamCtrldll.MV_CC_SetBayerGammaParam(self.handle, byref(stGammaParam))

    # ch:设置Bayer格式的CCM使能和矩阵，量化系数默认1024 | en:Set CCM param,Scale default 1024
    def MV_CC_SetBayerCCMParam(self, stCCMParam):
        MvCamCtrldll.MV_CC_SetBayerCCMParam.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetBayerCCMParam.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerCCMParam(IN void* handle, IN MV_CC_CCM_PARAM* pstCCMParam);
        return MvCamCtrldll.MV_CC_SetBayerCCMParam(self.handle, byref(stCCMParam))

    # ch:设置Bayer格式的CCM使能和矩阵 | en:Set CCM param
    def MV_CC_SetBayerCCMParamEx(self, stCCMParam):
        MvCamCtrldll.MV_CC_SetBayerCCMParamEx.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_SetBayerCCMParamEx.restype = c_uint
        # C原型：int __stdcall MV_CC_SetBayerCCMParamEx(IN void* handle, IN MV_CC_CCM_PARAM_EX* pstCCMParam);
        return MvCamCtrldll.MV_CC_SetBayerCCMParamEx(self.handle, byref(stCCMParam))

    # ch:图像对比度调节 | en:Adjust image contrast
    def MV_CC_ImageContrast(self, stConstrastParam):
        MvCamCtrldll.MV_CC_ImageContrast.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ImageContrast.restype = c_uint
        # C原型：int __stdcall MV_CC_ImageContrast(IN void* handle, IN OUT MV_CC_CONTRAST_PARAM* pstContrastParam);
        return MvCamCtrldll.MV_CC_ImageContrast(self.handle, byref(stConstrastParam))

    # ch:无损解码 | en:High Bandwidth Decode
    def MV_CC_HBDecode(self, stDecodeParam):
        MvCamCtrldll.MV_CC_HB_Decode.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_HB_Decode.restype = c_uint
        # C原型：int __stdcall MV_CC_HB_Decode(IN void* handle, IN OUT MV_CC_HB_DECODE_PARAM* pstDecodeParam);
        return MvCamCtrldll.MV_CC_HB_Decode(self.handle, byref(stDecodeParam))

    # ch:在图像上绘制矩形框辅助线 | en:Draw Rect Auxiliary Line
    def MV_CC_DrawRect(self, stRectInfo):
        MvCamCtrldll.MV_CC_DrawRect.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DrawRect.restype = c_uint
        # C原型: int __stdcall MV_CC_DrawRect(IN void* handle, IN MVCC_RECT_INFO* pRectInfo);
        return MvCamCtrldll.MV_CC_DrawRect(self.handle, byref(stRectInfo))

    # ch:在图像上绘制圆形辅助线 | en:Draw Circle Auxiliary Line
    def MV_CC_DrawCircle(self, stCircleInfo):
        MvCamCtrldll.MV_CC_DrawCircle.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DrawCircle.restype = c_uint
        # C原型: int __stdcall MV_CC_DrawCircle(IN void* handle, IN MVCC_CIRCLE_INFO* pCircleInfo);
        return MvCamCtrldll.MV_CC_DrawCircle(self.handle, byref(stCircleInfo))

    # ch:在图像上绘制线条 | en:Draw Line Auxiliary Line
    def MV_CC_DrawLines(self, stLineInfo):
        MvCamCtrldll.MV_CC_DrawLines.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_DrawLines.restype = c_uint
        # C原型: int __stdcall MV_CC_DrawLines(IN void* handle, IN MVCC_LINES_INFO* pLinesInfo);
        return MvCamCtrldll.MV_CC_DrawLines(self.handle, byref(stLineInfo))

    # ch:开始录像 | en:Start Record
    def MV_CC_StartRecord(self, stRecordParam):
        MvCamCtrldll.MV_CC_StartRecord.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_StartRecord.restype = c_uint
        # C原型:int __stdcall MV_CC_StartRecord(IN void* handle, IN MV_CC_RECORD_PARAM* pstRecordParam);
        return MvCamCtrldll.MV_CC_StartRecord(self.handle, byref(stRecordParam))

    # ch: 输入录像数据 | en:Input RAW data to Record
    def MV_CC_InputOneFrame(self, stInputFrameInfo):
        MvCamCtrldll.MV_CC_InputOneFrame.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_InputOneFrame.restype = c_uint
        # C原型：int __stdcall MV_CC_InputOneFrame(IN void* handle, IN MV_CC_INPUT_FRAME_INFO * pstInputFrameInfo);
        return MvCamCtrldll.MV_CC_InputOneFrame(self.handle, byref(stInputFrameInfo))

    # ch:停止录像 | en:Stop Record
    def MV_CC_StopRecord(self):
        MvCamCtrldll.MV_CC_StopRecord.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_StopRecord.restype = c_uint
        # C原型：int __stdcall MV_CC_StopRecord(IN void* handle);
        return MvCamCtrldll.MV_CC_StopRecord(self.handle)

    # ch:打开获取或设置相机参数的GUI界面 | en:Open the GUI interface for getting or setting camera parameters
    def MV_CC_OpenParamsGUI(self):
        MvCamCtrldll.MV_CC_OpenParamsGUI.argtype = (c_void_p)
        MvCamCtrldll.MV_CC_OpenParamsGUI.restype = c_uint
        # C原型: __stdcall MV_CC_OpenParamsGUI(IN void* handle);
        return MvCamCtrldll.MV_CC_OpenParamsGUI(self.handle)

    # ch:重构图像(用于分时曝光功能) | en:Reconstruct Image(For time-division exposure function)
    def MV_CC_ReconstructImage(self, stReconstructParam):
        MvCamCtrldll.MV_CC_ReconstructImage.argtype = (c_void_p, c_void_p)
        MvCamCtrldll.MV_CC_ReconstructImage.restype = c_uint
        # C原型：int __stdcall MV_CC_ReconstructImage(IN void* handle, IN OUT MV_RECONSTRUCT_IMAGE_PARAM* pstReconstructParam);
        return MvCamCtrldll.MV_CC_ReconstructImage(self.handle, byref(stReconstructParam))


**System:** #!/usr/bin/env python
# -*- coding: utf-8 -*-

MV_OK                                        = 0x00000000  # < \~chinese 成功，无错误             \~english Successed, no error

# 通用错误码定义:范围0x80000000-0x800000FF
MV_E_HANDLE                                  = 0x80000000  # < \~chinese 错误或无效的句柄         \~english Error or invalid handle
MV_E_SUPPORT                                 = 0x80000001  # < \~chinese 不支持的功能             \~english Not supported function
MV_E_BUFOVER                                 = 0x80000002  # < \~chinese 缓存已满                 \~english Buffer overflow
MV_E_CALLORDER                               = 0x80000003  # < \~chinese 函数调用顺序错误         \~english Function calling order error
MV_E_PARAMETER                               = 0x80000004  # < \~chinese 错误的参数               \~english Incorrect parameter
MV_E_RESOURCE                                = 0x80000006  # < \~chinese 资源申请失败             \~english Applying resource failed
MV_E_NODATA                                  = 0x80000007  # < \~chinese 无数据                   \~english No data
MV_E_PRECONDITION                            = 0x80000008  # < \~chinese 前置条件有误，或运行环境已发生变化       \~english Precondition error, or running environment changed
MV_E_VERSION                                 = 0x80000009  # < \~chinese 版本不匹配               \~english Version mismatches
MV_E_NOENOUGH_BUF                            = 0x8000000A  # < \~chinese 传入的内存空间不足       \~english Insufficient memory
MV_E_ABNORMAL_IMAGE                          = 0x8000000B  # < \~chinese 异常图像，可能是丢包导致图像不完整       \~english Abnormal image, maybe incomplete image because of lost packet
MV_E_LOAD_LIBRARY                            = 0x8000000C  # < \~chinese 动态导入DLL失败          \~english Load library failed
MV_E_NOOUTBUF                                = 0x8000000D  # < \~chinese 没有可输出的缓存         \~english No Avaliable Buffer
MV_E_ENCRYPT                                 = 0x8000000E  # < \~chinese 加密错误                 \~english Encryption error
MV_E_OPENFILE                                = 0x8000000F  # < \~chinese 打开文件出现错误         \~english open file error
MV_E_BUF_IN_USE                              = 0x80000010  # < \~chinese 缓存地址已使用           \~english Buffer already in use
MV_E_BUF_INVALID                             = 0x80000011  # < \~chinese 无效的缓存地址           \~english Buffer address invalid
MV_E_NOALIGN_BUF                             = 0x80000012  # < \~chinese 缓存对齐异常             \~english Buffer alignmenterror error
MV_E_NOENOUGH_BUF_NUM                        = 0x80000013  # < \~chinese 缓存个数不足             \~english Insufficient cache count
MV_E_PORT_IN_USE                             = 0x80000014  # < \~chinese 串口被占用               \~english Port is in use
MV_E_IMAGE_DECODEC                           = 0x80000015  # < \~chinese 解码错误(SDK校验图像异常)\~english Decoding error (SDK verification image exception)
MV_E_UNKNOW                                  = 0x800000FF  # < \~chinese 未知的错误               \~english Unknown error

# GenICam系列错误:范围0x80000100-0x800001FF
MV_E_GC_GENERIC                              = 0x80000100  # < \~chinese 通用错误                 \~english General error
MV_E_GC_ARGUMENT                             = 0x80000101  # < \~chinese 参数非法                 \~english Illegal parameters
MV_E_GC_RANGE                                = 0x80000102  # < \~chinese 值超出范围               \~english The value is out of range
MV_E_GC_PROPERTY                             = 0x80000103  # < \~chinese 属性                     \~english Property
MV_E_GC_RUNTIME                              = 0x80000104  # < \~chinese 运行环境有问题           \~english Running environment error
MV_E_GC_LOGICAL                              = 0x80000105  # < \~chinese 逻辑错误                 \~english Logical error
MV_E_GC_ACCESS                               = 0x80000106  # < \~chinese 节点访问条件有误         \~english Node accessing condition error
MV_E_GC_TIMEOUT                              = 0x80000107  # < \~chinese 超时                     \~english Timeout
MV_E_GC_DYNAMICCAST                          = 0x80000108  # < \~chinese 转换异常                 \~english Transformation exception
MV_E_GC_UNKNOW                               = 0x800001FF  # < \~chinese GenICam未知错误          \~english GenICam unknown error

# GigE_STATUS对应的错误码:范围0x80000200-0x800002FF
MV_E_NOT_IMPLEMENTED                         = 0x80000200  # < \~chinese 命令不被设备支持         \~english The command is not supported by device
MV_E_INVALID_ADDRESS                         = 0x80000201  # < \~chinese 访问的目标地址不存在     \~english The target address being accessed does not exist
MV_E_WRITE_PROTECT                           = 0x80000202  # < \~chinese 目标地址不可写           \~english The target address is not writable
MV_E_ACCESS_DENIED                           = 0x80000203  # < \~chinese 设备无访问权限           \~english No permission
MV_E_BUSY                                    = 0x80000204  # < \~chinese 设备忙，或网络断开       \~english Device is busy, or network disconnected
MV_E_PACKET                                  = 0x80000205  # < \~chinese 网络包数据错误           \~english Network data packet error
MV_E_NETER                                   = 0x80000206  # < \~chinese 网络相关错误             \~english Network error
MV_E_KEY_VERIFICATION                        = 0x8000020F  # < \~chinese 秘钥校验错误              \~english SwitchKey error
MV_E_IP_CONFLICT                             = 0x80000221  # < \~chinese 设备IP冲突               \~english Device IP conflict

# USB_STATUS对应的错误码:范围0x80000300-0x800003FF
MV_E_USB_READ                                = 0x80000300  # < \~chinese 读usb出错               \~english Reading USB error
MV_E_USB_WRITE                               = 0x80000301  # < \~chinese 写usb出错               \~english Writing USB error
MV_E_USB_DEVICE                              = 0x80000302  # < \~chinese 设备异常                \~english Device exception
MV_E_USB_GENICAM                             = 0x80000303  # < \~chinese GenICam相关错误         \~english GenICam error
MV_E_USB_BANDWIDTH                           = 0x80000304  # < \~chinese 带宽不足  该错误码新增   \~english Insufficient bandwidth, this error code is newly added
MV_E_USB_DRIVER                              = 0x80000305  # < \~chinese 驱动不匹配或者未装驱动   \~english Driver mismatch or unmounted drive
MV_E_USB_UNKNOW                              = 0x800003FF  # < \~chinese USB未知的错误           \~english USB unknown error

# 升级时对应的错误码:范围0x80000400-0x800004FF
MV_E_UPG_FILE_MISMATCH                       = 0x80000400  # < \~chinese 升级固件不匹配           \~english Firmware mismatches
MV_E_UPG_LANGUSGE_MISMATCH                   = 0x80000401  # < \~chinese 升级固件语言不匹配       \~english Firmware language mismatches
MV_E_UPG_CONFLICT                            = 0x80000402  # < \~chinese 升级冲突（设备已经在升级了再次请求升级即返回此错误）   \~english Upgrading conflicted (repeated upgrading requests during device upgrade)
MV_E_UPG_INNER_ERR                           = 0x80000403  # < \~chinese 升级时设备内部出现错误   \~english Camera internal error during upgrade
MV_E_UPG_UNKNOW                              = 0x800004FF  # < \~chinese 升级时未知错误          \~english Unknown error during upgrade


**System:** # -*- coding: utf-8 -*-
from ctypes import *

PixelType_Gvsp_BGR12_Packed = 36700187
PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK = -2112094207
PixelType_Gvsp_RGB10V1_Packed = 35651612
PixelType_Gvsp_BayerRG12_Packed = 17563691
PixelType_Gvsp_RGB12_Planar = 36700195
PixelType_Gvsp_YUV411_Packed = 34340894
PixelType_Gvsp_YUV444_Packed = 35127328
PixelType_Gvsp_BGR10_Packed = 36700185
PixelType_Gvsp_YCBCR422_8 = 34603067
PixelType_Gvsp_YCBCR709_422_8 = 34603073
PixelType_Gvsp_RGB12_Packed = 36700186
PixelType_Gvsp_Coord3D_ABC32f_Planar = 39846081
PixelType_Gvsp_Mono8_Signed = 17301506
PixelType_Gvsp_YUV422_YUYV_Packed = 34603058
PixelType_Gvsp_Mono4p = 17039417
PixelType_Gvsp_BayerGR12_Packed = 17563690
PixelType_Gvsp_Coord3D_ABC32 = -2107625471
PixelType_Gvsp_Coord3D_AB32f = -2109722622
PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY = 34340930
PixelType_Gvsp_YCBCR709_422_8_CBYCRY = 34603077
PixelType_Gvsp_Coord3D_AB32 = -2109722621
PixelType_Gvsp_YCBCR601_422_8_CBYCRY = 34603076
PixelType_Gvsp_YCBCR709_8_CBYCR = 35127360
PixelType_Gvsp_Coord3D_AC32f = 36176066
PixelType_Gvsp_YCBCR8_CBYCR = 35127354
PixelType_Gvsp_YCBCR411_8_CBYYCRYY = 34340924
PixelType_Gvsp_Coord3D_ABC32f = 39846080
PixelType_Gvsp_YUV422_Packed = 34603039
PixelType_Gvsp_Coord3D_ABC16 = 36700345
PixelType_Gvsp_RGB10_Planar = 36700194
PixelType_Gvsp_RGB8_Planar = 35127329
PixelType_Gvsp_RGB10_Packed = 36700184
PixelType_Gvsp_Coord3D_C32 = -2128596986
PixelType_Gvsp_RGB16_Packed = 36700211
PixelType_Gvsp_YCBCR422_8_CBYCRY = 34603075
PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY = 34340927
PixelType_Gvsp_BGRA8_Packed = 35651607
PixelType_Gvsp_Jpeg = -2145910783
PixelType_Gvsp_YCBCR601_422_8 = 34603070
PixelType_Gvsp_Coord3D_C32f = 18874559
PixelType_Gvsp_BayerGB12_Packed = 17563692
PixelType_Gvsp_BayerRG16 = 17825839
PixelType_Gvsp_BayerGB10_Packed = 17563688
PixelType_Gvsp_RGB12V1_Packed = 35913780
PixelType_Gvsp_RGB16_Planar = 36700196
PixelType_Gvsp_BGR565_Packed = 34603062
PixelType_Gvsp_Mono16 = 17825799
PixelType_Gvsp_BayerBG10 = 17825807
PixelType_Gvsp_Coord3D_AC32f_64 = 37748930
PixelType_Gvsp_RGBA8_Packed = 35651606
PixelType_Gvsp_Mono12 = 17825797
PixelType_Gvsp_Coord3D_A32f = 18874557
PixelType_Gvsp_YCBCR601_8_CBYCR = 35127357
PixelType_Gvsp_BayerGB16 = 17825840
PixelType_Gvsp_Coord3D_AC32 = -2109722620
PixelType_Gvsp_BayerBG16 = 17825841
PixelType_Gvsp_Coord3D_AC32f_Planar = 37748931
PixelType_Gvsp_BayerBG10_Packed = 17563689
PixelType_Gvsp_RGB8_Packed = 35127316
PixelType_Gvsp_BGR8_Packed = 35127317
PixelType_Gvsp_BayerGR16 = 17825838
PixelType_Gvsp_BayerGR10_Packed = 17563686
PixelType_Gvsp_Mono8 = 17301505
PixelType_Gvsp_Mono14 = 17825829
PixelType_Gvsp_BayerGB10 = 17825806
PixelType_Gvsp_Undefined = -1
PixelType_Gvsp_BayerRG8 = 17301513
PixelType_Gvsp_BayerGB12 = 17825810
PixelType_Gvsp_Mono12_Packed = 17563654
PixelType_Gvsp_BayerBG8 = 17301515
PixelType_Gvsp_BayerBG12_Packed = 17563693
PixelType_Gvsp_Mono1p = 16842807
PixelType_Gvsp_Mono2p = 16908344
PixelType_Gvsp_RGB565_Packed = 34603061
PixelType_Gvsp_RGB10V2_Packed = 35651613
PixelType_Gvsp_BayerRG12 = 17825809
PixelType_Gvsp_Mono10_Packed = 17563652
PixelType_Gvsp_BayerGR8 = 17301512
PixelType_Gvsp_BayerGB8 = 17301514
PixelType_Gvsp_BayerGR12 = 17825808
PixelType_Gvsp_BayerGR10 = 17825804
PixelType_Gvsp_BayerRG10 = 17825805
PixelType_Gvsp_BayerBG12 = 17825811
PixelType_Gvsp_Coord3D_A32 = -2128596987
PixelType_Gvsp_Mono10 = 17825795
PixelType_Gvsp_BayerRG10_Packed = 17563687
PixelType_Gvsp_YUV420SP_NV12 = 34373633
PixelType_Gvsp_YUV420SP_NV21 = 34373634
PixelType_Gvsp_Coord3D_C16 = 17825976
PixelType_Gvsp_BayerRBGG8 = 17301574
PixelType_Gvsp_HB_Mono8 = -2130182143
PixelType_Gvsp_HB_Mono10 = -2129657853
PixelType_Gvsp_HB_Mono10_Packed = -2129919996
PixelType_Gvsp_HB_Mono12 = -2129657851
PixelType_Gvsp_HB_Mono12_Packed = -2129919994
PixelType_Gvsp_HB_Mono16 = -2129657849
PixelType_Gvsp_HB_BayerGR8 = -2130182136
PixelType_Gvsp_HB_BayerRG8 = -2130182135
PixelType_Gvsp_HB_BayerGB8 = -2130182134
PixelType_Gvsp_HB_BayerBG8 = -2130182133
PixelType_Gvsp_HB_BayerRBGG8 = -2130182074
PixelType_Gvsp_HB_BayerGR10 = -2129657844
PixelType_Gvsp_HB_BayerRG10 = -2129657843
PixelType_Gvsp_HB_BayerGB10 = -2129657842
PixelType_Gvsp_HB_BayerBG10 = -2129657841
PixelType_Gvsp_HB_BayerGR12 = -2129657840
PixelType_Gvsp_HB_BayerRG12 = -2129657839
PixelType_Gvsp_HB_BayerGB12 = -2129657838
PixelType_Gvsp_HB_BayerBG12 = -2129657837
PixelType_Gvsp_HB_BayerGR10_Packed = -2129919962
PixelType_Gvsp_HB_BayerRG10_Packed = -2129919961
PixelType_Gvsp_HB_BayerGB10_Packed = -2129919960
PixelType_Gvsp_HB_BayerBG10_Packed = -2129919959
PixelType_Gvsp_HB_BayerGR12_Packed = -2129919958
PixelType_Gvsp_HB_BayerRG12_Packed = -2129919957
PixelType_Gvsp_HB_BayerGB12_Packed = -2129919956
PixelType_Gvsp_HB_BayerBG12_Packed = -2129919955
PixelType_Gvsp_HB_YUV422_Packed = -2112880609
PixelType_Gvsp_HB_YUV422_YUYV_Packed = -2112880590
PixelType_Gvsp_HB_RGB8_Packed = -2112356332
PixelType_Gvsp_HB_BGR8_Packed = -2112356331
PixelType_Gvsp_HB_RGBA8_Packed = -2111832042
PixelType_Gvsp_HB_BGRA8_Packed = -2111832041
PixelType_Gvsp_HB_RGB16_Packed = -2110783437
PixelType_Gvsp_HB_BGR16_Packed = -2110783413
PixelType_Gvsp_HB_RGBA16_Packed = -2109734812
PixelType_Gvsp_HB_BGRA16_Packed = -2109734831

__all__ = ['PixelType_Gvsp_BayerRG8',
           'PixelType_Gvsp_YCBCR422_8',
           'PixelType_Gvsp_Coord3D_ABC32',
           'PixelType_Gvsp_Coord3D_AB32f',
           'PixelType_Gvsp_COORD3D_DEPTH_PLUS_MASK',
           'PixelType_Gvsp_RGB10_Packed',
           'PixelType_Gvsp_RGB10V1_Packed',
           'PixelType_Gvsp_RGB8_Planar',
           'PixelType_Gvsp_RGBA8_Packed',
           'PixelType_Gvsp_RGB8_Packed',
           'PixelType_Gvsp_BayerBG12',
           'PixelType_Gvsp_Coord3D_AC32f_Planar',
           'PixelType_Gvsp_BayerBG10_Packed',
           'PixelType_Gvsp_YCBCR709_422_8_CBYCRY',
           'PixelType_Gvsp_Coord3D_A32f',
           'PixelType_Gvsp_YUV411_Packed',
           'PixelType_Gvsp_BayerBG12_Packed',
           'PixelType_Gvsp_RGB16_Packed',
           'PixelType_Gvsp_BayerRG12',
           'PixelType_Gvsp_BayerRG10',
           'PixelType_Gvsp_BayerRG16',
           'PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY',
           'PixelType_Gvsp_BayerGB12_Packed',
           'PixelType_Gvsp_Coord3D_AC32f',
           'PixelType_Gvsp_BayerRG12_Packed',
           'PixelType_Gvsp_Coord3D_AB32',
           'PixelType_Gvsp_BGR12_Packed',
           'PixelType_Gvsp_BayerGR10_Packed',
           'PixelType_Gvsp_Coord3D_AC32',
           'PixelType_Gvsp_RGB12_Planar',
           'PixelType_Gvsp_YCBCR709_422_8',
           'PixelType_Gvsp_BGR8_Packed',
           'PixelType_Gvsp_Jpeg',
           'PixelType_Gvsp_Coord3D_AC32f_64',
           'PixelType_Gvsp_YUV422_Packed',
           'PixelType_Gvsp_Mono8_Signed',
           'PixelType_Gvsp_BayerBG10',
           'PixelType_Gvsp_BayerBG16',
           'PixelType_Gvsp_BayerGR8',
           'PixelType_Gvsp_RGB16_Planar',
           'PixelType_Gvsp_Mono4p',
           'PixelType_Gvsp_BayerRG10_Packed',
           'PixelType_Gvsp_Mono8',
           'PixelType_Gvsp_BayerGR16',
           'PixelType_Gvsp_BayerGR10',
           'PixelType_Gvsp_BGRA8_Packed',
           'PixelType_Gvsp_BayerGR12',
           'PixelType_Gvsp_Mono12_Packed',
           'PixelType_Gvsp_YCBCR709_8_CBYCR',
           'PixelType_Gvsp_Coord3D_A32',
           'PixelType_Gvsp_YCBCR601_422_8',
           'PixelType_Gvsp_Coord3D_C32',
           'PixelType_Gvsp_YCBCR411_8_CBYYCRYY',
           'PixelType_Gvsp_Undefined',
           'PixelType_Gvsp_BayerGR12_Packed',
           'PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY',
           'PixelType_Gvsp_RGB10_Planar',
           'PixelType_Gvsp_BayerGB16',
           'PixelType_Gvsp_BayerGB10',
           'PixelType_Gvsp_BayerGB12',
           'PixelType_Gvsp_BGR565_Packed',
           'PixelType_Gvsp_Mono1p',
           'PixelType_Gvsp_Coord3D_ABC16',
           'PixelType_Gvsp_YUV444_Packed',
           'PixelType_Gvsp_YUV422_YUYV_Packed',
           'PixelType_Gvsp_BayerBG8',
           'PixelType_Gvsp_Coord3D_C32f',
           'PixelType_Gvsp_BGR10_Packed',
           'PixelType_Gvsp_BayerGB10_Packed',
           'PixelType_Gvsp_Coord3D_ABC32f_Planar',
           'PixelType_Gvsp_Coord3D_ABC32f',
           'PixelType_Gvsp_YCBCR422_8_CBYCRY',
           'PixelType_Gvsp_RGB12_Packed',
           'PixelType_Gvsp_Mono12',
           'PixelType_Gvsp_Mono10',
           'PixelType_Gvsp_Mono16',
           'PixelType_Gvsp_Mono2p',
           'PixelType_Gvsp_Mono14',
           'PixelType_Gvsp_RGB10V2_Packed',
           'PixelType_Gvsp_RGB12V1_Packed',
           'PixelType_Gvsp_Mono10_Packed',
           'PixelType_Gvsp_YCBCR601_8_CBYCR',
           'PixelType_Gvsp_BayerGB8',
           'PixelType_Gvsp_YCBCR8_CBYCR',
           'PixelType_Gvsp_RGB565_Packed',
           'PixelType_Gvsp_YCBCR601_422_8_CBYCRY',
           'PixelType_Gvsp_YUV420SP_NV12',
           'PixelType_Gvsp_YUV420SP_NV21',
           'PixelType_Gvsp_Coord3D_C16',
           'PixelType_Gvsp_BayerRBGG8',
           'PixelType_Gvsp_HB_Mono8',
           'PixelType_Gvsp_HB_Mono10',
           'PixelType_Gvsp_HB_Mono10_Packed',
           'PixelType_Gvsp_HB_Mono12',
           'PixelType_Gvsp_HB_Mono12_Packed',
           'PixelType_Gvsp_HB_Mono16',
           'PixelType_Gvsp_HB_BayerGR8',
           'PixelType_Gvsp_HB_BayerRG8',
           'PixelType_Gvsp_HB_BayerGB8',
           'PixelType_Gvsp_HB_BayerBG8',
           'PixelType_Gvsp_HB_BayerRBGG8',
           'PixelType_Gvsp_HB_BayerGR10',
           'PixelType_Gvsp_HB_BayerRG10',
           'PixelType_Gvsp_HB_BayerGB10',
           'PixelType_Gvsp_HB_BayerBG10',
           'PixelType_Gvsp_HB_BayerGR12',
           'PixelType_Gvsp_HB_BayerRG12',
           'PixelType_Gvsp_HB_BayerGB12',
           'PixelType_Gvsp_HB_BayerBG12',
           'PixelType_Gvsp_HB_BayerGR10_Packed',
           'PixelType_Gvsp_HB_BayerRG10_Packed',
           'PixelType_Gvsp_HB_BayerGB10_Packed',
           'PixelType_Gvsp_HB_BayerBG10_Packed',
           'PixelType_Gvsp_HB_BayerGR12_Packed',
           'PixelType_Gvsp_HB_BayerRG12_Packed',
           'PixelType_Gvsp_HB_BayerGB12_Packed',
           'PixelType_Gvsp_HB_BayerBG12_Packed',
           'PixelType_Gvsp_HB_YUV422_Packed',
           'PixelType_Gvsp_HB_YUV422_YUYV_Packed',
           'PixelType_Gvsp_HB_RGB8_Packed',
           'PixelType_Gvsp_HB_BGR8_Packed',
           'PixelType_Gvsp_HB_RGBA8_Packed',
           'PixelType_Gvsp_HB_BGRA8_Packed',
           'PixelType_Gvsp_HB_RGB16_Packed',
           'PixelType_Gvsp_HB_BGR16_Packed',
           'PixelType_Gvsp_HB_RGBA16_Packed',
           'PixelType_Gvsp_HB_BGRA16_Packed']


